Index: vendor/branch/980CN1/vendor/mediatek/proprietary/bootable/bootloader/lk/target/aus6739_66_n1/include/target/cust_usb.h
===================================================================
--- vendor/branch/980CN1/vendor/mediatek/proprietary/bootable/bootloader/lk/target/aus6739_66_n1/include/target/cust_usb.h	(revision 0)
+++ vendor/branch/980CN1/vendor/mediatek/proprietary/bootable/bootloader/lk/target/aus6739_66_n1/include/target/cust_usb.h	(revision 1376)
@@ -0,0 +1,14 @@
+#ifndef __CUST_USB_H__
+#define __CUST_USB_H__
+
+#define CONFIG_USBD_LANG	"0409"
+
+#define USB_VENDORID		(0x0BB4)
+#define USB_PRODUCTID		(0x0C01)
+#define USB_VERSIONID		(0x0100)
+#define USB_MANUFACTURER	"TCL"
+#define USB_PRODUCT_NAME	"TCL 980CN1"
+#define FASTBOOT_DEVNAME	"TCL 980CN1"
+#define SN_BUF_LEN		19
+
+#endif /* __CUST_USB_H__ */
Index: vendor/branch/980CN1/vendor/mediatek/proprietary/bootable/bootloader/preloader/custom/aus6739_66_n1/inc/cust_usb.h
===================================================================
--- vendor/branch/980CN1/vendor/mediatek/proprietary/bootable/bootloader/preloader/custom/aus6739_66_n1/inc/cust_usb.h	(revision 0)
+++ vendor/branch/980CN1/vendor/mediatek/proprietary/bootable/bootloader/preloader/custom/aus6739_66_n1/inc/cust_usb.h	(revision 1376)
@@ -0,0 +1,52 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+
+#ifndef CUST_USB_H
+#define CUST_USB_H
+
+
+/*=======================================================================*/
+/* USB Control                                                           */	
+/*=======================================================================*/
+#define USBD_MANUFACTURER               "TCL"
+#define USBD_PRODUCT_NAME               "TCL 980CN1"
+#define USBD_VENDORID                   (0x0E8D)
+#define USBD_PRODUCTID                  (0x2000)
+
+#define CFG_USB_HANDSHAKE_TIMEOUT_EN    (1)
+#define CFG_USB_ENUM_TIMEOUT_EN         (1)
+
+#endif   /*_CUST_USBDL_FLOW_H*/
Index: vendor/branch/980CN1/vendor/mediatek/proprietary/custom/common/hal/inc/camera_custom_exif.h
===================================================================
--- vendor/branch/980CN1/vendor/mediatek/proprietary/custom/common/hal/inc/camera_custom_exif.h	(revision 0)
+++ vendor/branch/980CN1/vendor/mediatek/proprietary/custom/common/hal/inc/camera_custom_exif.h	(revision 1376)
@@ -0,0 +1,118 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+#ifndef _CAMERA_CUSTOM_EXIF_
+#define _CAMERA_CUSTOM_EXIF_
+//
+#include "camera_custom_types.h"
+
+//
+namespace NSCamCustom
+{
+/*******************************************************************************
+* Custom EXIF: Imgsensor-related.
+*******************************************************************************/
+typedef struct SensorExifInfo_S
+{
+    MUINT32 uFLengthNum;
+    MUINT32 uFLengthDenom;
+    
+} SensorExifInfo_T;
+
+SensorExifInfo_T const&
+getParamSensorExif()
+{
+    static SensorExifInfo_T inst = { 
+        uFLengthNum     : 35, // Numerator of Focal Length. Default is 35.
+        uFLengthDenom   : 10, // Denominator of Focal Length, it should not be 0.  Default is 10.
+    };
+    return inst;
+}
+
+
+/*******************************************************************************
+* Custom EXIF
+******************************************************************************/
+//#define EN_CUSTOM_EXIF_INFO
+#define SET_EXIF_TAG_STRING(tag,str) \
+    if (strlen((const char*)str) <= 32) { \
+        strcpy((char *)pexifApp1Info->tag, (const char*)str); }
+        
+typedef struct customExifInfo_s {
+    unsigned char strMake[32];
+    unsigned char strModel[32];
+    unsigned char strSoftware[32];
+} customExifInfo_t;
+
+MINT32 custom_SetExif(void **ppCustomExifTag)
+{
+#ifdef EN_CUSTOM_EXIF_INFO
+#define CUSTOM_EXIF_STRING_MAKE  "TCL"
+#define CUSTOM_EXIF_STRING_MODEL "980CN1"
+#define CUSTOM_EXIF_STRING_SOFTWARE "custom software"
+static customExifInfo_t exifTag = {CUSTOM_EXIF_STRING_MAKE,CUSTOM_EXIF_STRING_MODEL,CUSTOM_EXIF_STRING_SOFTWARE};
+    if (0 != ppCustomExifTag) {
+        *ppCustomExifTag = (void*)&exifTag;
+    }
+    return 0;
+#else
+    return -1;
+#endif
+}
+
+
+/*******************************************************************************
+* Custom EXIF: Exposure Program
+******************************************************************************/
+typedef struct customExif_s
+{
+    MBOOL   bEnCustom;
+    MUINT32 u4ExpProgram;
+    
+} customExif_t;
+
+customExif_t const&
+getCustomExif()
+{
+    static customExif_t inst = {
+        bEnCustom       :   false,  // default value: false.
+        u4ExpProgram    :   0,      // default value: 0.    '0' means not defined, '1' manual control, '2' program normal
+    };
+    return inst;
+}
+
+
+};  //NSCamCustom
+#endif  //  _CAMERA_CUSTOM_EXIF_
+
Index: vendor/branch/980CN1/device/ausshine/aus6739_66_n1/full_aus6739_66_n1.mk
===================================================================
--- vendor/branch/980CN1/device/ausshine/aus6739_66_n1/full_aus6739_66_n1.mk	(revision 1375)
+++ vendor/branch/980CN1/device/ausshine/aus6739_66_n1/full_aus6739_66_n1.mk	(revision 1376)
@@ -32,10 +32,10 @@
 #endif
 PRODUCT_LOCALES := zh_CN en_US en_GB zh_HK zh_TW
 # Set those variables here to overwrite the inherited values.
-PRODUCT_MANUFACTURER := alps
+PRODUCT_MANUFACTURER := TCL
 PRODUCT_NAME := full_aus6739_66_n1
 PRODUCT_DEVICE := aus6739_66_n1
-PRODUCT_MODEL := aus6739_66_n1
+PRODUCT_MODEL := 980CN1
 PRODUCT_POLICY := android.policy_phone
 PRODUCT_BRAND := alps
 
Index: vendor/branch/980CN1/device/mediatek/common/custom.conf
===================================================================
--- vendor/branch/980CN1/device/mediatek/common/custom.conf	(revision 1375)
+++ vendor/branch/980CN1/device/mediatek/common/custom.conf	(revision 1376)
@@ -21,7 +21,7 @@
 rtsp_streaming.UserAgent = stagefright/1.2 (Linux;Android @ro.build.version.release )
 #http_streaming.UAProfileURL = http://218.249.47.94/Xianghe/MTK_Athens15_UAProfile.xml
 #rtsp_streaming.UAProfileURL = http://218.249.47.94/Xianghe/MTK_Athens15_UAProfile.xml
-dm.Manufacturer = ALCATEL
+dm.Manufacturer = TCL
 dm.Model = 980CN1
 bluetooth.HostName = TCL 980CN1
 fmtransmitter.RDSValue = TCL 980CN1
Index: vendor/branch/980CN1/frameworks/av/media/mtp/MtpServer.cpp
===================================================================
--- vendor/branch/980CN1/frameworks/av/media/mtp/MtpServer.cpp	(revision 0)
+++ vendor/branch/980CN1/frameworks/av/media/mtp/MtpServer.cpp	(revision 1376)
@@ -0,0 +1,1383 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <dirent.h>
+
+#include <cutils/properties.h>
+
+#define LOG_TAG "MtpServer"
+
+#include "MtpDebug.h"
+#include "MtpDatabase.h"
+#include "MtpObjectInfo.h"
+#include "MtpProperty.h"
+#include "MtpServer.h"
+#include "MtpStorage.h"
+#include "MtpStringBuffer.h"
+
+#include <linux/usb/f_mtp.h>
+
+// switch log level for user build
+#ifdef MTK_USER_BUILD
+#undef ALOGD
+#define ALOGD ALOGV
+#endif
+
+namespace android {
+
+static const MtpOperationCode kSupportedOperationCodes[] = {
+    MTP_OPERATION_GET_DEVICE_INFO,
+    MTP_OPERATION_OPEN_SESSION,
+    MTP_OPERATION_CLOSE_SESSION,
+    MTP_OPERATION_GET_STORAGE_IDS,
+    MTP_OPERATION_GET_STORAGE_INFO,
+    MTP_OPERATION_GET_NUM_OBJECTS,
+    MTP_OPERATION_GET_OBJECT_HANDLES,
+    MTP_OPERATION_GET_OBJECT_INFO,
+    MTP_OPERATION_GET_OBJECT,
+    MTP_OPERATION_GET_THUMB,
+    MTP_OPERATION_DELETE_OBJECT,
+    MTP_OPERATION_SEND_OBJECT_INFO,
+    MTP_OPERATION_SEND_OBJECT,
+//    MTP_OPERATION_INITIATE_CAPTURE,
+//    MTP_OPERATION_FORMAT_STORE,
+//    MTP_OPERATION_RESET_DEVICE,
+//    MTP_OPERATION_SELF_TEST,
+//    MTP_OPERATION_SET_OBJECT_PROTECTION,
+//    MTP_OPERATION_POWER_DOWN,
+    MTP_OPERATION_GET_DEVICE_PROP_DESC,
+    MTP_OPERATION_GET_DEVICE_PROP_VALUE,
+    MTP_OPERATION_SET_DEVICE_PROP_VALUE,
+    MTP_OPERATION_RESET_DEVICE_PROP_VALUE,
+//    MTP_OPERATION_TERMINATE_OPEN_CAPTURE,
+//    MTP_OPERATION_MOVE_OBJECT,
+//    MTP_OPERATION_COPY_OBJECT,
+    MTP_OPERATION_GET_PARTIAL_OBJECT,
+//    MTP_OPERATION_INITIATE_OPEN_CAPTURE,
+    MTP_OPERATION_GET_OBJECT_PROPS_SUPPORTED,
+    MTP_OPERATION_GET_OBJECT_PROP_DESC,
+    MTP_OPERATION_GET_OBJECT_PROP_VALUE,
+    MTP_OPERATION_SET_OBJECT_PROP_VALUE,
+    MTP_OPERATION_GET_OBJECT_PROP_LIST,
+//    MTP_OPERATION_SET_OBJECT_PROP_LIST,
+//    MTP_OPERATION_GET_INTERDEPENDENT_PROP_DESC,
+//    MTP_OPERATION_SEND_OBJECT_PROP_LIST,
+    MTP_OPERATION_GET_OBJECT_REFERENCES,
+    MTP_OPERATION_SET_OBJECT_REFERENCES,
+//    MTP_OPERATION_SKIP,
+    // Android extension for direct file IO
+    MTP_OPERATION_GET_PARTIAL_OBJECT_64,
+    MTP_OPERATION_SEND_PARTIAL_OBJECT,
+    MTP_OPERATION_TRUNCATE_OBJECT,
+    MTP_OPERATION_BEGIN_EDIT_OBJECT,
+    MTP_OPERATION_END_EDIT_OBJECT,
+};
+
+static const MtpEventCode kSupportedEventCodes[] = {
+    MTP_EVENT_OBJECT_ADDED,
+    MTP_EVENT_OBJECT_REMOVED,
+    MTP_EVENT_STORE_ADDED,
+    MTP_EVENT_STORE_REMOVED,
+    MTP_EVENT_DEVICE_PROP_CHANGED,
+    // for storage update
+    MTP_EVENT_OBJECT_INFO_CHANGED,
+    MTP_EVENT_STORAGE_INFO_CHANGED,
+};
+
+MtpServer::MtpServer(int fd, MtpDatabase* database, bool ptp,
+                    int fileGroup, int filePerm, int directoryPerm)
+    :   mFD(fd),
+        mDatabase(database),
+        mPtp(ptp),
+        mFileGroup(fileGroup),
+        mFilePermission(filePerm),
+        mDirectoryPermission(directoryPerm),
+        mSessionID(0),
+        mSessionOpen(false),
+        mSendObjectHandle(kInvalidObjectHandle),
+        mSendObjectFormat(0),
+        mSendObjectFileSize(0)
+{
+}
+
+MtpServer::~MtpServer() {
+}
+
+void MtpServer::addStorage(MtpStorage* storage) {
+    Mutex::Autolock autoLock(mMutex);
+
+    mStorages.push(storage);
+    sendStoreAdded(storage->getStorageID());
+
+    ALOGD("addStorage, storageID = 0x%x, size = %zd",
+        storage->getStorageID(), mStorages.size());
+}
+
+void MtpServer::removeStorage(MtpStorage* storage) {
+    Mutex::Autolock autoLock(mMutex);
+
+    ALOGD("removeStorage, storageID = 0x%x",
+        storage->getStorageID());
+
+    for (size_t i = 0; i < mStorages.size(); i++) {
+        if (mStorages[i] == storage) {
+            mStorages.removeAt(i);
+            sendStoreRemoved(storage->getStorageID());
+            break;
+        }
+    }
+}
+
+MtpStorage* MtpServer::getStorage(MtpStorageID id) {
+    if (id == 0)
+        return mStorages[0];
+    for (size_t i = 0; i < mStorages.size(); i++) {
+        MtpStorage* storage = mStorages[i];
+        if (storage->getStorageID() == id)
+            return storage;
+    }
+    return NULL;
+}
+
+bool MtpServer::hasStorage(MtpStorageID id) {
+    if (id == 0 || id == 0xFFFFFFFF)
+        return mStorages.size() > 0;
+    return (getStorage(id) != NULL);
+}
+
+void MtpServer::run() {
+    int fd = mFD;
+
+    ALOGD("MtpServer::run fd: %d\n", fd);
+
+    while (1) {
+        int ret = mRequest.read(fd);
+        if (ret < 0) {
+            ALOGD("request read returned %d, errno: %d", ret, errno);
+            if (errno == ECANCELED) {
+                // return to top of loop and wait for next command
+                continue;
+            }
+            break;
+        }
+        MtpOperationCode operation = mRequest.getOperationCode();
+        MtpTransactionID transaction = mRequest.getTransactionID();
+
+        ALOGD("operation: %s", MtpDebug::getOperationCodeName(operation));
+
+        // FIXME need to generalize this
+        bool dataIn = (operation == MTP_OPERATION_SEND_OBJECT_INFO
+                    || operation == MTP_OPERATION_SET_OBJECT_REFERENCES
+                    || operation == MTP_OPERATION_SET_OBJECT_PROP_VALUE
+                    || operation == MTP_OPERATION_SET_DEVICE_PROP_VALUE);
+        if (dataIn) {
+            int ret = mData.read(fd);
+            if (ret < 0) {
+                ALOGE("data read returned %d, errno: %d", ret, errno);
+                if (errno == ECANCELED) {
+                    // return to top of loop and wait for next command
+                    continue;
+                }
+                break;
+            }
+            ALOGV("received data:");
+        } else {
+            mData.reset();
+        }
+
+        if (handleRequest()) {
+            if (!dataIn && mData.hasData()) {
+                mData.setOperationCode(operation);
+                mData.setTransactionID(transaction);
+                ALOGV("sending data:");
+                ret = mData.write(fd);
+                if (ret < 0) {
+                    ALOGE("request write returned %d, errno: %d", ret, errno);
+                    if (errno == ECANCELED) {
+                        // return to top of loop and wait for next command
+                        continue;
+                    }
+                    break;
+                }
+            }
+
+            mResponse.setTransactionID(transaction);
+            ALOGD("sending response %04X", mResponse.getResponseCode());
+            ret = mResponse.write(fd);
+            const int savedErrno = errno;
+            if (ret < 0) {
+                ALOGE("request write returned %d, errno: %d", ret, errno);
+                if (savedErrno == ECANCELED) {
+                    // return to top of loop and wait for next command
+                    continue;
+                }
+                break;
+            }
+        } else {
+            ALOGD("skipping response\n");
+        }
+    }
+
+    // commit any open edits
+    int count = mObjectEditList.size();
+    for (int i = 0; i < count; i++) {
+        ObjectEdit* edit = mObjectEditList[i];
+        commitEdit(edit);
+        delete edit;
+    }
+    mObjectEditList.clear();
+
+    if (mSessionOpen)
+        mDatabase->sessionEnded();
+    close(fd);
+    mFD = -1;
+}
+
+void MtpServer::sendObjectAdded(MtpObjectHandle handle) {
+    ALOGV("sendObjectAdded %d\n", handle);
+    sendEvent(MTP_EVENT_OBJECT_ADDED, handle);
+}
+
+void MtpServer::sendObjectRemoved(MtpObjectHandle handle) {
+    ALOGV("sendObjectRemoved %d\n", handle);
+    sendEvent(MTP_EVENT_OBJECT_REMOVED, handle);
+}
+
+void MtpServer::sendStoreAdded(MtpStorageID id) {
+    ALOGV("sendStoreAdded %08X\n", id);
+    sendEvent(MTP_EVENT_STORE_ADDED, id);
+}
+
+void MtpServer::sendStoreRemoved(MtpStorageID id) {
+    ALOGV("sendStoreRemoved %08X\n", id);
+    sendEvent(MTP_EVENT_STORE_REMOVED, id);
+}
+
+void MtpServer::sendDevicePropertyChanged(MtpDeviceProperty property) {
+    ALOGV("sendDevicePropertyChanged %d\n", property);
+    sendEvent(MTP_EVENT_DEVICE_PROP_CHANGED, property);
+}
+
+void MtpServer::sendEvent(MtpEventCode code, uint32_t param1) {
+    if (mSessionOpen) {
+        mEvent.setEventCode(code);
+        mEvent.setTransactionID(mRequest.getTransactionID());
+        mEvent.setParameter(1, param1);
+        int ret = mEvent.write(mFD);
+        ALOGV("mEvent.write returned %d\n", ret);
+    }
+}
+
+void MtpServer::sendObjectInfoChanged(MtpObjectHandle handle) {
+    ALOGV("sendObjectInfoChanged handle = %d\n", handle);
+    sendEvent(MTP_EVENT_OBJECT_INFO_CHANGED, handle);
+}
+void MtpServer::sendStorageInfoChanged(MtpStorageID id) {
+    ALOGV("sendStorageInfoChanged id = %d\n", id);
+    sendEvent(MTP_EVENT_STORAGE_INFO_CHANGED, id);
+}
+
+void MtpServer::addEditObject(MtpObjectHandle handle, MtpString& path,
+        uint64_t size, MtpObjectFormat format, int fd) {
+    ObjectEdit*  edit = new ObjectEdit(handle, path, size, format, fd);
+    mObjectEditList.add(edit);
+}
+
+MtpServer::ObjectEdit* MtpServer::getEditObject(MtpObjectHandle handle) {
+    int count = mObjectEditList.size();
+    for (int i = 0; i < count; i++) {
+        ObjectEdit* edit = mObjectEditList[i];
+        if (edit->mHandle == handle) return edit;
+    }
+    return NULL;
+}
+
+void MtpServer::removeEditObject(MtpObjectHandle handle) {
+    int count = mObjectEditList.size();
+    for (int i = 0; i < count; i++) {
+        ObjectEdit* edit = mObjectEditList[i];
+        if (edit->mHandle == handle) {
+            delete edit;
+            mObjectEditList.removeAt(i);
+            return;
+        }
+    }
+    ALOGE("ObjectEdit not found in removeEditObject");
+}
+
+void MtpServer::commitEdit(ObjectEdit* edit) {
+    mDatabase->endSendObject((const char *)edit->mPath, edit->mHandle, edit->mFormat, true);
+}
+
+
+bool MtpServer::handleRequest() {
+    Mutex::Autolock autoLock(mMutex);
+
+    MtpOperationCode operation = mRequest.getOperationCode();
+    MtpResponseCode response;
+
+    mResponse.reset();
+
+    if (mSendObjectHandle != kInvalidObjectHandle && operation != MTP_OPERATION_SEND_OBJECT) {
+        // FIXME - need to delete mSendObjectHandle from the database
+        ALOGE("expected SendObject after SendObjectInfo");
+        mDatabase->endSendObject(mSendObjectFilePath, mSendObjectHandle, mSendObjectFormat, 0);
+        mSendObjectHandle = kInvalidObjectHandle;
+    }
+
+    int containertype = mRequest.getContainerType();
+    if (containertype != MTP_CONTAINER_TYPE_COMMAND) {
+        ALOGE("wrong container type %d", containertype);
+        return false;
+    }
+
+    ALOGV("got command %s (%x)", MtpDebug::getOperationCodeName(operation), operation);
+
+    switch (operation) {
+        case MTP_OPERATION_GET_DEVICE_INFO:
+            response = doGetDeviceInfo();
+            break;
+        case MTP_OPERATION_OPEN_SESSION:
+            response = doOpenSession();
+            break;
+        case MTP_OPERATION_CLOSE_SESSION:
+            response = doCloseSession();
+            break;
+        case MTP_OPERATION_GET_STORAGE_IDS:
+            response = doGetStorageIDs();
+            break;
+         case MTP_OPERATION_GET_STORAGE_INFO:
+            response = doGetStorageInfo();
+            break;
+        case MTP_OPERATION_GET_OBJECT_PROPS_SUPPORTED:
+            response = doGetObjectPropsSupported();
+            break;
+        case MTP_OPERATION_GET_OBJECT_HANDLES:
+            response = doGetObjectHandles();
+            break;
+        case MTP_OPERATION_GET_NUM_OBJECTS:
+            response = doGetNumObjects();
+            break;
+        case MTP_OPERATION_GET_OBJECT_REFERENCES:
+            response = doGetObjectReferences();
+            break;
+        case MTP_OPERATION_SET_OBJECT_REFERENCES:
+            response = doSetObjectReferences();
+            break;
+        case MTP_OPERATION_GET_OBJECT_PROP_VALUE:
+            response = doGetObjectPropValue();
+            break;
+        case MTP_OPERATION_SET_OBJECT_PROP_VALUE:
+            response = doSetObjectPropValue();
+            break;
+        case MTP_OPERATION_GET_DEVICE_PROP_VALUE:
+            response = doGetDevicePropValue();
+            break;
+        case MTP_OPERATION_SET_DEVICE_PROP_VALUE:
+            response = doSetDevicePropValue();
+            break;
+        case MTP_OPERATION_RESET_DEVICE_PROP_VALUE:
+            response = doResetDevicePropValue();
+            break;
+        case MTP_OPERATION_GET_OBJECT_PROP_LIST:
+            response = doGetObjectPropList();
+            break;
+        case MTP_OPERATION_GET_OBJECT_INFO:
+            response = doGetObjectInfo();
+            break;
+        case MTP_OPERATION_GET_OBJECT:
+            response = doGetObject();
+            break;
+        case MTP_OPERATION_GET_THUMB:
+            response = doGetThumb();
+            break;
+        case MTP_OPERATION_GET_PARTIAL_OBJECT:
+        case MTP_OPERATION_GET_PARTIAL_OBJECT_64:
+            response = doGetPartialObject(operation);
+            break;
+        case MTP_OPERATION_SEND_OBJECT_INFO:
+            response = doSendObjectInfo();
+            break;
+        case MTP_OPERATION_SEND_OBJECT:
+            response = doSendObject();
+            break;
+        case MTP_OPERATION_DELETE_OBJECT:
+            response = doDeleteObject();
+            break;
+        case MTP_OPERATION_GET_OBJECT_PROP_DESC:
+            response = doGetObjectPropDesc();
+            break;
+        case MTP_OPERATION_GET_DEVICE_PROP_DESC:
+            response = doGetDevicePropDesc();
+            break;
+        case MTP_OPERATION_SEND_PARTIAL_OBJECT:
+            response = doSendPartialObject();
+            break;
+        case MTP_OPERATION_TRUNCATE_OBJECT:
+            response = doTruncateObject();
+            break;
+        case MTP_OPERATION_BEGIN_EDIT_OBJECT:
+            response = doBeginEditObject();
+            break;
+        case MTP_OPERATION_END_EDIT_OBJECT:
+            response = doEndEditObject();
+            break;
+        default:
+            ALOGE("got unsupported command %s (%x)",
+                    MtpDebug::getOperationCodeName(operation), operation);
+            response = MTP_RESPONSE_OPERATION_NOT_SUPPORTED;
+            break;
+    }
+
+    if (response == MTP_RESPONSE_TRANSACTION_CANCELLED)
+        return false;
+    mResponse.setResponseCode(response);
+    return true;
+}
+
+MtpResponseCode MtpServer::doGetDeviceInfo() {
+    MtpStringBuffer   string;
+    char prop_value[PROPERTY_VALUE_MAX];
+
+    MtpObjectFormatList* playbackFormats = mDatabase->getSupportedPlaybackFormats();
+    MtpObjectFormatList* captureFormats = mDatabase->getSupportedCaptureFormats();
+    MtpDevicePropertyList* deviceProperties = mDatabase->getSupportedDeviceProperties();
+
+    // fill in device info
+    mData.putUInt16(MTP_STANDARD_VERSION);
+    if (mPtp) {
+        mData.putUInt32(0);
+    } else {
+        // MTP Vendor Extension ID
+        mData.putUInt32(6);
+    }
+    mData.putUInt16(MTP_STANDARD_VERSION);
+    if (mPtp) {
+        // no extensions
+        string.set("");
+    } else {
+        // MTP extensions
+        string.set("microsoft.com: 1.0; android.com: 1.0;");
+    }
+    mData.putString(string); // MTP Extensions
+    mData.putUInt16(0); //Functional Mode
+    mData.putAUInt16(kSupportedOperationCodes,
+            sizeof(kSupportedOperationCodes) / sizeof(uint16_t)); // Operations Supported
+    mData.putAUInt16(kSupportedEventCodes,
+            sizeof(kSupportedEventCodes) / sizeof(uint16_t)); // Events Supported
+    mData.putAUInt16(deviceProperties); // Device Properties Supported
+    mData.putAUInt16(captureFormats); // Capture Formats
+    mData.putAUInt16(playbackFormats);  // Playback Formats
+
+    property_get("ro.product.manufacturer", prop_value, "unknown manufacturer");
+    string.set("TCL 980CN1");
+    mData.putString(string);   // Manufacturer
+
+    property_get("ro.product.model", prop_value, "MTP Device");
+    string.set(prop_value);
+    mData.putString(string);   // Model
+    string.set("1.0");
+    mData.putString(string);   // Device Version
+
+    property_get("ro.serialno", prop_value, "????????");
+    string.set(prop_value);
+    mData.putString(string);   // Serial Number
+
+    delete playbackFormats;
+    delete captureFormats;
+    delete deviceProperties;
+
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doOpenSession() {
+    if (mSessionOpen) {
+        mResponse.setParameter(1, mSessionID);
+        return MTP_RESPONSE_SESSION_ALREADY_OPEN;
+    }
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+
+    mSessionID = mRequest.getParameter(1);
+    mSessionOpen = true;
+
+    mDatabase->sessionStarted();
+
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doCloseSession() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    mSessionID = 0;
+    mSessionOpen = false;
+    mDatabase->sessionEnded();
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doGetStorageIDs() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+
+    int count = mStorages.size();
+
+    ALOGD("doGetStorageIDs: mStorageCount = %d", count);
+
+    mData.putUInt32(count);
+    for (int i = 0; i < count; i++)
+        mData.putUInt32(mStorages[i]->getStorageID());
+
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doGetStorageInfo() {
+    MtpStringBuffer   string;
+
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+
+    MtpStorageID id = mRequest.getParameter(1);
+    MtpStorage* storage = getStorage(id);
+    if (!storage)
+        return MTP_RESPONSE_INVALID_STORAGE_ID;
+
+    mData.putUInt16(storage->getType());
+    mData.putUInt16(storage->getFileSystemType());
+    mData.putUInt16(storage->getAccessCapability());
+    mData.putUInt64(storage->getMaxCapacity());
+    mData.putUInt64(storage->getFreeSpace());
+    mData.putUInt32(1024*1024*1024); // Free Space in Objects
+    string.set(storage->getDescription());
+    mData.putString(string);
+    mData.putEmptyString();   // Volume Identifier
+
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doGetObjectPropsSupported() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectFormat format = mRequest.getParameter(1);
+    MtpObjectPropertyList* properties = mDatabase->getSupportedObjectProperties(format);
+    mData.putAUInt16(properties);
+    delete properties;
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doGetObjectHandles() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    if (mRequest.getParameterCount() < 3)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpStorageID storageID = mRequest.getParameter(1);      // 0xFFFFFFFF for all storage
+    MtpObjectFormat format = mRequest.getParameter(2);      // 0 for all formats
+    MtpObjectHandle parent = mRequest.getParameter(3);      // 0xFFFFFFFF for objects with no parent
+                                                            // 0x00000000 for all objects
+
+    ALOGD("doGetObjectHandles: storageID = 0x%x, format = 0x%x, parent = 0x%x",
+        storageID, format, parent);
+
+
+    if (!hasStorage(storageID))
+        return MTP_RESPONSE_INVALID_STORAGE_ID;
+
+    MtpObjectHandleList* handles = mDatabase->getObjectList(storageID, format, parent);
+    mData.putAUInt32(handles);
+    delete handles;
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doGetNumObjects() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    if (mRequest.getParameterCount() < 3)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpStorageID storageID = mRequest.getParameter(1);      // 0xFFFFFFFF for all storage
+    MtpObjectFormat format = mRequest.getParameter(2);      // 0 for all formats
+    MtpObjectHandle parent = mRequest.getParameter(3);      // 0xFFFFFFFF for objects with no parent
+                                                            // 0x00000000 for all objects
+
+    ALOGD("doGetNumObjects: storageID = 0x%x, format = 0x%x, parent = 0x%x \n",
+        storageID, format, parent);
+
+    if (!hasStorage(storageID))
+        return MTP_RESPONSE_INVALID_STORAGE_ID;
+
+    int count = mDatabase->getNumObjects(storageID, format, parent);
+    if (count >= 0) {
+        mResponse.setParameter(1, count);
+        return MTP_RESPONSE_OK;
+    } else {
+        mResponse.setParameter(1, 0);
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    }
+}
+
+MtpResponseCode MtpServer::doGetObjectReferences() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+
+    ALOGD("doGetObjectReferences: handle = 0x%x \n",handle);
+
+    // FIXME - check for invalid object handle
+    MtpObjectHandleList* handles = mDatabase->getObjectReferences(handle);
+    if (handles) {
+        mData.putAUInt32(handles);
+        delete handles;
+    } else {
+        mData.putEmptyArray();
+    }
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doSetObjectReferences() {
+    if (!mSessionOpen)
+        return MTP_RESPONSE_SESSION_NOT_OPEN;
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpStorageID handle = mRequest.getParameter(1);
+
+    MtpObjectHandleList* references = mData.getAUInt32();
+    if (!references)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+
+    ALOGD("doSetObjectReferences: handle = 0x%x \n", handle);
+
+    MtpResponseCode result = mDatabase->setObjectReferences(handle, references);
+    delete references;
+    return result;
+}
+
+MtpResponseCode MtpServer::doGetObjectPropValue() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 2)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    MtpObjectProperty property = mRequest.getParameter(2);
+    ALOGD("GetObjectPropValue %d %s\n", handle,
+            MtpDebug::getObjectPropCodeName(property));
+
+    return mDatabase->getObjectPropertyValue(handle, property, mData);
+}
+
+MtpResponseCode MtpServer::doSetObjectPropValue() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 2)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    MtpObjectProperty property = mRequest.getParameter(2);
+    ALOGD("SetObjectPropValue %d %s\n", handle,
+            MtpDebug::getObjectPropCodeName(property));
+
+    return mDatabase->setObjectPropertyValue(handle, property, mData);
+}
+
+MtpResponseCode MtpServer::doGetDevicePropValue() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpDeviceProperty property = mRequest.getParameter(1);
+    ALOGD("GetDevicePropValue %s\n",
+            MtpDebug::getDevicePropCodeName(property));
+
+    return mDatabase->getDevicePropertyValue(property, mData);
+}
+
+MtpResponseCode MtpServer::doSetDevicePropValue() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpDeviceProperty property = mRequest.getParameter(1);
+    ALOGD("SetDevicePropValue %s\n",
+            MtpDebug::getDevicePropCodeName(property));
+
+    return mDatabase->setDevicePropertyValue(property, mData);
+}
+
+MtpResponseCode MtpServer::doResetDevicePropValue() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpDeviceProperty property = mRequest.getParameter(1);
+    ALOGD("ResetDevicePropValue %s\n",
+            MtpDebug::getDevicePropCodeName(property));
+
+    return mDatabase->resetDeviceProperty(property);
+}
+
+MtpResponseCode MtpServer::doGetObjectPropList() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 5)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    // use uint32_t so we can support 0xFFFFFFFF
+    uint32_t format = mRequest.getParameter(2);
+    uint32_t property = mRequest.getParameter(3);
+    int groupCode = mRequest.getParameter(4);
+    int depth = mRequest.getParameter(5);
+   ALOGD("GetObjectPropList %d format: %s property: %s group: %d depth: %d\n",
+            handle, MtpDebug::getFormatCodeName(format),
+            MtpDebug::getObjectPropCodeName(property), groupCode, depth);
+
+    return mDatabase->getObjectPropertyList(handle, format, property, groupCode, depth, mData);
+}
+
+MtpResponseCode MtpServer::doGetObjectInfo() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+
+    ALOGD("doGetObjectInfo handle = 0x%x \n", handle);
+
+    MtpObjectInfo info(handle);
+    MtpResponseCode result = mDatabase->getObjectInfo(handle, info);
+    if (result == MTP_RESPONSE_OK) {
+        char    date[20];
+
+        mData.putUInt32(info.mStorageID);
+        mData.putUInt16(info.mFormat);
+        mData.putUInt16(info.mProtectionStatus);
+
+        // if object is being edited the database size may be out of date
+        uint32_t size = info.mCompressedSize;
+        ObjectEdit* edit = getEditObject(handle);
+        if (edit)
+            size = (edit->mSize > 0xFFFFFFFFLL ? 0xFFFFFFFF : (uint32_t)edit->mSize);
+        mData.putUInt32(size);
+
+        ALOGD("doGetObjectInfo edit = %p, size=%d \n", edit, size);
+        if (info.mName)
+            ALOGD("doGetObjectInfo info.mName = %s \n", info.mName);
+
+        mData.putUInt16(info.mThumbFormat);
+        mData.putUInt32(info.mThumbCompressedSize);
+        mData.putUInt32(info.mThumbPixWidth);
+        mData.putUInt32(info.mThumbPixHeight);
+        mData.putUInt32(info.mImagePixWidth);
+        mData.putUInt32(info.mImagePixHeight);
+        mData.putUInt32(info.mImagePixDepth);
+        mData.putUInt32(info.mParent);
+        mData.putUInt16(info.mAssociationType);
+        mData.putUInt32(info.mAssociationDesc);
+        mData.putUInt32(info.mSequenceNumber);
+        mData.putString(info.mName);
+        formatDateTime(info.mDateCreated, date, sizeof(date));
+        mData.putString(date);   // date created
+        formatDateTime(info.mDateModified, date, sizeof(date));
+        mData.putString(date);   // date modified
+        mData.putEmptyString();   // keywords
+    }
+    return result;
+}
+
+MtpResponseCode MtpServer::doGetObject() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+
+    ALOGD("doGetObject handle = 0x%x \n", handle);
+
+    MtpString pathBuf;
+    int64_t fileLength;
+    MtpObjectFormat format;
+    int result = mDatabase->getObjectFilePath(handle, pathBuf, fileLength, format);
+    if (result != MTP_RESPONSE_OK)
+        return result;
+
+    const char* filePath = (const char *)pathBuf;
+    mtp_file_range  mfr;
+    mfr.fd = open(filePath, O_RDONLY);
+    if (mfr.fd < 0) {
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+    mfr.offset = 0;
+    mfr.length = fileLength;
+    mfr.command = mRequest.getOperationCode();
+    mfr.transaction_id = mRequest.getTransactionID();
+
+    ALOGD("doGetObject filePath = %s \n", (const char *)filePath);
+    ALOGD("mfr.length = %" PRIu64 "\n", mfr.length);
+    ALOGD("mfr.transaction_id = %d \n", mfr.transaction_id);
+
+    // then transfer the file
+    int ret = ioctl(mFD, MTP_SEND_FILE_WITH_HEADER, (unsigned long)&mfr);
+    close(mfr.fd);
+    if (ret < 0) {
+        ALOGE("read file error: errno = 0x%x \n", errno);
+        if (errno == ECANCELED)
+            result = MTP_RESPONSE_TRANSACTION_CANCELLED;
+        else
+            result = MTP_RESPONSE_GENERAL_ERROR;
+    } else {
+        result = MTP_RESPONSE_OK;
+    }
+    ALOGV("MTP_SEND_FILE_WITH_HEADER returned %d\n", result);
+    return result;
+}
+
+MtpResponseCode MtpServer::doGetThumb() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+
+    ALOGD("doGetThumb Handle 0x%x\n", handle);
+
+    size_t thumbSize;
+    void* thumb = mDatabase->getThumbnail(handle, thumbSize);
+    if (thumb) {
+        // send data
+        mData.setOperationCode(mRequest.getOperationCode());
+        mData.setTransactionID(mRequest.getTransactionID());
+        mData.writeData(mFD, thumb, thumbSize);
+        free(thumb);
+        return MTP_RESPONSE_OK;
+    } else {
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+}
+
+MtpResponseCode MtpServer::doGetPartialObject(MtpOperationCode operation) {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    uint64_t offset;
+    uint32_t length;
+    offset = mRequest.getParameter(2);
+    if (operation == MTP_OPERATION_GET_PARTIAL_OBJECT_64) {
+        // MTP_OPERATION_GET_PARTIAL_OBJECT_64 takes 4 arguments
+        if (mRequest.getParameterCount() < 4)
+            return MTP_RESPONSE_INVALID_PARAMETER;
+
+        // android extension with 64 bit offset
+        uint64_t offset2 = mRequest.getParameter(3);
+        offset = offset | (offset2 << 32);
+        length = mRequest.getParameter(4);
+    } else {
+        // MTP_OPERATION_GET_PARTIAL_OBJECT takes 3 arguments
+        if (mRequest.getParameterCount() < 3)
+            return MTP_RESPONSE_INVALID_PARAMETER;
+
+        // standard GetPartialObject
+        length = mRequest.getParameter(3);
+    }
+    MtpString pathBuf;
+    int64_t fileLength;
+    MtpObjectFormat format;
+    int result = mDatabase->getObjectFilePath(handle, pathBuf, fileLength, format);
+    if (result != MTP_RESPONSE_OK)
+        return result;
+    if (offset + length > (uint64_t)fileLength)
+        length = fileLength - offset;
+
+    const char* filePath = (const char *)pathBuf;
+    mtp_file_range  mfr;
+    mfr.fd = open(filePath, O_RDONLY);
+    if (mfr.fd < 0) {
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+    mfr.offset = offset;
+    mfr.length = length;
+    mfr.command = mRequest.getOperationCode();
+    mfr.transaction_id = mRequest.getTransactionID();
+    mResponse.setParameter(1, length);
+
+    // transfer the file
+    int ret = ioctl(mFD, MTP_SEND_FILE_WITH_HEADER, (unsigned long)&mfr);
+    ALOGV("MTP_SEND_FILE_WITH_HEADER returned %d\n", ret);
+    result = MTP_RESPONSE_OK;
+    if (ret < 0) {
+        if (errno == ECANCELED)
+            result = MTP_RESPONSE_TRANSACTION_CANCELLED;
+        else
+            result = MTP_RESPONSE_GENERAL_ERROR;
+    }
+    close(mfr.fd);
+    return result;
+}
+
+MtpResponseCode MtpServer::doSendObjectInfo() {
+    MtpString path;
+    uint16_t temp16;
+    uint32_t temp32;
+
+    if (mRequest.getParameterCount() < 2)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpStorageID storageID = mRequest.getParameter(1);
+    MtpStorage* storage = getStorage(storageID);
+    MtpObjectHandle parent = mRequest.getParameter(2);
+    if (!storage)
+        return MTP_RESPONSE_INVALID_STORAGE_ID;
+
+    ALOGD("storageID: %08X, parent: 0x%x", storageID, parent );
+    // special case the root
+    if (parent == MTP_PARENT_ROOT) {
+        path = storage->getPath();
+        parent = 0;
+    } else {
+        int64_t length;
+        MtpObjectFormat format;
+        int result = mDatabase->getObjectFilePath(parent, path, length, format);
+        if (result != MTP_RESPONSE_OK)
+            return result;
+        if (format != MTP_FORMAT_ASSOCIATION)
+            return MTP_RESPONSE_INVALID_PARENT_OBJECT;
+    }
+
+    // read only the fields we need
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // storage ID
+    if (!mData.getUInt16(temp16)) return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectFormat format = temp16;
+    if (!mData.getUInt16(temp16)) return MTP_RESPONSE_INVALID_PARAMETER;  // protection status
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;
+    mSendObjectFileSize = temp32;
+    if (!mData.getUInt16(temp16)) return MTP_RESPONSE_INVALID_PARAMETER;  // thumb format
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // thumb compressed size
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // thumb pix width
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // thumb pix height
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // image pix width
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // image pix height
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // image bit depth
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // parent
+    if (!mData.getUInt16(temp16)) return MTP_RESPONSE_INVALID_PARAMETER;
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;
+    if (!mData.getUInt32(temp32)) return MTP_RESPONSE_INVALID_PARAMETER;  // sequence number
+    MtpStringBuffer name, created, modified;
+    if (!mData.getString(name)) return MTP_RESPONSE_INVALID_PARAMETER;    // file name
+    if (name.getCharCount() == 0) {
+        ALOGE("empty name");
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    }
+    if (!mData.getString(created)) return MTP_RESPONSE_INVALID_PARAMETER;      // date created
+    if (!mData.getString(modified)) return MTP_RESPONSE_INVALID_PARAMETER;     // date modified
+    // keywords follow
+
+    ALOGV("name: %s format: %04X\n", (const char *)name, format);
+    time_t modifiedTime;
+    if (!parseDateTime(modified, modifiedTime))
+        modifiedTime = 0;
+
+    if (path[path.size() - 1] != '/')
+        path += "/";
+    path += (const char *)name;
+
+    // check space first
+    if (mSendObjectFileSize > storage->getFreeSpace())
+        return MTP_RESPONSE_STORAGE_FULL;
+    uint64_t maxFileSize = storage->getMaxFileSize();
+    // check storage max file size
+    ALOGD("name: %s , mSendObjectFileSize = %zd, maxSize: %" PRIu64 "\n",
+        (const char *)name, mSendObjectFileSize, maxFileSize);
+
+    if (maxFileSize != 0) {
+        // if mSendObjectFileSize is 0xFFFFFFFF, then all we know is the file size
+        // is >= 0xFFFFFFFF
+        if (mSendObjectFileSize > maxFileSize || mSendObjectFileSize == 0xFFFFFFFF)
+            return MTP_RESPONSE_OBJECT_TOO_LARGE;
+    }
+
+    ALOGD("path: %s parent: %d storageID: %08X", (const char*)path, parent, storageID);
+    MtpObjectHandle handle = mDatabase->beginSendObject((const char*)path,
+            format, parent, storageID, mSendObjectFileSize, modifiedTime);
+    if (handle == kInvalidObjectHandle) {
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+  if (format == MTP_FORMAT_ASSOCIATION) {
+        struct stat statbuf;
+        mode_t mask = umask(0);
+        int ret = mkdir((const char *)path, mDirectoryPermission);
+        umask(mask);
+        if (ret && stat((const char *)path, &statbuf) != 0) {
+            ALOGE("mkdir %s failed: %d", (const char *)path, ret);
+            return MTP_RESPONSE_GENERAL_ERROR;
+        }
+        chown((const char *)path, getuid(), mFileGroup);
+
+        // SendObject does not get sent for directories, so call endSendObject here instead
+        mDatabase->endSendObject(path, handle, MTP_FORMAT_ASSOCIATION, MTP_RESPONSE_OK);
+    } else {
+        mSendObjectFilePath = path;
+        // save the handle for the SendObject call, which should follow
+        mSendObjectHandle = handle;
+        mSendObjectFormat = format;
+    }
+
+    mResponse.setParameter(1, storageID);
+    mResponse.setParameter(2, parent);
+    mResponse.setParameter(3, handle);
+
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doSendObject() {
+    if (!hasStorage())
+        return MTP_RESPONSE_GENERAL_ERROR;
+    MtpResponseCode result = MTP_RESPONSE_OK;
+    mode_t mask;
+    int ret, initialData;
+    bool isCanceled = false;
+
+    if (mSendObjectHandle == kInvalidObjectHandle) {
+        ALOGE("Expected SendObjectInfo before SendObject");
+        result = MTP_RESPONSE_NO_VALID_OBJECT_INFO;
+        goto done;
+    }
+
+    // read the header, and possibly some data
+    ret = mData.read(mFD);
+    if (ret < MTP_CONTAINER_HEADER_SIZE) {
+        result = MTP_RESPONSE_GENERAL_ERROR;
+        goto done;
+    }
+    initialData = ret - MTP_CONTAINER_HEADER_SIZE;
+
+    mtp_file_range  mfr;
+    mfr.fd = open(mSendObjectFilePath, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
+    if (mfr.fd < 0) {
+        ALOGE("mfr.fd %d < 0", mfr.fd);
+        result = MTP_RESPONSE_GENERAL_ERROR;
+        goto done;
+    }
+        fchown(mfr.fd, getuid(), mFileGroup);
+        // set permissions
+        mask = umask(0);
+        fchmod(mfr.fd, mFilePermission);
+        umask(mask);
+
+        if (initialData > 0) {
+            ret = write(mfr.fd, mData.getData(), initialData);
+        }
+
+        if (ret < 0) {
+            ALOGE("failed to write initial data");
+            result = MTP_RESPONSE_GENERAL_ERROR;
+        } else {
+            if (mSendObjectFileSize - initialData > 0) {
+                mfr.offset = initialData;
+                if (mSendObjectFileSize == 0xFFFFFFFF) {
+                    // tell driver to read until it receives a short packet
+                    mfr.length = 0xFFFFFFFF;
+                } else {
+                    mfr.length = mSendObjectFileSize - initialData;
+                }
+
+            ALOGV("receiving %s\n", (const char *)mSendObjectFilePath);
+            // transfer the file
+            ret = ioctl(mFD, MTP_RECEIVE_FILE, (unsigned long)&mfr);
+            if ((ret < 0) && (errno == ECANCELED)) {
+                isCanceled = true;
+            }
+
+            ALOGV("MTP_RECEIVE_FILE returned %d\n", ret);
+            }
+        }
+        close(mfr.fd);
+
+    if (ret < 0) {
+        unlink(mSendObjectFilePath);
+        if (isCanceled)
+            result = MTP_RESPONSE_TRANSACTION_CANCELLED;
+        else
+            result = MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+done:
+    // reset so we don't attempt to send the data back
+    mData.reset();
+
+    mDatabase->endSendObject(mSendObjectFilePath, mSendObjectHandle, mSendObjectFormat,
+            result == MTP_RESPONSE_OK);
+    mSendObjectHandle = kInvalidObjectHandle;
+    mSendObjectFormat = 0;
+    return result;
+}
+
+static void deleteRecursive(const char* path) {
+    char pathbuf[PATH_MAX];
+    size_t pathLength = strlen(path);
+    if (pathLength >= sizeof(pathbuf) - 1) {
+        ALOGE("path too long: %s\n", path);
+    }
+    strcpy(pathbuf, path);
+    if (pathbuf[pathLength - 1] != '/') {
+        pathbuf[pathLength++] = '/';
+    }
+    char* fileSpot = pathbuf + pathLength;
+    int pathRemaining = sizeof(pathbuf) - pathLength - 1;
+
+    DIR* dir = opendir(path);
+    if (!dir) {
+        ALOGE("opendir %s failed: %s", path, strerror(errno));
+        return;
+    }
+
+    struct dirent* entry;
+    while ((entry = readdir(dir))) {
+        const char* name = entry->d_name;
+
+        // ignore "." and ".."
+        if (name[0] == '.' && (name[1] == 0 || (name[1] == '.' && name[2] == 0))) {
+            continue;
+        }
+
+        int nameLength = strlen(name);
+        if (nameLength > pathRemaining) {
+            ALOGE("path %s/%s too long\n", path, name);
+            continue;
+        }
+        strcpy(fileSpot, name);
+
+        if (entry->d_type == DT_DIR) {
+            deleteRecursive(pathbuf);
+            rmdir(pathbuf);
+        } else {
+            unlink(pathbuf);
+        }
+    }
+    closedir(dir);
+}
+
+static void deletePath(const char* path) {
+    struct stat statbuf;
+    if (stat(path, &statbuf) == 0) {
+        if (S_ISDIR(statbuf.st_mode)) {
+            deleteRecursive(path);
+            rmdir(path);
+        } else {
+            unlink(path);
+        }
+    } else {
+        ALOGE("deletePath stat failed for %s: %s", path, strerror(errno));
+    }
+}
+
+MtpResponseCode MtpServer::doDeleteObject() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    MtpObjectFormat format;
+    // FIXME - support deleting all objects if handle is 0xFFFFFFFF
+    // FIXME - implement deleting objects by format
+
+    MtpString filePath;
+    int64_t fileLength;
+    int result = mDatabase->getObjectFilePath(handle, filePath, fileLength, format);
+    if (result == MTP_RESPONSE_OK) {
+        ALOGD("deleting %s", (const char *)filePath);
+        result = mDatabase->deleteFile(handle);
+        // Don't delete the actual files unless the database deletion is allowed
+        if (result == MTP_RESPONSE_OK) {
+            deletePath((const char *)filePath);
+        }
+    }
+
+    return result;
+}
+
+MtpResponseCode MtpServer::doGetObjectPropDesc() {
+    if (mRequest.getParameterCount() < 2)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectProperty propCode = mRequest.getParameter(1);
+    MtpObjectFormat format = mRequest.getParameter(2);
+    ALOGD("GetObjectPropDesc %s %s\n", MtpDebug::getObjectPropCodeName(propCode),
+                                        MtpDebug::getFormatCodeName(format));
+    MtpProperty* property = mDatabase->getObjectPropertyDesc(propCode, format);
+    if (!property)
+        return MTP_RESPONSE_OBJECT_PROP_NOT_SUPPORTED;
+    property->write(mData);
+    delete property;
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doGetDevicePropDesc() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpDeviceProperty propCode = mRequest.getParameter(1);
+    ALOGD("GetDevicePropDesc %s\n", MtpDebug::getDevicePropCodeName(propCode));
+    MtpProperty* property = mDatabase->getDevicePropertyDesc(propCode);
+    if (!property)
+        return MTP_RESPONSE_DEVICE_PROP_NOT_SUPPORTED;
+    property->write(mData);
+    delete property;
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doSendPartialObject() {
+    if (!hasStorage())
+        return MTP_RESPONSE_INVALID_OBJECT_HANDLE;
+    if (mRequest.getParameterCount() < 4)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    uint64_t offset = mRequest.getParameter(2);
+    uint64_t offset2 = mRequest.getParameter(3);
+    offset = offset | (offset2 << 32);
+    uint32_t length = mRequest.getParameter(4);
+
+    ObjectEdit* edit = getEditObject(handle);
+    if (!edit) {
+        ALOGE("object not open for edit in doSendPartialObject");
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    // can't start writing past the end of the file
+    if (offset > edit->mSize) {
+        ALOGD("writing past end of object, offset: %" PRIu64 ", edit->mSize: %" PRIu64,
+            offset, edit->mSize);
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    const char* filePath = (const char *)edit->mPath;
+    ALOGV("receiving partial %s %" PRIu64 " %" PRIu32, filePath, offset, length);
+
+    // read the header, and possibly some data
+    int ret = mData.read(mFD);
+    if (ret < MTP_CONTAINER_HEADER_SIZE)
+        return MTP_RESPONSE_GENERAL_ERROR;
+    int initialData = ret - MTP_CONTAINER_HEADER_SIZE;
+
+    if (initialData > 0) {
+        ret = pwrite(edit->mFD, mData.getData(), initialData, offset);
+        offset += initialData;
+        length -= initialData;
+    }
+
+    bool isCanceled = false;
+    if (ret < 0) {
+        ALOGE("failed to write initial data");
+    } else {
+        if (length > 0) {
+            mtp_file_range  mfr;
+            mfr.fd = edit->mFD;
+            mfr.offset = offset;
+            mfr.length = length;
+
+            // transfer the file
+            ret = ioctl(mFD, MTP_RECEIVE_FILE, (unsigned long)&mfr);
+            if ((ret < 0) && (errno == ECANCELED)) {
+                isCanceled = true;
+            }
+            ALOGV("MTP_RECEIVE_FILE returned %d", ret);
+        }
+    }
+    if (ret < 0) {
+        mResponse.setParameter(1, 0);
+        ALOGE("MTP_RECEIVE_FILE, ret=%d, errno = %d\n", ret, errno);
+        if (isCanceled)
+            return MTP_RESPONSE_TRANSACTION_CANCELLED;
+        else
+            return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    // reset so we don't attempt to send this back
+    mData.reset();
+    mResponse.setParameter(1, length);
+    uint64_t end = offset + length;
+    if (end > edit->mSize) {
+        edit->mSize = end;
+    }
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doTruncateObject() {
+    if (mRequest.getParameterCount() < 3)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    ObjectEdit* edit = getEditObject(handle);
+    if (!edit) {
+        ALOGE("object not open for edit in doTruncateObject");
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    uint64_t offset = mRequest.getParameter(2);
+    uint64_t offset2 = mRequest.getParameter(3);
+    offset |= (offset2 << 32);
+    if (ftruncate(edit->mFD, offset) != 0) {
+        return MTP_RESPONSE_GENERAL_ERROR;
+    } else {
+        edit->mSize = offset;
+        return MTP_RESPONSE_OK;
+    }
+}
+
+MtpResponseCode MtpServer::doBeginEditObject() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    if (getEditObject(handle)) {
+        ALOGE("object already open for edit in doBeginEditObject");
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    MtpString path;
+    int64_t fileLength;
+    MtpObjectFormat format;
+    int result = mDatabase->getObjectFilePath(handle, path, fileLength, format);
+    if (result != MTP_RESPONSE_OK)
+        return result;
+
+    int fd = open((const char *)path, O_RDWR | O_EXCL);
+    if (fd < 0) {
+        ALOGE("open failed for %s in doBeginEditObject (%d)", (const char *)path, errno);
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    addEditObject(handle, path, fileLength, format, fd);
+    return MTP_RESPONSE_OK;
+}
+
+MtpResponseCode MtpServer::doEndEditObject() {
+    if (mRequest.getParameterCount() < 1)
+        return MTP_RESPONSE_INVALID_PARAMETER;
+    MtpObjectHandle handle = mRequest.getParameter(1);
+    ObjectEdit* edit = getEditObject(handle);
+    if (!edit) {
+        ALOGE("object not open for edit in doEndEditObject");
+        return MTP_RESPONSE_GENERAL_ERROR;
+    }
+
+    commitEdit(edit);
+    removeEditObject(handle);
+    return MTP_RESPONSE_OK;
+}
+
+}  // namespace android
Index: vendor/branch/980CN1/frameworks/opt/net/wifi/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java
===================================================================
--- vendor/branch/980CN1/frameworks/opt/net/wifi/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java	(revision 0)
+++ vendor/branch/980CN1/frameworks/opt/net/wifi/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java	(revision 1376)
@@ -0,0 +1,5319 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi.p2p;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.net.ConnectivityManager;
+import android.net.DhcpResults;
+import android.net.InterfaceConfiguration;
+import android.net.LinkAddress;
+import android.net.LinkProperties;
+import android.net.NetworkInfo;
+import android.net.NetworkUtils;
+import android.net.ip.IpManager;
+import android.net.wifi.WpsInfo;
+import android.net.wifi.p2p.IWifiP2pManager;
+import android.net.wifi.p2p.WifiP2pConfig;
+import android.net.wifi.p2p.WifiP2pDevice;
+import android.net.wifi.p2p.WifiP2pDeviceList;
+import android.net.wifi.p2p.WifiP2pGroup;
+import android.net.wifi.p2p.WifiP2pGroupList;
+import android.net.wifi.p2p.WifiP2pGroupList.GroupDeleteListener;
+import android.net.wifi.p2p.WifiP2pInfo;
+import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pProvDiscEvent;
+import android.net.wifi.p2p.WifiP2pWfdInfo;
+import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
+import android.net.wifi.p2p.nsd.WifiP2pServiceRequest;
+import android.net.wifi.p2p.nsd.WifiP2pServiceResponse;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.INetworkManagementService;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.text.TextUtils;
+import android.util.Slog;
+import android.util.SparseArray;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.WindowManager;
+import android.widget.EditText;
+import android.widget.TextView;
+
+import com.android.internal.R;
+import com.android.internal.util.AsyncChannel;
+import com.android.internal.util.Protocol;
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+import com.android.server.wifi.WifiMonitor;
+import com.android.server.wifi.WifiNative;
+import com.android.server.wifi.WifiStateMachine;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+
+///M:@{
+import android.net.StaticIpConfiguration;
+import android.net.wifi.SupplicantState;
+import android.net.wifi.WifiInfo;
+import android.net.wifi.WifiManager;
+import android.net.wifi.WifiSsid;
+import android.net.wifi.p2p.link.WifiP2pLinkInfo;
+import android.os.SystemProperties;
+import android.util.Log;
+import android.widget.Toast;
+
+import com.mediatek.server.wifi.WifiNvRamAgent;
+
+import java.io.BufferedReader;
+import java.io.DataInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.FileInputStream;
+///@}
+
+/**
+ * WifiP2pService includes a state machine to perform Wi-Fi p2p operations. Applications
+ * communicate with this service to issue device discovery and connectivity requests
+ * through the WifiP2pManager interface. The state machine communicates with the wifi
+ * driver through wpa_supplicant and handles the event responses through WifiMonitor.
+ *
+ * Note that the term Wifi when used without a p2p suffix refers to the client mode
+ * of Wifi operation
+ * @hide
+ */
+public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
+    private static final String TAG = "WifiP2pService";
+    private static final boolean DBG = true;  ///Modify by MTK
+    private static final String NETWORKTYPE = "WIFI_P2P";
+
+    private Context mContext;
+    private String mInterface;
+
+    INetworkManagementService mNwService;
+    private IpManager mIpManager;
+    private DhcpResults mDhcpResults;
+
+    private P2pStateMachine mP2pStateMachine;
+    private AsyncChannel mReplyChannel = new AsyncChannel();
+    private AsyncChannel mWifiChannel;
+
+    private static final Boolean JOIN_GROUP = true;
+    private static final Boolean FORM_GROUP = false;
+
+    private static final Boolean RELOAD = true;
+    private static final Boolean NO_RELOAD = false;
+
+    /* Two minutes comes from the wpa_supplicant setting */
+    private static final int GROUP_CREATING_WAIT_TIME_MS = 120 * 1000;
+    private static int mGroupCreatingTimeoutIndex = 0;
+
+    private static final int DISABLE_P2P_WAIT_TIME_MS = 5 * 1000;
+    private static int mDisableP2pTimeoutIndex = 0;
+
+    /* Set a two minute discover timeout to avoid STA scans from being blocked */
+    private static final int DISCOVER_TIMEOUT_S = 120;
+
+    /* Idle time after a peer is gone when the group is torn down */
+    private static final int GROUP_IDLE_TIME_S = 10;
+
+    /*M: Used for received intive response with info unavailable */
+    private static final int RECONN_FOR_INVITE_RES_INFO_UNAVAILABLE_TIME_MS = 120 * 1000;
+
+    private static final int BASE = Protocol.BASE_WIFI_P2P_SERVICE;
+
+    /* Delayed message to timeout group creation */
+    public static final int GROUP_CREATING_TIMED_OUT        =   BASE + 1;
+
+    /* User accepted a peer request */
+    private static final int PEER_CONNECTION_USER_ACCEPT    =   BASE + 2;
+    /* User rejected a peer request */
+    private static final int PEER_CONNECTION_USER_REJECT    =   BASE + 3;
+    /* User wants to disconnect wifi in favour of p2p */
+    private static final int DROP_WIFI_USER_ACCEPT          =   BASE + 4;
+    /* User wants to keep his wifi connection and drop p2p */
+    private static final int DROP_WIFI_USER_REJECT          =   BASE + 5;
+    /* Delayed message to timeout p2p disable */
+    public static final int DISABLE_P2P_TIMED_OUT           =   BASE + 6;
+
+
+    /* Commands to the WifiStateMachine */
+    public static final int P2P_CONNECTION_CHANGED          =   BASE + 11;
+
+    /* These commands are used to temporarily disconnect wifi when we detect
+     * a frequency conflict which would make it impossible to have with p2p
+     * and wifi active at the same time.
+     *
+     * If the user chooses to disable wifi temporarily, we keep wifi disconnected
+     * until the p2p connection is done and terminated at which point we will
+     * bring back wifi up
+     *
+     * DISCONNECT_WIFI_REQUEST
+     *      msg.arg1 = 1 enables temporary disconnect and 0 disables it.
+     */
+    public static final int DISCONNECT_WIFI_REQUEST         =   BASE + 12;
+    public static final int DISCONNECT_WIFI_RESPONSE        =   BASE + 13;
+
+    public static final int SET_MIRACAST_MODE               =   BASE + 14;
+
+    // During dhcp (and perhaps other times) we can't afford to drop packets
+    // but Discovery will switch our channel enough we will.
+    //   msg.arg1 = ENABLED for blocking, DISABLED for resumed.
+    //   msg.arg2 = msg to send when blocked
+    //   msg.obj  = StateMachine to send to when blocked
+    public static final int BLOCK_DISCOVERY                 =   BASE + 15;
+
+    /*M: increase success rate for invitation*/
+    private static final int M_P2P_DEVICE_FOUND_INVITATION  =   BASE + 20;
+    ///@}
+
+    /*M: Used for received intive response with info unavailable */
+    private static final int M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE  =   BASE + 21;
+
+    private static final int SET_BEAM_MODE  =   BASE + 22;
+    ///@}
+
+    // Messages for interaction with IpManager.
+    private static final int IPM_PRE_DHCP_ACTION            =   BASE + 30;
+    private static final int IPM_POST_DHCP_ACTION           =   BASE + 31;
+    private static final int IPM_DHCP_RESULTS               =   BASE + 32;
+    private static final int IPM_PROVISIONING_SUCCESS       =   BASE + 33;
+    private static final int IPM_PROVISIONING_FAILURE       =   BASE + 34;
+
+    public static final int ENABLED                         = 1;
+    public static final int DISABLED                        = 0;
+
+    private final boolean mP2pSupported;
+
+    private WifiP2pDevice mThisDevice = new WifiP2pDevice();
+
+    /* When a group has been explicitly created by an app, we persist the group
+     * even after all clients have been disconnected until an explicit remove
+     * is invoked */
+    private boolean mAutonomousGroup;
+
+    /* Invitation to join an existing p2p group */
+    private boolean mJoinExistingGroup;
+
+    /* Track whether we are in p2p discovery. This is used to avoid sending duplicate
+     * broadcasts
+     */
+    private boolean mDiscoveryStarted;
+    /* Track whether servcice/peer discovery is blocked in favor of other wifi actions
+     * (notably dhcp)
+     */
+    private boolean mDiscoveryBlocked;
+
+    /*
+     * remember if we were in a scan when it had to be stopped
+     */
+    private boolean mDiscoveryPostponed = false;
+
+    private NetworkInfo mNetworkInfo;
+
+    private boolean mTemporarilyDisconnectedWifi = false;
+
+    /* The transaction Id of service discovery request */
+    private byte mServiceTransactionId = 0;
+
+    /* Service discovery request ID of wpa_supplicant.
+     * null means it's not set yet. */
+    private String mServiceDiscReqId;
+
+    /* clients(application) information list. */
+    private HashMap<Messenger, ClientInfo> mClientInfoList = new HashMap<Messenger, ClientInfo>();
+
+    /* Is chosen as a unique address to avoid conflict with
+       the ranges defined in Tethering.java */
+    private static final String SERVER_ADDRESS = "192.168.49.1";
+
+    ///M:@{
+    private boolean mGcIgnoresDhcpReq = false;
+    private static final String STATIC_CLIENT_ADDRESS = "192.168.49.2";
+    ///@}
+
+    ///M: variables @{
+    /*M: Set 25s for ALPS00450978, because scan block to
+     * feel some peers has diappeared*/
+    private static final int CONNECTED_DISCOVER_TIMEOUT_S = 25;
+
+    /*M: Power Saving Command*/
+    public static final int P2P_ACTIVE  = 0;
+    //When traffic is large will not ajust active/PS
+    public static final int P2P_MAX_PS  = 1;
+    //When traffic is large ajust active/PS automatically
+    public static final int P2P_FAST_PS = 2;
+
+    /*M: add to Enable wifi/wifi p2p */
+    private WifiManager mWifiManager;
+
+    /*M: ALPS00677009: broadcast the group removed reason*/
+    private P2pStatus mGroupRemoveReason = P2pStatus.UNKNOWN;
+
+    /*M: ALPS01593529: no p2p_invite in wfd source case*/
+    private int mMiracastMode = WifiP2pManager.MIRACAST_DISABLED;
+
+    /*M: ALPS01303168: wfd sink*/
+    private int mDeviceCapa;
+    // for getPeerIpAddress()
+    private static final String DHCP_INFO_FILE = "/data/misc/dhcp/dnsmasq.p2p0.leases";
+
+    /*M: ALPS01467393: disableState need stop WifiMonitor*/
+    private static final int STOP_P2P_MONITOR_WAIT_TIME_MS = 5 * 1000;
+    private int mStopP2pMonitorTimeoutIndex = 0;
+
+    /*M: ALPS01593529: For the dongles that don't support p2p_invite*/
+    private boolean WFD_DONGLE_USE_P2P_INVITE =
+        SystemProperties.getBoolean("persist.p2p.wfd.invitedongle", true);
+    private String mWfdSourceAddr;
+
+    /*M: enhance frequency conflict @{ */
+    private int mP2pOperFreq = -1;
+
+    /*M: ALPS01859775: handle device nego-failed wiht NO_COMMON_CHANNEL
+    after receiving nego-request*/
+    boolean mNegoChannelConflict = false;
+
+    /*M: ALPS01976478: SCC then MCC*/
+    private boolean mConnectToPeer = false;
+    private boolean mMccSupport = false;
+
+    /*M: Delay 120s to connect peer if info unavailable received*/
+    private boolean mDelayReconnectForInfoUnavailable = true;
+    ///@}
+
+    /*M: increase success rate for invitation*/
+    private boolean mUpdatePeerForInvited = false;
+
+    /*M: for crossmount*/
+    private boolean mCrossmountIEAdded = false;
+    private boolean mCrossmountEventReceived = false;
+    private String mCrossmountSessionInfo = "";
+
+    private static final int VENDOR_IE_ALL_FRAME_TAG = 99;
+    // refer to WifiNative.java "Frame id" comments
+    private static final int VENDOR_IE_FRAME_ID_AMOUNTS = 12;
+    private static final String UNKNOWN_COMMAND = "UNKNOWN COMMAND";
+    private static final String VENDOR_IE_TAG = "dd";
+    private static final String VENDOR_IE_MTK_OUI = "000ce7";
+    private static final String VENDOR_IE_OUI_TYPE__CROSSMOUNT = "33";
+    ///@}
+
+    /**
+     * Error code definition.
+     * see the Table.8 in the WiFi Direct specification for the detail.
+     */
+    public static enum P2pStatus {
+        /* Success. */
+        SUCCESS,
+
+        /* The target device is currently unavailable. */
+        INFORMATION_IS_CURRENTLY_UNAVAILABLE,
+
+        /* Protocol error. */
+        INCOMPATIBLE_PARAMETERS,
+
+        /* The target device reached the limit of the number of the connectable device.
+         * For example, device limit or group limit is set. */
+        LIMIT_REACHED,
+
+        /* Protocol error. */
+        INVALID_PARAMETER,
+
+        /* Unable to accommodate request. */
+        UNABLE_TO_ACCOMMODATE_REQUEST,
+
+        /* Previous protocol error, or disruptive behavior. */
+        PREVIOUS_PROTOCOL_ERROR,
+
+        /* There is no common channels the both devices can use. */
+        NO_COMMON_CHANNEL,
+
+        /* Unknown p2p group. For example, Device A tries to invoke the previous persistent group,
+         *  but device B has removed the specified credential already. */
+        UNKNOWN_P2P_GROUP,
+
+        /* Both p2p devices indicated an intent of 15 in group owner negotiation. */
+        BOTH_GO_INTENT_15,
+
+        /* Incompatible provisioning method. */
+        INCOMPATIBLE_PROVISIONING_METHOD,
+
+        /* Rejected by user */
+        REJECTED_BY_USER,
+
+        ///M: expand reason code  @{
+        MTK_EXPAND_01,
+        MTK_EXPAND_02,
+        ///@}
+
+        /* Unknown error */
+        UNKNOWN;
+
+        public static P2pStatus valueOf(int error) {
+            switch(error) {
+            case 0 :
+                return SUCCESS;
+            case 1:
+                return INFORMATION_IS_CURRENTLY_UNAVAILABLE;
+            case 2:
+                return INCOMPATIBLE_PARAMETERS;
+            case 3:
+                return LIMIT_REACHED;
+            case 4:
+                return INVALID_PARAMETER;
+            case 5:
+                return UNABLE_TO_ACCOMMODATE_REQUEST;
+            case 6:
+                return PREVIOUS_PROTOCOL_ERROR;
+            case 7:
+                return NO_COMMON_CHANNEL;
+            case 8:
+                return UNKNOWN_P2P_GROUP;
+            case 9:
+                return BOTH_GO_INTENT_15;
+            case 10:
+                return INCOMPATIBLE_PROVISIONING_METHOD;
+            case 11:
+                return REJECTED_BY_USER;
+            ///M: expand reason code  @{
+            case 12:
+                return MTK_EXPAND_01;
+            case 13:
+                return MTK_EXPAND_02;
+            ///@}
+            default:
+                return UNKNOWN;
+            }
+        }
+    }
+
+    /**
+     * Handles client connections
+     */
+    private class ClientHandler extends Handler {
+
+        ClientHandler(android.os.Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+              case WifiP2pManager.SET_DEVICE_NAME:
+              case WifiP2pManager.SET_WFD_INFO:
+              case WifiP2pManager.DISCOVER_PEERS:
+              case WifiP2pManager.STOP_DISCOVERY:
+              case WifiP2pManager.CONNECT:
+              case WifiP2pManager.CANCEL_CONNECT:
+              case WifiP2pManager.CREATE_GROUP:
+              case WifiP2pManager.REMOVE_GROUP:
+              case WifiP2pManager.START_LISTEN:
+              case WifiP2pManager.STOP_LISTEN:
+              case WifiP2pManager.SET_CHANNEL:
+              case WifiP2pManager.START_WPS:
+              case WifiP2pManager.ADD_LOCAL_SERVICE:
+              case WifiP2pManager.REMOVE_LOCAL_SERVICE:
+              case WifiP2pManager.CLEAR_LOCAL_SERVICES:
+              case WifiP2pManager.DISCOVER_SERVICES:
+              case WifiP2pManager.ADD_SERVICE_REQUEST:
+              case WifiP2pManager.REMOVE_SERVICE_REQUEST:
+              case WifiP2pManager.CLEAR_SERVICE_REQUESTS:
+              case WifiP2pManager.REQUEST_PEERS:
+              case WifiP2pManager.REQUEST_CONNECTION_INFO:
+              case WifiP2pManager.REQUEST_GROUP_INFO:
+              case WifiP2pManager.DELETE_PERSISTENT_GROUP:
+              case WifiP2pManager.REQUEST_PERSISTENT_GROUP_INFO:
+              ///M: MTK added on feature  @{
+              case WifiP2pManager.GET_HANDOVER_REQUEST:  //Google feature
+              case WifiP2pManager.GET_HANDOVER_SELECT:  //Google feature
+              case WifiP2pManager.INITIATOR_REPORT_NFC_HANDOVER:  //Google feature
+              case WifiP2pManager.RESPONDER_REPORT_NFC_HANDOVER:  //Google feature
+              case WifiP2pManager.REQUEST_LINK_INFO:
+              case WifiP2pManager.SET_AUTO_CHANNEL_SELECT:
+              case WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER:
+              case WifiP2pManager.PEER_CONNECTION_USER_REJECT_FROM_OUTER:
+              case WifiP2pManager.FREQ_CONFLICT_EX_RESULT:
+              case WifiP2pManager.REMOVE_CLIENT:
+              case WifiP2pManager.STOP_P2P_FIND_ONLY:
+              case WifiP2pManager.ADD_PERSISTENT_GROUP:
+              ///@}
+                mP2pStateMachine.sendMessage(Message.obtain(msg));
+                break;
+              default:
+                Slog.d(TAG, "ClientHandler.handleMessage ignoring msg=" + msg);
+                break;
+            }
+        }
+    }
+    private ClientHandler mClientHandler;
+
+    public WifiP2pServiceImpl(Context context) {
+        mContext = context;
+
+        mNetworkInfo = new NetworkInfo(ConnectivityManager.TYPE_WIFI_P2P, 0, NETWORKTYPE, "");
+
+        mP2pSupported = mContext.getPackageManager().hasSystemFeature(
+                PackageManager.FEATURE_WIFI_DIRECT);
+
+        mThisDevice.primaryDeviceType = mContext.getResources().getString(
+                com.android.internal.R.string.config_wifi_p2p_device_type);
+
+        HandlerThread wifiP2pThread = new HandlerThread("WifiP2pService");
+        wifiP2pThread.start();
+        mClientHandler = new ClientHandler(wifiP2pThread.getLooper());
+
+        mP2pStateMachine = new P2pStateMachine(TAG, wifiP2pThread.getLooper(), mP2pSupported);
+        mP2pStateMachine.start();
+    }
+
+    public void connectivityServiceReady() {
+        IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
+        mNwService = INetworkManagementService.Stub.asInterface(b);
+    }
+
+    private void enforceAccessPermission() {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_WIFI_STATE,
+                "WifiP2pService");
+    }
+
+    private void enforceChangePermission() {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.CHANGE_WIFI_STATE,
+                "WifiP2pService");
+    }
+
+    private void enforceConnectivityInternalPermission() {
+        mContext.enforceCallingOrSelfPermission(
+                android.Manifest.permission.CONNECTIVITY_INTERNAL,
+                "WifiP2pService");
+    }
+
+    private int checkConnectivityInternalPermission() {
+        return mContext.checkCallingOrSelfPermission(
+                android.Manifest.permission.CONNECTIVITY_INTERNAL);
+    }
+
+    private int checkLocationHardwarePermission() {
+        return mContext.checkCallingOrSelfPermission(
+                android.Manifest.permission.LOCATION_HARDWARE);
+    }
+
+    private void enforceConnectivityInternalOrLocationHardwarePermission() {
+        if (checkConnectivityInternalPermission() != PackageManager.PERMISSION_GRANTED
+                && checkLocationHardwarePermission() != PackageManager.PERMISSION_GRANTED) {
+            enforceConnectivityInternalPermission();
+        }
+    }
+
+    private void stopIpManager() {
+        if (mIpManager != null) {
+            mIpManager.stop();
+            mIpManager = null;
+        }
+        mDhcpResults = null;
+    }
+
+    private void startIpManager(String ifname) {
+        stopIpManager();
+
+        mIpManager = new IpManager(mContext, ifname,
+                new IpManager.Callback() {
+                    @Override
+                    public void onPreDhcpAction() {
+                        mP2pStateMachine.sendMessage(IPM_PRE_DHCP_ACTION);
+                    }
+                    @Override
+                    public void onPostDhcpAction() {
+                        mP2pStateMachine.sendMessage(IPM_POST_DHCP_ACTION);
+                    }
+                    @Override
+                    public void onNewDhcpResults(DhcpResults dhcpResults) {
+                        mP2pStateMachine.sendMessage(IPM_DHCP_RESULTS, dhcpResults);
+                    }
+                    @Override
+                    public void onProvisioningSuccess(LinkProperties newLp) {
+                        mP2pStateMachine.sendMessage(IPM_PROVISIONING_SUCCESS);
+                    }
+                    @Override
+                    public void onProvisioningFailure(LinkProperties newLp) {
+                        mP2pStateMachine.sendMessage(IPM_PROVISIONING_FAILURE);
+                    }
+                },
+                mNwService);
+
+        final IpManager.ProvisioningConfiguration config =
+                mIpManager.buildProvisioningConfiguration()
+                          .withoutIPv6()
+                          .withoutIpReachabilityMonitor()
+                          .withPreDhcpAction(30 * 1000)
+                          .withProvisioningTimeoutMs(36 * 1000)
+                          .build();
+        mIpManager.startProvisioning(config);
+    }
+
+    /**
+     * Get a reference to handler. This is used by a client to establish
+     * an AsyncChannel communication with WifiP2pService
+     */
+    public Messenger getMessenger() {
+        enforceAccessPermission();
+        enforceChangePermission();
+        return new Messenger(mClientHandler);
+    }
+
+    /**
+     * Get a reference to handler. This is used by a WifiStateMachine to establish
+     * an AsyncChannel communication with P2pStateMachine
+     * @hide
+     */
+    public Messenger getP2pStateMachineMessenger() {
+        enforceConnectivityInternalOrLocationHardwarePermission();
+        enforceAccessPermission();
+        enforceChangePermission();
+        return new Messenger(mP2pStateMachine.getHandler());
+    }
+
+    /** This is used to provide information to drivers to optimize performance depending
+     * on the current mode of operation.
+     * 0 - disabled
+     * 1 - source operation
+     * 2 - sink operation
+     *
+     * As an example, the driver could reduce the channel dwell time during scanning
+     * when acting as a source or sink to minimize impact on miracast.
+     */
+    public void setMiracastMode(int mode) {
+        enforceConnectivityInternalPermission();
+        mP2pStateMachine.sendMessage(SET_MIRACAST_MODE, mode);
+    }
+
+    ///M: wfd source MCC mechanism, and crossmount mechanism  @{
+    /** This is used to provide information to drivers to optimize performance depending
+     * on the current mode of operation.
+     * 0 - disabled
+     * 1 - source operation
+     * 2 - sink operation
+     *
+     * As an example, the driver could reduce the channel dwell time during scanning
+     * when acting as a source or sink to minimize impact on miracast.
+     */
+    public void setMiracastModeEx(int mode, int freq) {
+        //enforceConnectivityInternalPermission();
+        mP2pStateMachine.sendMessage(SET_MIRACAST_MODE, mode, freq);
+    }
+    ///@}
+
+    @Override
+    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP)
+                != PackageManager.PERMISSION_GRANTED) {
+            pw.println("Permission Denial: can't dump WifiP2pService from from pid="
+                    + Binder.getCallingPid()
+                    + ", uid=" + Binder.getCallingUid());
+            return;
+        }
+        mP2pStateMachine.dump(fd, pw, args);
+        pw.println("mAutonomousGroup " + mAutonomousGroup);
+        pw.println("mJoinExistingGroup " + mJoinExistingGroup);
+        pw.println("mDiscoveryStarted " + mDiscoveryStarted);
+        pw.println("mNetworkInfo " + mNetworkInfo);
+        pw.println("mTemporarilyDisconnectedWifi " + mTemporarilyDisconnectedWifi);
+        pw.println("mServiceDiscReqId " + mServiceDiscReqId);
+        pw.println();
+
+        final IpManager ipManager = mIpManager;
+        if (ipManager != null) {
+            pw.println("mIpManager:");
+            ipManager.dump(fd, pw, args);
+        }
+    }
+
+    ///M:@{
+    /*M: get this device's Device Address*/
+    //M: ALPS01860962: To retrive wifi mac from NVRAM. Wifi p2p mac rule follow wifi hal.
+    public String getMacAddress() {
+        Log.d(TAG, "getMacAddress(): before retriving from NVRAM = " + mThisDevice.deviceAddress);
+
+        final String MAC_ADDRESS_FILENAME = "/data/nvram/APCFG/APRDEB/WIFI";
+        final int MAC_ADDRESS_DIGITS = 6;
+        final String NVRAM_AGENT_SERVICE = "NvRAMAgent";
+
+        try {
+            WifiNvRamAgent agent = WifiNvRamAgent.Stub.asInterface(
+                    ServiceManager.getService(NVRAM_AGENT_SERVICE));
+            byte[] buff = agent.readFileByName(MAC_ADDRESS_FILENAME);
+            String macFromNVRam = "";
+
+            if (buff != null) {
+                macFromNVRam = String.format("%02x:%02x:%02x:%02x:%02x:%02x",
+                    buff[4] | 0x02, buff[5], buff[6], buff[7], buff[8], buff[9]);
+                if (!TextUtils.isEmpty(macFromNVRam))
+                    mThisDevice.deviceAddress = macFromNVRam;
+            }
+
+        } catch (RemoteException re) {
+            re.printStackTrace();
+
+        } catch (IndexOutOfBoundsException iobe) {
+            iobe.printStackTrace();
+
+        } finally {
+            Log.d(TAG, "getMacAddress(): after retriving from NVRAM = " +
+                    mThisDevice.deviceAddress);
+
+        }
+
+        return mThisDevice.deviceAddress;
+    }
+
+    /*M: get peer device's IP*/
+    public String getPeerIpAddress(String peerMacAddress) {
+        return mP2pStateMachine.getPeerIpAddress(peerMacAddress);
+    }
+
+    /*M: set IE for crossmount*/
+    public void setCrossMountIE(boolean isAdd, String hexData) {
+        mP2pStateMachine.setCrossMountIE(isAdd, hexData);
+    }
+
+    /*M: Set beam mode*/
+    /** This is used to provide information to drivers to optimize performance depending.
+         * @param mode for beam mode and set to wifi driver.
+     */
+    public void setBeamMode(int mode) {
+        enforceConnectivityInternalPermission();
+        mP2pStateMachine.sendMessage(SET_BEAM_MODE, mode);
+    }
+    ///@}
+
+    /**
+     * Handles interaction with WifiStateMachine
+     */
+    private class P2pStateMachine extends StateMachine {
+
+        private DefaultState mDefaultState = new DefaultState();
+        private P2pNotSupportedState mP2pNotSupportedState = new P2pNotSupportedState();
+        private P2pDisablingState mP2pDisablingState = new P2pDisablingState();
+        private P2pDisabledState mP2pDisabledState = new P2pDisabledState();
+        private P2pEnablingState mP2pEnablingState = new P2pEnablingState();
+        private P2pEnabledState mP2pEnabledState = new P2pEnabledState();
+        // Inactive is when p2p is enabled with no connectivity
+        private InactiveState mInactiveState = new InactiveState();
+        private GroupCreatingState mGroupCreatingState = new GroupCreatingState();
+        private UserAuthorizingInviteRequestState mUserAuthorizingInviteRequestState
+                = new UserAuthorizingInviteRequestState();
+        private UserAuthorizingNegotiationRequestState mUserAuthorizingNegotiationRequestState
+                = new UserAuthorizingNegotiationRequestState();
+        private ProvisionDiscoveryState mProvisionDiscoveryState = new ProvisionDiscoveryState();
+        private GroupNegotiationState mGroupNegotiationState = new GroupNegotiationState();
+        private FrequencyConflictState mFrequencyConflictState = new FrequencyConflictState();
+
+        private GroupCreatedState mGroupCreatedState = new GroupCreatedState();
+        private UserAuthorizingJoinState mUserAuthorizingJoinState = new UserAuthorizingJoinState();
+        private OngoingGroupRemovalState mOngoingGroupRemovalState = new OngoingGroupRemovalState();
+
+        private WifiNative mWifiNative = WifiNative.getP2pNativeInterface();
+        private WifiMonitor mWifiMonitor = WifiMonitor.getInstance();
+        private final WifiP2pDeviceList mPeers = new WifiP2pDeviceList();
+        /* During a connection, supplicant can tell us that a device was lost. From a supplicant's
+         * perspective, the discovery stops during connection and it purges device since it does
+         * not get latest updates about the device without being in discovery state.
+         *
+         * From the framework perspective, the device is still there since we are connecting or
+         * connected to it. so we keep these devices in a separate list, so that they are removed
+         * when connection is cancelled or lost
+         */
+        private final WifiP2pDeviceList mPeersLostDuringConnection = new WifiP2pDeviceList();
+        private final WifiP2pGroupList mGroups = new WifiP2pGroupList(null,
+                new GroupDeleteListener() {
+            @Override
+            public void onDeleteGroup(int netId) {
+                if (DBG) logd("called onDeleteGroup() netId=" + netId);
+                mWifiNative.removeNetwork(netId);
+                mWifiNative.saveConfig();
+                sendP2pPersistentGroupsChangedBroadcast();
+            }
+        });
+        private final WifiP2pInfo mWifiP2pInfo = new WifiP2pInfo();
+        private WifiP2pGroup mGroup;
+
+        // Saved WifiP2pConfig for an ongoing peer connection. This will never be null.
+        // The deviceAddress will be an empty string when the device is inactive
+        // or if it is connected without any ongoing join request
+        private WifiP2pConfig mSavedPeerConfig = new WifiP2pConfig();
+
+        P2pStateMachine(String name, Looper looper, boolean p2pSupported) {
+            super(name, looper);
+
+            addState(mDefaultState);
+                addState(mP2pNotSupportedState, mDefaultState);
+                addState(mP2pDisablingState, mDefaultState);
+                addState(mP2pDisabledState, mDefaultState);
+                addState(mP2pEnablingState, mDefaultState);
+                addState(mP2pEnabledState, mDefaultState);
+                    addState(mInactiveState, mP2pEnabledState);
+                    addState(mGroupCreatingState, mP2pEnabledState);
+                        addState(mUserAuthorizingInviteRequestState, mGroupCreatingState);
+                        addState(mUserAuthorizingNegotiationRequestState, mGroupCreatingState);
+                        addState(mProvisionDiscoveryState, mGroupCreatingState);
+                        addState(mGroupNegotiationState, mGroupCreatingState);
+                        addState(mFrequencyConflictState, mGroupCreatingState);
+                    addState(mGroupCreatedState, mP2pEnabledState);
+                        addState(mUserAuthorizingJoinState, mGroupCreatedState);
+                        addState(mOngoingGroupRemovalState, mGroupCreatedState);
+
+            if (p2pSupported) {
+                setInitialState(mP2pDisabledState);
+            } else {
+                setInitialState(mP2pNotSupportedState);
+            }
+            setLogRecSize(50);
+            setLogOnlyTransitions(true);
+
+            String interfaceName = mWifiNative.getInterfaceName();
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.AP_STA_CONNECTED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.AP_STA_DISCONNECTED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.AUTHENTICATION_FAILURE_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.NETWORK_CONNECTION_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.NETWORK_DISCONNECTION_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_DEVICE_FOUND_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_DEVICE_LOST_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_FIND_STOPPED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GO_NEGOTIATION_FAILURE_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GO_NEGOTIATION_REQUEST_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GO_NEGOTIATION_SUCCESS_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GROUP_FORMATION_FAILURE_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GROUP_FORMATION_SUCCESS_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GROUP_REMOVED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_GROUP_STARTED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_INVITATION_RECEIVED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_INVITATION_RESULT_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_PROV_DISC_FAILURE_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_PROV_DISC_PBC_REQ_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_PROV_DISC_PBC_RSP_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.P2P_SERV_DISC_RESP_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.SCAN_RESULTS_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.SUP_CONNECTION_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.SUP_DISCONNECTION_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.WPS_FAIL_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.WPS_OVERLAP_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.WPS_SUCCESS_EVENT, getHandler());
+            mWifiMonitor.registerHandler(interfaceName,
+                    WifiMonitor.WPS_TIMEOUT_EVENT, getHandler());
+        }
+
+    class DefaultState extends State {
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
+                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
+                        if (DBG) logd("Full connection with WifiStateMachine established");
+                        mWifiChannel = (AsyncChannel) message.obj;
+                    } else {
+                        loge("Full connection failure, error = " + message.arg1);
+                        mWifiChannel = null;
+                    }
+                    break;
+
+                case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
+                    if (message.arg1 == AsyncChannel.STATUS_SEND_UNSUCCESSFUL) {
+                        loge("Send failed, client connection lost");
+                    } else {
+                        loge("Client connection lost with reason: " + message.arg1);
+                    }
+                    mWifiChannel = null;
+                    break;
+
+                case AsyncChannel.CMD_CHANNEL_FULL_CONNECTION:
+                    AsyncChannel ac = new AsyncChannel();
+                    ac.connect(mContext, getHandler(), message.replyTo);
+                    break;
+                case BLOCK_DISCOVERY:
+                    mDiscoveryBlocked = (message.arg1 == ENABLED ? true : false);
+                    // always reset this - we went to a state that doesn't support discovery so
+                    // it would have stopped regardless
+                    mDiscoveryPostponed = false;
+                    if (mDiscoveryBlocked) {
+                        try {
+                            StateMachine m = (StateMachine)message.obj;
+                            m.sendMessage(message.arg2);
+                        } catch (Exception e) {
+                            loge("unable to send BLOCK_DISCOVERY response: " + e);
+                        }
+                    }
+                    break;
+                case WifiP2pManager.DISCOVER_PEERS:
+                    replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.STOP_DISCOVERY:
+                    replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.DISCOVER_SERVICES:
+                    replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.CONNECT:
+                    replyToMessage(message, WifiP2pManager.CONNECT_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.CANCEL_CONNECT:
+                    replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.CREATE_GROUP:
+                    replyToMessage(message, WifiP2pManager.CREATE_GROUP_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.REMOVE_GROUP:
+                    replyToMessage(message, WifiP2pManager.REMOVE_GROUP_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.ADD_LOCAL_SERVICE:
+                    replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.REMOVE_LOCAL_SERVICE:
+                    replyToMessage(message, WifiP2pManager.REMOVE_LOCAL_SERVICE_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.CLEAR_LOCAL_SERVICES:
+                    replyToMessage(message, WifiP2pManager.CLEAR_LOCAL_SERVICES_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.ADD_SERVICE_REQUEST:
+                    replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.REMOVE_SERVICE_REQUEST:
+                    replyToMessage(message,
+                            WifiP2pManager.REMOVE_SERVICE_REQUEST_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.CLEAR_SERVICE_REQUESTS:
+                    replyToMessage(message,
+                            WifiP2pManager.CLEAR_SERVICE_REQUESTS_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.SET_DEVICE_NAME:
+                    replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.DELETE_PERSISTENT_GROUP:
+                    replyToMessage(message, WifiP2pManager.DELETE_PERSISTENT_GROUP,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.SET_WFD_INFO:
+                    replyToMessage(message, WifiP2pManager.SET_WFD_INFO_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.REQUEST_PEERS:
+                    replyToMessage(message, WifiP2pManager.RESPONSE_PEERS,
+                            new WifiP2pDeviceList(mPeers));
+                    break;
+                case WifiP2pManager.REQUEST_CONNECTION_INFO:
+                    replyToMessage(message, WifiP2pManager.RESPONSE_CONNECTION_INFO,
+                            new WifiP2pInfo(mWifiP2pInfo));
+                    break;
+                case WifiP2pManager.REQUEST_GROUP_INFO:
+                    replyToMessage(message, WifiP2pManager.RESPONSE_GROUP_INFO,
+                            mGroup != null ? new WifiP2pGroup(mGroup) : null);
+                    break;
+                case WifiP2pManager.REQUEST_PERSISTENT_GROUP_INFO:
+                    replyToMessage(message, WifiP2pManager.RESPONSE_PERSISTENT_GROUP_INFO,
+                            new WifiP2pGroupList(mGroups, null));
+                    break;
+                case WifiP2pManager.START_WPS:
+                    replyToMessage(message, WifiP2pManager.START_WPS_FAILED,
+                        WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.GET_HANDOVER_REQUEST:
+                case WifiP2pManager.GET_HANDOVER_SELECT:
+                    replyToMessage(message, WifiP2pManager.RESPONSE_GET_HANDOVER_MESSAGE, null);
+                    break;
+                case WifiP2pManager.INITIATOR_REPORT_NFC_HANDOVER:
+                case WifiP2pManager.RESPONDER_REPORT_NFC_HANDOVER:
+                    replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                    // Ignore
+                case WifiMonitor.P2P_INVITATION_RESULT_EVENT:
+                case WifiMonitor.SCAN_RESULTS_EVENT:
+                case WifiMonitor.SUP_CONNECTION_EVENT:
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                case WifiMonitor.NETWORK_CONNECTION_EVENT:
+                case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
+                case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
+                case WifiMonitor.WPS_SUCCESS_EVENT:
+                case WifiMonitor.WPS_FAIL_EVENT:
+                case WifiMonitor.WPS_OVERLAP_EVENT:
+                case WifiMonitor.WPS_TIMEOUT_EVENT:
+                case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
+                case WifiMonitor.P2P_DEVICE_FOUND_EVENT:
+                case WifiMonitor.P2P_DEVICE_LOST_EVENT:
+                case WifiMonitor.P2P_FIND_STOPPED_EVENT:
+                case WifiMonitor.P2P_SERV_DISC_RESP_EVENT:
+                case PEER_CONNECTION_USER_ACCEPT:
+                case PEER_CONNECTION_USER_REJECT:
+                case DISCONNECT_WIFI_RESPONSE:
+                case DROP_WIFI_USER_ACCEPT:
+                case DROP_WIFI_USER_REJECT:
+                case GROUP_CREATING_TIMED_OUT:
+                case DISABLE_P2P_TIMED_OUT:
+                case IPM_PRE_DHCP_ACTION:
+                case IPM_POST_DHCP_ACTION:
+                case IPM_DHCP_RESULTS:
+                case IPM_PROVISIONING_SUCCESS:
+                case IPM_PROVISIONING_FAILURE:
+                case WifiMonitor.P2P_PROV_DISC_FAILURE_EVENT:
+                case SET_MIRACAST_MODE:
+                case WifiP2pManager.START_LISTEN:
+                case WifiP2pManager.STOP_LISTEN:
+                case WifiP2pManager.SET_CHANNEL:
+                case WifiStateMachine.CMD_ENABLE_P2P:
+                    // Enable is lazy and has no response
+                    break;
+                case WifiStateMachine.CMD_DISABLE_P2P_REQ:
+                    // If we end up handling in default, p2p is not enabled
+                    mWifiChannel.sendMessage(WifiStateMachine.CMD_DISABLE_P2P_RSP);
+                    break;
+                    /* unexpected group created, remove */
+                case WifiMonitor.P2P_GROUP_STARTED_EVENT:
+                    mGroup = (WifiP2pGroup) message.obj;
+                    loge("Unexpected group creation, remove " + mGroup);
+                    mWifiNative.p2pGroupRemove(mGroup.getInterface());
+                    break;
+                // A group formation failure is always followed by
+                // a group removed event. Flushing things at group formation
+                // failure causes supplicant issues. Ignore right now.
+                case WifiMonitor.P2P_GROUP_FORMATION_FAILURE_EVENT:
+                    break;
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER:
+                    break;
+                case WifiP2pManager.PEER_CONNECTION_USER_REJECT_FROM_OUTER:
+                    break;
+                ///@}
+                ///M:  @{
+                case WifiP2pManager.REMOVE_CLIENT:
+                    replyToMessage(message, WifiP2pManager.REMOVE_CLIENT_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                ///@}
+                ///M: Add persistent @{
+                case WifiP2pManager.ADD_PERSISTENT_GROUP:
+                    replyToMessage(message, WifiP2pManager.ADD_PERSISTENT_GROUP,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.STOP_P2P_FIND_ONLY:
+                    replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                ///@}
+                ///M: Set beam mode @{
+                case SET_BEAM_MODE:
+                    break;
+                ///@}
+                default:
+                    loge("Unhandled message " + message);
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class P2pNotSupportedState extends State {
+        @Override
+        public boolean processMessage(Message message) {
+            switch (message.what) {
+               case WifiP2pManager.DISCOVER_PEERS:
+                    replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.STOP_DISCOVERY:
+                    replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.DISCOVER_SERVICES:
+                    replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.CONNECT:
+                    replyToMessage(message, WifiP2pManager.CONNECT_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.CANCEL_CONNECT:
+                    replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+               case WifiP2pManager.CREATE_GROUP:
+                    replyToMessage(message, WifiP2pManager.CREATE_GROUP_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.REMOVE_GROUP:
+                    replyToMessage(message, WifiP2pManager.REMOVE_GROUP_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.ADD_LOCAL_SERVICE:
+                    replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.REMOVE_LOCAL_SERVICE:
+                    replyToMessage(message, WifiP2pManager.REMOVE_LOCAL_SERVICE_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.CLEAR_LOCAL_SERVICES:
+                    replyToMessage(message, WifiP2pManager.CLEAR_LOCAL_SERVICES_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.ADD_SERVICE_REQUEST:
+                    replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.REMOVE_SERVICE_REQUEST:
+                    replyToMessage(message,
+                            WifiP2pManager.REMOVE_SERVICE_REQUEST_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.CLEAR_SERVICE_REQUESTS:
+                    replyToMessage(message,
+                            WifiP2pManager.CLEAR_SERVICE_REQUESTS_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.SET_DEVICE_NAME:
+                    replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.DELETE_PERSISTENT_GROUP:
+                    replyToMessage(message, WifiP2pManager.DELETE_PERSISTENT_GROUP,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.SET_WFD_INFO:
+                    replyToMessage(message, WifiP2pManager.SET_WFD_INFO_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.START_WPS:
+                    replyToMessage(message, WifiP2pManager.START_WPS_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.START_LISTEN:
+                    replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                case WifiP2pManager.STOP_LISTEN:
+                    replyToMessage(message, WifiP2pManager.STOP_LISTEN_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER:
+                    break;
+                case WifiP2pManager.PEER_CONNECTION_USER_REJECT_FROM_OUTER:
+                    break;
+                ///@}
+                ///M:  @{
+                case WifiP2pManager.REMOVE_CLIENT:
+                    replyToMessage(message, WifiP2pManager.REMOVE_CLIENT_FAILED,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                ///@}
+                ///M: Add persistent @{
+                case WifiP2pManager.ADD_PERSISTENT_GROUP:
+                    replyToMessage(message, WifiP2pManager.ADD_PERSISTENT_GROUP,
+                            WifiP2pManager.P2P_UNSUPPORTED);
+                    break;
+                ///@}
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class P2pDisablingState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            sendMessageDelayed(obtainMessage(DISABLE_P2P_TIMED_OUT,
+                    ++mDisableP2pTimeoutIndex, 0), DISABLE_P2P_WAIT_TIME_MS);
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                    if (DBG) logd("p2p socket connection lost");
+                    transitionTo(mP2pDisabledState);
+                    break;
+                case WifiStateMachine.CMD_ENABLE_P2P:
+                case WifiStateMachine.CMD_DISABLE_P2P_REQ:
+                    deferMessage(message);
+                    break;
+                case DISABLE_P2P_TIMED_OUT:
+                    if (mDisableP2pTimeoutIndex == message.arg1) {
+                        loge("P2p disable timed out");
+                        transitionTo(mP2pDisabledState);
+                    }
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        @Override
+        public void exit() {
+            mWifiChannel.sendMessage(WifiStateMachine.CMD_DISABLE_P2P_RSP);
+        }
+    }
+
+    class P2pDisabledState extends State {
+       @Override
+        public void enter() {
+            if (DBG) logd(getName());
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case WifiStateMachine.CMD_ENABLE_P2P:
+                    try {
+                        mNwService.setInterfaceUp(mWifiNative.getInterfaceName());
+                        ///M: ALPS01443292: enable/disable IPv6 on demand  @{
+                        //mNwService.disableIpv6(mInterface);
+                        ///@}
+                    } catch (RemoteException re) {
+                        loge("Unable to change interface settings: " + re);
+                    } catch (IllegalStateException ie) {
+                        loge("Unable to change interface settings: " + ie);
+                    }
+                    mWifiMonitor.startMonitoring(mWifiNative.getInterfaceName());
+                    transitionTo(mP2pEnablingState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class P2pEnablingState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case WifiMonitor.SUP_CONNECTION_EVENT:
+                    if (DBG) logd("P2p socket connection successful");
+                    mWifiNative.startDriver();  ///Add by MTK
+                    transitionTo(mInactiveState);
+                    break;
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                    loge("P2p socket connection failed");
+                    transitionTo(mP2pDisabledState);
+                    break;
+                case WifiStateMachine.CMD_ENABLE_P2P:
+                case WifiStateMachine.CMD_DISABLE_P2P_REQ:
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class P2pEnabledState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            sendP2pStateChangedBroadcast(true);
+            mNetworkInfo.setIsAvailable(true);
+            sendP2pConnectionChangedBroadcast();
+            initializeP2pSettings();
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            ///M: To avoid ConcurrentModificationException in WifiStateMachine.dump()@{
+            if (DBG && message.what == BLOCK_DISCOVERY) logd("BLOCK_DISCOVERY");
+            else if (DBG) logd(getName() + message.toString());
+            ///@}
+            switch (message.what) {
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                    loge("Unexpected loss of p2p socket connection");
+                    transitionTo(mP2pDisabledState);
+                    break;
+                case WifiStateMachine.CMD_ENABLE_P2P:
+                    //Nothing to do
+                    break;
+                case WifiStateMachine.CMD_DISABLE_P2P_REQ:
+                    if (mPeers.clear()) {
+                        sendPeersChangedBroadcast();
+                    }
+                    if (mGroups.clear()) sendP2pPersistentGroupsChangedBroadcast();
+
+                    mWifiMonitor.stopMonitoring(mWifiNative.getInterfaceName());
+                    mWifiNative.stopDriver();  ///Add by MTK
+                    transitionTo(mP2pDisablingState);
+                    break;
+                case WifiP2pManager.SET_DEVICE_NAME:
+                {
+                    WifiP2pDevice d = (WifiP2pDevice) message.obj;
+                    if (d != null && setAndPersistDeviceName(d.deviceName)) {
+                        if (DBG) logd("set device name " + d.deviceName);
+                        replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                }
+                case WifiP2pManager.SET_WFD_INFO:
+                {
+                    WifiP2pWfdInfo d = (WifiP2pWfdInfo) message.obj;
+                    if (d != null && setWfdInfo(d)) {
+                        replyToMessage(message, WifiP2pManager.SET_WFD_INFO_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.SET_WFD_INFO_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    //M: ALPS02303267: reset wfd info@crossmount case   @{
+                    if (mThisDevice.wfdInfo != null && mThisDevice.wfdInfo.mCrossmountLoaned) {
+                        mThisDevice.wfdInfo = null;
+                        logd("[crossmount] reset wfd info in wifi p2p framework");
+                    }
+                    ///@}
+                    break;
+                }
+                case BLOCK_DISCOVERY:
+                    boolean blocked = (message.arg1 == ENABLED ? true : false);
+                    logd("blocked:" + blocked + ", mDiscoveryBlocked:" + mDiscoveryBlocked);
+                    if (mDiscoveryBlocked == blocked) break;
+                    mDiscoveryBlocked = blocked;
+                    if (blocked && mDiscoveryStarted) {
+                        mWifiNative.p2pStopFind();
+                        mDiscoveryPostponed = true;
+                    }
+                    if (!blocked && mDiscoveryPostponed) {
+                        mDiscoveryPostponed = false;
+                        mWifiNative.p2pFind(DISCOVER_TIMEOUT_S);
+                    }
+                    if (blocked) {
+                        try {
+                            StateMachine m = (StateMachine)message.obj;
+                            m.sendMessage(message.arg2);
+                        } catch (Exception e) {
+                            loge("unable to send BLOCK_DISCOVERY response: " + e);
+                        }
+                    }
+                    break;
+                case WifiP2pManager.DISCOVER_PEERS:
+                    if (mDiscoveryBlocked) {
+                        logd("DiscoveryBlocked"); ///Add by MTK
+                        replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED,
+                                WifiP2pManager.BUSY);
+                        break;
+                    }
+                    // do not send service discovery request while normal find operation.
+                    clearSupplicantServiceRequest();
+                    ///M: Scan for Beam@{
+                    int timeout = message.arg1;
+                    ///@}
+
+                    ///M: wfd sink  @{
+                    boolean retP2pFind = false;
+                    if (isWfdSinkEnabled()) {
+                        //copy from HE dongle
+                        p2pConfigWfdSink();
+                        retP2pFind = mWifiNative.p2pFind();
+                    } else if (timeout == WifiP2pManager.BEAM_DISCOVERY_TIMEOUT) {
+                        ///M: Scan for Beam@{
+                        retP2pFind = mWifiNative.p2pFind(WifiP2pManager.BEAM_DISCOVERY_TIMEOUT);
+                        ///@}
+                    } else {
+                        retP2pFind = mWifiNative.p2pFind(DISCOVER_TIMEOUT_S);
+                    }
+                    if (retP2pFind) {
+                    ///@}
+                        replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_SUCCEEDED);
+                        sendP2pDiscoveryChangedBroadcast(true);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                case WifiMonitor.P2P_FIND_STOPPED_EVENT:
+                    sendP2pDiscoveryChangedBroadcast(false);
+                    break;
+                case WifiP2pManager.STOP_DISCOVERY:
+                    if (mWifiNative.p2pStopFind()) {
+                        replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    ///M: wfd sink, restore configuration  @{
+                    if (isWfdSinkEnabled())
+                        p2pUnconfigWfdSink();
+                    ///@}
+                    break;
+                case WifiP2pManager.DISCOVER_SERVICES:
+                    if (mDiscoveryBlocked) {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                                WifiP2pManager.BUSY);
+                        break;
+                    }
+                    if (DBG) logd(getName() + " discover services");
+                    if (!updateSupplicantServiceRequest()) {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                                WifiP2pManager.NO_SERVICE_REQUESTS);
+                        break;
+                    }
+                    if (mWifiNative.p2pFind(DISCOVER_TIMEOUT_S)) {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                case WifiMonitor.P2P_DEVICE_FOUND_EVENT:
+                    WifiP2pDevice device = (WifiP2pDevice) message.obj;
+                    if (mThisDevice.deviceAddress.equals(device.deviceAddress)) break;
+                    mPeers.updateSupplicantDetails(device);
+                    sendPeersChangedBroadcast();
+                     ///M: force update peer information for invitation  @{
+                    if (mUpdatePeerForInvited) {
+                        if (mSavedPeerConfig.deviceAddress.equals(device.deviceAddress)) {
+                            mUpdatePeerForInvited = false;
+                            sendMessage(M_P2P_DEVICE_FOUND_INVITATION);
+                        }
+                    }
+                    ///@}
+                    break;
+                case WifiMonitor.P2P_DEVICE_LOST_EVENT:
+                    device = (WifiP2pDevice) message.obj;
+                    // Gets current details for the one removed
+                    device = mPeers.remove(device.deviceAddress);
+                    if (device != null) {
+                        sendPeersChangedBroadcast();
+                    }
+                    break;
+                case WifiP2pManager.ADD_LOCAL_SERVICE:
+                    if (DBG) logd(getName() + " add service");
+                    WifiP2pServiceInfo servInfo = (WifiP2pServiceInfo)message.obj;
+                    if (addLocalService(message.replyTo, servInfo)) {
+                        replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_FAILED);
+                    }
+                    break;
+                case WifiP2pManager.REMOVE_LOCAL_SERVICE:
+                    if (DBG) logd(getName() + " remove service");
+                    servInfo = (WifiP2pServiceInfo)message.obj;
+                    removeLocalService(message.replyTo, servInfo);
+                    replyToMessage(message, WifiP2pManager.REMOVE_LOCAL_SERVICE_SUCCEEDED);
+                    break;
+                case WifiP2pManager.CLEAR_LOCAL_SERVICES:
+                    if (DBG) logd(getName() + " clear service");
+                    clearLocalServices(message.replyTo);
+                    replyToMessage(message, WifiP2pManager.CLEAR_LOCAL_SERVICES_SUCCEEDED);
+                    break;
+                case WifiP2pManager.ADD_SERVICE_REQUEST:
+                    if (DBG) logd(getName() + " add service request");
+                    if (!addServiceRequest(message.replyTo, (WifiP2pServiceRequest)message.obj)) {
+                        replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_FAILED);
+                        break;
+                    }
+                    replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_SUCCEEDED);
+                    break;
+                case WifiP2pManager.REMOVE_SERVICE_REQUEST:
+                    if (DBG) logd(getName() + " remove service request");
+                    removeServiceRequest(message.replyTo, (WifiP2pServiceRequest)message.obj);
+                    replyToMessage(message, WifiP2pManager.REMOVE_SERVICE_REQUEST_SUCCEEDED);
+                    break;
+                case WifiP2pManager.CLEAR_SERVICE_REQUESTS:
+                    if (DBG) logd(getName() + " clear service request");
+                    clearServiceRequests(message.replyTo);
+                    replyToMessage(message, WifiP2pManager.CLEAR_SERVICE_REQUESTS_SUCCEEDED);
+                    break;
+                case WifiMonitor.P2P_SERV_DISC_RESP_EVENT:
+                    if (DBG) logd(getName() + " receive service response");
+                    List<WifiP2pServiceResponse> sdRespList =
+                        (List<WifiP2pServiceResponse>) message.obj;
+                    for (WifiP2pServiceResponse resp : sdRespList) {
+                        WifiP2pDevice dev =
+                            mPeers.get(resp.getSrcDevice().deviceAddress);
+                        resp.setSrcDevice(dev);
+                        sendServiceResponse(resp);
+                    }
+                    break;
+                case WifiP2pManager.DELETE_PERSISTENT_GROUP:
+                   if (DBG) logd(getName() + " delete persistent group");
+                   mGroups.remove(message.arg1);
+                   replyToMessage(message, WifiP2pManager.DELETE_PERSISTENT_GROUP_SUCCEEDED);
+                   break;
+                case SET_MIRACAST_MODE:
+                    ///M: wfd sink MCC mechanism  @{
+                    if (0 != message.arg2) {
+                        mWifiNative.setMiracastMode(message.arg1, message.arg2);
+                    } else
+                    ///@}
+                    mWifiNative.setMiracastMode(message.arg1);
+
+                    ///M: ALPS01593529: no p2p_invite in wfd source case @{
+                    mMiracastMode = (int) message.arg1;
+                    ///@}
+                    break;
+                case WifiP2pManager.START_LISTEN:
+                    if (DBG) logd(getName() + " start listen mode");
+                    mWifiNative.p2pFlush();
+                    if (mWifiNative.p2pExtListen(true, 500, 500)) {
+                        replyToMessage(message, WifiP2pManager.START_LISTEN_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED);
+                    }
+                    break;
+                case WifiP2pManager.STOP_LISTEN:
+                    if (DBG) logd(getName() + " stop listen mode");
+                    if (mWifiNative.p2pExtListen(false, 0, 0)) {
+                        replyToMessage(message, WifiP2pManager.STOP_LISTEN_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.STOP_LISTEN_FAILED);
+                    }
+                    mWifiNative.p2pFlush();
+                    break;
+                case WifiP2pManager.SET_CHANNEL:
+                    Bundle p2pChannels = (Bundle) message.obj;
+                    int lc = p2pChannels.getInt("lc", 0);
+                    int oc = p2pChannels.getInt("oc", 0);
+                    if (DBG) logd(getName() + " set listen and operating channel");
+                    if (mWifiNative.p2pSetChannel(lc, oc)) {
+                        replyToMessage(message, WifiP2pManager.SET_CHANNEL_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.SET_CHANNEL_FAILED);
+                    }
+                    break;
+                case WifiP2pManager.GET_HANDOVER_REQUEST:
+                    Bundle requestBundle = new Bundle();
+                    requestBundle.putString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE,
+                            mWifiNative.getNfcHandoverRequest());
+                    replyToMessage(message, WifiP2pManager.RESPONSE_GET_HANDOVER_MESSAGE,
+                            requestBundle);
+                    break;
+                case WifiP2pManager.GET_HANDOVER_SELECT:
+                    Bundle selectBundle = new Bundle();
+                    selectBundle.putString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE,
+                            mWifiNative.getNfcHandoverSelect());
+                    replyToMessage(message, WifiP2pManager.RESPONSE_GET_HANDOVER_MESSAGE,
+                            selectBundle);
+                    break;
+                ///M:@{
+                case WifiP2pManager.REQUEST_LINK_INFO:
+                    WifiP2pLinkInfo info = (WifiP2pLinkInfo) message.obj;
+                    info.linkInfo = p2pLinkStatics(info.interfaceAddress);
+                    logd("Wifi P2p link info is " + info.toString());
+                    replyToMessage(message, WifiP2pManager.RESPONSE_LINK_INFO,
+                            new WifiP2pLinkInfo(info));
+                    break;
+                case WifiP2pManager.SET_AUTO_CHANNEL_SELECT:
+                    int enable = message.arg1;
+                    p2pAutoChannel(enable);
+                    replyToMessage(message, WifiP2pManager.SET_AUTO_CHANNEL_SELECT_SUCCEEDED);
+                    break;
+                case WifiP2pManager.STOP_P2P_FIND_ONLY:
+                    if (mWifiNative.p2pStopFind()) {
+                        replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                case WifiP2pManager.ADD_PERSISTENT_GROUP:
+                    if (DBG) {
+                        logd(getName() + " ADD_PERSISTENT_GROUP");
+                    }
+                    Bundle bVariables = (Bundle) message.obj;
+                    HashMap<String, String> hVariables =
+                        (HashMap<String, String>) bVariables.getSerializable("variables");
+                    if (hVariables != null) {
+                        WifiP2pGroup group = addPersistentGroup(hVariables);
+                        replyToMessage(message, WifiP2pManager.RESPONSE_ADD_PERSISTENT_GROUP,
+                                new WifiP2pGroup(group));
+                    } else {
+                        replyToMessage(message, WifiP2pManager.ADD_PERSISTENT_GROUP_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                case SET_BEAM_MODE:
+                    if (DBG) {
+                        logd(getName() + " SET_BEAM_MODE");
+                    }
+                    setBeamMode(message.arg1);
+                    break;
+                ///@}
+                default:
+                   return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        @Override
+        public void exit() {
+            sendP2pDiscoveryChangedBroadcast(false);
+            sendP2pStateChangedBroadcast(false);
+            mNetworkInfo.setIsAvailable(false);
+        }
+    }
+
+    class InactiveState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            ///M: MTK removed
+            // it will cause 2nd connect of channel conflict failed, Google issue @{
+            //mSavedPeerConfig.invalidate();
+            ///@}
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            ///M: To avoid ANR due to WifiLogger is locked in WifiStateMachine.dump()@{
+            if (DBG && message.what == BLOCK_DISCOVERY) logd("BLOCK_DISCOVERY");
+            else if (DBG) logd(getName() + message.toString());
+            ///@}
+            switch (message.what) {
+                case WifiP2pManager.CONNECT:
+                    if (DBG) logd(getName() + " sending connect:" + (WifiP2pConfig) message.obj);
+                    WifiP2pConfig config = (WifiP2pConfig) message.obj;
+                    if (isConfigInvalid(config)) {
+                        loge("Dropping connect request " + config);
+                        replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
+                        break;
+                    }
+
+                    mAutonomousGroup = false;
+                    /** M: ALPS02364885: p2p stop find will disorder wpa_supplicant state */
+                    //mWifiNative.p2pStopFind();
+                    ///@}
+                    /** M: ALPS01976478: SCC then MCC @{ */
+                    mConnectToPeer = true;
+                    ///@}
+                    //M: ALPS01593529: no p2p_invite in wfd source case
+                    //logd("CONNECT: mMiracastMode=" + mMiracastMode);
+                    if (mMiracastMode == WifiP2pManager.MIRACAST_SOURCE
+                        && !WFD_DONGLE_USE_P2P_INVITE) {
+                        // To support WFD dongle that doesn't support p2p_invite
+                        transitionTo(mProvisionDiscoveryState);
+                    } else {
+                        // Normal connection case
+                        if (reinvokePersistentGroup(config)) {
+                            transitionTo(mGroupNegotiationState);
+                        } else {
+                            transitionTo(mProvisionDiscoveryState);
+                        }
+                    }
+                    mSavedPeerConfig = config;
+                    mPeers.updateStatus(mSavedPeerConfig.deviceAddress, WifiP2pDevice.INVITED);
+                    sendPeersChangedBroadcast();
+                    replyToMessage(message, WifiP2pManager.CONNECT_SUCCEEDED);
+                    break;
+                case WifiP2pManager.STOP_DISCOVERY:
+                    if (mWifiNative.p2pStopFind()) {
+                        // When discovery stops in inactive state, flush to clear
+                        // state peer data
+                        mWifiNative.p2pFlush();
+                        ///M: Google issue,
+                        /// reset mServiceDiscReqId would cause service discovery can't clear up @{
+                        //mServiceDiscReqId = null;
+                        clearSupplicantServiceRequest();
+                        ///@}
+                        replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                case WifiMonitor.P2P_GO_NEGOTIATION_REQUEST_EVENT:
+                    config = (WifiP2pConfig) message.obj;
+                    if (isConfigInvalid(config)) {
+                        loge("Dropping GO neg request " + config);
+                        break;
+                    }
+                    mSavedPeerConfig = config;
+                    mAutonomousGroup = false;
+                    mJoinExistingGroup = false;
+                    transitionTo(mUserAuthorizingNegotiationRequestState);
+                    break;
+                case WifiMonitor.P2P_INVITATION_RECEIVED_EVENT:
+                    WifiP2pGroup group = (WifiP2pGroup) message.obj;
+                    WifiP2pDevice owner = group.getOwner();
+
+                    if (owner == null) {
+                        int id = group.getNetworkId();
+                        if (id < 0) {
+                            loge("Ignored invitation from null owner");
+                            break;
+                        }
+
+                        String addr = mGroups.getOwnerAddr(id);
+                        if (addr != null) {
+                            group.setOwner(new WifiP2pDevice(addr));
+                            owner = group.getOwner();
+                        } else {
+                            loge("Ignored invitation from null owner");
+                            break;
+                        }
+                    }
+
+                    config = new WifiP2pConfig();
+                    config.deviceAddress = group.getOwner().deviceAddress;
+
+                    ///M: force update peer information for CrossMount vendor IE  @{
+                    if (mCrossmountIEAdded) {
+                        mWifiNative.doCustomSupplicantCommand("P2P_FIND " + DISCOVER_TIMEOUT_S +
+                            " type=progressive" + " dev_id=" + config.deviceAddress);
+                        mUpdatePeerForInvited = true;
+                    } else {
+                        if (isConfigInvalid(config)) {
+                            loge("Dropping invitation request " + config);
+                            break;
+                        }
+                        sendMessage(M_P2P_DEVICE_FOUND_INVITATION);
+                    }
+                    mSavedPeerConfig = config;
+                    break;
+                    ///@}
+                ///M: increase success rate for invitation  @{
+                case M_P2P_DEVICE_FOUND_INVITATION:
+                    WifiP2pDevice owner02 = null;
+
+                    //Check if we have the owner in peer list and use appropriate
+                    //wps method. Default is to use PBC.
+                    if ((owner02 = mPeers.get(mSavedPeerConfig.deviceAddress)) != null) {
+                        if (owner02.wpsPbcSupported()) {
+                            mSavedPeerConfig.wps.setup = WpsInfo.PBC;
+                        } else if (owner02.wpsKeypadSupported()) {
+                            mSavedPeerConfig.wps.setup = WpsInfo.KEYPAD;
+                        } else if (owner02.wpsDisplaySupported()) {
+                            mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
+                        }
+                    }
+                    ///M: for crossmount  @{
+                    updateCrossMountInfo(mSavedPeerConfig.deviceAddress);
+                    ///@}
+                    mAutonomousGroup = false;
+                    mJoinExistingGroup = true;
+                    transitionTo(mUserAuthorizingInviteRequestState);
+                    break;
+                ///@}
+                case WifiMonitor.P2P_PROV_DISC_PBC_REQ_EVENT:
+                case WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
+                case WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
+                    //We let the supplicant handle the provision discovery response
+                    //and wait instead for the GO_NEGOTIATION_REQUEST_EVENT.
+                    //Handling provision discovery and issuing a p2p_connect before
+                    //group negotiation comes through causes issues
+
+                    ///M: for crossmount  @{
+                    WifiP2pProvDiscEvent provDisc = (WifiP2pProvDiscEvent) message.obj;
+                    updateCrossMountInfo(provDisc.device.deviceAddress);
+                    ///@}
+                    ///M: support show PIN passively  @{
+                    if (message.what == WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT) {
+                        logd("Show PIN passively");
+
+                        config = new WifiP2pConfig();
+                        config.deviceAddress = provDisc.device.deviceAddress;
+                        mSavedPeerConfig = config;
+                        mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
+                        mSavedPeerConfig.wps.pin = provDisc.pin;
+
+                        if (isAppHandledConnection()) {
+                            transitionTo(mUserAuthorizingNegotiationRequestState);
+                        ///M: ALPS02537982: check scan result to avoid exception  @{
+                        } else if (mPeers.get(config.deviceAddress) == null) {
+                            loge("peer device is not in our scan result, drop this pd. "
+                                + config.deviceAddress);
+                        ///@}
+                        } else {
+                            p2pConnectWithPinDisplay(mSavedPeerConfig);
+                            notifyInvitationSent(provDisc.pin, mSavedPeerConfig.deviceAddress);
+                            transitionTo(mGroupNegotiationState);
+                        }
+                    }
+                    ///@}
+                    break;
+                case WifiP2pManager.CREATE_GROUP:
+                    mAutonomousGroup = true;
+                    int netId = message.arg1;
+                    boolean ret = false;
+                    if (netId == WifiP2pGroup.PERSISTENT_NET_ID) {
+                        // check if the go persistent group is present.
+                        netId = mGroups.getNetworkId(mThisDevice.deviceAddress);
+                        if (netId != -1) {
+                            ret = mWifiNative.p2pGroupAdd(netId);
+                        } else {
+                            ret = mWifiNative.p2pGroupAdd(true);
+                        }
+                    /// M: [ALPS03344752] fix typo, this will cause p2pGroupAdd twice
+                    } else if (netId > -1 && mGroups.contains(netId)) {
+                        // check if the go persistent group is present.
+                        if (mThisDevice.deviceAddress.equals(mGroups.getOwnerAddr(netId))) {
+                            ret = mWifiNative.p2pGroupAdd(netId);
+                        }
+                    } else {
+                        ret = mWifiNative.p2pGroupAdd(false);
+                    }
+
+                    if (ret) {
+                        replyToMessage(message, WifiP2pManager.CREATE_GROUP_SUCCEEDED);
+                        transitionTo(mGroupNegotiationState);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.CREATE_GROUP_FAILED,
+                                WifiP2pManager.ERROR);
+                        // remain at this state.
+                    }
+                    break;
+                case WifiMonitor.P2P_GROUP_STARTED_EVENT:
+                    mGroup = (WifiP2pGroup) message.obj;
+                    if (DBG) logd(getName() + " group started");
+
+                    // We hit this scenario when a persistent group is reinvoked
+                    if (mGroup.getNetworkId() == WifiP2pGroup.PERSISTENT_NET_ID) {
+                        mAutonomousGroup = false;
+                        deferMessage(message);
+                        transitionTo(mGroupNegotiationState);
+                    } else {
+                        loge("Unexpected group creation, remove " + mGroup);
+                        mWifiNative.p2pGroupRemove(mGroup.getInterface());
+                    }
+                    break;
+                /// M: marked due to refactoring Google code.
+                /// Let event handled at P2pEnabledState  @{
+                /*
+                case WifiP2pManager.START_LISTEN:
+                    if (DBG) logd(getName() + " start listen mode");
+                    mWifiNative.p2pFlush();
+                    if (mWifiNative.p2pExtListen(true, 500, 500)) {
+                        replyToMessage(message, WifiP2pManager.START_LISTEN_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED);
+                    }
+                    break;
+                case WifiP2pManager.STOP_LISTEN:
+                    if (DBG) logd(getName() + " stop listen mode");
+                    if (mWifiNative.p2pExtListen(false, 0, 0)) {
+                        replyToMessage(message, WifiP2pManager.STOP_LISTEN_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.STOP_LISTEN_FAILED);
+                    }
+                    mWifiNative.p2pFlush();
+                    break;
+                */
+                case WifiP2pManager.SET_CHANNEL:
+                    Bundle p2pChannels = (Bundle) message.obj;
+                    int lc = p2pChannels.getInt("lc", 0);
+                    int oc = p2pChannels.getInt("oc", 0);
+                    if (DBG) logd(getName() + " set listen and operating channel");
+                    if (mWifiNative.p2pSetChannel(lc, oc)) {
+                        replyToMessage(message, WifiP2pManager.SET_CHANNEL_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.SET_CHANNEL_FAILED);
+                    }
+                    break;
+                case WifiP2pManager.INITIATOR_REPORT_NFC_HANDOVER:
+                    String handoverSelect = null;
+
+                    if (message.obj != null) {
+                        handoverSelect = ((Bundle) message.obj)
+                                .getString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE);
+                    }
+
+                    if (handoverSelect != null
+                            && mWifiNative.initiatorReportNfcHandover(handoverSelect)) {
+                        replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_SUCCEEDED);
+                        transitionTo(mGroupCreatingState);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED);
+                    }
+                    break;
+                case WifiP2pManager.RESPONDER_REPORT_NFC_HANDOVER:
+                    String handoverRequest = null;
+
+                    if (message.obj != null) {
+                        handoverRequest = ((Bundle) message.obj)
+                                .getString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE);
+                    }
+
+                    if (handoverRequest != null
+                            && mWifiNative.responderReportNfcHandover(handoverRequest)) {
+                        replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_SUCCEEDED);
+                        transitionTo(mGroupCreatingState);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED);
+                    }
+                    break;
+                ///M:@{
+                case M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE:
+                    /*M: Reconnect to peer because received info unavailable 120s ago*/
+                    if (mDelayReconnectForInfoUnavailable) {
+                        if (DBG) logd(getName() + " mDelayReconnectForInfoUnavailable:" +
+                                         mDelayReconnectForInfoUnavailable +
+                                         " M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE:" +
+                                         (WifiP2pConfig) message.obj);
+                        config = (WifiP2pConfig) message.obj;
+                        mSavedPeerConfig = config;
+                        if (mPeers.containsPeer(mSavedPeerConfig.deviceAddress)) {
+                            p2pConnectWithPinDisplay(config);
+                            transitionTo(mGroupNegotiationState);
+                        } else {
+                            removeMessages(M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE);
+                        }
+                    }
+                    break;
+                ///@}
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        @Override
+        public void exit() {
+            ///M: For received invire response with info unavailable = 1
+            if (mDelayReconnectForInfoUnavailable) {
+                if (DBG) logd(getName() + " mDelayReconnectForInfoUnavailable:" +
+                                 mDelayReconnectForInfoUnavailable +
+                                 ", remove M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE");
+                removeMessages(M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE);
+            }
+            ///@}
+        }
+    }
+
+    class GroupCreatingState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            sendMessageDelayed(obtainMessage(GROUP_CREATING_TIMED_OUT,
+                    ++mGroupCreatingTimeoutIndex, 0), GROUP_CREATING_WAIT_TIME_MS);
+            ///M: ALPS01212893: for poor link, wifi p2p start Tx all traffic @{
+            sendP2pTxBroadcast(true);
+            ///@}
+
+            /** M: enhance frequency conflict @{ */
+            mP2pOperFreq = -1;
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            boolean ret = HANDLED;
+            switch (message.what) {
+               case GROUP_CREATING_TIMED_OUT:
+                    if (mGroupCreatingTimeoutIndex == message.arg1) {
+                        if (DBG) logd("Group negotiation timed out");
+                        handleGroupCreationFailure();
+                        transitionTo(mInactiveState);
+                    }
+                    break;
+                case WifiMonitor.P2P_DEVICE_LOST_EVENT:
+                    WifiP2pDevice device = (WifiP2pDevice) message.obj;
+                    if (!mSavedPeerConfig.deviceAddress.equals(device.deviceAddress)) {
+                        if (DBG) {
+                            logd("mSavedPeerConfig " + mSavedPeerConfig.deviceAddress +
+                                "device " + device.deviceAddress);
+                        }
+                        // Do the regular device lost handling
+                        ret = NOT_HANDLED;
+                        break;
+                    }
+                    // Do nothing
+                    if (DBG) logd("Add device to lost list " + device);
+                    mPeersLostDuringConnection.updateSupplicantDetails(device);
+                    break;
+                case WifiP2pManager.DISCOVER_PEERS:
+                    /* Discovery will break negotiation */
+                    replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED,
+                            WifiP2pManager.BUSY);
+                    break;
+                case WifiP2pManager.CANCEL_CONNECT:
+                    //Do a supplicant p2p_cancel which only cancels an ongoing
+                    //group negotiation. This will fail for a pending provision
+                    //discovery or for a pending user action, but at the framework
+                    //level, we always treat cancel as succeeded and enter
+                    //an inactive state
+                    ///M: enhance cancelConnect() flow  @{
+                    boolean success = false;
+                    if (mWifiNative.p2pCancelConnect()) {
+                        success = true;
+                    } else if (mWifiNative.p2pGroupRemove(mInterface)) {
+                        success = true;
+                    }
+                    handleGroupCreationFailure();
+                    transitionTo(mInactiveState);
+                    if (success) {
+                        replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_FAILED);
+                    }
+                    ///@}
+                    break;
+                case WifiMonitor.P2P_GO_NEGOTIATION_SUCCESS_EVENT:
+                    // We hit this scenario when NFC handover is invoked.
+                    mAutonomousGroup = false;
+                    transitionTo(mGroupNegotiationState);
+                    break;
+                ///M:@{
+                case WifiMonitor.P2P_DEVICE_FOUND_EVENT:
+                    WifiP2pDevice peerDevice = (WifiP2pDevice) message.obj;
+                    if (mThisDevice.deviceAddress.equals(peerDevice.deviceAddress)) break;
+                    if (mSavedPeerConfig != null &&
+                            mSavedPeerConfig.deviceAddress.equals(peerDevice.deviceAddress)) {
+                        peerDevice.status = WifiP2pDevice.INVITED;
+                    }
+                    mPeers.update(peerDevice);
+                    sendPeersChangedBroadcast();
+                    break;
+                //ALPS01497387
+                case BLOCK_DISCOVERY:
+                    if (DBG) logd("defer BLOCK_DISCOVERY@GroupCreatingState");
+                    deferMessage(message);
+                    break;
+                //ALPS02191437: p2pStopFind() would make group nego. failed
+                case WifiMonitor.P2P_FIND_STOPPED_EVENT:
+                    if (DBG) logd("defer P2P_FIND_STOPPED_EVENT@GroupCreatingState");
+                    deferMessage(message);
+                    break;
+                //ALPS02191437: STOP_DISCOVERY procedure would trigger p2pStopFind(),
+                // it would make group nego. failed.
+                case WifiP2pManager.STOP_DISCOVERY:
+                    if (DBG) logd("defer STOP_DISCOVERY@GroupCreatingState");
+                    deferMessage(message);
+                    break;
+                // functionality is like WifiP2pManager.STOP_DISCOVERY
+                case WifiP2pManager.STOP_P2P_FIND_ONLY:
+                    if (DBG) logd("defer STOP_P2P_FIND_ONLY@GroupCreatingState");
+                    deferMessage(message);
+                    break;
+                ///@}
+                default:
+                    ret = NOT_HANDLED;
+            }
+            return ret;
+        }
+    }
+
+    class UserAuthorizingNegotiationRequestState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            ///M: wfd sink: dialog handling move to wfd framework  @{
+            if (isWfdSinkEnabled()) {
+                sendP2pGOandGCRequestConnectBroadcast();
+
+            ///M: crossmount: dialog handling move to crossmount framework  @{
+            } else if (mCrossmountEventReceived) {
+                sendP2pCrossmountIntentionBroadcast();
+
+            } else
+            ///@}
+            notifyInvitationReceived();
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            boolean ret = HANDLED;
+            switch (message.what) {
+                case PEER_CONNECTION_USER_ACCEPT:
+                ///M: wfd sink and crossmount  @{
+                case WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER:
+                    if (message.what == WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER &&
+                        isAppHandledConnection()) {
+                        p2pUserAuthPreprocess(message);
+                        ///M: crossmount, support PIN code from outside  @{
+                        p2pOverwriteWpsPin(
+                            "[crossmount] USER_ACCEPT@UserAuthorizingNegotiationRequestState",
+                            message.obj);
+                        ///@
+                    }
+                ///@}
+                    if (DBG) logd("User accept negotiation: mSavedPeerConfig = " +
+                            mSavedPeerConfig);
+
+                    ///M: ALPS01859775: handle device nego-failed with NO_COMMON_CHANNEL
+                    // after receiving nego-request  @{
+                    if (mNegoChannelConflict) {
+                        mNegoChannelConflict = false;
+                        logd("PEER_CONNECTION_USER_ACCEPT_FROM_OUTER," +
+                                "switch to FrequencyConflictState");
+                        transitionTo(mFrequencyConflictState);
+                        break;
+                    }
+                    ///@}
+                    ///M: ALPS01899589: Assign the freq for "Sink + MCC_Enabled"
+                    // to avoid performance issue {
+                    if (DBG) logd("isWfdSinkEnabled()=" + isWfdSinkEnabled());
+                    if (isWfdSinkEnabled()) {
+                        WifiInfo wifiInfo = getWifiConnectionInfo();
+                        if (wifiInfo != null) {
+                            if (DBG) logd("wifiInfo=" + wifiInfo);
+                            if (wifiInfo.getSupplicantState() == SupplicantState.COMPLETED) {
+                                if (DBG) {
+                                    logd("wifiInfo.getSupplicantState() ==" +
+                                        " SupplicantState.COMPLETED");
+                                    logd("wifiInfo.getFrequency()=" + wifiInfo.getFrequency());
+                                }
+                                mSavedPeerConfig.setPreferOperFreq(wifiInfo.getFrequency());
+                            }
+                        }
+                    }
+                    ///@}
+                    ///M: for peer isn't existed in mPeers
+                    /// but existing in supplicant's scan result  @{
+                    p2pUpdateScanList(mSavedPeerConfig.deviceAddress);
+                    ///@}
+                    mWifiNative.p2pStopFind();
+                    p2pConnectWithPinDisplay(mSavedPeerConfig);
+                    mPeers.updateStatus(mSavedPeerConfig.deviceAddress, WifiP2pDevice.INVITED);
+                    sendPeersChangedBroadcast();
+                    transitionTo(mGroupNegotiationState);
+                   break;
+                case PEER_CONNECTION_USER_REJECT:
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_REJECT_FROM_OUTER:
+                ///@}
+                    if (DBG) logd("User rejected negotiation " + mSavedPeerConfig);
+                    ///M: ALPS02494768: Peer status may be configured to INVITED.
+                    ///    Reset it when user reject this request.  @{
+                    if (mSavedPeerConfig != null) {
+                        WifiP2pDevice peerDevice02 = mPeers.get(mSavedPeerConfig.deviceAddress);
+                        if (peerDevice02 != null &&
+                                peerDevice02.status == WifiP2pDevice.INVITED) {
+                            mPeers.updateStatus(mSavedPeerConfig.deviceAddress,
+                                WifiP2pDevice.AVAILABLE);
+                            sendPeersChangedBroadcast();
+                        }
+                    }
+                    ///@}
+                    transitionTo(mInactiveState);
+                    break;
+                ///M: ALPS01859775: handle device nego-failed with NO_COMMON_CHANNEL after
+                // receiving nego-request  @{
+                case WifiMonitor.P2P_GO_NEGOTIATION_FAILURE_EVENT:
+                    /** M: enhance frequency conflict @{ */
+                    if (message.arg1 != 0)    mP2pOperFreq = message.arg1;
+                    P2pStatus status = (P2pStatus) message.obj;
+                    loge("go negotiation failed@UserAuthorizingNegotiationRequestState, status = " +
+                         status + "\tmP2pOperFreq = " + mP2pOperFreq);
+                    if (status == P2pStatus.NO_COMMON_CHANNEL) {
+                        //transitionTo(mFrequencyConflictState);
+                        mNegoChannelConflict = true;
+                    } else {
+                        loge("other kinds of negotiation errors");
+                        transitionTo(mInactiveState);
+                    }
+                    break;
+                ///@}
+                default:
+                    return NOT_HANDLED;
+            }
+            return ret;
+        }
+
+        @Override
+        public void exit() {
+            //TODO: dismiss dialog if not already done
+        }
+    }
+
+    class UserAuthorizingInviteRequestState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            ///M: for wfd sink, reject 2nd gc  @{
+            if (isWfdSinkEnabled()) {
+                sendMessage(PEER_CONNECTION_USER_REJECT);
+
+            ///M: crossmount: dialog handling move to crossmount framework  @{
+            } else if (mCrossmountEventReceived) {
+                sendP2pCrossmountIntentionBroadcast();
+
+            } else
+            ///@}
+            notifyInvitationReceived();
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            boolean ret = HANDLED;
+            switch (message.what) {
+                case PEER_CONNECTION_USER_ACCEPT:
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER:
+                    ///M: for crossmount, 3rd device's invitation procedure
+                    if (message.what == WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER &&
+                        mCrossmountEventReceived) {
+                        p2pUserAuthPreprocess(message);
+                        ///M: crossmount, support PIN code from outside  @{
+                        p2pOverwriteWpsPin(
+                            "[crossmount] USER_ACCEPT@UserAuthorizingInviteRequestState",
+                            message.obj);
+                        ///@
+                    }
+                ///@}
+                    mWifiNative.p2pStopFind();
+                    if (!reinvokePersistentGroup(mSavedPeerConfig)) {
+                        // Do negotiation when persistence fails
+                        p2pConnectWithPinDisplay(mSavedPeerConfig);
+                    }
+                    mPeers.updateStatus(mSavedPeerConfig.deviceAddress, WifiP2pDevice.INVITED);
+                    sendPeersChangedBroadcast();
+                    transitionTo(mGroupNegotiationState);
+                   break;
+                case PEER_CONNECTION_USER_REJECT:
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_REJECT_FROM_OUTER:
+                ///@}
+                    if (DBG) logd("User rejected invitation " + mSavedPeerConfig);
+                    transitionTo(mInactiveState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return ret;
+        }
+
+        @Override
+        public void exit() {
+            //TODO: dismiss dialog if not already done
+        }
+    }
+
+
+
+    class ProvisionDiscoveryState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            mWifiNative.p2pProvisionDiscovery(mSavedPeerConfig);
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            WifiP2pProvDiscEvent provDisc;
+            WifiP2pDevice device;
+            switch (message.what) {
+                case WifiMonitor.P2P_PROV_DISC_PBC_RSP_EVENT:
+                    provDisc = (WifiP2pProvDiscEvent) message.obj;
+                    device = provDisc.device;
+                    if (!device.deviceAddress.equals(mSavedPeerConfig.deviceAddress)) break;
+                    ///M: for crossmount  @{
+                    updateCrossMountInfo(provDisc.device.deviceAddress);
+                    ///@}
+                    if (mSavedPeerConfig.wps.setup == WpsInfo.PBC) {
+                        if (DBG) logd("Found a match " + mSavedPeerConfig);
+                        p2pConnectWithPinDisplay(mSavedPeerConfig);
+                        transitionTo(mGroupNegotiationState);
+                    }
+                    break;
+                case WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
+                    provDisc = (WifiP2pProvDiscEvent) message.obj;
+                    device = provDisc.device;
+                    if (!device.deviceAddress.equals(mSavedPeerConfig.deviceAddress)) break;
+                    ///M: for crossmount  @{
+                    updateCrossMountInfo(provDisc.device.deviceAddress);
+                    ///@}
+                    if (mSavedPeerConfig.wps.setup == WpsInfo.KEYPAD) {
+                        if (DBG) logd("Found a match " + mSavedPeerConfig);
+                        /* we already have the pin */
+                        if (!TextUtils.isEmpty(mSavedPeerConfig.wps.pin)) {
+                            p2pConnectWithPinDisplay(mSavedPeerConfig);
+                            transitionTo(mGroupNegotiationState);
+                        } else {
+                            mJoinExistingGroup = false;
+                            transitionTo(mUserAuthorizingNegotiationRequestState);
+                        }
+                    }
+                    break;
+                case WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
+                    provDisc = (WifiP2pProvDiscEvent) message.obj;
+                    device = provDisc.device;
+                    if (!device.deviceAddress.equals(mSavedPeerConfig.deviceAddress)) break;
+                    ///M: for crossmount  @{
+                    updateCrossMountInfo(provDisc.device.deviceAddress);
+                    ///@}
+                    if (mSavedPeerConfig.wps.setup == WpsInfo.DISPLAY) {
+                        if (DBG) logd("Found a match " + mSavedPeerConfig);
+                        ///M: for crossmount, support PIN code from outside  @{
+                        if (!mCrossmountEventReceived) {
+                            mSavedPeerConfig.wps.pin = provDisc.pin;
+                            p2pConnectWithPinDisplay(mSavedPeerConfig);
+                            notifyInvitationSent(provDisc.pin, device.deviceAddress);
+                            transitionTo(mGroupNegotiationState);
+                        } else {
+                            logd("[crossmount] PD rsp: SHOW_PIN," +
+                                " move process to UserAuthorizingNegotiationRequestState");
+                            mJoinExistingGroup = false;
+                            transitionTo(mUserAuthorizingNegotiationRequestState);
+                        }
+                        ///@}
+                    }
+                    break;
+                case WifiMonitor.P2P_PROV_DISC_FAILURE_EVENT:
+                    loge("provision discovery failed");
+                    handleGroupCreationFailure();
+                    transitionTo(mInactiveState);
+                    break;
+                ///M:@{
+                case WifiP2pManager.CANCEL_CONNECT:
+                    //Do a supplicant p2p_cancel which only cancels an ongoing
+                    //group negotiation. This will fail for a pending provision
+                    //discovery or for a pending user action, so try Remove group
+                    boolean success = mWifiNative.p2pGroupRemove(mInterface);
+                    handleGroupCreationFailure();
+                    transitionTo(mInactiveState);
+                    if (success) {
+                        replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_FAILED);
+                    }
+
+                    break;
+                ///@}
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class GroupNegotiationState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                // We ignore these right now, since we get a GROUP_STARTED notification
+                // afterwards
+                case WifiMonitor.P2P_GO_NEGOTIATION_SUCCESS_EVENT:
+                case WifiMonitor.P2P_GROUP_FORMATION_SUCCESS_EVENT:
+                    if (DBG) logd(getName() + " go success");
+                    break;
+                case WifiMonitor.P2P_GROUP_STARTED_EVENT:
+                    mGroup = (WifiP2pGroup) message.obj;
+                    if (DBG) logd(getName() + " group started");
+
+                    ///M: ALPS01443292: enable/disable IPv6 on demand  @{
+                    // Always exception, mark until further CTS error with log provided
+                    /*try {
+                        mNwService.enableIpv6(mInterface);
+                    } catch (RemoteException re) {
+                        loge(getName() + " RemoteException: " + re);
+                    } catch (IllegalStateException ie) {
+                        loge(getName() + " IllegalStateException: " + ie);
+                    }*/
+
+                    ///@}
+                    if (mGroup.getNetworkId() == WifiP2pGroup.PERSISTENT_NET_ID) {
+                        /*
+                         * update cache information and set network id to mGroup.
+                         */
+                        updatePersistentNetworks(NO_RELOAD);
+                        String devAddr = mGroup.getOwner().deviceAddress;
+                        mGroup.setNetworkId(mGroups.getNetworkId(devAddr,
+                                mGroup.getNetworkName()));
+
+                        ////M: ALPS01593529: no p2p_invite in wfd source case,
+                        //don't keep persistent group @{
+                        if (mMiracastMode == WifiP2pManager.MIRACAST_SOURCE
+                            && !WFD_DONGLE_USE_P2P_INVITE) {
+                            mWfdSourceAddr = mGroup.getOwner().deviceAddress;
+                            logd("wfd source case: mWfdSourceAddr = " + mWfdSourceAddr);
+                        }
+                        ///@}
+                    }
+
+                    if (mGroup.isGroupOwner()) {
+                        /* Setting an idle time out on GO causes issues with certain scenarios
+                         * on clients where it can be off-channel for longer and with the power
+                         * save modes used.
+                         *
+                         * TODO: Verify multi-channel scenarios and supplicant behavior are
+                         * better before adding a time out in future
+                         */
+                        //Set group idle timeout of 10 sec, to avoid GO beaconing incase of any
+                        //failure during 4-way Handshake.
+                        if (!mAutonomousGroup) {
+                            mWifiNative.setP2pGroupIdle(mGroup.getInterface(), GROUP_IDLE_TIME_S);
+                        }
+                        startDhcpServer(mGroup.getInterface());
+                    } else {
+                        ///M: No DHCP, use static IP @{
+                        if (mGcIgnoresDhcpReq) {
+                            setWifiP2pInfoOnGroupFormation(
+                                NetworkUtils.numericToInetAddress(SERVER_ADDRESS));
+                            String gcIp = STATIC_CLIENT_ADDRESS;
+                            String intf = mGroup.getInterface();
+                            try {
+                                InterfaceConfiguration ifcg = mNwService.getInterfaceConfig(intf);
+                                ifcg.setLinkAddress(new LinkAddress(
+                                        NetworkUtils.numericToInetAddress(gcIp), 24));
+                                ifcg.setInterfaceUp();
+                                mNwService.setInterfaceConfig(intf, ifcg);
+                                //do addInterfaceToLocalNetwork()
+                                StaticIpConfiguration staticIpConfiguration =
+                                    new StaticIpConfiguration();
+                                staticIpConfiguration.ipAddress =
+                                    new LinkAddress(NetworkUtils.numericToInetAddress(gcIp), 24);
+                                mNwService.addInterfaceToLocalNetwork(
+                                    intf,
+                                    staticIpConfiguration.getRoutes(intf));
+                            }  catch (RemoteException re) {
+                                loge("Error! Configuring static IP to " + intf +
+                                        ", :" + re);
+                            }
+                        } else {
+                            mWifiNative.setP2pGroupIdle(mGroup.getInterface(), GROUP_IDLE_TIME_S);
+                            startIpManager(mGroup.getInterface());
+                        }
+                        ///@}
+                        ///M: use MTK power saving command @{
+                        //mWifiNative.setP2pPowerSave(mGroup.getInterface(), false);
+                        setP2pPowerSaveMtk(mGroup.getInterface(), P2P_FAST_PS);
+                        ///@}
+                        WifiP2pDevice groupOwner = mGroup.getOwner();
+                        WifiP2pDevice peer = mPeers.get(groupOwner.deviceAddress);
+                        if (peer != null) {
+                            // update group owner details with peer details found at discovery
+                            groupOwner.updateSupplicantDetails(peer);
+                            mPeers.updateStatus(groupOwner.deviceAddress, WifiP2pDevice.CONNECTED);
+                            sendPeersChangedBroadcast();
+                        } else {
+                            // A supplicant bug can lead to reporting an invalid
+                            // group owner address (all zeroes) at times. Avoid a
+                            // crash, but continue group creation since it is not
+                            // essential.
+                            logw("Unknown group owner " + groupOwner);
+                        }
+                    }
+                    transitionTo(mGroupCreatedState);
+                    break;
+                case WifiMonitor.P2P_GO_NEGOTIATION_FAILURE_EVENT:
+                    /** M: enhance frequency conflict @{ */
+                    if (0 != message.arg1) {
+                        mP2pOperFreq = message.arg1;
+                    }
+                    P2pStatus status = (P2pStatus) message.obj;
+                    loge("go negotiation failed, status = " + status + "\tmP2pOperFreq = " +
+                            mP2pOperFreq);
+                    if (status == P2pStatus.NO_COMMON_CHANNEL) {
+                        transitionTo(mFrequencyConflictState);
+                        break;
+                    }
+                    /* continue with group removal handling */
+                case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
+                    if (DBG) logd(getName() + " go failure");
+                    handleGroupCreationFailure();
+                    transitionTo(mInactiveState);
+                    break;
+                // A group formation failure is always followed by
+                // a group removed event. Flushing things at group formation
+                // failure causes supplicant issues. Ignore right now.
+                case WifiMonitor.P2P_GROUP_FORMATION_FAILURE_EVENT:
+                    /** M: enhance frequency conflict @{ */
+                    if (0 != message.arg1) {
+                        mP2pOperFreq = message.arg1;
+                    }
+                    status = (P2pStatus) message.obj;
+                    loge("group formation failed, status = " + status + "\tmP2pOperFreq = " +
+                            mP2pOperFreq);
+                    if (status == P2pStatus.NO_COMMON_CHANNEL) {
+                        transitionTo(mFrequencyConflictState);
+                        break;
+                    }
+                    break;
+                case WifiMonitor.P2P_INVITATION_RESULT_EVENT:
+                    status = (P2pStatus)message.obj;
+                    if (status == P2pStatus.SUCCESS) {
+                        // invocation was succeeded.
+                        // wait P2P_GROUP_STARTED_EVENT.
+                        break;
+                    }
+                    loge("Invitation result " + status);
+                    if (status == P2pStatus.UNKNOWN_P2P_GROUP) {
+                        // target device has already removed the credential.
+                        // So, remove this credential accordingly.
+                        int netId = mSavedPeerConfig.netId;
+                        if (netId >= 0) {
+                            if (DBG) logd("Remove unknown client from the list");
+                            removeClientFromList(netId, mSavedPeerConfig.deviceAddress, true);
+                        }
+
+                        // Reinvocation has failed, try group negotiation
+                        mSavedPeerConfig.netId = WifiP2pGroup.PERSISTENT_NET_ID;
+                        p2pConnectWithPinDisplay(mSavedPeerConfig);
+                    } else if (status == P2pStatus.INFORMATION_IS_CURRENTLY_UNAVAILABLE) {
+                        if (mDelayReconnectForInfoUnavailable) {
+                            if (DBG)
+                                logd(getName() +
+                                        " mDelayReconnectForInfoUnavailable:" +
+                                        mDelayReconnectForInfoUnavailable);
+                            WifiP2pDevice dev = fetchCurrentDeviceDetails(mSavedPeerConfig);
+                            if ((dev.groupCapability & 0x20 /*bit5*/) == 0) {
+                                if (DBG)
+                                    logd(getName() + "Persistent Reconnect=0, " +
+                                                 "wait for peer re-invite or " +
+                                                 "reconnect peer 120s later");
+
+                                WifiP2pConfig peerConfig = new WifiP2pConfig(mSavedPeerConfig);
+                                sendMessageDelayed(
+                                        obtainMessage(M_P2P_CONN_FOR_INVITE_RES_INFO_UNAVAILABLE,
+                                        peerConfig),
+                                        RECONN_FOR_INVITE_RES_INFO_UNAVAILABLE_TIME_MS);
+                                if (mWifiNative.p2pFind(DISCOVER_TIMEOUT_S)) {
+                                    logd(getName() + "Sart p2pFind for waiting peer invitation");
+                                    sendP2pDiscoveryChangedBroadcast(true);
+                                }
+                                transitionTo(mInactiveState);
+                                break;
+                            } else {
+                                if (DBG)
+                                    logd(getName() + "Persistent Reconnect=1, " +
+                                                 "connect to peer directly");
+                            }
+                        }
+                        // Devices setting persistent_reconnect to 0 in wpa_supplicant
+                        // always defer the invocation request and return
+                        // "information is currently unable" error.
+                        // So, try another way to connect for interoperability.
+                        mSavedPeerConfig.netId = WifiP2pGroup.PERSISTENT_NET_ID;
+                        p2pConnectWithPinDisplay(mSavedPeerConfig);
+                    } else if (status == P2pStatus.NO_COMMON_CHANNEL) {
+                        /** M: enhance frequency conflict @{ */
+                        if (0 != message.arg1)    mP2pOperFreq = message.arg1;
+                        logd("Invitation mP2pOperFreq = " + mP2pOperFreq);
+                        transitionTo(mFrequencyConflictState);
+                    } else {
+                        handleGroupCreationFailure();
+                        transitionTo(mInactiveState);
+                    }
+                    break;
+                ///M:@{
+                case WifiMonitor.WPS_OVERLAP_EVENT:
+                    Toast.makeText(mContext, com.mediatek.internal.R.string.wifi_wps_failed_overlap
+                        , Toast.LENGTH_SHORT).show();
+                    break;
+                ///@}
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class FrequencyConflictState extends State {
+        private AlertDialog mFrequencyConflictDialog;
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+
+            /** M: ALPS01976478: SCC then MCC @{ */
+            if (mMccSupport) {
+                p2pSetCCMode(1);
+            }
+            ///@}
+
+            /** M: enhance frequency conflict @{ */
+            if (!mMccSupport && mMiracastMode == WifiP2pManager.MIRACAST_SOURCE) {
+                sendP2pOPChannelBroadcast();
+                return;
+            } else if (mMiracastMode == WifiP2pManager.MIRACAST_SINK) {
+                // WFD/CrossMount Sink retry to connect.
+                // App wiil disconnect legcy wifi according to AIS channel after P2P connected.
+                logd("[sink] channel conflict, disconnecting wifi by app layer");
+                sendMessage(WifiP2pManager.FREQ_CONFLICT_EX_RESULT, 1);
+                return;
+            }
+            /** @} */
+
+            /** M: ALPS01976478: SCC then MCC, only pure SCC will need channel conflict dialog @{ */
+            if (mMccSupport == true) {
+                if (mConnectToPeer == true) {
+                    if (DBG) logd(getName() + " SCC->MCC, mConnectToPeer=" + mConnectToPeer +
+                        "\tP2pOperFreq=" + mP2pOperFreq);
+                    mSavedPeerConfig.setPreferOperFreq(mP2pOperFreq);
+
+                    // do p2p_connect/p2p_invite again
+                    if (!reinvokePersistentGroup(mSavedPeerConfig)) {
+                        // no need PD again!
+                        p2pConnectWithPinDisplay(mSavedPeerConfig);
+                    }
+
+                } else {
+                    if (DBG) logd(getName() + " SCC->MCC, mConnectToPeer=" + mConnectToPeer +
+                        "\tdo p2p_connect/p2p_invite again!");
+                    // don't attach peer op freq. parameter,
+                    //supplicant will switch to MCC automatically
+                    mP2pOperFreq = -1;
+                    mSavedPeerConfig.setPreferOperFreq(mP2pOperFreq);
+
+
+                    // do p2p_connect/p2p_invite again
+                    if (!reinvokePersistentGroup(mSavedPeerConfig)) {
+                        // no need PD again!
+                        p2pConnectWithPinDisplay(mSavedPeerConfig);
+                    }
+                }
+                transitionTo(mGroupNegotiationState);
+
+            } else {
+                notifyFrequencyConflict();
+
+            }
+            ///@}
+        }
+
+        private void notifyFrequencyConflict() {
+            logd("Notify frequency conflict");
+            Resources r = Resources.getSystem();
+
+            AlertDialog dialog = new AlertDialog.Builder(mContext)
+                .setMessage(r.getString(R.string.wifi_p2p_frequency_conflict_message,
+                        getDeviceName(mSavedPeerConfig.deviceAddress)))
+                .setPositiveButton(r.getString(R.string.dlg_ok), new OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            sendMessage(DROP_WIFI_USER_ACCEPT);
+                        }
+                    })
+                .setNegativeButton(r.getString(R.string.decline), new OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            sendMessage(DROP_WIFI_USER_REJECT);
+                        }
+                    })
+                .setOnCancelListener(new DialogInterface.OnCancelListener() {
+                        @Override
+                        public void onCancel(DialogInterface arg0) {
+                            sendMessage(DROP_WIFI_USER_REJECT);
+                        }
+                    })
+                .create();
+
+            dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+            WindowManager.LayoutParams attrs = dialog.getWindow().getAttributes();
+            attrs.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
+            dialog.getWindow().setAttributes(attrs);
+            dialog.show();
+            mFrequencyConflictDialog = dialog;
+        }
+
+        /** M: enhance frequency conflict @{ */
+        private void notifyFrequencyConflictEx() {
+            logd("Notify frequency conflict enhancement! mP2pOperFreq = " + mP2pOperFreq);
+            Resources r = Resources.getSystem();
+            String localFreq = "";
+
+            if (mP2pOperFreq > 0) {
+                if (mP2pOperFreq < 5000) {
+                    localFreq = "2.4G band-" + new String("" + mP2pOperFreq) + " MHz";
+                } else {
+                    localFreq = "5G band-" + new String("" + mP2pOperFreq) + " MHz";
+                }
+            } else {
+                loge(getName() + " in-valid OP channel: " + mP2pOperFreq);
+            }
+
+            AlertDialog dialog = new AlertDialog.Builder(mContext)
+                .setMessage(r.getString(
+                        com.mediatek.internal.R.string.wifi_p2p_frequency_conflict_message,
+                        getDeviceName(mSavedPeerConfig.deviceAddress),
+                        localFreq))
+                .setPositiveButton(r.getString(R.string.dlg_ok), new OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            sendMessage(DROP_WIFI_USER_ACCEPT);
+                        }
+                    })
+                .setNegativeButton(r.getString(R.string.decline), new OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            sendMessage(DROP_WIFI_USER_REJECT);
+                        }
+                    })
+                .setOnCancelListener(new DialogInterface.OnCancelListener() {
+                        @Override
+                        public void onCancel(DialogInterface arg0) {
+                            sendMessage(DROP_WIFI_USER_REJECT);
+                        }
+                    })
+                .create();
+
+            dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+            dialog.show();
+            mFrequencyConflictDialog = dialog;
+        }
+        /** @} */
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case WifiMonitor.P2P_GO_NEGOTIATION_SUCCESS_EVENT:
+                case WifiMonitor.P2P_GROUP_FORMATION_SUCCESS_EVENT:
+                    loge(getName() + "group sucess during freq conflict!");
+                    break;
+                case WifiMonitor.P2P_GROUP_STARTED_EVENT:
+                    loge(getName() + "group started after freq conflict, handle anyway");
+                    deferMessage(message);
+                    transitionTo(mGroupNegotiationState);
+                    break;
+                case WifiMonitor.P2P_GO_NEGOTIATION_FAILURE_EVENT:
+                case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
+                case WifiMonitor.P2P_GROUP_FORMATION_FAILURE_EVENT:
+                    // Ignore failures since we retry again
+                    break;
+                case DROP_WIFI_USER_REJECT:
+                    ///M: ALPS01472489: notify user decline channel conflict  @{
+                    mGroupRemoveReason = P2pStatus.MTK_EXPAND_02;
+                    ///@}
+                    // User rejected dropping wifi in favour of p2p
+                    handleGroupCreationFailure();
+                    transitionTo(mInactiveState);
+                    break;
+                case DROP_WIFI_USER_ACCEPT:
+                    // User accepted dropping wifi in favour of p2p
+                    mWifiChannel.sendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST, 1);
+                    mTemporarilyDisconnectedWifi = true;
+                    break;
+                case DISCONNECT_WIFI_RESPONSE:
+                    // Got a response from wifistatemachine, retry p2p
+                    if (DBG) logd(getName() + "Wifi disconnected, retry p2p");
+                    transitionTo(mInactiveState);
+                    ///M:@{
+                    mP2pOperFreq = -1;
+                    mSavedPeerConfig.setPreferOperFreq(mP2pOperFreq);
+                    sendMessage(WifiP2pManager.CONNECT, mSavedPeerConfig);
+                    ///@}
+                    break;
+                /** M: enhance frequency conflict @{ */
+                case WifiP2pManager.FREQ_CONFLICT_EX_RESULT:
+                    int accept = (int) message.arg1;
+                    if (DBG) {
+                        logd(getName() + " frequency confliect enhancement decision: " + accept +
+                        ", and mP2pOperFreq = " + mP2pOperFreq);
+                    }
+                    if (1 == accept) {
+                        transitionTo(mInactiveState);
+                        mSavedPeerConfig.setPreferOperFreq(mP2pOperFreq);
+                        sendMessage(WifiP2pManager.CONNECT, mSavedPeerConfig);
+                    } else {
+                        notifyFrequencyConflictEx();
+                    }
+                    break;
+                /** @} */
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        public void exit() {
+            if (mFrequencyConflictDialog != null) mFrequencyConflictDialog.dismiss();
+        }
+    }
+
+    class GroupCreatedState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            // Once connected, peer config details are invalid
+            mSavedPeerConfig.invalidate();
+            mNetworkInfo.setDetailedState(NetworkInfo.DetailedState.CONNECTED, null, null);
+
+            updateThisDevice(WifiP2pDevice.CONNECTED);
+
+            //DHCP server has already been started if I am a group owner
+            if (mGroup.isGroupOwner()) {
+                setWifiP2pInfoOnGroupFormation(NetworkUtils.numericToInetAddress(SERVER_ADDRESS));
+            ///M:@{
+            } else {
+                ///M: wfd sink@GC, stop listening to avoid packet lost  @{
+                if (isWfdSinkConnected()) {
+                    if (DBG) logd(getName() + " [wfd sink] stop scan@GC, to avoid packet lost");
+                    mWifiNative.p2pStopFind();
+                }
+                ///@}
+            }
+            ///@}
+
+            // In case of a negotiation group, connection changed is sent
+            // after a client joins. For autonomous, send now
+            if (mAutonomousGroup) {
+                sendP2pConnectionChangedBroadcast();
+            }
+
+            // Use static IP without IPM message, send connection change now
+            if (mGcIgnoresDhcpReq) {
+                sendP2pConnectionChangedBroadcast();
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case WifiMonitor.AP_STA_CONNECTED_EVENT:
+                    WifiP2pDevice device = (WifiP2pDevice) message.obj;
+                    String deviceAddress = device.deviceAddress;
+                    // Clear timeout that was set when group was started.
+                    mWifiNative.setP2pGroupIdle(mGroup.getInterface(), 0);
+                    if (deviceAddress != null) {
+                        if (mPeers.get(deviceAddress) != null) {
+                            mGroup.addClient(mPeers.get(deviceAddress));
+                        } else {
+                            ///M: ALPS00712601 + ALPS00741190: GC connected but not in GO UI @{
+                            //mGroup.addClient(deviceAddress);
+                            device = p2pGoGetSta(device, deviceAddress);
+                            mGroup.addClient(device);
+                            mPeers.update(device);
+                            ///@}
+                        }
+                        ///M: update interface address in mPeers @{
+                        WifiP2pDevice gcLocal = mPeers.get(deviceAddress);
+                        gcLocal.interfaceAddress = device.interfaceAddress;
+                        mPeers.update(gcLocal);
+                        ///@}
+                        mPeers.updateStatus(deviceAddress, WifiP2pDevice.CONNECTED);
+                        sendPeersChangedBroadcast();
+                        ///@}
+                        ///M: wfd sink@GO, stop listening to avoid packet lost  @{
+                        if (isWfdSinkConnected()) {
+                            if (DBG) {
+                                logd(getName() + " [wfd sink] stop scan@GO, to avoid packet lost");
+                            }
+                            mWifiNative.p2pStopFind();
+                        }
+                        ///@}
+                    } else {
+                        loge("Connect on null device address, ignore");
+                    }
+                    sendP2pConnectionChangedBroadcast();
+                    break;
+                case WifiMonitor.AP_STA_DISCONNECTED_EVENT:
+                    device = (WifiP2pDevice) message.obj;
+                    deviceAddress = device.deviceAddress;
+                    if (deviceAddress != null) {
+                        mPeers.updateStatus(deviceAddress, WifiP2pDevice.AVAILABLE);
+                        if (mGroup.removeClient(deviceAddress)) {
+                            if (DBG) logd("Removed client " + deviceAddress);
+                            if (!mAutonomousGroup && mGroup.isClientListEmpty()) {
+                                logd("Client list empty, remove non-persistent p2p group");
+                                mWifiNative.p2pGroupRemove(mGroup.getInterface());
+                                // We end up sending connection changed broadcast
+                                // when this happens at exit()
+                            } else {
+                                // Notify when a client disconnects from group
+                                sendP2pConnectionChangedBroadcast();
+                            }
+                        } else {
+                            if (DBG) logd("Failed to remove client " + deviceAddress);
+                            for (WifiP2pDevice c : mGroup.getClientList()) {
+                                if (DBG) logd("client " + c.deviceAddress);
+                            }
+                        }
+                        sendPeersChangedBroadcast();
+                        if (DBG) logd(getName() + " ap sta disconnected");
+                    } else {
+                        loge("Disconnect on unknown device: " + device);
+                    }
+                    break;
+                case IPM_PRE_DHCP_ACTION:
+                    mWifiNative.setP2pPowerSave(mGroup.getInterface(), false);
+                    mIpManager.completedPreDhcpAction();
+                    break;
+                case IPM_POST_DHCP_ACTION:
+                    /// M: MTK removed,
+                    /// GC power saving had doing at GroupNegotiationState
+                    /// P2P_GROUP_STARTED_EVENT @{
+                    //mWifiNative.setP2pPowerSave(mGroup.getInterface(), true);
+                    break;
+                case IPM_DHCP_RESULTS:
+                    mDhcpResults = (DhcpResults) message.obj;
+                    break;
+                case IPM_PROVISIONING_SUCCESS:
+                    if (DBG) logd("mDhcpResults: " + mDhcpResults);
+                    setWifiP2pInfoOnGroupFormation(mDhcpResults.serverAddress);
+                    // Send this broadcast later
+                    //sendP2pConnectionChangedBroadcast();
+                    try {
+                        final String ifname = mGroup.getInterface();
+                        mNwService.addInterfaceToLocalNetwork(
+                                ifname, mDhcpResults.getRoutes(ifname));
+                    } catch (RemoteException e) {
+                        loge("Failed to add iface to local network " + e);
+                    } catch (IllegalStateException ie) {
+                        loge("Failed to add iface to local network: IllegalStateException=" + ie);
+                    }
+                    ///M: for getPeerIpAddress(), remove "/" prefix  @{
+                    if (mDhcpResults != null) {
+                        if (mDhcpResults.serverAddress != null &&
+                                mDhcpResults.serverAddress.toString().startsWith("/")) {
+                            mGroup.getOwner().deviceIP =
+                                    mDhcpResults.serverAddress.toString().substring(1);
+                        } else {
+                            mGroup.getOwner().deviceIP = "" + mDhcpResults.serverAddress;
+                        }
+                    }
+                    ///@}
+                    /// M: To fix application start socket programming but p2p IP routing
+                    /// rule isn't ready. Do broadcast after addInterfaceToLocalNetwork().  @{
+                    sendP2pConnectionChangedBroadcast();
+                    ///@}
+                    break;
+                case IPM_PROVISIONING_FAILURE:
+                    loge("IP provisioning failed");
+                    mWifiNative.p2pGroupRemove(mGroup.getInterface());
+                    break;
+                case WifiP2pManager.REMOVE_GROUP:
+                    if (DBG) logd(getName() + " remove group");
+                    if (mWifiNative.p2pGroupRemove(mGroup.getInterface())) {
+                        transitionTo(mOngoingGroupRemovalState);
+                        replyToMessage(message, WifiP2pManager.REMOVE_GROUP_SUCCEEDED);
+                    } else {
+                        handleGroupRemoved();
+                        transitionTo(mInactiveState);
+                        replyToMessage(message, WifiP2pManager.REMOVE_GROUP_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                /* We do not listen to NETWORK_DISCONNECTION_EVENT for group removal
+                 * handling since supplicant actually tries to reconnect after a temporary
+                 * disconnect until group idle time out. Eventually, a group removal event
+                 * will come when group has been removed.
+                 *
+                 * When there are connectivity issues during temporary disconnect, the application
+                 * will also just remove the group.
+                 *
+                 * Treating network disconnection as group removal causes race conditions since
+                 * supplicant would still maintain the group at that stage.
+                 */
+                case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
+                    ///M:@{
+                    /** M: enhance frequency conflict @{ */
+                    if (0 != message.arg1)    mP2pOperFreq = message.arg1;
+                    mGroupRemoveReason = (P2pStatus) message.obj;
+                    if (DBG) logd(getName() + " group removed, reason: " + mGroupRemoveReason +
+                        ", mP2pOperFreq: " + mP2pOperFreq);
+                    ///@}
+                    handleGroupRemoved();
+                    transitionTo(mInactiveState);
+                    break;
+                case WifiMonitor.P2P_DEVICE_LOST_EVENT:
+                    device = (WifiP2pDevice) message.obj;
+                    //Device loss for a connected device indicates it is not in discovery any more
+                    if (mGroup.contains(device)) {
+                        if (DBG) logd("Add device to lost list " + device);
+                        mPeersLostDuringConnection.updateSupplicantDetails(device);
+                        return HANDLED;
+                    }
+                    // Do the regular device lost handling
+                    return NOT_HANDLED;
+                case WifiStateMachine.CMD_DISABLE_P2P_REQ:
+                    sendMessage(WifiP2pManager.REMOVE_GROUP);
+                    deferMessage(message);
+                    break;
+                    // This allows any client to join the GO during the
+                    // WPS window
+                case WifiP2pManager.START_WPS:
+                    WpsInfo wps = (WpsInfo) message.obj;
+                    if (wps == null) {
+                        replyToMessage(message, WifiP2pManager.START_WPS_FAILED);
+                        break;
+                    }
+                    boolean ret = true;
+                    if (wps.setup == WpsInfo.PBC) {
+                        ret = mWifiNative.startWpsPbc(mGroup.getInterface(), null);
+                    } else {
+                        if (wps.pin == null) {
+                            String pin = mWifiNative.startWpsPinDisplay(mGroup.getInterface());
+                            try {
+                                Integer.parseInt(pin);
+                                notifyInvitationSent(pin, "any");
+                            } catch (NumberFormatException ignore) {
+                                ret = false;
+                            }
+                        } else {
+                            ret = mWifiNative.startWpsPinKeypad(mGroup.getInterface(),
+                                    wps.pin);
+                        }
+                    }
+                    replyToMessage(message, ret ? WifiP2pManager.START_WPS_SUCCEEDED :
+                            WifiP2pManager.START_WPS_FAILED);
+                    break;
+                case WifiP2pManager.CONNECT:
+                    WifiP2pConfig config = (WifiP2pConfig) message.obj;
+                    if (isConfigInvalid(config)) {
+                        loge("Dropping connect requeset " + config);
+                        replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
+                        break;
+                    }
+                    logd("Inviting device : " + config.deviceAddress);
+                    mSavedPeerConfig = config;
+                    /** M: ALPS01976478: SCC then MCC @{ */
+                    mConnectToPeer = true;
+                    ///@}
+
+                    if (mWifiNative.p2pInvite(mGroup, config.deviceAddress)) {
+                        mPeers.updateStatus(config.deviceAddress, WifiP2pDevice.INVITED);
+                        sendPeersChangedBroadcast();
+                        replyToMessage(message, WifiP2pManager.CONNECT_SUCCEEDED);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.CONNECT_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    // TODO: figure out updating the status to declined when invitation is rejected
+                    break;
+                case WifiMonitor.P2P_INVITATION_RESULT_EVENT:
+                    P2pStatus status = (P2pStatus)message.obj;
+                    logd("===> INVITATION RESULT EVENT : " + status +
+                        ",\tis GO ? : " +
+                        mGroup.getOwner().deviceAddress.equals(mThisDevice.deviceAddress));
+                    ///M: ALPS00609781: remove 3rd phone on gc UI when 3rd is invited @{
+                    boolean inviteDone = false;
+                    if (status == P2pStatus.SUCCESS) {
+                        // invocation was succeeded.
+                        //break;
+                        inviteDone = true;
+                    }
+                    loge("Invitation result " + status +
+                        ",\tis GO ? : " +
+                        mGroup.getOwner().deviceAddress.equals(mThisDevice.deviceAddress));
+                    if (status == P2pStatus.UNKNOWN_P2P_GROUP) {
+                        // target device has already removed the credential.
+                        // So, remove this credential accordingly.
+                        int netId = mGroup.getNetworkId();
+                        if (netId >= 0) {
+                            if (DBG) logd("Remove unknown client from the list");
+                            if (!removeClientFromList(netId,
+                                    mSavedPeerConfig.deviceAddress, false)) {
+                                // not found the client on the list
+                                loge("Already removed the client, ignore");
+                                break;
+                            }
+                            // try invitation.
+                            sendMessage(WifiP2pManager.CONNECT, mSavedPeerConfig);
+                        }
+                    /** M: ALPS01976478: SCC then MCC @{ */
+                    } else if (status == P2pStatus.NO_COMMON_CHANNEL) {
+                        if (mMccSupport) {
+                            p2pSetCCMode(1);
+                        }
+                    ///@}
+                        inviteDone = true;
+                    } else {
+                        inviteDone = true;
+                    }
+
+                    if (inviteDone &&
+                        !mGroup.getOwner().deviceAddress.equals(mThisDevice.deviceAddress)) {
+                        if (mPeers.remove(mPeers.get(mSavedPeerConfig.deviceAddress))) {
+                              sendPeersChangedBroadcast();
+                        }
+                    }
+                    ///@}
+                    break;
+                case WifiMonitor.P2P_PROV_DISC_PBC_REQ_EVENT:
+                case WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
+                case WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
+                    WifiP2pProvDiscEvent provDisc = (WifiP2pProvDiscEvent) message.obj;
+                    if (!TextUtils.isEmpty(provDisc.device.deviceName)) {
+                        mPeers.update(provDisc.device);
+                    }
+                    ///M: for crossmount  @{
+                    updateCrossMountInfo(provDisc.device.deviceAddress);
+                    ///@}
+                    mSavedPeerConfig = new WifiP2pConfig();
+                    mSavedPeerConfig.deviceAddress = provDisc.device.deviceAddress;
+                    if (message.what == WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT) {
+                        mSavedPeerConfig.wps.setup = WpsInfo.KEYPAD;
+                    } else if (message.what == WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT) {
+                        mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
+                        mSavedPeerConfig.wps.pin = provDisc.pin;
+                    } else {
+                        mSavedPeerConfig.wps.setup = WpsInfo.PBC;
+                    }
+                    transitionTo(mUserAuthorizingJoinState);
+                    break;
+                case WifiMonitor.P2P_GROUP_STARTED_EVENT:
+                    loge("Duplicate group creation event notice, ignore");
+                    break;
+                ///M:@{
+                //ALPS02238912
+                case WifiP2pManager.REMOVE_CLIENT:
+                    String mac = null;
+                    if (message.obj != null) {
+                        mac = ((Bundle) message.obj)
+                                .getString(WifiP2pManager.EXTRA_CLIENT_MESSAGE);
+                    }
+                    logd("remove client, am I GO? " +
+                        mGroup.getOwner().deviceAddress.equals(mThisDevice.deviceAddress) +
+                        ", ths client is " + mac);
+
+                    if (!mGroup.getOwner().deviceAddress.equals(mThisDevice.deviceAddress)) {
+                        replyToMessage(message, WifiP2pManager.REMOVE_CLIENT_FAILED,
+                                WifiP2pManager.ERROR);
+                    } else {
+                        if (p2pRemoveClient(mGroup.getInterface(), mac)) {
+                            replyToMessage(message, WifiP2pManager.REMOVE_CLIENT_SUCCEEDED);
+                        } else {
+                            replyToMessage(message, WifiP2pManager.REMOVE_CLIENT_FAILED,
+                                WifiP2pManager.ERROR);
+                        }
+                    }
+                    break;
+                case WifiMonitor.P2P_PEER_DISCONNECT_EVENT:
+                    /*M: ALPS00790492: handle P2P_PEER_DISCONNECT_EVENT frequency conflict error,
+                    //reason code is 99*/
+                    int IEEE802_11_ReasonCode = -1;
+                    if (message.obj != null) {
+                        try {
+                            IEEE802_11_ReasonCode = Integer.valueOf((String) message.obj);
+                            if (IEEE802_11_ReasonCode == 99) {
+                                mGroupRemoveReason = P2pStatus.NO_COMMON_CHANNEL;
+                            }
+                        } catch (NumberFormatException e) {
+                            loge("Error! Format unexpected");
+                        }
+                    }
+                    /** M: enhance frequency conflict @{ */
+                    if (0 != message.arg1)    mP2pOperFreq = message.arg1;
+                    /* only GC will received this event */
+                    if (DBG)
+                        loge(getName() +
+                             " I'm GC and has been disconnected by GO. IEEE 802.11 reason code: " +
+                             IEEE802_11_ReasonCode +
+                        ", mP2pOperFreq: " + mP2pOperFreq);
+                    mWifiNative.p2pGroupRemove(mGroup.getInterface());
+                    handleGroupRemoved();
+                    transitionTo(mInactiveState);
+                    break;
+                case WifiMonitor.P2P_DEVICE_FOUND_EVENT:
+                    WifiP2pDevice peerDevice = (WifiP2pDevice) message.obj;
+                    if (mThisDevice.deviceAddress.equals(peerDevice.deviceAddress)) break;
+                    if (mGroup.contains(peerDevice)) {
+                        peerDevice.status = WifiP2pDevice.CONNECTED;
+                    }
+                    mPeers.update(peerDevice);
+                    sendPeersChangedBroadcast();
+                    break;
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                    if (DBG) loge("Supplicant close unexpected, send fake Group Remove event");
+                    sendMessage(WifiMonitor.P2P_GROUP_REMOVED_EVENT);
+                    deferMessage(message);
+                    break;
+                case WifiP2pManager.DISCOVER_PEERS:
+                    // do not send service discovery request while normal find operation.
+                    clearSupplicantServiceRequest();
+                    if (mWifiNative.p2pFind(CONNECTED_DISCOVER_TIMEOUT_S)) {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_SUCCEEDED);
+                        sendP2pDiscoveryChangedBroadcast(true);
+                    } else {
+                        replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED,
+                                WifiP2pManager.ERROR);
+                    }
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        public void exit() {
+            updateThisDevice(WifiP2pDevice.AVAILABLE);
+            resetWifiP2pInfo();
+            mNetworkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
+            ///M: wfd sink & crossmount, label this broadcast due to 2nd GC connection comming  @{
+            if (mGroup != null) {
+                logd("[wfd sink/source] [crossmount] " +
+                    " {1} isGroupOwner: " + mGroup.isGroupOwner() +
+                    " {2} getClientAmount: " + mGroup.getClientAmount() +
+                    " {3} isGroupRemoved(): " + isGroupRemoved() +
+                    " {4} mCrossmountIEAdded: " + mCrossmountIEAdded);
+            }
+            // case 1: wfd sink && go & gc amount=1
+            if (isWfdSinkConnected()) {
+                //sendP2pConnectionChangedBroadcast(P2pStatus.MTK_EXPAND_01);
+                logd("[wfd sink/source] don't bother wfd framework, case 1");
+
+            // case 2: wfd source && group still formed
+            } else if (isWfdSourceConnected()) {
+                //sendP2pConnectionChangedBroadcast(P2pStatus.MTK_EXPAND_01);
+                logd("[wfd sink/source] don't bother wfd framework, case 2");
+
+            // case 3: crossmount && go && gc amount>0
+            } else if (isCrossMountGOwithMultiGC()) {
+                logd("[crossmount] don't bother crossmount framework, case 3");
+
+            } else
+            ///@}
+            /*M: ALPS00677009: broadcast the group removed reason*/
+            sendP2pConnectionChangedBroadcast(mGroupRemoveReason);
+        }
+    }
+
+    class UserAuthorizingJoinState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+            ///M: for wfd sink, reject 2nd gc  @{
+            if (isWfdSinkEnabled()) {
+                sendMessage(PEER_CONNECTION_USER_REJECT);
+
+            ///M: crossmount: dialog handling move to crossmount framework  @{
+            } else if (mCrossmountEventReceived) {
+                sendP2pCrossmountIntentionBroadcast();
+
+            } else
+            ///@}
+            notifyInvitationReceived();
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                case WifiMonitor.P2P_PROV_DISC_PBC_REQ_EVENT:
+                case WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
+                case WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
+                    //Ignore more client requests
+                    break;
+                case PEER_CONNECTION_USER_ACCEPT:
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER:
+                    ///M: crossmount, support PIN code from outside  @{
+                    if (message.what == WifiP2pManager.PEER_CONNECTION_USER_ACCEPT_FROM_OUTER) {
+                        p2pOverwriteWpsPin(
+                            "[crossmount] USER_ACCEPT@UserAuthorizingJoinState",
+                            message.obj);
+                    }
+                    ///@
+                ///@}
+                    //Stop discovery to avoid failure due to channel switch
+                    mWifiNative.p2pStopFind();
+                    if (mSavedPeerConfig.wps.setup == WpsInfo.PBC) {
+                        mWifiNative.startWpsPbc(mGroup.getInterface(), null);
+                    } else {
+                        mWifiNative.startWpsPinKeypad(mGroup.getInterface(),
+                                mSavedPeerConfig.wps.pin);
+                    }
+                    //M: ALPS02215527: stay at UserAuthorizingJoinState,
+                    // wait connect result then going back to GroupCreatedState
+                    //transitionTo(mGroupCreatedState);
+                    ///@}
+                    break;
+                case PEER_CONNECTION_USER_REJECT:
+                ///M: wfd sink @{
+                case WifiP2pManager.PEER_CONNECTION_USER_REJECT_FROM_OUTER:
+                ///@}
+                    if (DBG) logd("User rejected incoming request");
+                    transitionTo(mGroupCreatedState);
+                    break;
+                /*M: ALPS02215527: to fit P2P-PROV-DISC-PBC-REQ received twice*/
+                case WifiMonitor.AP_STA_CONNECTED_EVENT:
+                    if (DBG) logd("incoming request is connected!");
+                    deferMessage(message);
+                    transitionTo(mGroupCreatedState);
+                    break;
+                case WifiMonitor.WPS_OVERLAP_EVENT:
+                case WifiMonitor.WPS_FAIL_EVENT:
+                case WifiMonitor.WPS_TIMEOUT_EVENT:
+                    if (DBG) logd("incoming request connect failed!");
+                    transitionTo(mGroupCreatedState);
+                    break;
+                ///@}
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        @Override
+        public void exit() {
+            //TODO: dismiss dialog if not already done
+        }
+    }
+
+    class OngoingGroupRemovalState extends State {
+        @Override
+        public void enter() {
+            if (DBG) logd(getName());
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) logd(getName() + message.toString());
+            switch (message.what) {
+                // Group removal ongoing. Multiple calls
+                // end up removing persisted network. Do nothing.
+                case WifiP2pManager.REMOVE_GROUP:
+                    replyToMessage(message, WifiP2pManager.REMOVE_GROUP_SUCCEEDED);
+                    break;
+                ///M: REMOVE_CLIENT follow REMOVE_GROUP behavior  @{
+                case WifiP2pManager.REMOVE_CLIENT:
+                    replyToMessage(message, WifiP2pManager.REMOVE_CLIENT_SUCCEEDED);
+                    break;
+                ///@}
+                // Parent state will transition out of this state
+                // when removal is complete
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        super.dump(fd, pw, args);
+        pw.println("mWifiP2pInfo " + mWifiP2pInfo);
+        pw.println("mGroup " + mGroup);
+        pw.println("mSavedPeerConfig " + mSavedPeerConfig);
+        pw.println();
+    }
+
+    private void sendP2pStateChangedBroadcast(boolean enabled) {
+        final Intent intent = new Intent(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        if (enabled) {
+            intent.putExtra(WifiP2pManager.EXTRA_WIFI_STATE,
+                    WifiP2pManager.WIFI_P2P_STATE_ENABLED);
+        } else {
+            intent.putExtra(WifiP2pManager.EXTRA_WIFI_STATE,
+                    WifiP2pManager.WIFI_P2P_STATE_DISABLED);
+        }
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void sendP2pDiscoveryChangedBroadcast(boolean started) {
+        if (mDiscoveryStarted == started) return;
+        mDiscoveryStarted = started;
+
+        if (DBG) logd("discovery change broadcast " + started);
+
+        final Intent intent = new Intent(WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(WifiP2pManager.EXTRA_DISCOVERY_STATE, started ?
+                WifiP2pManager.WIFI_P2P_DISCOVERY_STARTED :
+                WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void sendThisDeviceChangedBroadcast() {
+        final Intent intent = new Intent(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(WifiP2pManager.EXTRA_WIFI_P2P_DEVICE, new WifiP2pDevice(mThisDevice));
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void sendPeersChangedBroadcast() {
+        final Intent intent = new Intent(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
+        intent.putExtra(WifiP2pManager.EXTRA_P2P_DEVICE_LIST, new WifiP2pDeviceList(mPeers));
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        /*M: ALPS00541624, sticky broadcast to avoid apk miss peer information */
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void sendP2pConnectionChangedBroadcast() {
+        if (DBG) logd("sending p2p connection changed broadcast, mGroup: " + mGroup);
+        Intent intent = new Intent(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        intent.putExtra(WifiP2pManager.EXTRA_WIFI_P2P_INFO, new WifiP2pInfo(mWifiP2pInfo));
+        intent.putExtra(WifiP2pManager.EXTRA_NETWORK_INFO, new NetworkInfo(mNetworkInfo));
+        intent.putExtra(WifiP2pManager.EXTRA_WIFI_P2P_GROUP, new WifiP2pGroup(mGroup));
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+        mWifiChannel.sendMessage(WifiP2pServiceImpl.P2P_CONNECTION_CHANGED,
+                new NetworkInfo(mNetworkInfo));
+    }
+
+    private void sendP2pPersistentGroupsChangedBroadcast() {
+        if (DBG) logd("sending p2p persistent groups changed broadcast");
+        Intent intent = new Intent(WifiP2pManager.WIFI_P2P_PERSISTENT_GROUPS_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void startDhcpServer(String intf) {
+        InterfaceConfiguration ifcg = null;
+        try {
+            ifcg = mNwService.getInterfaceConfig(intf);
+            ifcg.setLinkAddress(new LinkAddress(NetworkUtils.numericToInetAddress(
+                        SERVER_ADDRESS), 24));
+            ifcg.setInterfaceUp();
+            mNwService.setInterfaceConfig(intf, ifcg);
+            /* This starts the dnsmasq server */
+            ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(
+                    Context.CONNECTIVITY_SERVICE);
+            String[] tetheringDhcpRanges = cm.getTetheredDhcpRanges();
+            if (mNwService.isTetheringStarted()) {
+                if (DBG) logd("Stop existing tethering and restart it");
+                mNwService.stopTethering();
+            }
+            mNwService.tetherInterface(intf);
+            mNwService.startTethering(tetheringDhcpRanges);
+        } catch (Exception e) {
+            loge("Error configuring interface " + intf + ", :" + e);
+            return;
+        }
+
+        logd("Started Dhcp server on " + intf);
+   }
+
+    private void stopDhcpServer(String intf) {
+        try {
+            mNwService.untetherInterface(intf);
+            for (String temp : mNwService.listTetheredInterfaces()) {
+                logd("List all interfaces " + temp);
+                if (temp.compareTo(intf) != 0) {
+                    logd("Found other tethering interfaces, so keep tethering alive");
+                    return;
+                }
+            }
+            mNwService.stopTethering();
+        } catch (Exception e) {
+            loge("Error stopping Dhcp server" + e);
+            return;
+        } finally {
+            logd("Stopped Dhcp server");
+        }
+    }
+
+    private void notifyP2pEnableFailure() {
+        Resources r = Resources.getSystem();
+        AlertDialog dialog = new AlertDialog.Builder(mContext)
+            .setTitle(r.getString(R.string.wifi_p2p_dialog_title))
+            .setMessage(r.getString(R.string.wifi_p2p_failed_message))
+            .setPositiveButton(r.getString(R.string.ok), null)
+            .create();
+        dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+        WindowManager.LayoutParams attrs = dialog.getWindow().getAttributes();
+        attrs.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
+        dialog.getWindow().setAttributes(attrs);
+        dialog.show();
+    }
+
+    private void addRowToDialog(ViewGroup group, int stringId, String value) {
+        Resources r = Resources.getSystem();
+        View row = LayoutInflater.from(mContext).inflate(R.layout.wifi_p2p_dialog_row,
+                group, false);
+        ((TextView) row.findViewById(R.id.name)).setText(r.getString(stringId));
+        ((TextView) row.findViewById(R.id.value)).setText(value);
+        group.addView(row);
+    }
+
+    private void notifyInvitationSent(String pin, String peerAddress) {
+        Resources r = Resources.getSystem();
+
+        final View textEntryView = LayoutInflater.from(mContext)
+                .inflate(R.layout.wifi_p2p_dialog, null);
+
+        ViewGroup group = (ViewGroup) textEntryView.findViewById(R.id.info);
+        addRowToDialog(group, R.string.wifi_p2p_to_message, getDeviceName(peerAddress));
+        addRowToDialog(group, R.string.wifi_p2p_show_pin_message, pin);
+
+        AlertDialog dialog = new AlertDialog.Builder(mContext)
+            .setTitle(r.getString(R.string.wifi_p2p_invitation_sent_title))
+            .setView(textEntryView)
+            .setPositiveButton(r.getString(R.string.ok), null)
+            .create();
+        dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+        WindowManager.LayoutParams attrs = dialog.getWindow().getAttributes();
+        attrs.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
+        dialog.getWindow().setAttributes(attrs);
+        dialog.show();
+    }
+
+    private void notifyInvitationReceived() {
+        Resources r = Resources.getSystem();
+        final WpsInfo wps = mSavedPeerConfig.wps;
+        final View textEntryView = LayoutInflater.from(mContext)
+                .inflate(R.layout.wifi_p2p_dialog, null);
+
+        ViewGroup group = (ViewGroup) textEntryView.findViewById(R.id.info);
+        addRowToDialog(group, R.string.wifi_p2p_from_message, getDeviceName(
+                mSavedPeerConfig.deviceAddress));
+
+        final EditText pin = (EditText) textEntryView.findViewById(R.id.wifi_p2p_wps_pin);
+
+        AlertDialog dialog = new AlertDialog.Builder(mContext)
+            .setTitle(r.getString(R.string.wifi_p2p_invitation_to_connect_title))
+            .setView(textEntryView)
+            .setPositiveButton(r.getString(R.string.accept), new OnClickListener() {
+                        public void onClick(DialogInterface dialog, int which) {
+                            if (wps.setup == WpsInfo.KEYPAD) {
+                                mSavedPeerConfig.wps.pin = pin.getText().toString();
+                            }
+                            if (DBG) logd(getName() + " accept invitation " + mSavedPeerConfig);
+                            sendMessage(PEER_CONNECTION_USER_ACCEPT);
+                        }
+                    })
+            .setNegativeButton(r.getString(R.string.decline), new OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            if (DBG) logd(getName() + " ignore connect");
+                            sendMessage(PEER_CONNECTION_USER_REJECT);
+                        }
+                    })
+            .setOnCancelListener(new DialogInterface.OnCancelListener() {
+                        @Override
+                        public void onCancel(DialogInterface arg0) {
+                            if (DBG) logd(getName() + " ignore connect");
+                            sendMessage(PEER_CONNECTION_USER_REJECT);
+                        }
+                    })
+            .create();
+
+        //make the enter pin area or the display pin area visible
+        switch (wps.setup) {
+            case WpsInfo.KEYPAD:
+                if (DBG) logd("Enter pin section visible");
+                textEntryView.findViewById(R.id.enter_pin_section).setVisibility(View.VISIBLE);
+                break;
+            case WpsInfo.DISPLAY:
+                if (DBG) logd("Shown pin section visible");
+                addRowToDialog(group, R.string.wifi_p2p_show_pin_message, wps.pin);
+                break;
+            default:
+                break;
+        }
+
+        if ((r.getConfiguration().uiMode & Configuration.UI_MODE_TYPE_APPLIANCE) ==
+                Configuration.UI_MODE_TYPE_APPLIANCE) {
+            // For appliance devices, add a key listener which accepts.
+            dialog.setOnKeyListener(new DialogInterface.OnKeyListener() {
+
+                @Override
+                public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
+                    // TODO: make the actual key come from a config value.
+                    if (keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
+                        sendMessage(PEER_CONNECTION_USER_ACCEPT);
+                        dialog.dismiss();
+                        return true;
+                    }
+                    return false;
+                }
+            });
+            // TODO: add timeout for this dialog.
+            // TODO: update UI in appliance mode to tell user what to do.
+        }
+
+        dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+        WindowManager.LayoutParams attrs = dialog.getWindow().getAttributes();
+        attrs.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
+        dialog.getWindow().setAttributes(attrs);
+        dialog.show();
+    }
+
+    /**
+     * Synchronize the persistent group list between
+     * wpa_supplicant and mGroups.
+     */
+    private void updatePersistentNetworks(boolean reload) {
+        String listStr = mWifiNative.listNetworks();
+        if (listStr == null) return;
+
+        boolean isSaveRequired = false;
+        String[] lines = listStr.split("\n");
+        if (lines == null) return;
+
+        if (reload) mGroups.clear();
+
+        // Skip the first line, which is a header
+        for (int i = 1; i < lines.length; i++) {
+            String[] result = lines[i].split("\t");
+            if (result == null || result.length < 4) {
+                continue;
+            }
+            // network-id | ssid | bssid | flags
+            int netId = -1;
+            String ssid = result[1];
+            String bssid = result[2];
+            String flags = result[3];
+            try {
+                netId = Integer.parseInt(result[0]);
+            } catch(NumberFormatException e) {
+                e.printStackTrace();
+                continue;
+            }
+
+            if (flags.indexOf("[CURRENT]") != -1) {
+                continue;
+            }
+            if (flags.indexOf("[P2P-PERSISTENT]") == -1) {
+                /*
+                 * The unused profile is sometimes remained when the p2p group formation is failed.
+                 * So, we clean up the p2p group here.
+                 */
+                if (DBG) logd("clean up the unused persistent group. netId=" + netId);
+                mWifiNative.removeNetwork(netId);
+                isSaveRequired = true;
+                continue;
+            }
+
+            if (mGroups.contains(netId)) {
+                continue;
+            }
+
+            WifiP2pGroup group = new WifiP2pGroup();
+            group.setNetworkId(netId);
+            ///M: For UTF8 and GBK support
+            WifiSsid wifiSssid = WifiSsid.createFromAsciiEncoded(ssid);
+            group.setNetworkName(wifiSssid.toString());
+            String mode = mWifiNative.getNetworkVariable(netId, "mode");
+            if (mode != null && mode.equals("3")) {
+                group.setIsGroupOwner(true);
+            }
+            if (bssid.equalsIgnoreCase(mThisDevice.deviceAddress)) {
+                group.setOwner(mThisDevice);
+            } else {
+                WifiP2pDevice device = new WifiP2pDevice();
+                device.deviceAddress = bssid;
+                group.setOwner(device);
+            }
+            mGroups.add(group);
+            isSaveRequired = true;
+        }
+
+        if (reload || isSaveRequired) {
+            mWifiNative.saveConfig();
+            sendP2pPersistentGroupsChangedBroadcast();
+        }
+    }
+
+    /**
+     * A config is valid if it has a peer address that has already been
+     * discovered
+     * @return true if it is invalid, false otherwise
+     */
+    private boolean isConfigInvalid(WifiP2pConfig config) {
+        if (config == null) return true;
+        if (TextUtils.isEmpty(config.deviceAddress)) return true;
+        if (mPeers.get(config.deviceAddress) == null) return true;
+        return false;
+    }
+
+    /* TODO: The supplicant does not provide group capability changes as an event.
+     * Having it pushed as an event would avoid polling for this information right
+     * before a connection
+     */
+    private WifiP2pDevice fetchCurrentDeviceDetails(WifiP2pConfig config) {
+        /* Fetch & update group capability from supplicant on the device */
+        int gc = mWifiNative.getGroupCapability(config.deviceAddress);
+
+        // Don't use gc fatch data from supplicant if we ware invited,
+        // the GO address in config is set from invitation event, which is
+        // definitely a GO device.
+        if (getCurrentState() instanceof UserAuthorizingInviteRequestState) {
+            gc |= 1; //WifiP2pDevice.GROUP_CAPAB_GROUP_OWNER
+        }
+        mPeers.updateGroupCapability(config.deviceAddress, gc);
+        return mPeers.get(config.deviceAddress);
+    }
+
+    /**
+     * Start a p2p group negotiation and display pin if necessary
+     * @param config for the peer
+     */
+    private void p2pConnectWithPinDisplay(WifiP2pConfig config) {
+        WifiP2pDevice dev = fetchCurrentDeviceDetails(config);
+
+        String pin = mWifiNative.p2pConnect(config, dev.isGroupOwner());
+        try {
+            Integer.parseInt(pin);
+            notifyInvitationSent(pin, config.deviceAddress);
+        } catch (NumberFormatException ignore) {
+            // do nothing if p2pConnect did not return a pin
+        }
+    }
+
+    /**
+     * Reinvoke a persistent group.
+     *
+     * @param config for the peer
+     * @return true on success, false on failure
+     */
+    private boolean reinvokePersistentGroup(WifiP2pConfig config) {
+        ///M: App sets the hide variable for the connections need it's permmit @{
+        if (config.netId == WifiP2pGroup.TEMPORARY_NET_ID) {
+            return false;
+        }
+        ///@}
+
+        WifiP2pDevice dev = fetchCurrentDeviceDetails(config);
+
+        boolean join = dev.isGroupOwner();
+        String ssid = mWifiNative.p2pGetSsid(dev.deviceAddress);
+        if (DBG) logd("target ssid is " + ssid + " join:" + join);
+
+        if (join && dev.isGroupLimit()) {
+            if (DBG) logd("target device reaches group limit.");
+
+            // if the target group has reached the limit,
+            // try group formation.
+            join = false;
+        } else if (join) {
+            int netId = mGroups.getNetworkId(dev.deviceAddress, ssid);
+            if (netId >= 0) {
+                ///M: ALPS00605482+ALPS00657537: can't use p2pGroupAdd when peer is GO and had
+                // ever formed @{
+                // Skip WPS and start 4way handshake immediately.
+                //if (!mWifiNative.p2pGroupAdd(netId)) {
+                if (!mWifiNative.p2pReinvoke(netId, dev.deviceAddress)) {
+                    return false;
+                }
+                ///@}
+                return true;
+            }
+        }
+
+        if (!join && dev.isDeviceLimit()) {
+            loge("target device reaches the device limit.");
+            return false;
+        }
+
+        if (!join && dev.isInvitationCapable()) {
+            int netId = WifiP2pGroup.PERSISTENT_NET_ID;
+            if (config.netId >= 0) {
+                if (config.deviceAddress.equals(mGroups.getOwnerAddr(config.netId))) {
+                    netId = config.netId;
+                }
+            } else {
+                netId = mGroups.getNetworkId(dev.deviceAddress);
+            }
+            if (netId < 0) {
+                netId = getNetworkIdFromClientList(dev.deviceAddress);
+            }
+            if (DBG) logd("netId related with " + dev.deviceAddress + " = " + netId);
+            if (netId >= 0) {
+                // Invoke the persistent group.
+                if (mWifiNative.p2pReinvoke(netId, dev.deviceAddress)) {
+                    // Save network id. It'll be used when an invitation result event is received.
+                    config.netId = netId;
+                    return true;
+                } else {
+                    loge("p2pReinvoke() failed, update networks");
+                    updatePersistentNetworks(RELOAD);
+                    return false;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Return the network id of the group owner profile which has the p2p client with
+     * the specified device address in it's client list.
+     * If more than one persistent group of the same address is present in its client
+     * lists, return the first one.
+     *
+     * @param deviceAddress p2p device address.
+     * @return the network id. if not found, return -1.
+     */
+    private int getNetworkIdFromClientList(String deviceAddress) {
+        if (deviceAddress == null) return -1;
+
+        Collection<WifiP2pGroup> groups = mGroups.getGroupList();
+        for (WifiP2pGroup group : groups) {
+            int netId = group.getNetworkId();
+            String[] p2pClientList = getClientList(netId);
+            if (p2pClientList == null) continue;
+            for (String client : p2pClientList) {
+                if (deviceAddress.equalsIgnoreCase(client)) {
+                    return netId;
+                }
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Return p2p client list associated with the specified network id.
+     * @param netId network id.
+     * @return p2p client list. if not found, return null.
+     */
+    private String[] getClientList(int netId) {
+        String p2pClients = mWifiNative.getNetworkVariable(netId, "p2p_client_list");
+        if (p2pClients == null) {
+            return null;
+        }
+        return p2pClients.split(" ");
+    }
+
+    /**
+     * Remove the specified p2p client from the specified profile.
+     * @param netId network id of the profile.
+     * @param addr p2p client address to be removed.
+     * @param isRemovable if true, remove the specified profile if its client list becomes empty.
+     * @return whether removing the specified p2p client is successful or not.
+     */
+    private boolean removeClientFromList(int netId, String addr, boolean isRemovable) {
+        StringBuilder modifiedClientList =  new StringBuilder();
+        String[] currentClientList = getClientList(netId);
+        boolean isClientRemoved = false;
+        if (currentClientList != null) {
+            for (String client : currentClientList) {
+                if (!client.equalsIgnoreCase(addr)) {
+                    modifiedClientList.append(" ");
+                    modifiedClientList.append(client);
+                } else {
+                    isClientRemoved = true;
+                }
+            }
+        }
+        if (modifiedClientList.length() == 0 && isRemovable) {
+            // the client list is empty. so remove it.
+            if (DBG) logd("Remove unknown network");
+            mGroups.remove(netId);
+            return true;
+        }
+
+        if (!isClientRemoved) {
+            // specified p2p client is not found. already removed.
+            return false;
+        }
+
+        if (DBG) logd("Modified client list: " + modifiedClientList);
+        if (modifiedClientList.length() == 0) {
+            modifiedClientList.append("\"\"");
+        }
+        mWifiNative.setNetworkVariable(netId,
+                "p2p_client_list", modifiedClientList.toString());
+        mWifiNative.saveConfig();
+        return true;
+    }
+
+    private void setWifiP2pInfoOnGroupFormation(InetAddress serverInetAddress) {
+        mWifiP2pInfo.groupFormed = true;
+        mWifiP2pInfo.isGroupOwner = mGroup.isGroupOwner();
+        mWifiP2pInfo.groupOwnerAddress = serverInetAddress;
+    }
+
+    private void resetWifiP2pInfo() {
+        mGcIgnoresDhcpReq = false;
+
+        ///M: ALPS01443292: enable/disable IPv6 on demand  @{
+        /*try {
+            mNwService.disableIpv6(mInterface);
+        } catch (RemoteException re) {
+            loge("resetWifiP2pInfo() disableIpv6 RemoteException: " + re);
+        } catch (IllegalStateException ie) {
+            loge("resetWifiP2pInfo() disableIpv6 IllegalStateException: " + ie);
+        }*/
+        ///@}
+        mWifiP2pInfo.groupFormed = false;
+        mWifiP2pInfo.isGroupOwner = false;
+        mWifiP2pInfo.groupOwnerAddress = null;
+        ///M: ALPS01212893: for poor link, wifi p2p stop Tx all traffic @{
+        sendP2pTxBroadcast(false);
+        ///@}
+        ///M: ALPS01859775: handle device nego-failed with NO_COMMON_CHANNEL after receiving
+        //nego-request  @{
+        mNegoChannelConflict = false;
+        ///@}
+        /** M: ALPS01976478: SCC then MCC @{ */
+        if (mMccSupport) {
+            p2pSetCCMode(0);
+        }
+        mConnectToPeer = false;
+        ///@}
+        ///M: for crossmount @{
+        mCrossmountEventReceived = false;
+        mCrossmountSessionInfo = "";
+        ///@}
+        ///M: increase success rate for invitation @{
+        mUpdatePeerForInvited = false;
+        ///@}
+    }
+
+    private String getDeviceName(String deviceAddress) {
+        WifiP2pDevice d = mPeers.get(deviceAddress);
+        if (d != null) {
+                return d.deviceName;
+        }
+        //Treat the address as name if there is no match
+        return deviceAddress;
+    }
+
+    private String getPersistedDeviceName() {
+        String deviceName = Settings.Global.getString(mContext.getContentResolver(),
+                Settings.Global.WIFI_P2P_DEVICE_NAME);
+        if (deviceName == null) {
+            /* We use the 4 digits of the ANDROID_ID to have a friendly
+             * default that has low likelihood of collision with a peer */
+            String id = Settings.Secure.getString(mContext.getContentResolver(),
+                    Settings.Secure.ANDROID_ID);
+            return "TCL 980CN1";
+        }
+        return deviceName;
+    }
+
+    private boolean setAndPersistDeviceName(String devName) {
+        if (devName == null) return false;
+
+        if (!mWifiNative.setDeviceName(devName)) {
+            loge("Failed to set device name " + devName);
+            return false;
+        }
+
+        mThisDevice.deviceName = devName;
+        mWifiNative.setP2pSsidPostfix("-" + getSsidPostfix(mThisDevice.deviceName));
+
+        Settings.Global.putString(mContext.getContentResolver(),
+                Settings.Global.WIFI_P2P_DEVICE_NAME, devName);
+        sendThisDeviceChangedBroadcast();
+        return true;
+    }
+
+    private boolean setWfdInfo(WifiP2pWfdInfo wfdInfo) {
+        boolean success;
+
+        if (!wfdInfo.isWfdEnabled()) {
+            success = mWifiNative.setWfdEnable(false);
+        } else {
+            success =
+                mWifiNative.setWfdEnable(true)
+                && mWifiNative.setWfdDeviceInfo(wfdInfo.getDeviceInfoHex());
+        }
+
+        if (!success) {
+            loge("Failed to set wfd properties, Device Info part");
+            return false;
+        }
+
+        //M: ALPS01255052: UIBC in WFD IE
+        if (wfdInfo.getExtendedCapability() != 0) {
+            setWfdExtCapability(wfdInfo.getExtCapaHex());
+        }
+
+        mThisDevice.wfdInfo = wfdInfo;
+        sendThisDeviceChangedBroadcast();
+        return true;
+    }
+
+    private void initializeP2pSettings() {
+        mWifiNative.setPersistentReconnect(true);
+        mThisDevice.deviceName = getPersistedDeviceName();
+        mWifiNative.setDeviceName(mThisDevice.deviceName);
+        // DIRECT-XY-DEVICENAME (XY is randomly generated)
+        mWifiNative.setP2pSsidPostfix("-" + getSsidPostfix(mThisDevice.deviceName));
+        mWifiNative.setDeviceType(mThisDevice.primaryDeviceType);
+        // Supplicant defaults to using virtual display with display
+        // which refers to a remote display. Use physical_display
+        mWifiNative.setConfigMethods("virtual_push_button physical_display keypad");
+        // STA has higher priority over P2P
+        mWifiNative.setConcurrencyPriority("sta");
+
+        if (DBG) logd("old DeviceAddress: " + mThisDevice.deviceAddress);
+        mThisDevice.deviceAddress = mWifiNative.p2pGetDeviceAddress();
+        if (DBG) logd("new DeviceAddress: " + mThisDevice.deviceAddress);
+        updateThisDevice(WifiP2pDevice.AVAILABLE);
+        if (DBG) logd("DeviceAddress: " + mThisDevice.deviceAddress);
+
+        mClientInfoList.clear();
+        mWifiNative.p2pFlush();
+        mWifiNative.p2pServiceFlush();
+        mServiceTransactionId = 0;
+        mServiceDiscReqId = null;
+
+        updatePersistentNetworks(RELOAD);
+
+        /** M: ALPS01976478: SCC then MCC @{ */
+        mMccSupport = SystemProperties.get("ro.mtk_wifi_mcc_support").equals("1");
+        if (DBG) logd("is Mcc Supported: " + mMccSupport);
+        if (mMccSupport == true) {
+            p2pSetCCMode(0);
+        }
+        ///@}
+    }
+
+    private void updateThisDevice(int status) {
+        mThisDevice.status = status;
+        sendThisDeviceChangedBroadcast();
+    }
+
+    private void handleGroupCreationFailure() {
+        resetWifiP2pInfo();
+        mNetworkInfo.setDetailedState(NetworkInfo.DetailedState.FAILED, null, null);
+
+        ///M: ALPS01472489: notify user decline channel conflict  @{
+        if (mGroupRemoveReason == P2pStatus.UNKNOWN) {
+            sendP2pConnectionChangedBroadcast();
+        } else {
+            sendP2pConnectionChangedBroadcast(mGroupRemoveReason);
+        }
+        ///@}
+
+        // Remove only the peer we failed to connect to so that other devices discovered
+        // that have not timed out still remain in list for connection
+        boolean peersChanged = mPeers.remove(mPeersLostDuringConnection);
+        if (TextUtils.isEmpty(mSavedPeerConfig.deviceAddress) == false &&
+                mPeers.remove(mSavedPeerConfig.deviceAddress) != null) {
+            peersChanged = true;
+        }
+        if (peersChanged) {
+            sendPeersChangedBroadcast();
+        }
+
+        mPeersLostDuringConnection.clear();
+        ///M: Google issue, reset mServiceDiscReqId would cause service discovery can't clear up @{
+        //mServiceDiscReqId = null;
+        clearSupplicantServiceRequest();
+        ///@}
+
+        /*M: ALPS01807734: wfd sink won't trigger normal scan, let scan request from user */
+        if (!isWfdSinkEnabled()) {
+            sendMessage(WifiP2pManager.DISCOVER_PEERS);
+        }
+
+        /*M: ALPS01000415: case #17-7,#18-1 -> Wifi AP not reconnect problem */
+        if (mTemporarilyDisconnectedWifi) {
+            mWifiChannel.sendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST, 0);
+            mTemporarilyDisconnectedWifi = false;
+        }
+    }
+
+    private void handleGroupRemoved() {
+        if (mGroup.isGroupOwner()) {
+            stopDhcpServer(mGroup.getInterface());
+            ///M: remove dhcp info. file  @{
+            boolean b;
+            File dhcpFile = new File(DHCP_INFO_FILE);
+            if (DBG) logd("DHCP file exists=" + dhcpFile.exists());
+            if (dhcpFile.exists()) {
+                b = dhcpFile.delete();
+                if (b) logd("Delete p2p0 dhcp info file OK!");
+            }
+            ///@}
+        } else {
+            if (DBG) logd("stop IpManager");
+            stopIpManager();
+            try {
+                mNwService.removeInterfaceFromLocalNetwork(mGroup.getInterface());
+            } catch (RemoteException e) {
+                loge("Failed to remove iface from local network " + e);
+            }
+        }
+
+        try {
+            mNwService.clearInterfaceAddresses(mGroup.getInterface());
+        } catch (Exception e) {
+            loge("Failed to clear addresses " + e);
+        }
+
+        // Clear any timeout that was set. This is essential for devices
+        // that reuse the main p2p interface for a created group.
+        mWifiNative.setP2pGroupIdle(mGroup.getInterface(), 0);
+
+        ////M: ALPS01593529: no p2p_invite in wfd source case, don't keep persistent group @{
+        if (!TextUtils.isEmpty(mWfdSourceAddr)) {
+            logd("wfd source case: mWfdSourceAddr = " + mWfdSourceAddr);
+            while (mGroups.contains(mGroups.getNetworkId(mWfdSourceAddr))) {
+                mGroups.remove(mGroups.getNetworkId(mWfdSourceAddr));
+            }
+            mWfdSourceAddr = null;
+        }
+        ///@}
+
+        boolean peersChanged = false;
+        // Remove only peers part of the group, so that other devices discovered
+        // that have not timed out still remain in list for connection
+        for (WifiP2pDevice d : mGroup.getClientList()) {
+            if (d != null) {
+                logd("handleGroupRemoved, call mPeers.remove - d.deviceName = " +
+                    d.deviceName + " d.deviceAddress = " + d.deviceAddress);
+            }
+            if (mPeers.remove(d)) peersChanged = true;
+        }
+        if (mPeers.remove(mGroup.getOwner())) peersChanged = true;
+        if (mPeers.remove(mPeersLostDuringConnection)) peersChanged = true;
+        if (peersChanged) {
+            sendPeersChangedBroadcast();
+        }
+
+        mGroup = null;
+        mPeersLostDuringConnection.clear();
+        ///M: Google issue, reset mServiceDiscReqId would cause service discovery can't clear up @{
+        //mServiceDiscReqId = null;
+        clearSupplicantServiceRequest();
+        ///@}
+
+        if (mTemporarilyDisconnectedWifi) {
+            mWifiChannel.sendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST, 0);
+            mTemporarilyDisconnectedWifi = false;
+        }
+
+        ///M: from supplicant owner's request:
+        //    -to fix waiting 36s to find out peer when auto reconnect
+        mWifiNative.p2pFlush();
+        ///@}
+    }
+
+    //State machine initiated requests can have replyTo set to null indicating
+    //there are no recipients, we ignore those reply actions
+    private void replyToMessage(Message msg, int what) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessage(msg);
+        dstMsg.what = what;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+
+    private void replyToMessage(Message msg, int what, int arg1) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessage(msg);
+        dstMsg.what = what;
+        dstMsg.arg1 = arg1;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+
+    private void replyToMessage(Message msg, int what, Object obj) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessage(msg);
+        dstMsg.what = what;
+        dstMsg.obj = obj;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+
+    /* arg2 on the source message has a hash code that needs to be retained in replies
+     * see WifiP2pManager for details */
+    private Message obtainMessage(Message srcMsg) {
+        Message msg = Message.obtain();
+        msg.arg2 = srcMsg.arg2;
+        return msg;
+    }
+
+    @Override
+    protected void logd(String s) {
+        ///M: @{
+        //Slog.d(TAG, s);
+        Log.d(TAG, s);
+        ///@}
+    }
+
+    @Override
+    protected void loge(String s) {
+        ///M: @{
+        //Slog.e(TAG, s);
+        Log.e(TAG, s);
+        ///@}
+    }
+
+    /**
+     * Update service discovery request to wpa_supplicant.
+     */
+    private boolean updateSupplicantServiceRequest() {
+        clearSupplicantServiceRequest();
+
+        StringBuffer sb = new StringBuffer();
+        for (ClientInfo c: mClientInfoList.values()) {
+            int key;
+            WifiP2pServiceRequest req;
+            for (int i=0; i < c.mReqList.size(); i++) {
+                req = c.mReqList.valueAt(i);
+                if (req != null) {
+                    sb.append(req.getSupplicantQuery());
+                }
+            }
+        }
+
+        if (sb.length() == 0) {
+            return false;
+        }
+
+        mServiceDiscReqId = mWifiNative.p2pServDiscReq("00:00:00:00:00:00", sb.toString());
+        if (mServiceDiscReqId == null) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Clear service discovery request in wpa_supplicant
+     */
+    private void clearSupplicantServiceRequest() {
+        if (mServiceDiscReqId == null) return;
+
+        mWifiNative.p2pServDiscCancelReq(mServiceDiscReqId);
+        mServiceDiscReqId = null;
+    }
+
+    /* TODO: We could track individual service adds separately and avoid
+     * having to do update all service requests on every new request
+     */
+    private boolean addServiceRequest(Messenger m, WifiP2pServiceRequest req) {
+        clearClientDeadChannels();
+        ClientInfo clientInfo = getClientInfo(m, true);
+        if (clientInfo == null) {
+            return false;
+        }
+
+        ++mServiceTransactionId;
+        //The Wi-Fi p2p spec says transaction id should be non-zero
+        if (mServiceTransactionId == 0) ++mServiceTransactionId;
+        ///M: Google issue, cast from byte to int cause 0xffffff80 bug  @{
+        //req.setTransactionId(mServiceTransactionId);
+        //clientInfo.mReqList.put(mServiceTransactionId, req);
+        int localSevID = mServiceTransactionId & 0x000000ff;
+        req.setTransactionId(localSevID);
+        clientInfo.mReqList.put(localSevID, req);
+        ///@}
+
+        if (mServiceDiscReqId == null) {
+            return true;
+        }
+
+        return updateSupplicantServiceRequest();
+    }
+
+    private void removeServiceRequest(Messenger m, WifiP2pServiceRequest req) {
+        ClientInfo clientInfo = getClientInfo(m, false);
+        if (clientInfo == null) {
+            return;
+        }
+
+        //Application does not have transaction id information
+        //go through stored requests to remove
+        boolean removed = false;
+        for (int i=0; i<clientInfo.mReqList.size(); i++) {
+            if (req.equals(clientInfo.mReqList.valueAt(i))) {
+                removed = true;
+                clientInfo.mReqList.removeAt(i);
+                break;
+            }
+        }
+
+        if (!removed) return;
+
+        if (clientInfo.mReqList.size() == 0 && clientInfo.mServList.size() == 0) {
+            if (DBG) logd("remove client information from framework");
+            mClientInfoList.remove(clientInfo.mMessenger);
+        }
+
+        if (mServiceDiscReqId == null) {
+            return;
+        }
+
+        updateSupplicantServiceRequest();
+    }
+
+    private void clearServiceRequests(Messenger m) {
+
+        ClientInfo clientInfo = getClientInfo(m, false);
+        if (clientInfo == null) {
+            return;
+        }
+
+        if (clientInfo.mReqList.size() == 0) {
+            return;
+        }
+
+        clientInfo.mReqList.clear();
+
+        if (clientInfo.mServList.size() == 0) {
+            if (DBG) logd("remove channel information from framework");
+            mClientInfoList.remove(clientInfo.mMessenger);
+        }
+
+        if (mServiceDiscReqId == null) {
+            return;
+        }
+
+        updateSupplicantServiceRequest();
+    }
+
+    private boolean addLocalService(Messenger m, WifiP2pServiceInfo servInfo) {
+        clearClientDeadChannels();
+        ClientInfo clientInfo = getClientInfo(m, true);
+        if (clientInfo == null) {
+            return false;
+        }
+
+        if (!clientInfo.mServList.add(servInfo)) {
+            return false;
+        }
+
+        if (!mWifiNative.p2pServiceAdd(servInfo)) {
+            clientInfo.mServList.remove(servInfo);
+            return false;
+        }
+
+        return true;
+    }
+
+    private void removeLocalService(Messenger m, WifiP2pServiceInfo servInfo) {
+        ClientInfo clientInfo = getClientInfo(m, false);
+        if (clientInfo == null) {
+            return;
+        }
+
+        mWifiNative.p2pServiceDel(servInfo);
+
+        clientInfo.mServList.remove(servInfo);
+        if (clientInfo.mReqList.size() == 0 && clientInfo.mServList.size() == 0) {
+            if (DBG) logd("remove client information from framework");
+            mClientInfoList.remove(clientInfo.mMessenger);
+        }
+    }
+
+    private void clearLocalServices(Messenger m) {
+        ClientInfo clientInfo = getClientInfo(m, false);
+        if (clientInfo == null) {
+            return;
+        }
+
+        for (WifiP2pServiceInfo servInfo: clientInfo.mServList) {
+            mWifiNative.p2pServiceDel(servInfo);
+        }
+
+        clientInfo.mServList.clear();
+        if (clientInfo.mReqList.size() == 0) {
+            if (DBG) logd("remove client information from framework");
+            mClientInfoList.remove(clientInfo.mMessenger);
+        }
+    }
+
+    private void clearClientInfo(Messenger m) {
+        clearLocalServices(m);
+        clearServiceRequests(m);
+    }
+
+    /**
+     * Send the service response to the WifiP2pManager.Channel.
+     *
+     * @param resp
+     */
+    private void sendServiceResponse(WifiP2pServiceResponse resp) {
+        for (ClientInfo c : mClientInfoList.values()) {
+            WifiP2pServiceRequest req = c.mReqList.get(resp.getTransactionId());
+            if (req != null) {
+                Message msg = Message.obtain();
+                msg.what = WifiP2pManager.RESPONSE_SERVICE;
+                msg.arg1 = 0;
+                msg.arg2 = 0;
+                msg.obj = resp;
+                try {
+                    c.mMessenger.send(msg);
+                } catch (RemoteException e) {
+                    if (DBG) logd("detect dead channel");
+                    clearClientInfo(c.mMessenger);
+                    return;
+                }
+            }
+        }
+    }
+
+    /**
+     * We dont get notifications of clients that have gone away.
+     * We detect this actively when services are added and throw
+     * them away.
+     *
+     * TODO: This can be done better with full async channels.
+     */
+    private void clearClientDeadChannels() {
+        ArrayList<Messenger> deadClients = new ArrayList<Messenger>();
+
+        for (ClientInfo c : mClientInfoList.values()) {
+            Message msg = Message.obtain();
+            msg.what = WifiP2pManager.PING;
+            msg.arg1 = 0;
+            msg.arg2 = 0;
+            msg.obj = null;
+            try {
+                c.mMessenger.send(msg);
+            } catch (RemoteException e) {
+                if (DBG) logd("detect dead channel");
+                deadClients.add(c.mMessenger);
+            }
+        }
+
+        for (Messenger m : deadClients) {
+            clearClientInfo(m);
+        }
+    }
+
+    /**
+     * Return the specified ClientInfo.
+     * @param m Messenger
+     * @param createIfNotExist if true and the specified channel info does not exist,
+     * create new client info.
+     * @return the specified ClientInfo.
+     */
+    private ClientInfo getClientInfo(Messenger m, boolean createIfNotExist) {
+        ClientInfo clientInfo = mClientInfoList.get(m);
+
+        if (clientInfo == null && createIfNotExist) {
+            if (DBG) logd("add a new client");
+            clientInfo = new ClientInfo(m);
+            mClientInfoList.put(m, clientInfo);
+        }
+
+        return clientInfo;
+    }
+
+    ///M:@{
+    /*M: ALPS00677009: broadcast the group removed reason*/
+    private void sendP2pConnectionChangedBroadcast(P2pStatus reason) {
+        if (DBG) logd("sending p2p connection changed broadcast, reason = " + reason +
+            ", mGroup: " + mGroup +
+            ", mP2pOperFreq: " + mP2pOperFreq);
+        Intent intent = new Intent(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        intent.putExtra(WifiP2pManager.EXTRA_WIFI_P2P_INFO, new WifiP2pInfo(mWifiP2pInfo));
+        intent.putExtra(WifiP2pManager.EXTRA_NETWORK_INFO, new NetworkInfo(mNetworkInfo));
+        intent.putExtra(WifiP2pManager.EXTRA_WIFI_P2P_GROUP, new WifiP2pGroup(mGroup));
+        intent.putExtra("p2pOperFreq", mP2pOperFreq);
+
+        if (reason == P2pStatus.NO_COMMON_CHANNEL) {
+            intent.putExtra("reason=", 7);
+        } else if (reason == P2pStatus.MTK_EXPAND_02) {
+            if (DBG) logd("channel conflict, user decline, broadcast with reason=-3");
+            intent.putExtra("reason=", -3);
+        } else if (reason == P2pStatus.MTK_EXPAND_01) {
+            if (DBG) logd("[wfd sink/source] broadcast with reason=-2");
+            intent.putExtra("reason=", -2);
+        } else {
+            intent.putExtra("reason=", -1);
+        }
+
+        mGroupRemoveReason = P2pStatus.UNKNOWN;
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+        mWifiChannel.sendMessage(WifiP2pServiceImpl.P2P_CONNECTION_CHANGED,
+                new NetworkInfo(mNetworkInfo));
+    }
+
+    //ALPS01212893: for poor link: wifi p2p Tx broadcast
+    private void sendP2pTxBroadcast(boolean bStart) {
+        if (DBG) logd("sending p2p Tx broadcast: " + bStart);
+        Intent intent = new Intent("com.mediatek.wifi.p2p.Tx");
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        intent.putExtra("start", bStart);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    //M: wfd sink support
+    private void sendP2pGOandGCRequestConnectBroadcast() {
+        if (DBG) logd("sendP2pGOandGCRequestConnectBroadcast");
+        Intent intent = new Intent("com.mediatek.wifi.p2p.GO.GCrequest.connect");
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+
+        WifiP2pDevice dev = mPeers.get(mSavedPeerConfig.deviceAddress);
+        if (dev != null && dev.deviceName != null) {
+            intent.putExtra("deviceName", dev.deviceName);
+        } else {
+            intent.putExtra("deviceName", "wifidisplay source");
+        }
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    //M: enhance frequency conflict
+    private void sendP2pOPChannelBroadcast() {
+        if (DBG) logd("sendP2pOPChannelBroadcast: OperFreq = " + mP2pOperFreq);
+        Intent intent = new Intent("com.mediatek.wifi.p2p.OP.channel");
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+
+        intent.putExtra("p2pOperFreq", mP2pOperFreq);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    //M: frequency conflict notify
+    private void sendP2pFreqConflictBroadcast() {
+        if (DBG) logd("sendP2pFreqConflictBroadcast");
+        Intent intent = new Intent("com.mediatek.wifi.p2p.freq.conflict");
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    //M: crossmount wps dialog
+    private void sendP2pCrossmountIntentionBroadcast() {
+        if (DBG) logd("sendP2pCrossmountIntentionBroadcast, session info:" +
+            mCrossmountSessionInfo + ", wps method=" + mSavedPeerConfig.wps.setup);
+        Intent intent = new Intent("com.mediatek.wifi.p2p.crossmount.intention");
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+
+        WifiP2pDevice dev = mPeers.get(mSavedPeerConfig.deviceAddress);
+        if (dev != null && dev.deviceName != null) {
+            intent.putExtra("deviceName", dev.deviceName);
+            intent.putExtra("deviceAddress", dev.deviceAddress);
+            intent.putExtra("sessionInfo", mCrossmountSessionInfo);
+        } else {
+            intent.putExtra("deviceName", "crossmount source");
+            intent.putExtra("deviceAddress", "crossmount source");
+            // hex string is "crossmount source"
+            intent.putExtra("sessionInfo", "63726f73736d6f756e7420736f75726365");
+        }
+        intent.putExtra("wpsMethod", Integer.toString(mSavedPeerConfig.wps.setup));
+
+        // sticky broadcast would cause application receive fake connection request
+        // when crossmount switch from off to on
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private WifiP2pDevice p2pGoGetSta(WifiP2pDevice p2pDev, String p2pMAC) {
+        if (p2pMAC == null || p2pDev == null) {
+            loge("gc or gc mac is null");
+            return null;
+        }
+
+        p2pDev.deviceAddress = p2pMAC;
+        String p2pSta = p2pGoGetSta(p2pMAC);
+        if (p2pSta == null)
+            return p2pDev;
+        logd("p2pGoGetSta() return: " + p2pSta);
+
+        String[] tokens = p2pSta.split("\n");
+        for (String token : tokens) {
+            if (token.startsWith("p2p_device_name=")) {
+                String[] nameValue = token.split("=");
+                p2pDev.deviceName = nameValueAssign(nameValue, p2pDev.deviceName);
+            } else if (token.startsWith("p2p_primary_device_type=")) {
+                String[] nameValue = token.split("=");
+                p2pDev.primaryDeviceType = nameValueAssign(nameValue, p2pDev.primaryDeviceType);
+            } else if (token.startsWith("p2p_group_capab=")) {
+                String[] nameValue = token.split("=");
+                p2pDev.groupCapability = nameValueAssign(nameValue, p2pDev.groupCapability);
+            } else if (token.startsWith("p2p_dev_capab=")) {
+                String[] nameValue = token.split("=");
+                p2pDev.deviceCapability = nameValueAssign(nameValue, p2pDev.deviceCapability);
+            }  else if (token.startsWith("p2p_config_methods=")) {
+                String[] nameValue = token.split("=");
+                p2pDev.wpsConfigMethodsSupported =
+                        nameValueAssign(nameValue, p2pDev.wpsConfigMethodsSupported);
+            }
+        } //for
+
+        return p2pDev;
+    }
+
+    private String nameValueAssign(String[] nameValue, String string) {
+        if (nameValue == null || nameValue.length != 2) {
+            return null;
+        } else {
+            return nameValue[1];
+        }
+    }
+
+    private int nameValueAssign(String[] nameValue, int integer) {
+        if (nameValue == null || nameValue.length != 2) {
+            return 0;
+        } else {
+            if (nameValue[1] != null) {
+                return WifiP2pDevice.parseHex(nameValue[1]);
+            } else {
+                return 0;
+            }
+        }
+    }
+
+    private int nameValueAssign(String[] nameValue, int integer, int base) {
+        if (nameValue == null || nameValue.length != 2) {
+            return 0;
+        } else {
+            if (nameValue[1] != null && base != 0) {
+                return Integer.parseInt(nameValue[1], base);
+            } else {
+                return 0;
+            }
+        }
+    }
+
+    private void setWifiOn_WifiAPOff() {
+        if (mWifiManager == null) {
+            mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
+        }
+
+        int wifiApState = mWifiManager.getWifiApState();
+        if ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) ||
+                (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED)) {
+            mWifiManager.setWifiApEnabled(null, false);
+        }
+
+        logd("call WifiManager.stopReconnectAndScan() and WifiManager.setWifiEnabled()");
+        mWifiManager.stopReconnectAndScan(true, 0);
+        mWifiManager.setWifiEnabled(true);
+    }
+
+    /**
+     * Return dynamic information about the current Wi-Fi connection, if any is active.
+     * @return the Wi-Fi information, contained in {@link WifiInfo}.
+     */
+    public WifiInfo getWifiConnectionInfo() {
+        if (mWifiManager == null) {
+            mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
+        }
+        return mWifiManager.getConnectionInfo();
+    }
+
+    /**
+     * Get interface address if peer provided in the current group
+     */
+    private String getInterfaceAddress(String deviceAddress) {
+        if (DBG) logd("getInterfaceAddress(): deviceAddress=" + deviceAddress);
+        WifiP2pDevice d = mPeers.get(deviceAddress);
+        if (d == null) {
+            // Assume got an interface address.
+            return deviceAddress;
+        } else {
+            if (deviceAddress.equals(d.interfaceAddress)) {
+                // Peer not imlpement interface address mechanism
+                return deviceAddress;
+            }
+            if (DBG) logd("getInterfaceAddress(): interfaceAddress=" + d.interfaceAddress);
+            return d.interfaceAddress;
+        }
+    }
+
+    /* get peer IP address */
+    public String getPeerIpAddress(String inputAddress) {
+        logd("getPeerIpAddress(): input address=" + inputAddress);
+        if (inputAddress == null) {
+            return null;
+        }
+
+        if (mGroup == null) {
+            loge("getPeerIpAddress(): mGroup is null!");
+            return null;
+        }
+
+        //logd("getPeerIpAddress(): mThisDevice.isGroupOwner()=" + mThisDevice.isGroupOwner());
+        if (!mGroup.isGroupOwner()) {
+            // case 01: input parameter is GO device address
+            if (mGroup.getOwner().deviceAddress != null &&
+                inputAddress.equals(mGroup.getOwner().deviceAddress)) {
+                logd("getPeerIpAddress(): GO device address case, goIpAddress=" +
+                    mGroup.getOwner().deviceIP);
+                return mGroup.getOwner().deviceIP;
+
+            // case 02: input parameter is GO interface address
+            } else if (mGroup.getOwner().interfaceAddress != null &&
+                inputAddress.equals(mGroup.getOwner().interfaceAddress)) {
+                logd("getPeerIpAddress(): GO interface address case, goIpAddress=" +
+                    mGroup.getOwner().deviceIP);
+                return mGroup.getOwner().deviceIP;
+
+            } else {
+                loge("getPeerIpAddress(): no match GO address case, goIpAddress is null");
+                return null;
+            }
+        }
+
+        String intrerfaceAddress = getInterfaceAddress(inputAddress);
+
+        /** DHCP_INFO_FILE
+         * Example:
+         *  1393274309 02:08:22:8c:8f:0c 192.168.49.67 android-64e4f3ae3c5378aa *
+         */
+        FileInputStream fileStream = null;
+        try {
+            fileStream =  new FileInputStream(DHCP_INFO_FILE);
+            DataInputStream in = new DataInputStream(fileStream);
+            BufferedReader br = new BufferedReader(new InputStreamReader(in));
+            String str = br.readLine();
+            String lastOneIP = null;
+
+            //logd("getPeerIpAddress(): getClientIp() Read Message = " + str);
+            while ((str != null) && (str.length() != 0)) {
+                //logd("getPeerIpAddress(): getClientIp() read a line ok str = " + str);
+                String[] fields = str.split(" ");
+                //for (String s : fields) {
+                    //logd("getPeerIpAddress(): getClientIp() fields = " + s);
+                //}
+                if (fields.length > 3) {
+                    //logd("getPeerIpAddress(): getClientIp() get IP address = " + fields[2]);
+                    str = fields[2];
+                } else {
+                    str = null;
+                }
+
+                if (str != null && fields[1] != null &&
+                    fields[1].indexOf(intrerfaceAddress) != -1) {
+                    logd("getPeerIpAddress(): getClientIp() mac matched, get IP address = " + str);
+                    return str;
+                } else {
+                    lastOneIP = str;
+                }
+                str = br.readLine();
+            } //while()
+
+            loge("getPeerIpAddress(): getClientIp() dhcp client " + intrerfaceAddress +
+                " had not connected up!");
+            return null;
+
+        } catch (IOException e) {
+            loge("getPeerIpAddress(): getClientIp(): " + e);
+        } finally {
+            if (fileStream != null) {
+                try {
+                    fileStream.close();
+                    //logd("getPeerIpAddress(): getClientIp() close file OK!");
+                } catch (IOException e) {
+                    loge("getPeerIpAddress(): getClientIp() close file met IOException: " + e);
+                }
+            }
+        }
+
+        loge("getPeerIpAddress(): found nothing");
+        return null;
+    }
+
+    public void setCrossMountIE(boolean isAdd, String hexData) {
+        mCrossmountIEAdded = isAdd;
+        setVendorElemIE(isAdd, VENDOR_IE_ALL_FRAME_TAG, hexData);
+    }
+
+    public String getCrossMountIE(String hexData) {
+        // "length field" is 1 byte=2 hex data
+        int indexCrossMountTag =
+            hexData.indexOf(VENDOR_IE_MTK_OUI + VENDOR_IE_OUI_TYPE__CROSSMOUNT);
+        if (indexCrossMountTag < (VENDOR_IE_TAG.length() + 2)) { //+2 means "length field"
+            if (DBG)
+                loge("getCrossMountIE(): bad index: indexCrossMountTag=" + indexCrossMountTag);
+            return "";
+        }
+
+        String strLenIE = hexData.substring(indexCrossMountTag - 2, indexCrossMountTag);
+        if (TextUtils.isEmpty(strLenIE)) {
+            if (DBG) loge("getCrossMountIE(): bad strLenIE: " + strLenIE);
+            return "";
+        }
+        int lenIE = Integer.valueOf(strLenIE, 16);
+        // (1) -4: IE len including "OUI" "OUI_TYPE" field: 4 bytes
+        // (2) *2: IE len are ascii string length, here are hex data
+        lenIE = (lenIE - 4) * 2;
+
+        // "OUI" "OUI_TYPE" field are 4 bytes=8 hex data
+        String hexCrossMountIE = hexData.substring(
+            indexCrossMountTag + 8,
+            indexCrossMountTag + 8 + lenIE);
+
+        if (DBG) loge("getCrossMountIE(): hexCrossMountIE=" + hexCrossMountIE);
+        return hexCrossMountIE;
+    }
+
+    private boolean isGroupRemoved() {
+        boolean removed = true;
+
+        for (WifiP2pDevice d : mPeers.getDeviceList()) {
+            if (!mThisDevice.deviceAddress.equals(d.deviceAddress) &&
+                d.status == WifiP2pDevice.CONNECTED) {
+                removed = false;
+            }
+        }
+        if (DBG) logd("isGroupRemoved(): " + removed);
+        return removed;
+    }
+
+    private void resetWifiP2pConn() {
+        //ALPS01807734: restore state for both Created and Creating case
+        if (mGroup != null) {
+            mWifiNative.p2pGroupRemove(mInterface);
+        } else if (getHandler().hasMessages(GROUP_CREATING_TIMED_OUT)) {
+            //mWifiNative.p2pCancelConnect();
+            sendMessage(WifiP2pManager.CANCEL_CONNECT);
+        }
+    }
+
+    private void p2pConfigWfdSink() {
+        resetWifiP2pConn();
+
+        mWifiNative.setDeviceType("8-0050F204-2");
+        //ALPS01511867: disable DEVICE_CAPAB_INVITATION_PROCEDURE
+        String result = p2pGetDeviceCapa();
+        if (result.startsWith("p2p_dev_capa=")) {
+            String[] nameValue = result.split("=");
+            mDeviceCapa = nameValueAssign(nameValue, mDeviceCapa, 10);
+        } else {
+            mDeviceCapa = -1;
+        }
+        if (DBG) logd("[wfd sink] p2pConfigWfdSink() ori deviceCapa = " + mDeviceCapa);
+
+        if (mDeviceCapa > 0) {
+            String DeviceCapa_local = (Integer.valueOf(mDeviceCapa) & 0xDF) + "";
+            p2pSetDeviceCapa(DeviceCapa_local);
+            if (DBG) logd("[wfd sink] p2pConfigWfdSink() after: " + p2pGetDeviceCapa());
+        }
+    }
+
+    private void p2pUnconfigWfdSink() {
+        resetWifiP2pConn();
+
+        mWifiNative.setDeviceType(mThisDevice.primaryDeviceType);
+        if (0 < mDeviceCapa) {
+            p2pSetDeviceCapa(mDeviceCapa + "");
+            if (DBG) logd("[wfd sink] p2pUnconfigWfdSink(): " + p2pGetDeviceCapa());
+        }
+    }
+
+    private boolean isWfdSinkEnabled() {
+        if (!SystemProperties.get("ro.mtk_wfd_sink_support").equals("1")) {
+            if (DBG) logd("[wfd sink] isWfdSinkEnabled, property unset");
+        } else if (mThisDevice.wfdInfo == null) {
+            if (DBG) logd("[wfd sink] isWfdSinkEnabled, device wfdInfo unset");
+        } else if (mThisDevice.wfdInfo.getDeviceType() != WifiP2pWfdInfo.PRIMARY_SINK &&
+                   mThisDevice.wfdInfo.getDeviceType() != WifiP2pWfdInfo.SOURCE_OR_PRIMARY_SINK) {
+            if (DBG)
+                logd("[wfd sink] isWfdSinkEnabled, type :" + mThisDevice.wfdInfo.getDeviceType());
+        } else {
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isWfdSinkConnected() {
+        boolean basicCondition = isWfdSinkEnabled() && (mGroup != null);
+
+        if (!basicCondition) {
+            return false;
+        }
+
+        if (!mGroup.isGroupOwner()) {
+            //wfd sink GC case
+            return true;
+        } else {
+            //wfd sink GO case
+            if (mGroup.getClientAmount() == 1) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean isCrossMountGOwithMultiGC() {
+        boolean basicCondition = (mCrossmountIEAdded && (mGroup != null));
+
+        if (!basicCondition) {
+            return false;
+        }
+
+        if (!mGroup.isGroupOwner()) {
+            //GC case
+            return false;
+        } else {
+            //GO case
+            if (mGroup.getClientAmount() > 0) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean isWfdSourceConnected() {
+        if (mThisDevice.wfdInfo == null) {
+            if (DBG) logd("[wfd source] isWfdSourceConnected, device wfdInfo unset");
+        } else if (mThisDevice.wfdInfo.getDeviceType() != WifiP2pWfdInfo.WFD_SOURCE &&
+                   mThisDevice.wfdInfo.getDeviceType() != WifiP2pWfdInfo.SOURCE_OR_PRIMARY_SINK) {
+            if (DBG)
+                logd("[wfd source] isWfdSourceConnected, type :" +
+                    mThisDevice.wfdInfo.getDeviceType());
+        } else if (isGroupRemoved()) {
+            if (DBG) {
+                  logd("[wfd source] isWfdSourceConnected, GroupRemoved");
+            }
+        } else {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * -set IE for crossmount, format:
+     * Tag number: Vendor Specific, 221=0xdd, 1 byte
+     * Tag length: variable, 1 byte
+     * OUI: 00-0c-e7(Mediatek), 3 bytes
+     * Vendor Specific OUI Type: 0x33, 1 byte  //define via wifi p2p framework, for crossmount
+     * Vendor Specific Data: variable
+     *
+     * @param frameId    99(VENDOR_IE_ALL_FRAME_TAG) means for all frame,
+     *                   frame id list at WifiNative.java
+     */
+    private void setVendorElemIE(boolean isAdd, int frameId, String hexData) {
+        logd("setVendorElemIE(): isAdd=" + isAdd + ", frameId=" + frameId + ", hexData=" + hexData);
+
+        String ieBuf = VENDOR_IE_MTK_OUI + VENDOR_IE_OUI_TYPE__CROSSMOUNT + hexData;
+        int len = ieBuf.length() / 2;
+        ieBuf = VENDOR_IE_TAG + String.format("%02x", len & 0xFF) + ieBuf;
+
+        if (isAdd) {
+            if (frameId == VENDOR_IE_ALL_FRAME_TAG) {
+                for (int i = 0; i <= VENDOR_IE_FRAME_ID_AMOUNTS; i++) {
+                    vendorIEAdd(i, ieBuf);
+                    //logd("dump IE, frame id=" + i + ", hex=" + mWifiNative.vendorIEGet(i));
+                } // for
+            } else {
+                vendorIEAdd(frameId, ieBuf);
+            }
+        } else {
+            if (frameId == VENDOR_IE_ALL_FRAME_TAG) {
+                for (int i = 0; i <= VENDOR_IE_FRAME_ID_AMOUNTS; i++) {
+                    vendorIERemove(i, null);
+                } // for
+            } else {
+                vendorIERemove(frameId, null);
+            }
+        }
+    }
+
+    private void updateCrossMountInfo(String peerAddress) {
+        if (DBG) {
+            logd("updateCrossMountInfo(), peerAddress=" + peerAddress);
+        }
+        String peerVendorIE = mWifiNative.p2pGetVendorElems(peerAddress);
+        // reset parameters to fix flow were not going to crossmount connect intention case
+        mCrossmountEventReceived = false;
+
+        if (!TextUtils.isEmpty(peerVendorIE) &&
+                !peerVendorIE.equals(UNKNOWN_COMMAND) &&
+                peerVendorIE.contains(VENDOR_IE_MTK_OUI + VENDOR_IE_OUI_TYPE__CROSSMOUNT)) {
+            mCrossmountEventReceived = true;
+            mCrossmountSessionInfo = getCrossMountIE(peerVendorIE);
+        } else {
+            /**
+             * NOTE:
+             * -(1) For 3rd device receiving P2P-INVITATION-RECEIVED:
+             *        it will trigger 3rd device to do P2P_CONNECT join.
+             * -(2) Then the 1st device(device doing p2p_invite) would receive
+             *        P2P-PROV-DISC-PBC-REQ.
+             * -(3) At this case, 3rd device's PD request won't attached crossmount IE.
+             * -(4) So, it needs check 1st device itself crossmount IE capability!
+             */
+            String myVendorIE = null;
+
+            if (DBG) {
+                logd("updateCrossMountInfo(): check crossmount IE myself!");
+            }
+            for (int i = 0; i <= VENDOR_IE_FRAME_ID_AMOUNTS; i++) {
+                myVendorIE = vendorIEGet(i);
+                if (!TextUtils.isEmpty(myVendorIE) &&
+                        !myVendorIE.equals(UNKNOWN_COMMAND) &&
+                        myVendorIE.contains(VENDOR_IE_MTK_OUI + VENDOR_IE_OUI_TYPE__CROSSMOUNT)) {
+                    mCrossmountEventReceived = true;
+                    //Can't attach crossmount IE myself as peer's!
+                    mCrossmountSessionInfo = "";
+                    return;
+                }
+            } // for
+        }
+    }
+
+    private void p2pUpdateScanList(String peerAddress) {
+        if (mThisDevice.deviceAddress.equals(peerAddress)) {
+            return;
+        }
+
+        if (mPeers.get(peerAddress) == null) {
+            String peerInfo = mWifiNative.p2pPeer(peerAddress);
+            if (TextUtils.isEmpty(peerInfo)) {
+                return;
+            }
+            logd("p2pUpdateScanList(): " + peerAddress +
+                "  isn't in framework scan list but existed in supplicant's list");
+
+            WifiP2pDevice device = new WifiP2pDevice();
+            device.deviceAddress = peerAddress;
+            String[] tokens = peerInfo.split("\n");
+            for (String token : tokens) {
+                if (token.startsWith("device_name=")) {
+                    device.deviceName = nameValueAssign(token.split("="), device.deviceName);
+                } else if (token.startsWith("pri_dev_type=")) {
+                    device.primaryDeviceType = nameValueAssign(token.split("="),
+                        device.primaryDeviceType);
+                } else if (token.startsWith("config_methods=")) {
+                    device.wpsConfigMethodsSupported = nameValueAssign(token.split("="),
+                        device.wpsConfigMethodsSupported);
+                } else if (token.startsWith("dev_capab=")) {
+                    device.deviceCapability = nameValueAssign(token.split("="),
+                        device.deviceCapability);
+                } else if (token.startsWith("group_capab=")) {
+                    device.groupCapability = nameValueAssign(token.split("="),
+                        device.groupCapability);
+                }
+            } //for
+            //loge("[debug] p2pUpdateScanList(): device: " + device);
+            mPeers.updateSupplicantDetails(device);
+            //loge("[debug] p2pUpdateScanList(): mPeers: " + mPeers);
+        }
+    }
+
+    private void p2pOverwriteWpsPin(String caller, Object obj) {
+        int pinMethod = 0;
+        String pinCode = null;
+        if (obj != null) {
+            pinMethod = ((Bundle) obj)
+                .getInt(WifiP2pManager.EXTRA_PIN_METHOD);
+            pinCode = ((Bundle) obj)
+                .getString(WifiP2pManager.EXTRA_PIN_CODE);
+            mSavedPeerConfig.wps.setup = pinMethod;
+            mSavedPeerConfig.wps.pin = pinCode;
+
+            if (DBG) {
+                logd("p2pOverwriteWpsPin(): " + caller + ", wps pin code: " + pinCode +
+                        ", pin method: " + pinMethod);
+            }
+        }
+    }
+
+    private void p2pUserAuthPreprocess(Message message) {
+        // follow wifiNative check rule
+        if (message.arg1 >= 0 && message.arg1 <= 15) {
+            mSavedPeerConfig.groupOwnerIntent = (int) message.arg1;
+        }
+        mSavedPeerConfig.netId = WifiP2pGroup.TEMPORARY_NET_ID;
+
+        ///support show PIN passively  @{
+        if (mSavedPeerConfig.wps.setup == WpsInfo.DISPLAY) {
+            if (!mCrossmountEventReceived) {
+                notifyInvitationSent(mSavedPeerConfig.wps.pin, mSavedPeerConfig.deviceAddress);
+            }
+        }
+        ///@}
+    }
+
+    private boolean isAppHandledConnection() {
+        return (isWfdSinkEnabled() || mCrossmountEventReceived);
+    }
+
+    private boolean p2pRemoveClient(String iface, String mac) {
+        String ret =
+            mWifiNative.doCustomSupplicantCommand("IFNAME=" + iface + " P2P_REMOVE_CLIENT " + mac);
+        return (!TextUtils.isEmpty(ret) && ret.startsWith("OK"));
+    }
+
+    /* Set the current mode of channel concurrent.
+         *  0 = SCC
+         *  1 = MCC
+         */
+    private String p2pSetCCMode(int ccMode) {
+        return mWifiNative.doCustomSupplicantCommand("DRIVER p2p_use_mcc=" + ccMode);
+    }
+
+    private String p2pGetDeviceCapa() {
+        return mWifiNative.doCustomSupplicantCommand("DRIVER p2p_get_cap p2p_dev_capa");
+    }
+
+    private String p2pSetDeviceCapa(String strDecimal) {
+        return mWifiNative.doCustomSupplicantCommand("DRIVER p2p_set_cap p2p_dev_capa " +
+                strDecimal);
+    }
+
+    /*M: MTK power saving*/
+    private void setP2pPowerSaveMtk(String iface, int mode) {
+        mWifiNative.doCustomSupplicantCommand("DRIVER p2p_set_power_save " + mode);
+    }
+
+    private void setWfdExtCapability(String hex) {
+        mWifiNative.doCustomSupplicantCommand("WFD_SUBELEM_SET 7 " + hex);
+    }
+
+    private void p2pBeamPlusGO(int reserve) {
+        if (0 == reserve) {
+            mWifiNative.doCustomSupplicantCommand("DRIVER BEAMPLUS_GO_RESERVE_END");
+        } else if (1 == reserve) {
+            mWifiNative.doCustomSupplicantCommand("DRIVER BEAMPLUS_GO_RESERVE_START");
+        }
+    }
+
+    private void p2pBeamPlus(int state) {
+        if (0 == state) {
+            mWifiNative.doCustomSupplicantCommand("DRIVER BEAMPLUS_STOP");
+        } else if (1 == state) {
+            mWifiNative.doCustomSupplicantCommand("DRIVER BEAMPLUS_START");
+        }
+    }
+
+    private void p2pSetBssid(int id, String bssid) {
+        mWifiNative.doCustomSupplicantCommand("IFNAME=" + mWifiNative.getInterfaceName() +
+                " SET_NETWORK " + id + " bssid " + bssid);
+    }
+
+    private String p2pLinkStatics(String interfaceAddress) {
+        return mWifiNative.doCustomSupplicantCommand("DRIVER GET_STA_STATISTICS " +
+                interfaceAddress);
+    }
+
+    private String p2pGoGetSta(String deviceAddress) {
+        return mWifiNative.doCustomSupplicantCommand("IFNAME=" + mWifiNative.getInterfaceName() +
+                " " + "STA " + deviceAddress);
+    }
+
+    public void p2pAutoChannel(int enable) {
+        mWifiNative.doCustomSupplicantCommand("enable_channel_selection " + enable);
+    }
+
+    /* Add vendor ID.
+        * Frame id:
+        * 0    Probe Request frame in P2P device discovery
+        * 1    Probe Response frame from P2P Device rol
+        * 2    Probe Response frame from P2P GO
+        * 3    Beacon frame from P2P GO
+        * 4    PD Req
+        * 5    PD Resp
+        * 6    GO Neg Req
+        * 7    GO Neg Resp
+        * 8    GO Neg Conf
+        * 9    Invitation Request
+        * 10   Invitation Response
+        * 11   P2P Association Request
+        * 12   P2P Association Response
+        * 13   VENDOR_ELEM_ASSOC_REQ
+        */
+    //set FrameID with IE
+    private void vendorIEAdd(int frameId, String hex) {
+        mWifiNative.doCustomSupplicantCommand("IFNAME=" + mWifiNative.getInterfaceName() +
+                " VENDOR_ELEM_ADD " + frameId + " " + hex);
+    }
+
+    //get vendor IE with FrameID
+    private String vendorIEGet(int frameId) {
+        return mWifiNative.doCustomSupplicantCommand("IFNAME=" + mWifiNative.getInterfaceName() +
+                " VENDOR_ELEM_GET " + frameId);
+    }
+
+    //remove all/specific vendor IE with FrameID
+    private void vendorIERemove(int frameId, String hex) {
+        if (hex == null) {
+            mWifiNative.doCustomSupplicantCommand("IFNAME=" + mWifiNative.getInterfaceName() +
+                    " VENDOR_ELEM_REMOVE " + frameId + " *");
+        } else {
+            mWifiNative.doCustomSupplicantCommand("IFNAME=" + mWifiNative.getInterfaceName() +
+                    " VENDOR_ELEM_REMOVE " + frameId + " " + hex);
+        }
+    }
+
+    private WifiP2pGroup addPersistentGroup(HashMap<String, String> variables) {
+        if (DBG) {
+            logd("addPersistentGroup");
+        }
+        int netId = mWifiNative.addNetwork();
+        for (String key : variables.keySet()) {
+            if (DBG) {
+                logd("addPersistentGroup variable=" + key + " : " + variables.get(key));
+            }
+            mWifiNative.setNetworkVariable(netId, key, variables.get(key));
+        }
+        updatePersistentNetworks(true);
+        Collection<WifiP2pGroup> groups = mGroups.getGroupList();
+        for (WifiP2pGroup group : groups) {
+            if (netId == group.getNetworkId()) {
+                return group;
+            }
+        }
+        if (DBG) {
+            logd("addPersistentGroup failed.");
+        }
+        return null;
+    }
+
+    public void setBeamMode(int mode) {
+        if (DBG) {
+            logd("setBeamMode mode=" + mode);
+        }
+        switch (mode) {
+            case WifiP2pManager.BEAM_MODE_ENABLE:
+                p2pBeamPlus(1);
+                mGcIgnoresDhcpReq = true;
+                break;
+            case WifiP2pManager.BEAM_GO_MODE_ENABLE:
+                p2pBeamPlusGO(1);
+                break;
+            case WifiP2pManager.BEAM_MODE_DISABLE:
+                p2pBeamPlus(0);
+                mGcIgnoresDhcpReq = false;
+                break;
+            case WifiP2pManager.BEAM_GO_MODE_DISABLE:
+                p2pBeamPlusGO(0);
+                break;
+            default:
+                break;
+        }
+    }
+    } // end of class P2pStateMachine
+    ///@}
+
+    /**
+     * Information about a particular client and we track the service discovery requests
+     * and the local services registered by the client.
+     */
+    private class ClientInfo {
+
+        /*
+         * A reference to WifiP2pManager.Channel handler.
+         * The response of this request is notified to WifiP2pManager.Channel handler
+         */
+        private Messenger mMessenger;
+
+        /*
+         * A service discovery request list.
+         */
+        private SparseArray<WifiP2pServiceRequest> mReqList;
+
+        /*
+         * A local service information list.
+         */
+        private List<WifiP2pServiceInfo> mServList;
+
+        private ClientInfo(Messenger m) {
+            mMessenger = m;
+            mReqList = new SparseArray();
+            mServList = new ArrayList<WifiP2pServiceInfo>();
+        }
+    }
+
+    ///M: ALPS02475909: only 32 - 9  bytes is allowed for SSID postfix@{
+    // Calculate byte length for the UTF-8 string
+    private String getSsidPostfix(String deviceName) {
+        int utfCount = 0;
+        int strLen = 0;
+        // Default is UTF-8
+        byte[] bChar = deviceName.getBytes();
+
+        if (TextUtils.isEmpty(deviceName)) {
+            return deviceName;
+        } else if (bChar.length <= 22) {
+            return deviceName;
+        }
+
+        for (int i = 0 ; i <= deviceName.length() ; i++) {
+            // utfCount indicates the first byte of the next char
+            byte b0 = bChar[utfCount];
+            Log.d(TAG, "b0=" + b0 + ", i=" + i + ", utfCount=" + utfCount);
+            // To calculate the memory length of the next char
+            if ((b0 & 0x80) == 0) {
+                // ASCII encoding
+                // Range:  U-00000000 - U-0000007F
+                utfCount += 1;
+            } else {
+                // UTF8 encoding
+                if (b0 >= (byte) 0xFC && b0 <= (byte) 0xFD) {
+                    utfCount += 6;
+                } else if (b0 >= (byte) 0xF8) {
+                    utfCount += 5;
+                } else if (b0 >= (byte) 0xF0) {
+                    utfCount += 4;
+                } else if (b0 >= (byte) 0xE0) {
+                    utfCount += 3;
+                } else if (b0 >= (byte) 0xC0) {
+                    utfCount += 2;
+                }
+            }
+            // Memory length over 22 bytes with the next char (postfix limitation)
+            if (utfCount > 22) {
+                strLen = i;
+                Log.d(TAG, "break: utfCount=" + utfCount + ", strLen=" + strLen);
+                break;
+            }
+        }
+
+        return deviceName.substring(0, strLen);
+    }
+    ///@}
+}
Index: vendor/branch/980CN1/kernel-4.4/drivers/usb/gadget/android.c
===================================================================
--- vendor/branch/980CN1/kernel-4.4/drivers/usb/gadget/android.c	(revision 0)
+++ vendor/branch/980CN1/kernel-4.4/drivers/usb/gadget/android.c	(revision 1376)
@@ -0,0 +1,2944 @@
+/*
+ * Gadget Driver for Android
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *         Benoit Goby <benoit@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/utsname.h>
+#include <linux/platform_device.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/composite.h>
+#include <linux/usb/gadget.h>
+
+/* Add for HW/SW connect */
+#include "mtk_gadget.h"
+/* Add for HW/SW connect */
+
+#include "u_fs.h"
+
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+#include "f_hid.c"
+#endif
+#ifdef CONFIG_SND_RAWMIDI
+#include "f_midi.c"
+#endif
+
+
+#include "f_accessory.c"
+#include "f_mass_storage.h"
+#include "f_mtp.c"
+#include "f_eem.c"
+#include "f_rndis.c"
+/* note ERROR macro both appear on cdev & u_ether, make sure what you want */
+#include "rndis.c"
+#include "u_ether.c"
+
+#include "mbim_ether.c"
+#include "f_mbim.c"
+
+USB_ETHERNET_MODULE_PARAMETERS();
+
+#ifdef CONFIG_MTK_ECCCI_C2K
+#include "viatel_rawbulk.h"
+#endif
+
+#ifdef CONFIG_MTK_USB2JTAG_SUPPORT
+#include <mt-plat/mtk_usb2jtag.h>
+#endif
+
+MODULE_AUTHOR("Mike Lockwood");
+MODULE_DESCRIPTION("Android Composite USB Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+static const char longname[] = "Gadget Android";
+
+/* Default vendor and product IDs, overridden by userspace */
+#define VENDOR_ID		0x18D1
+#define PRODUCT_ID		0x0001
+
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+#include <mt-plat/mtk_boot_common.h>
+#define KPOC_USB_FUNC "hid"
+#define KPOC_USB_VENDOR_ID 0x0E8D
+#define KPOC_USB_PRODUCT_ID 0x20FF
+#endif
+
+#ifdef CONFIG_SND_RAWMIDI
+/* f_midi configuration */
+#define MIDI_INPUT_PORTS    1
+#define MIDI_OUTPUT_PORTS   1
+#define MIDI_BUFFER_SIZE    1024
+#define MIDI_QUEUE_LENGTH   32
+#endif
+#ifdef CONFIG_MTPROF
+#include "bootprof.h"
+#endif
+
+struct android_usb_function {
+	char *name;
+	void *config;
+
+	struct device *dev;
+	char *dev_name;
+	struct device_attribute **attributes;
+
+	/* for android_dev.enabled_functions */
+	struct list_head enabled_list;
+
+	/* Optional: initialization during gadget bind */
+	int (*init)(struct android_usb_function *, struct usb_composite_dev *);
+	/* Optional: cleanup during gadget unbind */
+	void (*cleanup)(struct android_usb_function *);
+	/* Optional: called when the function is added the list of
+	 *		enabled functions
+	 */
+	void (*enable)(struct android_usb_function *);
+	/* Optional: called when it is removed */
+	void (*disable)(struct android_usb_function *);
+
+	int (*bind_config)(struct android_usb_function *,
+			   struct usb_configuration *);
+
+	/* Optional: called when the configuration is removed */
+	void (*unbind_config)(struct android_usb_function *,
+			      struct usb_configuration *);
+	/* Optional: handle ctrl requests before the device is configured */
+	int (*ctrlrequest)(struct android_usb_function *,
+					struct usb_composite_dev *,
+					const struct usb_ctrlrequest *);
+};
+
+struct android_dev {
+	struct android_usb_function **functions;
+	struct list_head enabled_functions;
+	struct usb_composite_dev *cdev;
+	struct device *dev;
+
+	void (*setup_complete)(struct usb_ep *ep,
+				struct usb_request *req);
+
+	bool enabled;
+	int disable_depth;
+	struct mutex mutex;
+	bool connected;
+	bool sw_connected;
+	struct work_struct work;
+	char ffs_aliases[256];
+};
+
+static struct class *android_class;
+static struct android_dev *_android_dev;
+static int android_bind_config(struct usb_configuration *c);
+static void android_unbind_config(struct usb_configuration *c);
+static int android_setup_config(struct usb_configuration *c, const struct usb_ctrlrequest *ctrl);
+
+/* string IDs are assigned dynamically */
+#define STRING_MANUFACTURER_IDX		0
+#define STRING_PRODUCT_IDX		1
+#define STRING_SERIAL_IDX		2
+
+static char manufacturer_string[256];
+static char product_string[256];
+static char serial_string[256];
+
+/* String Table */
+static struct usb_string strings_dev[] = {
+	[STRING_MANUFACTURER_IDX].s = manufacturer_string,
+	[STRING_PRODUCT_IDX].s = product_string,
+	[STRING_SERIAL_IDX].s = serial_string,
+	{  }			/* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language	= 0x0409,	/* en-us */
+	.strings	= strings_dev,
+};
+
+static struct usb_gadget_strings *dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+static struct usb_device_descriptor device_desc = {
+	.bLength              = sizeof(device_desc),
+	.bDescriptorType      = USB_DT_DEVICE,
+#ifdef CONFIG_USB_MU3D_DRV
+	.bcdUSB               = cpu_to_le16(0x0300),
+#else
+	.bcdUSB               = cpu_to_le16(0x0200),
+#endif
+	.bDeviceClass         = USB_CLASS_PER_INTERFACE,
+	.idVendor             = cpu_to_le16(VENDOR_ID),
+	.idProduct            = cpu_to_le16(PRODUCT_ID),
+	.bcdDevice            = cpu_to_le16(0xffff),
+	.bNumConfigurations   = 1,
+};
+
+static struct usb_configuration android_config_driver = {
+	.label		= "android",
+	.setup		= android_setup_config,
+	.unbind		= android_unbind_config,
+	.bConfigurationValue = 1,
+#ifdef CONFIG_USBIF_COMPLIANCE
+	.bmAttributes	= USB_CONFIG_ATT_ONE,
+#else
+	.bmAttributes	= USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
+#endif
+#ifdef CONFIG_USB_MU3D_DRV
+	.MaxPower	= 192, /* Only consume 192ma for passing USB30CV Descriptor Test [USB3.0 devices]*/
+#else
+	.MaxPower	= 500, /* 500ma */
+#endif
+};
+
+static void android_work(struct work_struct *data)
+{
+	struct android_dev *dev = container_of(data, struct android_dev, work);
+	struct usb_composite_dev *cdev = dev->cdev;
+	char *disconnected[2] = { "USB_STATE=DISCONNECTED", NULL };
+	char *connected[2]    = { "USB_STATE=CONNECTED", NULL };
+	char *configured[2]   = { "USB_STATE=CONFIGURED", NULL };
+	/* Add for HW/SW connect */
+	char *hwdisconnected[2] = { "USB_STATE=HWDISCONNECTED", NULL };
+	bool is_hwconnected = true;
+	char **uevent_envp = NULL;
+	unsigned long flags;
+
+	if (!cdev) {
+		pr_notice("android_work, !cdev\n");
+		return;
+	}
+
+	/* be aware this could not be used in non-sleep context */
+	if (usb_cable_connected())
+		is_hwconnected = true;
+	else
+		is_hwconnected = false;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (cdev->config)
+		uevent_envp = configured;
+	else if (dev->connected != dev->sw_connected)
+		uevent_envp = dev->connected ? connected : disconnected;
+	dev->sw_connected = dev->connected;
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	if (uevent_envp) {
+		kobject_uevent_env(&dev->dev->kobj, KOBJ_CHANGE, uevent_envp);
+		pr_notice("%s: sent uevent %s, is_hwconnected=%d\n", __func__, uevent_envp[0], is_hwconnected);
+#ifdef CONFIG_MTPROF
+		if (uevent_envp == configured) {
+			static int first_shot = 1;
+
+			if (first_shot) {
+				log_boot("USB configured");
+				first_shot = 0;
+			}
+		}
+#endif
+	} else {
+		pr_notice("%s: did not send uevent (%d %d %p), is_hwconnected=%d\n", __func__,
+			 dev->connected, dev->sw_connected, cdev->config, is_hwconnected);
+	}
+
+	if (!is_hwconnected) {
+		kobject_uevent_env(&dev->dev->kobj, KOBJ_CHANGE, hwdisconnected);
+		pr_notice("[USB]%s: sent uevent %s\n", __func__, hwdisconnected[0]);
+	}
+}
+
+static void android_enable(struct android_dev *dev)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+
+
+	if (WARN_ON(!dev->disable_depth))
+		return;
+
+	if (--dev->disable_depth == 0) {
+		usb_add_config(cdev, &android_config_driver,
+					android_bind_config);
+		usb_gadget_connect(cdev->gadget);
+	}
+}
+
+static void android_disable(struct android_dev *dev)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+
+
+	if (dev->disable_depth++ == 0) {
+		usb_gadget_disconnect(cdev->gadget);
+		/* Cancel pending control requests */
+		usb_ep_dequeue(cdev->gadget->ep0, cdev->req);
+		usb_remove_config(cdev, &android_config_driver);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+/* Supported functions initialization */
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+static int hid_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	return ghid_setup(cdev->gadget, 2);
+}
+static int hid_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	return hidg_bind_config(c, NULL, 0);
+}
+static void hid_function_cleanup(struct android_usb_function *f)
+{
+	ghid_cleanup();
+}
+static struct android_usb_function hid_function = {
+	.name		= "hid",
+	.init		= hid_function_init,
+	.cleanup	= hid_function_cleanup,
+	.bind_config	= hid_function_bind_config,
+};
+#endif
+
+struct functionfs_config {
+	bool opened;
+	bool enabled;
+	struct usb_function *func;
+	struct usb_function_instance *fi;
+	struct ffs_data *data;
+};
+
+static int functionfs_ready_callback(struct ffs_data *ffs);
+static void functionfs_closed_callback(struct ffs_data *ffs);
+
+static int ffs_function_init(struct android_usb_function *f,
+			     struct usb_composite_dev *cdev)
+{
+	struct functionfs_config *config;
+	struct f_fs_opts *opts;
+
+	f->config = kzalloc(sizeof(struct functionfs_config), GFP_KERNEL);
+	if (!f->config)
+		return -ENOMEM;
+
+	config = f->config;
+	config->fi = usb_get_function_instance("ffs");
+	if (IS_ERR(config->fi))
+		return PTR_ERR(config->fi);
+
+	opts = to_f_fs_opts(config->fi);
+	opts->dev->ffs_ready_callback = functionfs_ready_callback;
+	opts->dev->ffs_closed_callback = functionfs_closed_callback;
+	opts->no_configfs = true;
+
+	return ffs_single_dev(opts->dev);
+}
+
+static void ffs_function_cleanup(struct android_usb_function *f)
+{
+	struct functionfs_config *config = f->config;
+
+
+	if (config)
+		usb_put_function_instance(config->fi);
+
+	kfree(f->config);
+}
+
+static void ffs_function_enable(struct android_usb_function *f)
+{
+	struct android_dev *dev = _android_dev;
+	struct functionfs_config *config = f->config;
+
+
+	config->enabled = true;
+
+	/* Disable the gadget until the function is ready */
+	if (!config->opened)
+		android_disable(dev);
+}
+
+static void ffs_function_disable(struct android_usb_function *f)
+{
+	struct android_dev *dev = _android_dev;
+	struct functionfs_config *config = f->config;
+
+
+	config->enabled = false;
+
+	/* Balance the disable that was called in closed_callback */
+	if (!config->opened)
+		android_enable(dev);
+}
+
+static int ffs_function_bind_config(struct android_usb_function *f,
+				    struct usb_configuration *c)
+{
+	struct functionfs_config *config = f->config;
+	int ret;
+
+	config->func = usb_get_function(config->fi);
+	if (IS_ERR(config->func))
+		return PTR_ERR(config->func);
+
+	ret = usb_add_function(c, config->func);
+	if (ret) {
+		pr_err("%s(): usb_add_function() fails (err:%d) for ffs\n",
+							__func__, ret);
+
+		usb_put_function(config->func);
+		config->func = NULL;
+	}
+
+	return ret;
+}
+
+static ssize_t
+ffs_aliases_show(struct device *pdev, struct device_attribute *attr, char *buf)
+{
+	struct android_dev *dev = _android_dev;
+	int ret;
+
+	mutex_lock(&dev->mutex);
+	ret = sprintf(buf, "%s\n", dev->ffs_aliases);
+	mutex_unlock(&dev->mutex);
+
+	return ret;
+}
+
+static ssize_t
+ffs_aliases_store(struct device *pdev, struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct android_dev *dev = _android_dev;
+	char buff[256];
+
+	mutex_lock(&dev->mutex);
+
+	if (dev->enabled) {
+		mutex_unlock(&dev->mutex);
+		return -EBUSY;
+	}
+
+	strlcpy(buff, buf, sizeof(buff));
+	strlcpy(dev->ffs_aliases, strim(buff), sizeof(dev->ffs_aliases));
+
+	mutex_unlock(&dev->mutex);
+
+	return size;
+}
+
+static DEVICE_ATTR(aliases, S_IRUGO | S_IWUSR, ffs_aliases_show,
+					       ffs_aliases_store);
+static struct device_attribute *ffs_function_attributes[] = {
+	&dev_attr_aliases,
+	NULL
+};
+
+static struct android_usb_function ffs_function = {
+	.name		= "ffs",
+	.init		= ffs_function_init,
+	.enable		= ffs_function_enable,
+	.disable	= ffs_function_disable,
+	.cleanup	= ffs_function_cleanup,
+	.bind_config	= ffs_function_bind_config,
+	.attributes	= ffs_function_attributes,
+};
+
+static int functionfs_ready_callback(struct ffs_data *ffs)
+{
+	struct android_dev *dev = _android_dev;
+	struct functionfs_config *config = ffs_function.config;
+	int ret = 0;
+
+	mutex_lock(&dev->mutex);
+
+	config->data = ffs;
+	config->opened = true;
+
+	if (config->enabled)
+		android_enable(dev);
+
+	mutex_unlock(&dev->mutex);
+	return ret;
+}
+
+static void functionfs_closed_callback(struct ffs_data *ffs)
+{
+	struct android_dev *dev = _android_dev;
+	struct functionfs_config *config = ffs_function.config;
+
+	mutex_lock(&dev->mutex);
+
+	if (config->enabled)
+		android_disable(dev);
+
+	config->opened = false;
+	config->data = NULL;
+
+	if (config->func) {
+		usb_put_function(config->func);
+		config->func = NULL;
+	}
+
+	mutex_unlock(&dev->mutex);
+}
+
+/* note all serial port number could not exceed MAX_U_SERIAL_PORTS */
+#define MAX_ACM_INSTANCES 4
+struct acm_function_config {
+	int instances;
+	int instances_on;
+	struct usb_function *f_acm[MAX_ACM_INSTANCES];
+	struct usb_function_instance *f_acm_inst[MAX_ACM_INSTANCES];
+	int port_index[MAX_ACM_INSTANCES];
+	int port_index_on[MAX_ACM_INSTANCES];
+};
+
+static int
+acm_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	int i;
+	int ret;
+	struct acm_function_config *config;
+
+	config = kzalloc(sizeof(struct acm_function_config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+	f->config = config;
+
+	for (i = 0; i < MAX_ACM_INSTANCES; i++) {
+		config->f_acm_inst[i] = usb_get_function_instance("acm");
+		if (IS_ERR(config->f_acm_inst[i])) {
+			ret = PTR_ERR(config->f_acm_inst[i]);
+			goto err_usb_get_function_instance;
+		}
+		config->f_acm[i] = usb_get_function(config->f_acm_inst[i]);
+		if (IS_ERR(config->f_acm[i])) {
+			ret = PTR_ERR(config->f_acm[i]);
+			goto err_usb_get_function;
+		}
+	}
+	return 0;
+err_usb_get_function_instance:
+	pr_err("Could not usb_get_function_instance() %d\n", i);
+	while (i-- > 0) {
+		usb_put_function(config->f_acm[i]);
+err_usb_get_function:
+		pr_err("Could not usb_get_function() %d\n", i);
+		usb_put_function_instance(config->f_acm_inst[i]);
+	}
+	return ret;
+}
+
+static void acm_function_cleanup(struct android_usb_function *f)
+{
+	int i;
+	struct acm_function_config *config = f->config;
+
+	for (i = 0; i < MAX_ACM_INSTANCES; i++) {
+		usb_put_function(config->f_acm[i]);
+		usb_put_function_instance(config->f_acm_inst[i]);
+	}
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int
+acm_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	int i;
+	int ret = 0;
+	struct acm_function_config *config = f->config;
+	/*1st:Modem, 2nd:Modem, 3rd:BT, 4th:MD logger*/
+	for (i = 0; i < MAX_ACM_INSTANCES; i++) {
+		if (config->port_index[i] != 0) {
+			ret = usb_add_function(c, config->f_acm[i]);
+			if (ret) {
+				pr_err("Could not bind acm%u config\n", i);
+				goto err_usb_add_function;
+			}
+			pr_notice("%s Open /dev/ttyGS%d\n", __func__, i);
+			config->port_index[i] = 0;
+			config->port_index_on[i] = 1;
+			config->instances = 0;
+		}
+	}
+
+
+	config->instances_on = config->instances;
+	for (i = 0; i < config->instances_on; i++) {
+		ret = usb_add_function(c, config->f_acm[i]);
+		if (ret) {
+			pr_err("Could not bind acm%u config\n", i);
+			goto err_usb_add_function;
+		}
+	}
+
+	return 0;
+
+err_usb_add_function:
+	while (i-- > 0)
+		usb_remove_function(c, config->f_acm[i]);
+	return ret;
+}
+
+static void acm_function_unbind_config(struct android_usb_function *f,
+				       struct usb_configuration *c)
+{
+	struct acm_function_config *config = f->config;
+
+	config->instances_on = 0;
+}
+
+static ssize_t acm_instances_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct acm_function_config *config = f->config;
+
+	return sprintf(buf, "%d\n", config->instances);
+}
+
+static ssize_t acm_instances_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct acm_function_config *config = f->config;
+
+	int value, ret;
+
+
+	ret = kstrtoint(buf, 0, &value);
+	if (value > MAX_ACM_INSTANCES)
+		value = MAX_ACM_INSTANCES;
+	config->instances = value;
+	return size;
+}
+
+static DEVICE_ATTR(instances, S_IRUGO | S_IWUSR, acm_instances_show,
+						 acm_instances_store);
+
+static ssize_t acm_port_index_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct acm_function_config *config = f->config;
+
+	return sprintf(buf, "%d,%d,%d,%d\n", config->port_index[0], config->port_index[1],
+		config->port_index[2], config->port_index[3]);
+}
+
+static ssize_t acm_port_index_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct acm_function_config *config = f->config;
+	int val[MAX_ACM_INSTANCES] = {0};
+	int num = 0;
+	int tmp = 0;
+
+	num = sscanf(buf, "%d,%d,%d,%d", &(val[0]), &(val[1]), &(val[2]), &(val[3]));
+
+	pr_notice("%s [0]=%d,[1]=%d,[2]=%d,[3]=%d, num=%d\n", __func__, val[0], val[1], val[2], val[3], num);
+
+	/* Set all port_index as 0*/
+	for (tmp = 0; tmp < MAX_ACM_INSTANCES; tmp++)
+		config->port_index[tmp] = 0;
+
+	for (tmp = 0; tmp < num; tmp++) {
+		int port = (val[tmp] > MAX_ACM_INSTANCES || val[tmp] < 1) ? 0 : val[tmp]-1;
+
+		config->port_index[port] = 1;
+	}
+
+	return size;
+}
+
+static DEVICE_ATTR(port_index, S_IRUGO | S_IWUSR, acm_port_index_show,
+						 acm_port_index_store);
+
+static struct device_attribute *acm_function_attributes[] = {
+	&dev_attr_instances,
+	&dev_attr_port_index, /*Only open the specific port*/
+	NULL
+};
+
+static struct android_usb_function acm_function = {
+	.name		= "acm",
+	.init		= acm_function_init,
+	.cleanup	= acm_function_cleanup,
+	.bind_config	= acm_function_bind_config,
+	.unbind_config	= acm_function_unbind_config,
+	.attributes	= acm_function_attributes,
+};
+
+#ifdef CONFIG_USB_F_SS_LB
+#define MAX_LOOPBACK_INSTANCES 1
+
+struct loopback_function_config {
+	int port_num;
+	struct usb_function *f_lp[MAX_LOOPBACK_INSTANCES];
+	struct usb_function_instance *f_lp_inst[MAX_LOOPBACK_INSTANCES];
+};
+
+static int loopback_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
+{
+	int i;
+	int ret;
+	struct loopback_function_config *config;
+
+
+	config = kzalloc(sizeof(struct loopback_function_config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+	f->config = config;
+
+	for (i = 0; i < MAX_LOOPBACK_INSTANCES; i++) {
+		config->f_lp_inst[i] = usb_get_function_instance("Loopback");
+		if (IS_ERR(config->f_lp_inst[i])) {
+			ret = PTR_ERR(config->f_lp_inst[i]);
+			goto err_usb_get_function_instance;
+		}
+		config->f_lp[i] = usb_get_function(config->f_lp_inst[i]);
+		if (IS_ERR(config->f_lp[i])) {
+			ret = PTR_ERR(config->f_lp[i]);
+			goto err_usb_get_function;
+		}
+	}
+	return 0;
+err_usb_get_function_instance:
+	pr_err("Could not usb_get_function_instance() %d\n", i);
+	while (i-- > 0) {
+		usb_put_function(config->f_lp[i]);
+err_usb_get_function:
+		pr_err("Could not usb_get_function() %d\n", i);
+		usb_put_function_instance(config->f_lp_inst[i]);
+	}
+	return ret;
+}
+
+static void loopback_function_cleanup(struct android_usb_function *f)
+{
+	int i;
+	struct loopback_function_config *config = f->config;
+
+
+	for (i = 0; i < MAX_LOOPBACK_INSTANCES; i++) {
+		usb_put_function(config->f_lp[i]);
+		usb_put_function_instance(config->f_lp_inst[i]);
+	}
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int
+loopback_function_bind_config(struct android_usb_function *f, struct usb_configuration *c)
+{
+	int ret = 0;
+	struct loopback_function_config *config = f->config;
+
+
+	ret = usb_add_function(c, config->f_lp[config->port_num]);
+	if (ret) {
+		pr_err("Could not bind loopback%u config\n", config->port_num);
+		goto err_usb_add_function;
+	}
+	pr_notice("%s Open loopback\n", __func__);
+
+	return 0;
+
+err_usb_add_function:
+	usb_remove_function(c, config->f_lp[config->port_num]);
+	return ret;
+}
+
+static struct android_usb_function loopback_function = {
+	.name		= "loopback",
+	.init		= loopback_function_init,
+	.cleanup	= loopback_function_cleanup,
+	.bind_config	= loopback_function_bind_config,
+};
+#endif
+
+/* note all serial port number could not exceed MAX_U_SERIAL_PORTS */
+#define MAX_SERIAL_INSTANCES 4
+
+struct serial_function_config {
+	int port_num;
+	struct usb_function *f_ser[MAX_SERIAL_INSTANCES];
+	struct usb_function_instance *f_ser_inst[MAX_SERIAL_INSTANCES];
+};
+
+static int serial_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
+{
+	int i;
+	int ret;
+	struct serial_function_config *config;
+
+	config = kzalloc(sizeof(struct serial_function_config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+	f->config = config;
+
+	for (i = 0; i < MAX_SERIAL_INSTANCES; i++) {
+		config->f_ser_inst[i] = usb_get_function_instance("gser");
+		if (IS_ERR(config->f_ser_inst[i])) {
+			ret = PTR_ERR(config->f_ser_inst[i]);
+			goto err_usb_get_function_instance;
+		}
+		config->f_ser[i] = usb_get_function(config->f_ser_inst[i]);
+		if (IS_ERR(config->f_ser[i])) {
+			ret = PTR_ERR(config->f_ser[i]);
+			goto err_usb_get_function;
+		}
+	}
+		return 0;
+err_usb_get_function_instance:
+	pr_err("Could not usb_get_function_instance() %d\n", i);
+	while (i-- > 0) {
+		usb_put_function(config->f_ser[i]);
+err_usb_get_function:
+		pr_err("Could not usb_get_function() %d\n", i);
+		usb_put_function_instance(config->f_ser_inst[i]);
+	}
+	return ret;
+}
+
+static void serial_function_cleanup(struct android_usb_function *f)
+{
+	int i;
+	struct serial_function_config *config = f->config;
+
+	for (i = 0; i < MAX_SERIAL_INSTANCES; i++) {
+		usb_put_function(config->f_ser[i]);
+		usb_put_function_instance(config->f_ser_inst[i]);
+	}
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int
+serial_function_bind_config(struct android_usb_function *f, struct usb_configuration *c)
+{
+	int ret = 0;
+	struct serial_function_config *config = f->config;
+
+	ret = usb_add_function(c, config->f_ser[config->port_num]);
+	if (ret) {
+		pr_err("Could not bind ser%u config\n", config->port_num);
+		goto err_usb_add_function;
+	}
+	pr_notice("%s Open /dev/ttyGS%d\n", __func__, config->port_num);
+
+	return 0;
+
+err_usb_add_function:
+	usb_remove_function(c, config->f_ser[config->port_num]);
+	return ret;
+}
+
+static ssize_t serial_port_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct serial_function_config *config = f->config;
+
+	return sprintf(buf, "%d\n", config->port_num);
+}
+
+static ssize_t serial_port_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct serial_function_config *config = f->config;
+	int ret;
+	u32 value;
+
+	ret = kstrtou32(buf, 10, &value);
+	if (ret) {
+		pr_notice("serial_port_store err, ret:%d\n", ret);
+		return size;
+	}
+	if (value > MAX_SERIAL_INSTANCES)
+		value = MAX_SERIAL_INSTANCES;
+	config->port_num = value;
+	return size;
+}
+
+static DEVICE_ATTR(port, S_IRUGO | S_IWUSR, serial_port_show, serial_port_store);
+static struct device_attribute *serial_function_attributes[] = { &dev_attr_port, NULL };
+
+static struct android_usb_function serial_function = {
+	.name		= "gser",
+	.init		= serial_function_init,
+	.cleanup	= serial_function_cleanup,
+	.bind_config	= serial_function_bind_config,
+	.attributes	= serial_function_attributes,
+};
+
+
+static int
+mtp_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	return mtp_setup();
+}
+
+static void mtp_function_cleanup(struct android_usb_function *f)
+{
+	mtp_cleanup();
+}
+
+static int
+mtp_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	return mtp_bind_config(c, false);
+}
+
+static int
+ptp_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	/* nothing to do - initialization is handled by mtp_function_init */
+	return 0;
+}
+
+static void ptp_function_cleanup(struct android_usb_function *f)
+{
+	/* nothing to do - cleanup is handled by mtp_function_cleanup */
+}
+
+static int
+ptp_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	return mtp_bind_config(c, true);
+}
+
+static int mtp_function_ctrlrequest(struct android_usb_function *f,
+					struct usb_composite_dev *cdev,
+					const struct usb_ctrlrequest *c)
+{
+	return mtp_ctrlrequest(cdev, c);
+}
+
+static int cpumask_to_int(const struct cpumask *cpu_mask)
+{
+	int mask = 0;
+	int cpu;
+
+	for_each_cpu(cpu, cpu_mask) {
+		pr_debug("[USB]%d\n", cpu);
+		mask |= (1 << cpu);
+	}
+
+	return mask;
+}
+
+static ssize_t cpu_mask_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cpumask *cpu_mask = mtp_get_cpu_mask();
+
+	return sprintf(buf, "0x%X\n", (cpu_mask?cpumask_to_int(cpu_mask):0xFFFFFFFF));
+}
+
+static ssize_t cpu_mask_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	unsigned int mask;
+
+	if (kstrtouint(buf, 16, &mask) != 0)
+		return -EINVAL;
+
+	pr_info("Store => 0x%x\n", mask);
+
+	mtp_set_cpu_mask(mask);
+
+	return size;
+}
+
+static DEVICE_ATTR(cpu_mask, S_IRUGO | S_IWUSR, cpu_mask_show,
+					       cpu_mask_store);
+
+static ssize_t mtp_server_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", mtp_get_mtp_server());
+}
+
+static DEVICE_ATTR(mtp_server, S_IRUGO, mtp_server_show,
+					       NULL);
+
+static struct device_attribute *mtp_function_attributes[] = {
+	&dev_attr_cpu_mask,
+	&dev_attr_mtp_server,
+	NULL
+};
+
+static struct android_usb_function mtp_function = {
+	.name		= "mtp",
+	.init		= mtp_function_init,
+	.cleanup	= mtp_function_cleanup,
+	.bind_config	= mtp_function_bind_config,
+	.ctrlrequest	= mtp_function_ctrlrequest,
+	.attributes	= mtp_function_attributes,
+};
+
+/* PTP function is same as MTP with slightly different interface descriptor */
+static struct android_usb_function ptp_function = {
+	.name		= "ptp",
+	.init		= ptp_function_init,
+	.cleanup	= ptp_function_cleanup,
+	.bind_config	= ptp_function_bind_config,
+	.ctrlrequest	= mtp_function_ctrlrequest,
+};
+struct eem_function_config {
+	u8      ethaddr[ETH_ALEN];
+	char	manufacturer[256];
+	struct eth_dev *dev;
+};
+
+static int
+eem_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	f->config = kzalloc(sizeof(struct eem_function_config), GFP_KERNEL);
+	if (!f->config)
+		return -ENOMEM;
+	return 0;
+}
+
+static void eem_function_cleanup(struct android_usb_function *f)
+{
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int
+eem_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	int ret;
+	struct eth_dev *dev;
+	struct eem_function_config *eem = f->config;
+
+
+	pr_notice("[USB]%s:\n", __func__);
+
+	if (!eem) {
+		pr_err("%s: rndis_pdata\n", __func__);
+		return -1;
+	}
+
+	pr_notice("%s MAC: %02X:%02X:%02X:%02X:%02X:%02X\n", __func__,
+		eem->ethaddr[0], eem->ethaddr[1], eem->ethaddr[2],
+		eem->ethaddr[3], eem->ethaddr[4], eem->ethaddr[5]);
+
+	dev = gether_setup_name(c->cdev->gadget, dev_addr, host_addr,
+			eem->ethaddr, qmult, "rndis");
+	if (IS_ERR(dev)) {
+		ret = PTR_ERR(dev);
+		pr_err("%s: gether_setup failed\n", __func__);
+		return ret;
+	}
+	eem->dev = dev;
+
+	return eem_bind_config(c, eem->dev);
+}
+
+static void eem_function_unbind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct eem_function_config *eem = f->config;
+
+
+	gether_cleanup(eem->dev);
+}
+
+static ssize_t eem_ethaddr_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct eem_function_config *eem = f->config;
+
+
+	return sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		eem->ethaddr[0], eem->ethaddr[1], eem->ethaddr[2],
+		eem->ethaddr[3], eem->ethaddr[4], eem->ethaddr[5]);
+}
+
+static ssize_t eem_ethaddr_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct eem_function_config *eem = f->config;
+
+
+	if (sscanf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		    (int *)&eem->ethaddr[0], (int *)&eem->ethaddr[1],
+		    (int *)&eem->ethaddr[2], (int *)&eem->ethaddr[3],
+		    (int *)&eem->ethaddr[4], (int *)&eem->ethaddr[5]) == 6)
+		return size;
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(eem_ethaddr, S_IRUGO | S_IWUSR, eem_ethaddr_show,
+					       eem_ethaddr_store);
+
+static struct device_attribute *eem_function_attributes[] = {
+	&dev_attr_eem_ethaddr,
+	NULL
+};
+
+static struct android_usb_function eem_function = {
+	.name		= "eem",
+	.init		= eem_function_init,
+	.cleanup	= eem_function_cleanup,
+	.bind_config	= eem_function_bind_config,
+	.unbind_config	= eem_function_unbind_config,
+	.attributes	= eem_function_attributes,
+};
+
+struct rndis_function_config {
+	u8      ethaddr[ETH_ALEN];
+	u32     vendorID;
+	char	manufacturer[256];
+	/* "Wireless" RNDIS; auto-detected by Windows */
+	bool	wceis;
+	struct eth_dev *dev;
+#ifdef CONFIG_MTK_MD_DIRECT_TETHERING_SUPPORT
+	bool	direct_feature_on;
+	u8      direct_value;
+#endif
+};
+
+static int
+rndis_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	f->config = kzalloc(sizeof(struct rndis_function_config), GFP_KERNEL);
+	if (!f->config)
+		return -ENOMEM;
+	return 0;
+}
+
+static void rndis_function_cleanup(struct android_usb_function *f)
+{
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int
+rndis_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	int ret;
+	struct eth_dev *dev;
+	struct rndis_function_config *rndis = f->config;
+
+	if (!rndis) {
+		pr_err("%s: rndis_pdata\n", __func__);
+		return -1;
+	}
+
+	pr_notice("%s MAC: %02X:%02X:%02X:%02X:%02X:%02X\n", __func__,
+		rndis->ethaddr[0], rndis->ethaddr[1], rndis->ethaddr[2],
+		rndis->ethaddr[3], rndis->ethaddr[4], rndis->ethaddr[5]);
+
+	dev = gether_setup_name(c->cdev->gadget, dev_addr, host_addr,
+			rndis->ethaddr, qmult, "rndis");
+	if (IS_ERR(dev)) {
+		ret = PTR_ERR(dev);
+		pr_err("%s: gether_setup failed\n", __func__);
+		return ret;
+	}
+	rndis->dev = dev;
+
+	if (rndis->wceis) {
+		/* "Wireless" RNDIS; auto-detected by Windows */
+		rndis_iad_descriptor.bFunctionClass =
+						USB_CLASS_WIRELESS_CONTROLLER;
+		rndis_iad_descriptor.bFunctionSubClass = 0x01;
+		rndis_iad_descriptor.bFunctionProtocol = 0x03;
+		rndis_control_intf.bInterfaceClass =
+						USB_CLASS_WIRELESS_CONTROLLER;
+		rndis_control_intf.bInterfaceSubClass =	 0x01;
+		rndis_control_intf.bInterfaceProtocol =	 0x03;
+	}
+
+	return rndis_bind_config_vendor(c, rndis->ethaddr,
+				rndis->vendorID, rndis->manufacturer, rndis->dev);
+}
+
+static void rndis_function_unbind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct rndis_function_config *rndis = f->config;
+
+
+	gether_cleanup(rndis->dev);
+}
+
+static ssize_t rndis_manufacturer_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+
+
+	return sprintf(buf, "%s\n", config->manufacturer);
+}
+
+static ssize_t rndis_manufacturer_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+
+
+	if (size >= sizeof(config->manufacturer))
+		return -EINVAL;
+	if (sscanf(buf, "%s", config->manufacturer) == 1)
+		return size;
+	return -1;
+}
+
+static DEVICE_ATTR(manufacturer, S_IRUGO | S_IWUSR, rndis_manufacturer_show,
+						    rndis_manufacturer_store);
+
+static ssize_t rndis_wceis_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+
+
+	return sprintf(buf, "%d\n", config->wceis);
+}
+
+static ssize_t rndis_wceis_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+	int value;
+
+
+	if (kstrtoint(buf, 0, &value) == 0) {
+		config->wceis = value;
+		return size;
+	}
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(wceis, S_IRUGO | S_IWUSR, rndis_wceis_show,
+					     rndis_wceis_store);
+
+static ssize_t rndis_ethaddr_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *rndis = f->config;
+
+
+	return sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		rndis->ethaddr[0], rndis->ethaddr[1], rndis->ethaddr[2],
+		rndis->ethaddr[3], rndis->ethaddr[4], rndis->ethaddr[5]);
+}
+
+static ssize_t rndis_ethaddr_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *rndis = f->config;
+
+	if (sscanf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		    (int *)&rndis->ethaddr[0], (int *)&rndis->ethaddr[1],
+		    (int *)&rndis->ethaddr[2], (int *)&rndis->ethaddr[3],
+		    (int *)&rndis->ethaddr[4], (int *)&rndis->ethaddr[5]) == 6)
+		return size;
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(ethaddr, S_IRUGO | S_IWUSR, rndis_ethaddr_show,
+					       rndis_ethaddr_store);
+
+static ssize_t rndis_vendorID_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+
+	return sprintf(buf, "%04x\n", config->vendorID);
+}
+
+static ssize_t rndis_vendorID_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+	int value;
+
+	if (sscanf(buf, "%04x", &value) == 1) {
+		config->vendorID = value;
+		return size;
+	}
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(vendorID, S_IRUGO | S_IWUSR, rndis_vendorID_show,
+						rndis_vendorID_store);
+#ifdef CONFIG_MTK_MD_DIRECT_TETHERING_SUPPORT
+static ssize_t rndis_direct_feature_on_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+
+	return sprintf(buf, "%d\n", config->direct_feature_on);
+}
+
+static ssize_t rndis_direct_feature_on_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+	int value;
+	int ret;
+
+	ret = kstrtoint(buf, 10, &value);
+	if (ret)
+		return -EINVAL;
+
+	if (value > 0)
+		config->direct_feature_on = true;
+	else
+		config->direct_feature_on = false;
+	return size;
+}
+
+static DEVICE_ATTR(direct_feature_on, S_IRUGO | S_IWUSR, rndis_direct_feature_on_show,
+						rndis_direct_feature_on_store);
+
+static ssize_t rndis_direct_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *android_f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = android_f->config;
+
+	if (config != NULL)
+		return sprintf(buf, "%d\n", config->direct_value);
+	else
+		return sprintf(buf, "%d\n", 0);
+}
+
+static ssize_t rndis_direct_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *android_f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = android_f->config;
+	struct android_dev *pdev = _android_dev;
+	struct usb_composite_dev *cdev = pdev->cdev;
+	struct usb_function		*f;
+	int value;
+	int ret;
+
+	ret = kstrtoint(buf, 10, &value);
+
+	if (ret)
+		return -EINVAL;
+
+	if (!config)
+		return -EFAULT;
+
+	if (config->direct_feature_on)
+		pr_info("%s value:%d->%d\n", __func__, config->direct_value, value);
+	else
+		pr_info("%s direct feature is false\n", __func__);
+
+	if (config->direct_feature_on && value != config->direct_value) {
+		config->direct_value = value;
+		if (cdev->config != NULL) {
+			list_for_each_entry(f, &cdev->config->functions, list) {
+				if (f != NULL && !strcmp(f->name, "rndis")) {
+					if (value == 0)
+						rndis_set_direct_tethering(f, false);
+					else if (value == 1)
+						rndis_set_direct_tethering(f, true);
+				}
+			}
+		}
+	}
+
+	return size;
+}
+
+static DEVICE_ATTR(direct, S_IRUGO | S_IWUSR, rndis_direct_show,
+						rndis_direct_store);
+#endif
+
+static struct device_attribute *rndis_function_attributes[] = {
+	&dev_attr_manufacturer,
+	&dev_attr_wceis,
+	&dev_attr_ethaddr,
+	&dev_attr_vendorID,
+#ifdef CONFIG_MTK_MD_DIRECT_TETHERING_SUPPORT
+	&dev_attr_direct_feature_on,
+	&dev_attr_direct,
+#endif
+	NULL
+};
+
+static struct android_usb_function rndis_function = {
+	.name		= "rndis",
+	.init		= rndis_function_init,
+	.cleanup	= rndis_function_cleanup,
+	.bind_config	= rndis_function_bind_config,
+	.unbind_config	= rndis_function_unbind_config,
+	.attributes	= rndis_function_attributes,
+};
+
+
+
+struct mbim_function_config {
+	u8      ethaddr[ETH_ALEN];
+	char	manufacturer[256];
+	struct mbim_eth_dev *dev;
+};
+
+#define MAX_MBIM_INSTANCES 1
+
+static int mbim_function_init(struct android_usb_function *f,
+					 struct usb_composite_dev *cdev)
+{
+	int ret;
+
+	f->config = kzalloc(sizeof(struct mbim_function_config), GFP_KERNEL);
+	if (!f->config)
+		return -ENOMEM;
+
+	ret = mbim_init(MAX_MBIM_INSTANCES);
+	if (ret)
+		kfree(f->config);
+
+	return ret;
+}
+
+static void mbim_function_cleanup(struct android_usb_function *f)
+{
+	kfree(f->config);
+	f->config = NULL;
+	mbim_cleanup();
+}
+
+static int mbim_function_bind_config(struct android_usb_function *f,
+					  struct usb_configuration *c)
+{
+	int ret;
+	struct mbim_function_config *mbim = f->config;
+	struct mbim_eth_dev *dev;
+
+	dev = mbim_ether_setup_name(c->cdev->gadget);
+	if (IS_ERR(dev)) {
+		ret = PTR_ERR(dev);
+		pr_err("%s: mbim_gether_setup failed\n", __func__);
+		return ret;
+	}
+	mbim->dev = dev;
+	return mbim_bind_config(c, 0, mbim->dev);
+}
+static void mbim_function_unbind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct mbim_function_config *mbim = f->config;
+
+	mbim_ether_cleanup(mbim->dev);
+}
+
+static struct android_usb_function mbim_function = {
+	.name		= "mbim",
+	.init		= mbim_function_init,
+	.cleanup	= mbim_function_cleanup,
+	.bind_config	= mbim_function_bind_config,
+	.unbind_config	= mbim_function_unbind_config,
+};
+
+
+
+struct mass_storage_function_config {
+	struct usb_function *f_ms;
+	struct usb_function_instance *f_ms_inst;
+};
+#define fsg_num_buffers	CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS
+static struct fsg_module_parameters fsg_mod_data;
+FSG_MODULE_PARAMETERS(/* no prefix */, fsg_mod_data);
+
+static int mass_storage_function_init(struct android_usb_function *f,
+					struct usb_composite_dev *cdev)
+{
+	struct mass_storage_function_config *config;
+	int ret, i;
+	struct fsg_opts *fsg_opts;
+	struct fsg_config m_config;
+
+
+	pr_debug("%s(): Inside\n", __func__);
+	config = kzalloc(sizeof(struct mass_storage_function_config),
+								GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+	f->config = config;
+
+	config->f_ms_inst = usb_get_function_instance("mass_storage");
+	if (IS_ERR(config->f_ms_inst)) {
+		ret = PTR_ERR(config->f_ms_inst);
+		goto err_usb_get_function_instance;
+	}
+
+	config->f_ms = usb_get_function(config->f_ms_inst);
+	if (IS_ERR(config->f_ms)) {
+		ret = PTR_ERR(config->f_ms);
+		goto err_usb_get_function;
+	}
+#ifdef CONFIG_MTK_MULTI_STORAGE_SUPPORT
+#ifdef CONFIG_MTK_SHARED_SDCARD
+#define NLUN_STORAGE 1
+#else
+#define NLUN_STORAGE 2
+#endif
+#else
+#define NLUN_STORAGE 1
+#endif
+
+	fsg_mod_data.file_count = NLUN_STORAGE;
+	for (i = 0 ; i < fsg_mod_data.file_count; i++) {
+		fsg_mod_data.file[i] = "";
+		fsg_mod_data.removable[i] = true;
+		fsg_mod_data.nofua[i] = true;
+	}
+
+	fsg_config_from_params(&m_config, &fsg_mod_data, fsg_num_buffers);
+	fsg_opts = fsg_opts_from_func_inst(config->f_ms_inst);
+
+
+	/* note this is important for sysfs manipulation and this will be override when fsg_main_thread be created*/
+	ret = fsg_common_set_cdev(fsg_opts->common, cdev,
+						m_config.can_stall);
+	if (ret) {
+		pr_err("%s(): error(%d) for fsg_common_set_cdev\n",
+						__func__, ret);
+	}
+
+	/* this will affect lun create name */
+	fsg_common_set_sysfs(fsg_opts->common, true);
+	ret = fsg_common_create_luns(fsg_opts->common, &m_config);
+	if (ret) {
+		pr_err("%s(): error(%d) for fsg_common_create_luns\n",
+						__func__, ret);
+	}
+
+	/* use default one currently */
+	fsg_common_set_inquiry_string(fsg_opts->common, m_config.vendor_name,
+							m_config.product_name);
+
+	/* SYSFS create */
+	fsg_sysfs_update(fsg_opts->common, f->dev, true);
+
+	/* invoke thread */
+	/* ret = fsg_common_run_thread(fsg_opts->common); */
+	/*if (ret) */
+	/*	return ret; */
+
+	/* setup this to avoid create fsg thread in fsg_bind again */
+	fsg_opts->no_configfs = false;
+
+	return 0;
+
+
+err_usb_get_function:
+	usb_put_function_instance(config->f_ms_inst);
+
+err_usb_get_function_instance:
+	return ret;
+}
+
+static void mass_storage_function_cleanup(struct android_usb_function *f)
+{
+	struct mass_storage_function_config *config = f->config;
+
+	/* release what we required */
+	struct fsg_opts *fsg_opts;
+
+
+	fsg_opts = fsg_opts_from_func_inst(config->f_ms_inst);
+	fsg_sysfs_update(fsg_opts->common, f->dev, false);
+
+	usb_put_function(config->f_ms);
+	usb_put_function_instance(config->f_ms_inst);
+
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int mass_storage_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct mass_storage_function_config *config = f->config;
+	int ret = 0;
+
+
+	/* no_configfs :true, make fsg_bind skip for creating fsg thread */
+	ret = usb_add_function(c, config->f_ms);
+	if (ret)
+		pr_err("Could not bind config\n");
+
+	return 0;
+}
+
+static ssize_t mass_storage_inquiry_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct fsg_opts *fsg_opts;
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct mass_storage_function_config *config = f->config;
+
+
+	fsg_opts = fsg_opts_from_func_inst(config->f_ms_inst);
+
+	return fsg_inquiry_show(fsg_opts->common, buf);
+}
+
+static ssize_t mass_storage_inquiry_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct fsg_opts *fsg_opts;
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct mass_storage_function_config *config = f->config;
+
+
+	fsg_opts = fsg_opts_from_func_inst(config->f_ms_inst);
+
+	return fsg_inquiry_store(fsg_opts->common, buf, size);
+}
+
+static DEVICE_ATTR(inquiry_string, S_IRUGO | S_IWUSR,
+					mass_storage_inquiry_show,
+					mass_storage_inquiry_store);
+
+static ssize_t mass_storage_bicr_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct mass_storage_function_config *config = f->config;
+	struct fsg_opts *fsg_opts = fsg_opts_from_func_inst(config->f_ms_inst);
+
+
+	return fsg_bicr_show(fsg_opts->common, buf);
+}
+
+static ssize_t mass_storage_bicr_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct mass_storage_function_config *config = f->config;
+	struct fsg_opts *fsg_opts = fsg_opts_from_func_inst(config->f_ms_inst);
+
+
+	return fsg_bicr_store(fsg_opts->common, buf, size);
+}
+
+static DEVICE_ATTR(bicr, S_IRUGO | S_IWUSR,
+					mass_storage_bicr_show,
+					mass_storage_bicr_store);
+
+
+static struct device_attribute *mass_storage_function_attributes[] = {
+	&dev_attr_inquiry_string,
+	&dev_attr_bicr,
+	NULL
+};
+
+static struct android_usb_function mass_storage_function = {
+	.name		= "mass_storage",
+	.init		= mass_storage_function_init,
+	.cleanup	= mass_storage_function_cleanup,
+	.bind_config	= mass_storage_function_bind_config,
+	.attributes	= mass_storage_function_attributes,
+};
+
+
+static int accessory_function_init(struct android_usb_function *f,
+					struct usb_composite_dev *cdev)
+{
+	return acc_setup();
+}
+
+static void accessory_function_cleanup(struct android_usb_function *f)
+{
+	acc_cleanup();
+}
+
+static int accessory_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	return acc_bind_config(c);
+}
+
+static int accessory_function_ctrlrequest(struct android_usb_function *f,
+						struct usb_composite_dev *cdev,
+						const struct usb_ctrlrequest *c)
+{
+	return acc_ctrlrequest(cdev, c);
+}
+
+static struct android_usb_function accessory_function = {
+	.name		= "accessory",
+	.init		= accessory_function_init,
+	.cleanup	= accessory_function_cleanup,
+	.bind_config	= accessory_function_bind_config,
+	.ctrlrequest	= accessory_function_ctrlrequest,
+};
+
+
+struct audio_source_function_config {
+	struct usb_function *f_aud;
+	struct usb_function_instance *f_aud_inst;
+};
+
+static int audio_source_function_init(struct android_usb_function *f,
+			struct usb_composite_dev *cdev)
+{
+	struct audio_source_function_config *config;
+
+	config = kzalloc(sizeof(*config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+
+	config->f_aud_inst = usb_get_function_instance("audio_source");
+	if (IS_ERR(config->f_aud_inst))
+		return PTR_ERR(config->f_aud_inst);
+
+	config->f_aud = usb_get_function(config->f_aud_inst);
+	if (IS_ERR(config->f_aud)) {
+		usb_put_function_instance(config->f_aud_inst);
+		return PTR_ERR(config->f_aud);
+	}
+
+	f->config = config;
+	return 0;
+}
+
+static void audio_source_function_cleanup(struct android_usb_function *f)
+{
+	struct audio_source_function_config *config = f->config;
+
+
+	usb_put_function(config->f_aud);
+	usb_put_function_instance(config->f_aud_inst);
+
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int audio_source_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct audio_source_function_config *config = f->config;
+
+
+	return usb_add_function(c, config->f_aud);
+}
+
+static struct android_usb_function audio_source_function = {
+	.name		= "audio_source",
+	.init		= audio_source_function_init,
+	.cleanup	= audio_source_function_cleanup,
+	.bind_config	= audio_source_function_bind_config,
+};
+
+
+#ifdef CONFIG_MTK_ECCCI_C2K
+static int rawbulk_function_init(struct android_usb_function *f,
+					struct usb_composite_dev *cdev)
+{
+	return 0;
+}
+
+static void rawbulk_function_cleanup(struct android_usb_function *f)
+{
+	;
+}
+
+static int rawbulk_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	char *i = f->name + strlen("via_");
+
+	if (!strncmp(i, "modem", 5))
+		return rawbulk_bind_config(c, RAWBULK_TID_MODEM);
+	else if (!strncmp(i, "ets", 3))
+		return rawbulk_bind_config(c, RAWBULK_TID_ETS);
+	else if (!strncmp(i, "atc", 3))
+		return rawbulk_bind_config(c, RAWBULK_TID_AT);
+	else if (!strncmp(i, "pcv", 3))
+		return rawbulk_bind_config(c, RAWBULK_TID_PCV);
+	else if (!strncmp(i, "gps", 3))
+		return rawbulk_bind_config(c, RAWBULK_TID_GPS);
+	return -EINVAL;
+}
+
+static int rawbulk_function_modem_ctrlrequest(struct android_usb_function *f,
+						struct usb_composite_dev *cdev,
+						const struct usb_ctrlrequest *c)
+{
+	if ((c->bRequestType & USB_RECIP_MASK) == USB_RECIP_DEVICE &&
+			(c->bRequestType & USB_TYPE_MASK) == USB_TYPE_VENDOR) {
+		struct rawbulk_function *fn = rawbulk_lookup_function(RAWBULK_TID_MODEM);
+
+		return rawbulk_function_setup(&fn->function, c);
+	}
+	return -1;
+}
+
+static struct android_usb_function rawbulk_modem_function = {
+	.name		= "via_modem",
+	.init		= rawbulk_function_init,
+	.cleanup	= rawbulk_function_cleanup,
+	.bind_config	= rawbulk_function_bind_config,
+	.ctrlrequest	= rawbulk_function_modem_ctrlrequest,
+};
+
+static struct android_usb_function rawbulk_ets_function = {
+	.name		= "via_ets",
+	.init		= rawbulk_function_init,
+	.cleanup	= rawbulk_function_cleanup,
+	.bind_config	= rawbulk_function_bind_config,
+};
+
+static struct android_usb_function rawbulk_atc_function = {
+	.name		= "via_atc",
+	.init		= rawbulk_function_init,
+	.cleanup	= rawbulk_function_cleanup,
+	.bind_config	= rawbulk_function_bind_config,
+};
+
+static struct android_usb_function rawbulk_pcv_function = {
+	.name		= "via_pcv",
+	.init		= rawbulk_function_init,
+	.cleanup	= rawbulk_function_cleanup,
+	.bind_config	= rawbulk_function_bind_config,
+};
+
+static struct android_usb_function rawbulk_gps_function = {
+	.name		= "via_gps",
+	.init		= rawbulk_function_init,
+	.cleanup	= rawbulk_function_cleanup,
+	.bind_config	= rawbulk_function_bind_config,
+};
+#endif
+
+#ifdef CONFIG_SND_RAWMIDI
+static int midi_function_init(struct android_usb_function *f,
+					struct usb_composite_dev *cdev)
+{
+	struct midi_alsa_config *config;
+
+	config = kzalloc(sizeof(struct midi_alsa_config), GFP_KERNEL);
+	f->config = config;
+	if (!config)
+		return -ENOMEM;
+	config->card = -1;
+	config->device = -1;
+	return 0;
+}
+
+static void midi_function_cleanup(struct android_usb_function *f)
+{
+	kfree(f->config);
+}
+
+static int midi_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct midi_alsa_config *config = f->config;
+
+	return f_midi_bind_config(c, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
+			MIDI_INPUT_PORTS, MIDI_OUTPUT_PORTS, MIDI_BUFFER_SIZE,
+			MIDI_QUEUE_LENGTH, config);
+}
+
+static ssize_t midi_alsa_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct midi_alsa_config *config = f->config;
+
+	/* print ALSA card and device numbers */
+	return sprintf(buf, "%d %d\n", config->card, config->device);
+}
+
+static DEVICE_ATTR(alsa, S_IRUGO, midi_alsa_show, NULL);
+
+static struct device_attribute *midi_function_attributes[] = {
+	&dev_attr_alsa,
+	NULL
+};
+
+static struct android_usb_function midi_function = {
+	.name		= "midi",
+	.init		= midi_function_init,
+	.cleanup	= midi_function_cleanup,
+	.bind_config	= midi_function_bind_config,
+	.attributes	= midi_function_attributes,
+};
+#endif
+
+static struct android_usb_function *supported_functions[] = {
+	&ffs_function,
+	&mbim_function,
+	&acm_function,
+	&mtp_function,
+	&ptp_function,
+	&eem_function,
+	&serial_function,
+	&rndis_function,
+	&mass_storage_function,
+	&accessory_function,
+	&audio_source_function,
+#ifdef CONFIG_SND_RAWMIDI
+	&midi_function,
+#endif
+#ifdef CONFIG_MTK_ECCCI_C2K
+	&rawbulk_modem_function,
+	&rawbulk_ets_function,
+	&rawbulk_atc_function,
+	&rawbulk_pcv_function,
+	&rawbulk_gps_function,
+#endif
+#ifdef CONFIG_USB_F_SS_LB
+	&loopback_function,
+#endif
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	&hid_function,
+#endif
+	NULL
+};
+
+struct device *create_function_device(char *name)
+{
+	struct android_dev *dev = _android_dev;
+	struct android_usb_function **functions;
+	struct android_usb_function *f;
+
+	functions = dev->functions;
+
+
+	while ((f = *functions++))
+		if (!strcmp(name, f->dev_name))
+			return f->dev;
+
+	return ERR_PTR(-EINVAL);
+}
+
+static int android_init_functions(struct android_usb_function **functions,
+				  struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+	struct android_usb_function *f;
+	struct device_attribute **attrs;
+	struct device_attribute *attr;
+	int err;
+#ifdef CONFIG_USBIF_COMPLIANCE
+	int index = 1;
+#else
+	int index = 0;
+#endif
+
+	for (; (f = *functions++); index++) {
+		f->dev_name = kasprintf(GFP_KERNEL, "f_%s", f->name);
+		pr_notice("[USB]%s: f->dev_name = %s, f->name = %s\n", __func__, f->dev_name, f->name);
+		f->dev = device_create(android_class, dev->dev,
+				MKDEV(0, index), f, f->dev_name);
+		if (IS_ERR(f->dev)) {
+			pr_err("%s: Failed to create dev %s", __func__,
+							f->dev_name);
+			err = PTR_ERR(f->dev);
+			goto err_create;
+		}
+
+		if (f->init) {
+			err = f->init(f, cdev);
+			if (err) {
+				pr_err("%s: Failed to init %s", __func__,
+								f->name);
+				goto err_out;
+			} else
+				pr_notice("[USB]%s: init %s success!!\n", __func__, f->name);
+		}
+
+		attrs = f->attributes;
+		if (attrs) {
+			while ((attr = *attrs++) && !err)
+				err = device_create_file(f->dev, attr);
+		}
+		if (err) {
+			pr_err("%s: Failed to create function %s attributes",
+					__func__, f->name);
+			goto err_out;
+		}
+	}
+	return 0;
+
+err_out:
+	device_destroy(android_class, f->dev->devt);
+err_create:
+	kfree(f->dev_name);
+	return err;
+}
+
+static void android_cleanup_functions(struct android_usb_function **functions)
+{
+	struct android_usb_function *f;
+
+
+	while (*functions) {
+		f = *functions++;
+
+		if (f->dev) {
+			device_destroy(android_class, f->dev->devt);
+			kfree(f->dev_name);
+		}
+
+		if (f->cleanup)
+			f->cleanup(f);
+	}
+}
+
+static int
+android_bind_enabled_functions(struct android_dev *dev,
+			       struct usb_configuration *c)
+{
+	struct android_usb_function *f;
+	int ret;
+
+
+	list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+		pr_notice("[USB]bind_config function '%s'/%p\n", f->name, f);
+		ret = f->bind_config(f, c);
+		if (ret) {
+			pr_err("%s: %s failed", __func__, f->name);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static void
+android_unbind_enabled_functions(struct android_dev *dev,
+			       struct usb_configuration *c)
+{
+	struct android_usb_function *f;
+
+
+	list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+		if (f->unbind_config)
+			f->unbind_config(f, c);
+	}
+}
+
+static int android_enable_function(struct android_dev *dev, char *name)
+{
+	struct android_usb_function **functions = dev->functions;
+	struct android_usb_function *f;
+
+
+	while ((f = *functions++)) {
+		if (!strcmp(name, f->name)) {
+			list_add_tail(&f->enabled_list,
+						&dev->enabled_functions);
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/*-------------------------------------------------------------------------*/
+/* /sys/class/android_usb/android%d/ interface */
+
+static ssize_t
+functions_show(struct device *pdev, struct device_attribute *attr, char *buf)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+	struct android_usb_function *f;
+	char *buff = buf;
+
+	pr_notice("[USB]%s: ", __func__);
+	mutex_lock(&dev->mutex);
+
+	list_for_each_entry(f, &dev->enabled_functions, enabled_list)
+		buff += sprintf(buff, "%s,", f->name);
+
+	mutex_unlock(&dev->mutex);
+
+	if (buff != buf)
+		*(buff-1) = '\n';
+	return buff - buf;
+}
+
+static ssize_t
+functions_store(struct device *pdev, struct device_attribute *attr,
+			       const char *buff, size_t size)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+
+	char *name;
+	char buf[256], *b;
+	char aliases[256], *a;
+	int err;
+	int is_ffs;
+	int ffs_enabled = 0;
+
+	mutex_lock(&dev->mutex);
+
+	if (dev->enabled) {
+		mutex_unlock(&dev->mutex);
+		return -EBUSY;
+	}
+
+	INIT_LIST_HEAD(&dev->enabled_functions);
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	if (get_boot_mode() == KERNEL_POWER_OFF_CHARGING_BOOT || get_boot_mode() == LOW_POWER_OFF_CHARGING_BOOT) {
+		pr_notice("[USB]KPOC, func%s\n", KPOC_USB_FUNC);
+		err = android_enable_function(dev, KPOC_USB_FUNC);
+		if (err)
+			pr_err("android_usb: Cannot enable '%s' (%d)",
+					KPOC_USB_FUNC, err);
+		mutex_unlock(&dev->mutex);
+		return size;
+	}
+#endif
+
+	strlcpy(buf, buff, sizeof(buf));
+	b = strim(buf);
+
+	while (b) {
+		name = strsep(&b, ",");
+		pr_notice("[USB]%s: name = %s\n", __func__, name);
+		if (!name)
+			continue;
+
+		is_ffs = 0;
+		strlcpy(aliases, dev->ffs_aliases, sizeof(aliases));
+		a = aliases;
+
+		while (a) {
+			char *alias = strsep(&a, ",");
+
+			if (alias && !strcmp(name, alias)) {
+				is_ffs = 1;
+				break;
+			}
+		}
+
+		if (is_ffs) {
+			if (ffs_enabled)
+				continue;
+			err = android_enable_function(dev, "ffs");
+			if (err)
+				pr_err("android_usb: Cannot enable ffs (%d)",
+									err);
+			else
+				ffs_enabled = 1;
+			continue;
+		}
+
+		err = android_enable_function(dev, name);
+		if (err)
+			pr_err("android_usb: Cannot enable '%s' (%d)",
+							   name, err);
+	}
+
+	mutex_unlock(&dev->mutex);
+
+	return size;
+}
+
+static ssize_t enable_show(struct device *pdev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+
+
+	return sprintf(buf, "%d\n", dev->enabled);
+}
+
+static ssize_t enable_store(struct device *pdev, struct device_attribute *attr,
+			    const char *buff, size_t size)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct android_usb_function *f;
+	int enabled = 0;
+	int ret;
+
+	if (!cdev)
+		return -ENODEV;
+
+
+	mutex_lock(&dev->mutex);
+
+	pr_notice("[USB]%s: device_attr->attr.name: %s\n", __func__, attr->attr.name);
+
+	ret = kstrtoint(buff, 0, &enabled);
+
+	if (enabled && !dev->enabled) {
+		/* ALPS01770952
+		 * Reset next_string_id to 0 before enabling the gadget driver.
+		 * Otherwise, after a large number of enable/disable cycles,
+		 * function bind will fail because we cannot allocate new string ids.
+		 * String ids cannot be larger than 254 per USB spec.
+		 * 0~15 are reserved for usb device descriptor
+		 * 16~254 are for functions.
+		 */
+		cdev->next_string_id = 0x10;
+
+		/*
+		 * Update values in composite driver's copy of
+		 * device descriptor.
+		 */
+		cdev->desc.idVendor = device_desc.idVendor;
+		cdev->desc.idProduct = device_desc.idProduct;
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+		if (get_boot_mode() == KERNEL_POWER_OFF_CHARGING_BOOT
+				|| get_boot_mode() == LOW_POWER_OFF_CHARGING_BOOT) {
+			pr_notice("[USB]KPOC, vid:%d, pid:%d\n", KPOC_USB_VENDOR_ID, KPOC_USB_PRODUCT_ID);
+			cdev->desc.idVendor = cpu_to_le16(KPOC_USB_VENDOR_ID);
+			cdev->desc.idProduct = cpu_to_le16(KPOC_USB_PRODUCT_ID);
+		}
+#endif
+		cdev->desc.bcdDevice = device_desc.bcdDevice;
+		cdev->desc.bDeviceClass = device_desc.bDeviceClass;
+		cdev->desc.bDeviceSubClass = device_desc.bDeviceSubClass;
+		cdev->desc.bDeviceProtocol = device_desc.bDeviceProtocol;
+
+		/* special case for meta mode */
+		if (serial_string[0] == 0x20)
+			cdev->desc.iSerialNumber = 0;
+		else
+			cdev->desc.iSerialNumber = device_desc.iSerialNumber;
+
+		list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+			if (f->enable)
+				f->enable(f);
+		}
+		android_enable(dev);
+		dev->enabled = true;
+		pr_notice("[USB]%s: enable 0->1 case, device_desc.idVendor = 0x%x, device_desc.idProduct = 0x%x\n",
+				__func__, device_desc.idVendor, device_desc.idProduct);
+#ifdef CONFIG_MTPROF
+		{
+			static int first_shot = 1;
+
+			if (first_shot) {
+				log_boot("USB ready");
+				first_shot = 0;
+			}
+		}
+#endif
+	} else if (!enabled && dev->enabled) {
+		pr_notice("[USB]%s: enable 1->0 case, device_desc.idVendor = 0x%x, device_desc.idProduct = 0x%x\n",
+				__func__, device_desc.idVendor, device_desc.idProduct);
+		android_disable(dev);
+		list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+			pr_notice("[USB]disable function '%s'/%p\n", f->name, f);
+			if (f->disable)
+				f->disable(f);
+		}
+		dev->enabled = false;
+	} else {
+		pr_err("android_usb: already %s\n",
+				dev->enabled ? "enabled" : "disabled");
+	}
+
+	mutex_unlock(&dev->mutex);
+	return size;
+}
+
+static ssize_t state_show(struct device *pdev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+	struct usb_composite_dev *cdev = dev->cdev;
+	char *state = "DISCONNECTED";
+	unsigned long flags;
+
+	if (!cdev)
+		goto out;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (cdev->config)
+		state = "CONFIGURED";
+	else if (dev->connected)
+		state = "CONNECTED";
+	pr_warn("[USB]%s, state:%s\n", __func__, state);
+	spin_unlock_irqrestore(&cdev->lock, flags);
+out:
+	return sprintf(buf, "%s\n", state);
+}
+
+#define LOG_BUG_SZ 2048
+static char log_buf[LOG_BUG_SZ];
+static int log_buf_idx;
+static ssize_t
+log_show(struct device *pdev, struct device_attribute *attr, char *buf)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+
+	mutex_lock(&dev->mutex);
+
+	memcpy(buf, log_buf, log_buf_idx);
+
+	mutex_unlock(&dev->mutex);
+	return log_buf_idx;
+}
+
+static ssize_t
+log_store(struct device *pdev, struct device_attribute *attr,
+			       const char *buff, size_t size)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+	char buf[256], n;
+
+	mutex_lock(&dev->mutex);
+
+	n = strlcpy(buf, buff, sizeof(buf));
+
+	if ((log_buf_idx + (n + 1)) > LOG_BUG_SZ)
+		log_buf_idx = 0;
+
+	memcpy(log_buf + log_buf_idx, buf, n);
+	log_buf_idx += n;
+	log_buf[log_buf_idx++] = ' ';
+	pr_warn("[USB]%s, <%s>, n:%d, log_buf_idx:%d\n", __func__, buf, n, log_buf_idx);
+
+	mutex_unlock(&dev->mutex);
+	return size;
+}
+
+#define DESCRIPTOR_ATTR(field, format_string)				\
+static ssize_t								\
+field ## _show(struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
+{									\
+	return sprintf(buf, format_string, device_desc.field);		\
+}									\
+static ssize_t								\
+field ## _store(struct device *dev, struct device_attribute *attr,	\
+		const char *buf, size_t size)				\
+{									\
+	int value;							\
+	if (sscanf(buf, format_string, &value) == 1) {			\
+		device_desc.field = value;				\
+		return size;						\
+	}								\
+	return -1;							\
+}									\
+static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store)
+
+#define DESCRIPTOR_STRING_ATTR(field, buffer)				\
+static ssize_t								\
+field ## _show(struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
+{									\
+	return sprintf(buf, "%s", buffer);				\
+}									\
+static ssize_t								\
+field ## _store(struct device *dev, struct device_attribute *attr,	\
+		const char *buf, size_t size)				\
+{									\
+	if (size >= sizeof(buffer))					\
+		return -EINVAL;						\
+	return strlcpy(buffer, buf, sizeof(buffer));			\
+}									\
+static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store)
+
+
+DESCRIPTOR_ATTR(idVendor, "%04x\n");
+DESCRIPTOR_ATTR(idProduct, "%04x\n");
+DESCRIPTOR_ATTR(bcdDevice, "%04x\n");
+DESCRIPTOR_ATTR(bDeviceClass, "%d\n");
+DESCRIPTOR_ATTR(bDeviceSubClass, "%d\n");
+DESCRIPTOR_ATTR(bDeviceProtocol, "%d\n");
+DESCRIPTOR_STRING_ATTR(iManufacturer, manufacturer_string);
+DESCRIPTOR_STRING_ATTR(iProduct, product_string);
+DESCRIPTOR_STRING_ATTR(iSerial, serial_string);
+
+static DEVICE_ATTR(functions, S_IRUGO | S_IWUSR, functions_show,
+						 functions_store);
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, enable_show, enable_store);
+static DEVICE_ATTR(state, S_IRUGO, state_show, NULL);
+static DEVICE_ATTR(log, S_IRUGO | S_IWUSR, log_show,
+						 log_store);
+
+static struct device_attribute *android_usb_attributes[] = {
+	&dev_attr_idVendor,
+	&dev_attr_idProduct,
+	&dev_attr_bcdDevice,
+	&dev_attr_bDeviceClass,
+	&dev_attr_bDeviceSubClass,
+	&dev_attr_bDeviceProtocol,
+	&dev_attr_iManufacturer,
+	&dev_attr_iProduct,
+	&dev_attr_iSerial,
+	&dev_attr_functions,
+	&dev_attr_enable,
+	&dev_attr_state,
+	&dev_attr_log,
+	NULL
+};
+
+/*-------------------------------------------------------------------------*/
+/* Composite driver */
+
+static int android_bind_config(struct usb_configuration *c)
+{
+	struct android_dev *dev = _android_dev;
+	int ret = 0;
+
+	ret = android_bind_enabled_functions(dev, c);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void android_unbind_config(struct usb_configuration *c)
+{
+	struct android_dev *dev = _android_dev;
+
+
+	android_unbind_enabled_functions(dev, c);
+}
+
+static int android_setup_config(struct usb_configuration *c, const struct usb_ctrlrequest *ctrl)
+{
+	int handled = -EINVAL;
+	const u8 recip = ctrl->bRequestType & USB_RECIP_MASK;
+
+
+	pr_notice("%s bRequestType=%x, bRequest=%x, recip=%x\n", __func__, ctrl->bRequestType, ctrl->bRequest, recip);
+
+	if (!((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD))
+		return handled;
+
+	switch (ctrl->bRequest) {
+
+	case USB_REQ_CLEAR_FEATURE:
+		switch (recip) {
+		case USB_RECIP_DEVICE:
+			switch (ctrl->wValue) {
+			case USB_DEVICE_U1_ENABLE:
+				handled = 1;
+				pr_notice("Clear Feature->U1 Enable\n");
+				break;
+
+			case USB_DEVICE_U2_ENABLE:
+				handled = 1;
+				pr_notice("Clear Feature->U2 Enable\n");
+				break;
+
+			default:
+				handled = -EINVAL;
+				break;
+			}
+			break;
+		default:
+			handled = -EINVAL;
+			break;
+		}
+		break;
+
+	case USB_REQ_SET_FEATURE:
+		switch (recip) {
+		case USB_RECIP_DEVICE:
+			switch (ctrl->wValue) {
+			case USB_DEVICE_U1_ENABLE:
+				pr_notice("Set Feature->U1 Enable\n");
+				handled = 1;
+				break;
+			case USB_DEVICE_U2_ENABLE:
+				pr_notice("Set Feature->U2 Enable\n");
+				handled = 1;
+				break;
+			default:
+				handled = -EINVAL;
+				break;
+			}
+			break;
+
+		default:
+			handled = -EINVAL;
+			break;
+		}
+		break;
+
+	default:
+		handled = -EINVAL;
+		break;
+	}
+
+	return handled;
+}
+
+static int android_bind(struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+	struct usb_gadget	*gadget = cdev->gadget;
+	int			id, ret;
+
+	/* Save the default handler */
+	dev->setup_complete = cdev->req->complete;
+
+	/*
+	 * Start disconnected. Userspace will connect the gadget once
+	 * it is done configuring the functions.
+	 */
+	usb_gadget_disconnect(gadget);
+
+	ret = android_init_functions(dev->functions, cdev);
+	if (ret)
+		return ret;
+
+	/* Allocate string descriptor numbers ... note that string
+	 * contents can be overridden by the composite_dev glue.
+	 */
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_MANUFACTURER_IDX].id = id;
+	device_desc.iManufacturer = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_PRODUCT_IDX].id = id;
+	device_desc.iProduct = id;
+
+	/* Default strings - should be updated by userspace */
+	strncpy(manufacturer_string, "TCL", sizeof(manufacturer_string)-1);
+	strncpy(product_string, "980CN1", sizeof(product_string) - 1);
+	strncpy(serial_string, "0123456789ABCDEF", sizeof(serial_string) - 1);
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_SERIAL_IDX].id = id;
+	device_desc.iSerialNumber = id;
+
+#ifdef CONFIG_USBIF_COMPLIANCE
+	usb_gadget_clear_selfpowered(gadget);
+#else
+	usb_gadget_set_selfpowered(gadget);
+#endif
+	dev->cdev = cdev;
+
+	return 0;
+}
+
+static int android_usb_unbind(struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+
+
+	cancel_work_sync(&dev->work);
+	android_cleanup_functions(dev->functions);
+	return 0;
+}
+
+/* HACK: android needs to override setup for accessory to work */
+static int (*composite_setup_func)(struct usb_gadget *gadget, const struct usb_ctrlrequest *c);
+
+static int
+android_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *c)
+{
+	struct android_dev		*dev = _android_dev;
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	struct usb_request		*req = cdev->req;
+	struct android_usb_function	*f;
+	int value = -EOPNOTSUPP;
+	unsigned long flags;
+
+
+	req->zero = 0;
+	req->length = 0;
+	/* req->complete = dev->setup_complete; */
+	req->complete = composite_setup_complete;
+	gadget->ep0->driver_data = cdev;
+
+	list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+		if (f->ctrlrequest) {
+			value = f->ctrlrequest(f, cdev, c);
+			if (value >= 0)
+				break;
+		}
+	}
+
+	/* Special case the accessory function.
+	 * It needs to handle control requests before it is enabled.
+	 */
+
+	if (value < 0)
+		value = acc_ctrlrequest(cdev, c);
+
+	if (value < 0)
+		value = composite_setup_func(gadget, c);
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (!dev->connected) {
+		dev->connected = 1;
+		schedule_work(&dev->work);
+	} else if (c->bRequest == USB_REQ_SET_CONFIGURATION &&
+						cdev->config) {
+		schedule_work(&dev->work);
+	}
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	return value;
+}
+
+static void android_disconnect(struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+
+	/* accessory HID support can be active while the
+	 * accessory function is not actually enabled,
+	 * so we need to inform it when we are disconnected.
+	 */
+
+	acc_disconnect();
+
+	dev->connected = 0;
+	schedule_work(&dev->work);
+	pr_notice("[USB]%s: dev->connected = %d\n", __func__, dev->connected);
+}
+
+static struct usb_composite_driver android_usb_driver = {
+	.name		= "android_usb",
+	.dev		= &device_desc,
+	.strings	= dev_strings,
+	.bind		= android_bind,
+	.unbind		= android_usb_unbind,
+	.disconnect	= android_disconnect,
+#ifdef CONFIG_USB_MU3D_DRV
+	.max_speed	= USB_SPEED_SUPER
+#else
+	.max_speed	= USB_SPEED_HIGH
+#endif
+};
+
+#define USB_STATE_MONITOR_DELAY 3000
+static struct delayed_work android_usb_state_monitor_work;
+static void do_android_usb_state_monitor_work(struct work_struct *work)
+{
+	struct android_dev *dev = _android_dev;
+	char *usb_state = "NO-DEV";
+
+	if (dev && dev->cdev)
+		usb_state = "DISCONNECTED";
+
+	if (dev && dev->cdev && dev->cdev->config)
+		usb_state = "CONFIGURED";
+
+	pr_warn("usb_state<%s>\n", usb_state);
+	schedule_delayed_work(&android_usb_state_monitor_work, msecs_to_jiffies(USB_STATE_MONITOR_DELAY));
+}
+void trigger_android_usb_state_monitor_work(void)
+{
+	static int inited;
+
+	if (!inited) {
+		/* TIMER_DEFERRABLE for not interfering with deep idle */
+		INIT_DEFERRABLE_WORK(&android_usb_state_monitor_work, do_android_usb_state_monitor_work);
+		inited = 1;
+	}
+	schedule_delayed_work(&android_usb_state_monitor_work, msecs_to_jiffies(USB_STATE_MONITOR_DELAY));
+
+};
+
+static int android_create_device(struct android_dev *dev)
+{
+	struct device_attribute **attrs = android_usb_attributes;
+	struct device_attribute *attr;
+	int err;
+
+
+	dev->dev = device_create(android_class, NULL,
+					MKDEV(0, 0), NULL, "android0");
+	if (IS_ERR(dev->dev))
+		return PTR_ERR(dev->dev);
+
+	dev_set_drvdata(dev->dev, dev);
+
+	while ((attr = *attrs++)) {
+		err = device_create_file(dev->dev, attr);
+		if (err) {
+			device_destroy(android_class, dev->dev->devt);
+			return err;
+		}
+	}
+#ifdef CONFIG_MTK_USB2JTAG_SUPPORT
+	if (usb2jtag_mode())
+		pr_err("[USB2JTAG] in usb2jtag mode, not to initialize usb driver\n");
+	else
+		trigger_android_usb_state_monitor_work();
+#else
+		trigger_android_usb_state_monitor_work();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_USBIF_COMPLIANCE
+
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+#include <linux/seq_file.h>
+
+
+static int andoid_usbif_driver_on;
+
+static int android_start(void)
+{
+	int err;
+
+	pr_notice("android_start ===>\n");
+
+	err = usb_composite_probe(&android_usb_driver);
+	if (err)
+		pr_err("%s: failed to probe driver %d", __func__, err);
+
+	/* HACK: exchange composite's setup with ours */
+	composite_setup_func = android_usb_driver.gadget_driver.setup;
+	android_usb_driver.gadget_driver.setup = android_setup;
+
+	pr_notice("android_start <===\n");
+
+	return err;
+}
+
+static int android_stop(void)
+{
+	pr_notice("android_stop ===>\n");
+
+	usb_composite_unregister(&android_usb_driver);
+
+	pr_notice("android_stop <===\n");
+	return 0;
+}
+
+static int andoid_usbif_proc_show(struct seq_file *seq, void *v)
+{
+	seq_printf(seq, "andoid_usbif_proc_show, andoid_usbif_driver_on is %d (on:1, off:0)\n", andoid_usbif_driver_on);
+	return 0;
+}
+
+static int andoid_usbif_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, andoid_usbif_proc_show, inode->i_private);
+}
+
+static ssize_t andoid_usbif_proc_write(struct file *file, const char __user *buf, size_t length, loff_t *ppos)
+{
+	char msg[32];
+
+	if (length >= sizeof(msg)) {
+		pr_notice("andoid_usbif_proc_write length error, the error len is %d\n", (unsigned int)length);
+		return -EINVAL;
+	}
+	if (copy_from_user(msg, buf, length))
+		return -EFAULT;
+
+	msg[length] = 0;
+
+	pr_notice("andoid_usbif_proc_write: %s, current driver on/off: %d\n", msg, andoid_usbif_driver_on);
+
+	if ((msg[0] == '1') && (andoid_usbif_driver_on == 0)) {
+		pr_notice("start usb android driver ===>\n");
+		pr_warn("start usb android driver ===>\n");
+		android_start();
+		andoid_usbif_driver_on = 1;
+		pr_notice("start usb android driver <===\n");
+	} else if ((msg[0] == '0') && (andoid_usbif_driver_on == 1)) {
+		pr_notice("stop usb android driver ===>\n");
+		pr_warn("stop usb android driver ===>\n");
+		andoid_usbif_driver_on = 0;
+		android_stop();
+
+		pr_notice("stop usb android driver <===\n");
+	}
+
+	return length;
+}
+
+static const struct file_operations andoid_usbif_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = andoid_usbif_proc_open,
+	.write = andoid_usbif_proc_write,
+	.read = seq_read,
+	.llseek = seq_lseek,
+
+};
+
+static int __init init(void)
+{
+	struct android_dev *dev;
+	int err;
+	struct proc_dir_entry *prEntry;
+
+
+
+	android_class = class_create(THIS_MODULE, "android_usb");
+	if (IS_ERR(android_class))
+		return PTR_ERR(android_class);
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		err = -ENOMEM;
+		goto err_dev;
+	}
+
+	dev->disable_depth = 1;
+	dev->functions = supported_functions;
+	INIT_LIST_HEAD(&dev->enabled_functions);
+	INIT_WORK(&dev->work, android_work);
+	mutex_init(&dev->mutex);
+
+	err = android_create_device(dev);
+	if (err) {
+		pr_err("%s: failed to create android device %d", __func__, err);
+		goto err_create;
+	}
+
+	_android_dev = dev;
+
+	prEntry = proc_create("android_usbif_init", 0644, NULL, &andoid_usbif_proc_fops);
+
+	if (prEntry)
+		pr_warn("create the android_usbif_init proc OK!\n");
+	else
+		pr_warn("[ERROR] create the android_usbif_init proc FAIL\n");
+
+	/* set android up at boot up */
+	android_start();
+	andoid_usbif_driver_on = 1;
+
+	return 0;
+
+err_create:
+	kfree(dev);
+err_dev:
+	class_destroy(android_class);
+	return err;
+}
+
+late_initcall(init);
+
+
+static void __exit cleanup(void)
+{
+	pr_warn("[U3D] android cleanup ===>\n");
+	class_destroy(android_class);
+	kfree(_android_dev);
+	_android_dev = NULL;
+	pr_warn("[U3D] android cleanup <===\n");
+}
+module_exit(cleanup);
+
+#else
+static int __init init(void)
+{
+	struct android_dev *dev;
+	int err;
+
+	android_class = class_create(THIS_MODULE, "android_usb");
+	if (IS_ERR(android_class))
+		return PTR_ERR(android_class);
+
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		err = -ENOMEM;
+		goto err_dev;
+	}
+
+	dev->disable_depth = 1;
+	dev->functions = supported_functions;
+	INIT_LIST_HEAD(&dev->enabled_functions);
+	INIT_WORK(&dev->work, android_work);
+	mutex_init(&dev->mutex);
+
+	err = android_create_device(dev);
+	if (err) {
+		pr_err("%s: failed to create android device %d", __func__, err);
+		goto err_create;
+	}
+
+	_android_dev = dev;
+
+	err = usb_composite_probe(&android_usb_driver);
+	if (err) {
+		pr_err("%s: failed to probe driver %d", __func__, err);
+		_android_dev = NULL;
+		goto err_probe;
+	}
+
+	/* HACK: exchange composite's setup with ours */
+	composite_setup_func = android_usb_driver.gadget_driver.setup;
+	android_usb_driver.gadget_driver.setup = android_setup;
+
+	return 0;
+
+err_probe:
+	device_destroy(android_class, dev->dev->devt);
+err_create:
+	kfree(dev);
+err_dev:
+	class_destroy(android_class);
+	return err;
+}
+late_initcall(init);
+
+static void __exit cleanup(void)
+{
+	usb_composite_unregister(&android_usb_driver);
+	class_destroy(android_class);
+	kfree(_android_dev);
+	_android_dev = NULL;
+}
+module_exit(cleanup);
+#endif
