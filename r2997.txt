Index: device/cdfinger/cdfinger_product_64bit.mk
===================================================================
--- device/cdfinger/cdfinger_product_64bit.mk	(revision 2996)
+++ device/cdfinger/cdfinger_product_64bit.mk	(revision 2997)
@@ -3,7 +3,7 @@
 PRODUCT_COPY_FILES += $(LOCAL_PATH)/init.cdfinger.rc:root/init.cdfinger.rc
 
 # Default value is fingerprint, otherwise cdfinger.fingerprint
-FINGERPRINT_HARDWARE_MODULE_ID = fingerprint
+FINGERPRINT_HARDWARE_MODULE_ID = cdfinger.fingerprint
 ifeq ($(FINGERPRINT_HARDWARE_MODULE_ID),cdfinger.fingerprint)
     PRODUCT_COPY_FILES += $(LOCAL_PATH)/arm64-v8a/cdfinger.fingerprint.default.so:system/lib64/hw/cdfinger.fingerprint.default.so
 else
Index: device/mediatek/common/sepolicy/bsp/file_contexts
===================================================================
--- device/mediatek/common/sepolicy/bsp/file_contexts	(revision 2996)
+++ device/mediatek/common/sepolicy/bsp/file_contexts	(revision 2997)
@@ -80,3 +80,25 @@
 /(system\/vendor|vendor)/bin/guiext-server u:object_r:guiext-server_exec:s0
 
 /(system\/vendor|vendor)/app/mcRegistry(/.*)? u:object_r:mobicore_data_file:s0
+
+#microtrust_ifaa start
+/(system\/vendor|system)/bin/ifaad u:object_r:ifaad_exec:s0
+#microtrust_ifaa end
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
Index: device/mediatek/common/sepolicy/bsp/service_contexts
===================================================================
--- device/mediatek/common/sepolicy/bsp/service_contexts	(revision 2996)
+++ device/mediatek/common/sepolicy/bsp/service_contexts	(revision 2997)
@@ -20,3 +20,7 @@
 DmAgent             u:object_r:dm_agent_binder_service:s0
 AAL                 u:object_r:aal_service:s0
 FpsPolicyService    u:object_r:fpspolicy-server_service:s0
+
+#microtrust_ifaa begin
+android.hardware.ifaa.IIfaaDaemon             u:object_r:ifaad_service:s0
+#microtrust_ifaa end
Index: device/mediatek/common/sepolicy/bsp/ifaad.te
===================================================================
--- device/mediatek/common/sepolicy/bsp/ifaad.te	(revision 0)
+++ device/mediatek/common/sepolicy/bsp/ifaad.te	(revision 2997)
@@ -0,0 +1,51 @@
+# ==============================================
+# MTK Policy Rule
+# ============
+
+# Date : 2016/06/01
+# Operation: TEEI integration
+# Purpose: Microtrust ifaad service
+type ifaad, domain;
+type ifaad_exec, exec_type, file_type;
+type ifaad_service,service_manager_type;
+
+allow ifaad self:capability sys_module;
+allow ifaad teei_client_device:chr_file create_file_perms;
+#allow ifaad teei_data_file:dir create_dir_perms;
+#allow ifaad teei_data_file:file rw_file_perms;
+#allow ifaad teei_data_file:file create_file_perms;
+allow ifaad self:capability dac_override;
+allow ifaad device:dir rw_dir_perms;
+allow ifaad cache_file:file rw_file_perms;
+
+#enable access android property
+allow ifaad property_socket:sock_file {read write};
+allow ifaad init:unix_stream_socket {connectto};
+allow ifaad soter_teei_prop:property_service {set};
+
+#set up domain
+init_daemon_domain(ifaad)
+
+#for debug only
+allow ifaad kmsg_device:chr_file {open write};
+
+#define for mlsconstrain
+#typeattribute teei_client_device mlstrustedobject;
+
+allow ifaad servicemanager:binder call;
+allow ifaad servicemanager:binder transfer;
+allow servicemanager ifaad:binder set_context_mgr;
+
+allow servicemanager ifaad:dir search;
+allow ifaad servicemanager:dir search;
+allow servicemanager ifaad:file read;
+allow ifaad servicemanager:file read;
+allow servicemanager ifaad:file open;
+allow ifaad servicemanager:file open;;
+allow servicemanager ifaad:process getattr;
+allow ifaad servicemanager:process getattr;
+
+allow ifaad ifaad_service:service_manager add;
+allow ifaad ifaad_service:service_manager find;
+allow untrusted_app ifaad_service:service_manager find;
+allow untrusted_app ifaad:binder call;

Property changes on: device/mediatek/common/sepolicy/bsp/ifaad.te
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/mediatek/common/sepolicy/bsp/init_thh.te
===================================================================
--- device/mediatek/common/sepolicy/bsp/init_thh.te	(revision 2996)
+++ device/mediatek/common/sepolicy/bsp/init_thh.te	(revision 2997)
@@ -30,3 +30,6 @@
 #for debug only
 #write_klog(init_thh_service)
 
+#microtrust_ifaa begin
+allow ifaad       self:capability sys_module;
+#microtrust_ifaa end
Index: device/mediatek/common/device.mk
===================================================================
--- device/mediatek/common/device.mk	(revision 2996)
+++ device/mediatek/common/device.mk	(revision 2997)
@@ -3213,6 +3213,14 @@
 )
 endif
 
+ifeq ($(strip $(MICROTRUST_IFAA_SUPPORT)), yes)
+  PRODUCT_PACKAGES += libmtee
+  PRODUCT_PACKAGES += libteeclientjni
+  PRODUCT_PACKAGES += libifaa_daemon
+  PRODUCT_PACKAGES += ifaad
+  PRODUCT_PACKAGES += libifaa_jni
+endif
+
 ifeq ($(strip $(MTK_FULLSCREEN_SWITCH_SUPPORT)), yes)
   PRODUCT_PROPERTY_OVERRIDES += ro.mtk_fullscreen_switch=1
   PRODUCT_PACKAGES += FullscreenSwitchService
Index: device/mediatek/common
===================================================================
--- device/mediatek/common	(revision 2996)
+++ device/mediatek/common	(revision 2997)

Property changes on: device/mediatek/common
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /L05A/Trunk/ALPS-MP-N1.MP18-V1_AUS6739_66_N1_INHOUSE/device/mediatek/common:r2850-2851
Index: device/mediatek/mt6739/init.microtrust.rc
===================================================================
--- device/mediatek/mt6739/init.microtrust.rc	(revision 2996)
+++ device/mediatek/mt6739/init.microtrust.rc	(revision 2997)
@@ -98,11 +98,21 @@
    # oneshot
 
 on property:soter.teei.init=INIT_OK
-#    start init_thh_service
+    start init_thh_service
 
-#service init_thh_service /vendor/bin/init_thh init
-#    class core
-#    user system
-#    group system
-#    disabled
-#    oneshot
+service init_thh_service /vendor/bin/init_thh startload init
+    class core
+    user system
+    group system
+    disabled
+    oneshot
+	
+on property:soter.teei.init=INIT_OK
+    start ifaad
+
+# ifaa daemon
+service ifaad /system/vendor/bin/ifaad
+    class core
+    user system
+    group system
+    disabled
Index: device/mediatek/mt6739/device.mk
===================================================================
--- device/mediatek/mt6739/device.mk	(revision 2996)
+++ device/mediatek/mt6739/device.mk	(revision 2997)
@@ -1390,7 +1390,12 @@
 PRODUCT_COPY_FILES += 	device/mediatek/mt6739/init.microtrust.rc:root/init.microtrust.rc
 PRODUCT_COPY_FILES += 	vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/soter.raw:$(TARGET_COPY_OUT_VENDOR)/thh/soter.raw:mtk
 PRODUCT_COPY_FILES += 	vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/fp_server:$(TARGET_COPY_OUT_VENDOR)/thh/fp_server:mtk
-#PRODUCT_COPY_FILES += 	vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/init_thh:$(TARGET_COPY_OUT_VENDOR)/bin/init_thh:mtk
+PRODUCT_COPY_FILES += 	vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/fp_server_chipsailing:$(TARGET_COPY_OUT_VENDOR)/thh/fp_server_chipsailing:mtk
+PRODUCT_COPY_FILES += 	vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/fp_server_cdfinger:$(TARGET_COPY_OUT_VENDOR)/thh/fp_server_cdfinger:mtk
+PRODUCT_COPY_FILES += 	vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/uTAgent:$(TARGET_COPY_OUT_VENDOR)/thh/uTAgent:mtk
+PRODUCT_COPY_FILES += 	vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/alipayapp:$(TARGET_COPY_OUT_VENDOR)/thh/alipayapp:mtk
+PRODUCT_COPY_FILES += 	vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/init_thh:$(TARGET_COPY_OUT_VENDOR)/bin/init_thh:mtk
+
 PRODUCT_PACKAGES   += 	keystore.mt6739
 PRODUCT_PACKAGES   += 	gatekeeper.mt6739
 endif
Index: device/mediatek
===================================================================
--- device/mediatek	(revision 2996)
+++ device/mediatek	(revision 2997)

Property changes on: device/mediatek
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /L05A/Trunk/ALPS-MP-N1.MP18-V1_AUS6739_66_N1_INHOUSE/device/mediatek:r2850-2851
Index: device/chipsailing/csfinger_product_64bit.mk
===================================================================
--- device/chipsailing/csfinger_product_64bit.mk	(revision 0)
+++ device/chipsailing/csfinger_product_64bit.mk	(revision 2997)
@@ -0,0 +1,21 @@
+CS_LOCAL_PATH := device/chipsailing
+
+PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/64-bit/cs_fp:system/bin/cs_fp
+PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/64-bit/libcs_fp_binder.so:system/lib64/libcs_fp_binder.so
+
+
+PRODUCT_COPY_FILES += frameworks/native/data/etc/android.hardware.fingerprint.xml:system/etc/permissions/android.hardware.fingerprint.xml
+
+PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/64-bit/Android7/libfp_hal.so:system/lib64/libfp_hal.so
+	
+PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/64-bit/Android7/chipsailing.fingerprint.default.so:system/lib64/hw/chipsailing.fingerprint.default.so
+
+PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/64-bit/isee/libfp_tac.so:system/lib64/libfp_tac.so
+#PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/64-bit/isee/glass_ta/fp_server:system/vendor/thh/fp_server
+
+
+
+PRODUCT_COPY_FILES += device/chipsailing/init.csfinger.rc:root/init.csfinger.rc
+
+include $(CS_LOCAL_PATH)/config/cs_cfg_358_glass.mk
+

Property changes on: device/chipsailing/csfinger_product_64bit.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/32-bit/cs_fp
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/cs_fp
===================================================================
--- device/chipsailing/32-bit/cs_fp	(revision 0)
+++ device/chipsailing/32-bit/cs_fp	(revision 2997)

Property changes on: device/chipsailing/32-bit/cs_fp
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/trustonic/libfp_tac.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/trustonic/libfp_tac.so
===================================================================
--- device/chipsailing/32-bit/trustonic/libfp_tac.so	(revision 0)
+++ device/chipsailing/32-bit/trustonic/libfp_tac.so	(revision 2997)

Property changes on: device/chipsailing/32-bit/trustonic/libfp_tac.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/rsee/coating_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/rsee/coating_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
===================================================================
--- device/chipsailing/32-bit/rsee/coating_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta	(revision 0)
+++ device/chipsailing/32-bit/rsee/coating_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta	(revision 2997)

Property changes on: device/chipsailing/32-bit/rsee/coating_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/rsee/glass_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/rsee/glass_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
===================================================================
--- device/chipsailing/32-bit/rsee/glass_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta	(revision 0)
+++ device/chipsailing/32-bit/rsee/glass_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta	(revision 2997)

Property changes on: device/chipsailing/32-bit/rsee/glass_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/rsee/libfp_tac.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/rsee/libfp_tac.so
===================================================================
--- device/chipsailing/32-bit/rsee/libfp_tac.so	(revision 0)
+++ device/chipsailing/32-bit/rsee/libfp_tac.so	(revision 2997)

Property changes on: device/chipsailing/32-bit/rsee/libfp_tac.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/trustkernel/coating_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/trustkernel/coating_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
===================================================================
--- device/chipsailing/32-bit/trustkernel/coating_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta	(revision 0)
+++ device/chipsailing/32-bit/trustkernel/coating_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta	(revision 2997)

Property changes on: device/chipsailing/32-bit/trustkernel/coating_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/trustkernel/glass_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/trustkernel/glass_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
===================================================================
--- device/chipsailing/32-bit/trustkernel/glass_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta	(revision 0)
+++ device/chipsailing/32-bit/trustkernel/glass_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta	(revision 2997)

Property changes on: device/chipsailing/32-bit/trustkernel/glass_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/trustkernel/libfp_tac.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/trustkernel/libfp_tac.so
===================================================================
--- device/chipsailing/32-bit/trustkernel/libfp_tac.so	(revision 0)
+++ device/chipsailing/32-bit/trustkernel/libfp_tac.so	(revision 2997)

Property changes on: device/chipsailing/32-bit/trustkernel/libfp_tac.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/libcs_fp_binder.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/libcs_fp_binder.so
===================================================================
--- device/chipsailing/32-bit/libcs_fp_binder.so	(revision 0)
+++ device/chipsailing/32-bit/libcs_fp_binder.so	(revision 2997)

Property changes on: device/chipsailing/32-bit/libcs_fp_binder.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/isee/libfp_tac.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/isee/libfp_tac.so
===================================================================
--- device/chipsailing/32-bit/isee/libfp_tac.so	(revision 0)
+++ device/chipsailing/32-bit/isee/libfp_tac.so	(revision 2997)

Property changes on: device/chipsailing/32-bit/isee/libfp_tac.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/isee/coating_ta/cs_fp_server
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/isee/coating_ta/cs_fp_server
===================================================================
--- device/chipsailing/32-bit/isee/coating_ta/cs_fp_server	(revision 0)
+++ device/chipsailing/32-bit/isee/coating_ta/cs_fp_server	(revision 2997)

Property changes on: device/chipsailing/32-bit/isee/coating_ta/cs_fp_server
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/isee/glass_ta/cs_fp_server
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/isee/glass_ta/cs_fp_server
===================================================================
--- device/chipsailing/32-bit/isee/glass_ta/cs_fp_server	(revision 0)
+++ device/chipsailing/32-bit/isee/glass_ta/cs_fp_server	(revision 2997)

Property changes on: device/chipsailing/32-bit/isee/glass_ta/cs_fp_server
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/Android6/fingerprint.default.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/Android6/fingerprint.default.so
===================================================================
--- device/chipsailing/32-bit/Android6/fingerprint.default.so	(revision 0)
+++ device/chipsailing/32-bit/Android6/fingerprint.default.so	(revision 2997)

Property changes on: device/chipsailing/32-bit/Android6/fingerprint.default.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/Android6/libfp_hal.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/Android6/libfp_hal.so
===================================================================
--- device/chipsailing/32-bit/Android6/libfp_hal.so	(revision 0)
+++ device/chipsailing/32-bit/Android6/libfp_hal.so	(revision 2997)

Property changes on: device/chipsailing/32-bit/Android6/libfp_hal.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/Android6/chipsailing.fingerprint.default.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/Android6/chipsailing.fingerprint.default.so
===================================================================
--- device/chipsailing/32-bit/Android6/chipsailing.fingerprint.default.so	(revision 0)
+++ device/chipsailing/32-bit/Android6/chipsailing.fingerprint.default.so	(revision 2997)

Property changes on: device/chipsailing/32-bit/Android6/chipsailing.fingerprint.default.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/Android7/fingerprint.default.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/Android7/fingerprint.default.so
===================================================================
--- device/chipsailing/32-bit/Android7/fingerprint.default.so	(revision 0)
+++ device/chipsailing/32-bit/Android7/fingerprint.default.so	(revision 2997)

Property changes on: device/chipsailing/32-bit/Android7/fingerprint.default.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/Android7/libfp_hal.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/Android7/libfp_hal.so
===================================================================
--- device/chipsailing/32-bit/Android7/libfp_hal.so	(revision 0)
+++ device/chipsailing/32-bit/Android7/libfp_hal.so	(revision 2997)

Property changes on: device/chipsailing/32-bit/Android7/libfp_hal.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/32-bit/Android7/chipsailing.fingerprint.default.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/32-bit/Android7/chipsailing.fingerprint.default.so
===================================================================
--- device/chipsailing/32-bit/Android7/chipsailing.fingerprint.default.so	(revision 0)
+++ device/chipsailing/32-bit/Android7/chipsailing.fingerprint.default.so	(revision 2997)

Property changes on: device/chipsailing/32-bit/Android7/chipsailing.fingerprint.default.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/trustkernel/coating_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/trustkernel/coating_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
===================================================================
--- device/chipsailing/64-bit/trustkernel/coating_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta	(revision 0)
+++ device/chipsailing/64-bit/trustkernel/coating_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta	(revision 2997)

Property changes on: device/chipsailing/64-bit/trustkernel/coating_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/trustkernel/glass_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/trustkernel/glass_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
===================================================================
--- device/chipsailing/64-bit/trustkernel/glass_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta	(revision 0)
+++ device/chipsailing/64-bit/trustkernel/glass_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta	(revision 2997)

Property changes on: device/chipsailing/64-bit/trustkernel/glass_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/trustkernel/libfp_tac.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/trustkernel/libfp_tac.so
===================================================================
--- device/chipsailing/64-bit/trustkernel/libfp_tac.so	(revision 0)
+++ device/chipsailing/64-bit/trustkernel/libfp_tac.so	(revision 2997)

Property changes on: device/chipsailing/64-bit/trustkernel/libfp_tac.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/libcs_fp_binder.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/libcs_fp_binder.so
===================================================================
--- device/chipsailing/64-bit/libcs_fp_binder.so	(revision 0)
+++ device/chipsailing/64-bit/libcs_fp_binder.so	(revision 2997)

Property changes on: device/chipsailing/64-bit/libcs_fp_binder.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/isee/coating_ta/cs_fp_server
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/isee/coating_ta/cs_fp_server
===================================================================
--- device/chipsailing/64-bit/isee/coating_ta/cs_fp_server	(revision 0)
+++ device/chipsailing/64-bit/isee/coating_ta/cs_fp_server	(revision 2997)

Property changes on: device/chipsailing/64-bit/isee/coating_ta/cs_fp_server
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/isee/glass_ta/cs_fp_server
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/isee/glass_ta/cs_fp_server
===================================================================
--- device/chipsailing/64-bit/isee/glass_ta/cs_fp_server	(revision 0)
+++ device/chipsailing/64-bit/isee/glass_ta/cs_fp_server	(revision 2997)

Property changes on: device/chipsailing/64-bit/isee/glass_ta/cs_fp_server
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/isee/glass_ta/fp_server_chipsailing
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/isee/glass_ta/fp_server_chipsailing
===================================================================
--- device/chipsailing/64-bit/isee/glass_ta/fp_server_chipsailing	(revision 0)
+++ device/chipsailing/64-bit/isee/glass_ta/fp_server_chipsailing	(revision 2997)

Property changes on: device/chipsailing/64-bit/isee/glass_ta/fp_server_chipsailing
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/isee/glass_ta/fp_server
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/isee/glass_ta/fp_server
===================================================================
--- device/chipsailing/64-bit/isee/glass_ta/fp_server	(revision 0)
+++ device/chipsailing/64-bit/isee/glass_ta/fp_server	(revision 2997)

Property changes on: device/chipsailing/64-bit/isee/glass_ta/fp_server
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/Android6/libfp_hal.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/Android6/libfp_hal.so
===================================================================
--- device/chipsailing/64-bit/Android6/libfp_hal.so	(revision 0)
+++ device/chipsailing/64-bit/Android6/libfp_hal.so	(revision 2997)

Property changes on: device/chipsailing/64-bit/Android6/libfp_hal.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/Android6/chipsailing.fingerprint.default.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/Android6/chipsailing.fingerprint.default.so
===================================================================
--- device/chipsailing/64-bit/Android6/chipsailing.fingerprint.default.so	(revision 0)
+++ device/chipsailing/64-bit/Android6/chipsailing.fingerprint.default.so	(revision 2997)

Property changes on: device/chipsailing/64-bit/Android6/chipsailing.fingerprint.default.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/Android6/fingerprint.default.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/Android6/fingerprint.default.so
===================================================================
--- device/chipsailing/64-bit/Android6/fingerprint.default.so	(revision 0)
+++ device/chipsailing/64-bit/Android6/fingerprint.default.so	(revision 2997)

Property changes on: device/chipsailing/64-bit/Android6/fingerprint.default.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/Android7/fingerprint.default.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/Android7/fingerprint.default.so
===================================================================
--- device/chipsailing/64-bit/Android7/fingerprint.default.so	(revision 0)
+++ device/chipsailing/64-bit/Android7/fingerprint.default.so	(revision 2997)

Property changes on: device/chipsailing/64-bit/Android7/fingerprint.default.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/Android7/libfp_hal.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/Android7/libfp_hal.so
===================================================================
--- device/chipsailing/64-bit/Android7/libfp_hal.so	(revision 0)
+++ device/chipsailing/64-bit/Android7/libfp_hal.so	(revision 2997)

Property changes on: device/chipsailing/64-bit/Android7/libfp_hal.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/Android7/chipsailing.fingerprint.default.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/Android7/chipsailing.fingerprint.default.so
===================================================================
--- device/chipsailing/64-bit/Android7/chipsailing.fingerprint.default.so	(revision 0)
+++ device/chipsailing/64-bit/Android7/chipsailing.fingerprint.default.so	(revision 2997)

Property changes on: device/chipsailing/64-bit/Android7/chipsailing.fingerprint.default.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/cs_fp
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/cs_fp
===================================================================
--- device/chipsailing/64-bit/cs_fp	(revision 0)
+++ device/chipsailing/64-bit/cs_fp	(revision 2997)

Property changes on: device/chipsailing/64-bit/cs_fp
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/trustonic/libfp_tac.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/trustonic/libfp_tac.so
===================================================================
--- device/chipsailing/64-bit/trustonic/libfp_tac.so	(revision 0)
+++ device/chipsailing/64-bit/trustonic/libfp_tac.so	(revision 2997)

Property changes on: device/chipsailing/64-bit/trustonic/libfp_tac.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/rsee/coating_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/rsee/coating_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
===================================================================
--- device/chipsailing/64-bit/rsee/coating_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta	(revision 0)
+++ device/chipsailing/64-bit/rsee/coating_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta	(revision 2997)

Property changes on: device/chipsailing/64-bit/rsee/coating_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/rsee/glass_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/rsee/glass_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
===================================================================
--- device/chipsailing/64-bit/rsee/glass_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta	(revision 0)
+++ device/chipsailing/64-bit/rsee/glass_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta	(revision 2997)

Property changes on: device/chipsailing/64-bit/rsee/glass_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/64-bit/rsee/libfp_tac.so
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: device/chipsailing/64-bit/rsee/libfp_tac.so
===================================================================
--- device/chipsailing/64-bit/rsee/libfp_tac.so	(revision 0)
+++ device/chipsailing/64-bit/rsee/libfp_tac.so	(revision 2997)

Property changes on: device/chipsailing/64-bit/rsee/libfp_tac.so
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: device/chipsailing/config/cs_cfg_338_glass.mk
===================================================================
--- device/chipsailing/config/cs_cfg_338_glass.mk	(revision 0)
+++ device/chipsailing/config/cs_cfg_338_glass.mk	(revision 2997)
@@ -0,0 +1,45 @@
+  
+##############################################################
+#3711/3716/3511/3516/336/358
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.stype=338
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_area=true
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_finger=true
+
+#enroll_count:6~15
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.enroll_cnt=12
+
+#true:allow to report key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.key_support=false
+
+#true:support navigation  (358 not support)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.nav_support=false
+
+#true:only report up/down key (if true then singleclick/doubeclick/longtouch/navgation  function will disable)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dou_support=false
+
+#false:only disable singleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.singletap_support=false
+
+#false:only disable doubleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.doubletap_support=false
+
+#false:only disable longtouch key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.longtouch_support=false
+
+#setting Ms between singleclick:200~500
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dtime=300
+
+#setting touch (500~800)Ms to report longtouch key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.ltime=700
+
+#touch key table (should __setbit in fingerprint driver)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_singletap=87
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_doubletap=64
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_longtouch=63
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_up=65
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_down=66
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_left=67
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_right=68
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_dou=189

Property changes on: device/chipsailing/config/cs_cfg_338_glass.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/config/cs_cfg_356_glass.mk
===================================================================
--- device/chipsailing/config/cs_cfg_356_glass.mk	(revision 0)
+++ device/chipsailing/config/cs_cfg_356_glass.mk	(revision 2997)
@@ -0,0 +1,45 @@
+  
+##############################################################
+#3711/3716/3511/3516/336/358
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.stype=356
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_area=true
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_finger=true
+
+#enroll_count:6~15
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.enroll_cnt=12
+
+#true:allow to report key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.key_support=false
+
+#true:support navigation  (358 not support)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.nav_support=false
+
+#true:only report up/down key (if true then singleclick/doubeclick/longtouch/navgation  function will disable)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dou_support=false
+
+#false:only disable singleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.singletap_support=false
+
+#false:only disable doubleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.doubletap_support=false
+
+#false:only disable longtouch key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.longtouch_support=false
+
+#setting Ms between singleclick:200~500
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dtime=300
+
+#setting touch (500~800)Ms to report longtouch key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.ltime=700
+
+#touch key table (should __setbit in fingerprint driver)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_singletap=87
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_doubletap=64
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_longtouch=63
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_up=65
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_down=66
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_left=67
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_right=68
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_dou=189

Property changes on: device/chipsailing/config/cs_cfg_356_glass.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/config/cs_cfg_3516_glass.mk
===================================================================
--- device/chipsailing/config/cs_cfg_3516_glass.mk	(revision 0)
+++ device/chipsailing/config/cs_cfg_3516_glass.mk	(revision 2997)
@@ -0,0 +1,45 @@
+  
+##############################################################
+#3711/3716/3511/3516/336/358
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.stype=3516
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_area=true
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_finger=true
+
+#enroll_count:6~15
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.enroll_cnt=12
+
+#true:allow to report key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.key_support=false
+
+#true:support navigation  (358 not support)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.nav_support=false
+
+#true:only report up/down key (if true then singleclick/doubeclick/longtouch/navgation  function will disable)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dou_support=false
+
+#false:only disable singleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.singletap_support=false
+
+#false:only disable doubleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.doubletap_support=false
+
+#false:only disable longtouch key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.longtouch_support=false
+
+#setting Ms between singleclick:200~500
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dtime=300
+
+#setting touch (500~800)Ms to report longtouch key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.ltime=700
+
+#touch key table (should __setbit in fingerprint driver)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_singletap=87
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_doubletap=64
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_longtouch=63
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_up=65
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_down=66
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_left=67
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_right=68
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_dou=189

Property changes on: device/chipsailing/config/cs_cfg_3516_glass.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/config/cs_cfg_358_glass.mk
===================================================================
--- device/chipsailing/config/cs_cfg_358_glass.mk	(revision 0)
+++ device/chipsailing/config/cs_cfg_358_glass.mk	(revision 2997)
@@ -0,0 +1,45 @@
+  
+##############################################################
+#3711/3716/3511/3516/336/358
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.stype=358
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_area=true
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_finger=true
+
+#enroll_count:6~15
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.enroll_cnt=12
+
+#true:allow to report key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.key_support=false
+
+#true:support navigation  (358 not support)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.nav_support=false
+
+#true:only report up/down key (if true then singleclick/doubeclick/longtouch/navgation  function will disable)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dou_support=false
+
+#false:only disable singleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.singletap_support=false
+
+#false:only disable doubleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.doubletap_support=false
+
+#false:only disable longtouch key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.longtouch_support=false
+
+#setting Ms between singleclick:200~500
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dtime=300
+
+#setting touch (500~800)Ms to report longtouch key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.ltime=700
+
+#touch key table (should __setbit in fingerprint driver)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_singletap=87
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_doubletap=64
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_longtouch=63
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_up=65
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_down=66
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_left=67
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_right=68
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_dou=189

Property changes on: device/chipsailing/config/cs_cfg_358_glass.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/config/cs_cfg_3716_glass.mk
===================================================================
--- device/chipsailing/config/cs_cfg_3716_glass.mk	(revision 0)
+++ device/chipsailing/config/cs_cfg_3716_glass.mk	(revision 2997)
@@ -0,0 +1,45 @@
+  
+##############################################################
+#3711/3716/3511/3516/336/358
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.stype=3716
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_area=true
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_finger=true
+
+#enroll_count:6~15
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.enroll_cnt=12
+
+#true:allow to report key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.key_support=false
+
+#true:support navigation  (358 not support)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.nav_support=false
+
+#true:only report up/down key (if true then singleclick/doubeclick/longtouch/navgation  function will disable)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dou_support=false
+
+#false:only disable singleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.singletap_support=false
+
+#false:only disable doubleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.doubletap_support=false
+
+#false:only disable longtouch key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.longtouch_support=false
+
+#setting Ms between singleclick:200~500
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dtime=300
+
+#setting touch (500~800)Ms to report longtouch key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.ltime=700
+
+#touch key table (should __setbit in fingerprint driver)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_singletap=87
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_doubletap=64
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_longtouch=63
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_up=65
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_down=66
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_left=67
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_right=68
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_dou=189

Property changes on: device/chipsailing/config/cs_cfg_3716_glass.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/config/cs_cfg_3511_coating.mk
===================================================================
--- device/chipsailing/config/cs_cfg_3511_coating.mk	(revision 0)
+++ device/chipsailing/config/cs_cfg_3511_coating.mk	(revision 2997)
@@ -0,0 +1,45 @@
+  
+##############################################################
+#3711/3716/3511/3516/336/358
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.stype=3511
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_area=true
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_finger=true
+
+#enroll_count:6~15
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.enroll_cnt=12
+
+#true:allow to report key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.key_support=false
+
+#true:support navigation  (358 not support)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.nav_support=false
+
+#true:only report up/down key (if true then singleclick/doubeclick/longtouch/navgation  function will disable)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dou_support=false
+
+#false:only disable singleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.singletap_support=false
+
+#false:only disable doubleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.doubletap_support=false
+
+#false:only disable longtouch key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.longtouch_support=false
+
+#setting Ms between singleclick:200~500
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dtime=300
+
+#setting touch (500~800)Ms to report longtouch key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.ltime=700
+
+#touch key table (should __setbit in fingerprint driver)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_singletap=87
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_doubletap=64
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_longtouch=63
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_up=65
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_down=66
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_left=67
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_right=68
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_dou=189

Property changes on: device/chipsailing/config/cs_cfg_3511_coating.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/config/cs_cfg_3711_coating.mk
===================================================================
--- device/chipsailing/config/cs_cfg_3711_coating.mk	(revision 0)
+++ device/chipsailing/config/cs_cfg_3711_coating.mk	(revision 2997)
@@ -0,0 +1,45 @@
+  
+##############################################################
+#3711/3716/3511/3516/336/358
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.stype=3711
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_area=true
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_finger=true
+
+#enroll_count:6~15
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.enroll_cnt=12
+
+#true:allow to report key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.key_support=false
+
+#true:support navigation  (358 not support)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.nav_support=false
+
+#true:only report up/down key (if true then singleclick/doubeclick/longtouch/navgation  function will disable)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dou_support=false
+
+#false:only disable singleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.singletap_support=false
+
+#false:only disable doubleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.doubletap_support=false
+
+#false:only disable longtouch key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.longtouch_support=false
+
+#setting Ms between singleclick:200~500
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dtime=300
+
+#setting touch (500~800)Ms to report longtouch key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.ltime=700
+
+#touch key table (should __setbit in fingerprint driver)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_singletap=87
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_doubletap=64
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_longtouch=63
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_up=65
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_down=66
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_left=67
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_right=68
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_dou=189

Property changes on: device/chipsailing/config/cs_cfg_3711_coating.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/config/cs_cfg_351_glass.mk
===================================================================
--- device/chipsailing/config/cs_cfg_351_glass.mk	(revision 0)
+++ device/chipsailing/config/cs_cfg_351_glass.mk	(revision 2997)
@@ -0,0 +1,45 @@
+  
+##############################################################
+#3711/3716/3511/3516/336/358
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.stype=351
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_area=true
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_finger=true
+
+#enroll_count:6~15
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.enroll_cnt=12
+
+#true:allow to report key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.key_support=false
+
+#true:support navigation  (358 not support)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.nav_support=false
+
+#true:only report up/down key (if true then singleclick/doubeclick/longtouch/navgation  function will disable)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dou_support=false
+
+#false:only disable singleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.singletap_support=false
+
+#false:only disable doubleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.doubletap_support=false
+
+#false:only disable longtouch key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.longtouch_support=false
+
+#setting Ms between singleclick:200~500
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dtime=300
+
+#setting touch (500~800)Ms to report longtouch key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.ltime=700
+
+#touch key table (should __setbit in fingerprint driver)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_singletap=87
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_doubletap=64
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_longtouch=63
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_up=65
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_down=66
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_left=67
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_right=68
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_dou=189

Property changes on: device/chipsailing/config/cs_cfg_351_glass.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/config/cs_cfg_336_glass.mk
===================================================================
--- device/chipsailing/config/cs_cfg_336_glass.mk	(revision 0)
+++ device/chipsailing/config/cs_cfg_336_glass.mk	(revision 2997)
@@ -0,0 +1,45 @@
+  
+##############################################################
+#3711/3716/3511/3516/336/358
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.stype=336
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_area=true
+
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dup_finger=true
+
+#enroll_count:6~15
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.enroll_cnt=12
+
+#true:allow to report key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.key_support=false
+
+#true:support navigation  (358 not support)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.nav_support=false
+
+#true:only report up/down key (if true then singleclick/doubeclick/longtouch/navgation  function will disable)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dou_support=false
+
+#false:only disable singleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.singletap_support=false
+
+#false:only disable doubleclick key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.doubletap_support=false
+
+#false:only disable longtouch key report
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.longtouch_support=false
+
+#setting Ms between singleclick:200~500
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.dtime=300
+
+#setting touch (500~800)Ms to report longtouch key
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.ltime=700
+
+#touch key table (should __setbit in fingerprint driver)
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_singletap=87
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_doubletap=64
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_longtouch=63
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_up=65
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_down=66
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_left=67
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_right=68
+ADDITIONAL_BUILD_PROPERTIES +=persist.cs.fp.kcode_dou=189

Property changes on: device/chipsailing/config/cs_cfg_336_glass.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/init.csfinger.rc
===================================================================
--- device/chipsailing/init.csfinger.rc	(revision 0)
+++ device/chipsailing/init.csfinger.rc	(revision 2997)
@@ -0,0 +1,13 @@
+on boot
+    chmod 0666 /dev/cs_spi
+	chmod 0755 /system/bin/cs_fp
+
+service cs_fp /system/bin/cs_fp
+    class main
+    user system	
+	group root system	
+	
+service fingerprintd /system/bin/fingerprintd
+    class main
+    user system
+    group root system
\ No newline at end of file

Property changes on: device/chipsailing/init.csfinger.rc
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/Android.mk
===================================================================
--- device/chipsailing/Android.mk	(revision 0)
+++ device/chipsailing/Android.mk	(revision 2997)
@@ -0,0 +1 @@
+BOARD_SEPOLICY_DIRS += device/chipsailing/sepolicy

Property changes on: device/chipsailing/Android.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/sepolicy/untrusted_app.te
===================================================================
--- device/chipsailing/sepolicy/untrusted_app.te	(revision 0)
+++ device/chipsailing/sepolicy/untrusted_app.te	(revision 2997)
@@ -0,0 +1,5 @@
+#chipsailing
+allow untrusted_app csfinger_device: chr_file{ open read write ioctl getattr };
+# add for chipsailing cs_fp
+allow untrusted_app cs_fp_service:service_manager { find };
+

Property changes on: device/chipsailing/sepolicy/untrusted_app.te
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/sepolicy/device.te
===================================================================
--- device/chipsailing/sepolicy/device.te	(revision 0)
+++ device/chipsailing/sepolicy/device.te	(revision 2997)
@@ -0,0 +1,3 @@
+#chipsailing
+type csfinger_device , dev_type;
+

Property changes on: device/chipsailing/sepolicy/device.te
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/sepolicy/file.te
===================================================================
--- device/chipsailing/sepolicy/file.te	(revision 0)
+++ device/chipsailing/sepolicy/file.te	(revision 2997)
@@ -0,0 +1,3 @@
+#chipsailing
+#file type for cs_fp
+type cs_data_file, file_type, data_file_type;

Property changes on: device/chipsailing/sepolicy/file.te
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/sepolicy/file_contexts
===================================================================
--- device/chipsailing/sepolicy/file_contexts	(revision 0)
+++ device/chipsailing/sepolicy/file_contexts	(revision 2997)
@@ -0,0 +1,5 @@
+#chipsailing
+/dev/cs_spi    u:object_r:csfinger_device:s0
+#For ChipSailing fingerprint
+/system/bin/cs_fp        u:object_r:cs_fp_exec:s0
+

Property changes on: device/chipsailing/sepolicy/file_contexts
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/sepolicy/service.te
===================================================================
--- device/chipsailing/sepolicy/service.te	(revision 0)
+++ device/chipsailing/sepolicy/service.te	(revision 2997)
@@ -0,0 +1,2 @@
+#chipsailing
+type cs_fp_service, service_manager_type;

Property changes on: device/chipsailing/sepolicy/service.te
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/sepolicy/service_contexts
===================================================================
--- device/chipsailing/sepolicy/service_contexts	(revision 0)
+++ device/chipsailing/sepolicy/service_contexts	(revision 2997)
@@ -0,0 +1,3 @@
+# add for chipsailing cs_fp
+chipsailing.fingerprint.IChipsailFingerprintDaemon   u:object_r:cs_fp_service:s0
+

Property changes on: device/chipsailing/sepolicy/service_contexts
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/sepolicy/property.te
===================================================================
--- device/chipsailing/sepolicy/property.te	(revision 0)
+++ device/chipsailing/sepolicy/property.te	(revision 2997)
@@ -0,0 +1,2 @@
+
+type csfinger_prop, property_type;

Property changes on: device/chipsailing/sepolicy/property.te
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/sepolicy/property_contexts
===================================================================
--- device/chipsailing/sepolicy/property_contexts	(revision 0)
+++ device/chipsailing/sepolicy/property_contexts	(revision 2997)
@@ -0,0 +1,5 @@
+
+persist.cs.irqtest  u:object_r:csfinger_prop:s0
+persist.cs.reset u:object_r:csfinger_prop:s0
+persist.cs.spitest  u:object_r:csfinger_prop:s0
+persist.cs.pixeltest u:object_r:csfinger_prop:s0
\ No newline at end of file

Property changes on: device/chipsailing/sepolicy/property_contexts
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/sepolicy/system_app.te
===================================================================
--- device/chipsailing/sepolicy/system_app.te	(revision 0)
+++ device/chipsailing/sepolicy/system_app.te	(revision 2997)
@@ -0,0 +1,9 @@
+#chipsailing
+allow system_app csfinger_device: chr_file{ open read write ioctl getattr };
+
+allow system_app tee_device:dir r_dir_perms;
+#allow system_app tee_device:chr_file { write read open ioctl };
+
+# add for chipsailing cs_fp
+allow system_app cs_fp:binder call;
+

Property changes on: device/chipsailing/sepolicy/system_app.te
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/sepolicy/cs_fp.te
===================================================================
--- device/chipsailing/sepolicy/cs_fp.te	(revision 0)
+++ device/chipsailing/sepolicy/cs_fp.te	(revision 2997)
@@ -0,0 +1,93 @@
+type cs_fp, domain;
+type cs_fp_exec, exec_type, file_type;
+typeattribute cs_fp mlstrustedsubject;
+
+init_daemon_domain(cs_fp)
+r_dir_file(cs_fp, sdcard_type)
+file_type_auto_trans(cs_fp,system_data_file,cs_data_file)
+#file_type_auto_trans(tee,system_data_file,cs_data_file)
+binder_use(cs_fp)
+binder_call(cs_fp, binderservicedomain)
+binder_call(cs_fp, appdomain)
+binder_call(cs_fp, fingerprintd)
+binder_service(cs_fp)
+allow cs_fp self:process execmem;
+allow cs_fp kernel:system module_request;
+allow cs_fp sdcard_type:file write;
+allow cs_fp fuse:dir create_dir_perms;
+allow cs_fp fuse:file create_file_perms;
+allow cs_fp self:capability { dac_override dac_read_search };
+allow cs_fp cs_fp_service:service_manager add;
+r_dir_file(cs_fp, cs_data_file)
+allow cs_fp cs_data_file:dir ra_dir_perms;
+allow cs_fp cs_data_file:file create_file_perms;
+allow cs_fp csfinger_device:chr_file { open read write ioctl rw_file_perms};
+#allow cs_fp system_data_file:dir create_dir_perms;
+
+#allow cs_fp system_data_file:file create_file_perms;
+allow cs_fp cs_data_file:file create_file_perms;
+allow cs_fp system_file:file {read open execute_no_trans execute};
+allow cs_fp shell_exec:file { read open execute_no_trans execute };
+allow cs_fp app_data_file:dir {read write open ioctl execute search getattr add_name
+create_dir_perms};
+allow cs_fp app_data_file:file {read write open ioctl create_file_perms};
+allow cs_fp apk_data_file:file {read write open ioctl create_file_perms};
+allow cs_fp apk_data_file:dir {read write open ioctl execute search getattr add_name
+create_dir_perms};
+allow cs_fp cs_fp:netlink_socket {create bind connect listen accept write read setopt
+getopt getattr ioctl};
+allow cs_fp cs_fp:netlink_route_socket { create_socket_perms nlmsg_read nlmsg_write
+create ioctl bind };
+allow cs_fp cs_fp:udp_socket { create ioctl bind };
+allow cs_fp cs_fp:tcp_socket { create ioctl bind };
+allow cs_fp cs_fp:packet_socket { create ioctl bind};
+allow cs_fp cs_fp:netlink_kobject_uevent_socket { create setopt bind write read ioctl};
+allow cs_fp ueventd:dir search;
+allow cs_fp ueventd:file { create write read open };
+allow cs_fp block_device:dir { search };
+#allow cs_fp mmcblk_device:blk_file { open read write rw_file_perms};
+allow cs_fp untrusted_app:process { signull };
+#allow cs_fp system_data_file:dir { write open add_name create setattr };
+allow cs_fp system_app_data_file:dir { write open add_name create setattr search };
+allow cs_fp system_app_data_file:file { write open create setattr getattr };
+allow system_app cs_fp_service:service_manager add;
+allow system_app cs_data_file:dir create_dir_perms;
+allow system_app cs_data_file:file create_file_perms;
+allow cs_fp cs_fp_service:service_manager find;
+allow cs_fp permission_service:service_manager { find };
+allow fingerprintd cs_fp_service:service_manager { find };
+binder_use(fingerprintd)
+binder_call(fingerprintd, binderservicedomain)
+binder_call(fingerprintd, appdomain)
+binder_service(fingerprintd)
+allow system_app fingerprintd:binder call;
+allow system_app cs_fp:binder call;
+allow fingerprintd cs_fp:binder call;
+allow cs_fp system_data_file:file { open read getattr lock };
+allow cs_fp cs_data_file:file { create open write read};
+
+allow cs_fp sysfs:file { open read write getattr };
+allow cs_fp sysfs:dir { open read write getattr };
+
+#allow cs_fp firmware_file:dir r_dir_perms;
+#allow cs_fp firmware_file:file { getattr open read ioctl };
+allow cs_fp tee_device:dir r_dir_perms;
+allow cs_fp tee_device:chr_file { write read open ioctl };
+allow cs_fp teei_fp_device:dir r_dir_perms;
+allow cs_fp teei_fp_device:chr_file { write read open ioctl };
+allow cs_fp csfinger_prop:property_service { set };
+allow cs_fp csfinger_prop:file { open read getattr };
+allow system_app csfinger_prop:property_service { set };
+allow cs_fp property_socket:sock_file { write };
+allow cs_fp init:unix_stream_socket { connectto };
+allow cs_fp rootfs:lnk_file { open read getattr };
+allow cs_fp system_prop:property_service { set };
+
+allow cs_fp graphics_device:chr_file { read write ioctl open };
+allow cs_fp graphics_device:dir search;
+
+# allow HAL module to read dir contents
+allow cs_fp fingerprintd_data_file:file { create_file_perms };
+
+# allow HAL module to read/write/unlink contents of this dir
+allow cs_fp fingerprintd_data_file:dir rw_dir_perms;
\ No newline at end of file

Property changes on: device/chipsailing/sepolicy/cs_fp.te
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/sepolicy/system_server.te
===================================================================
--- device/chipsailing/sepolicy/system_server.te	(revision 0)
+++ device/chipsailing/sepolicy/system_server.te	(revision 2997)
@@ -0,0 +1,2 @@
+# add for chipsailing cs_fp
+allow system_server cs_fp_service:service_manager find;

Property changes on: device/chipsailing/sepolicy/system_server.te
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/sepolicy/fingerprintd.te
===================================================================
--- device/chipsailing/sepolicy/fingerprintd.te	(revision 0)
+++ device/chipsailing/sepolicy/fingerprintd.te	(revision 2997)
@@ -0,0 +1,16 @@
+#chipsailing
+allow fingerprintd csfinger_device:chr_file { open read write ioctl getattr };
+#allow fingerprintd firmware_file:dir r_dir_perms;
+#allow fingerprintd firmware_file:file { getattr open read ioctl };
+allow fingerprintd tee_device:dir r_dir_perms;
+allow fingerprintd tee_device:chr_file { write read open ioctl };
+allow fingerprintd teei_fp_device:dir r_dir_perms;
+allow fingerprintd teei_fp_device:chr_file { write read open ioctl };
+allow fingerprintd property_socket:sock_file { write };
+allow fingerprintd init:unix_stream_socket { connectto };
+allow fingerprintd csfinger_prop:property_service { set };
+allow fingerprintd system_prop:property_service { set };
+allow fingerprintd system_app_data_file:dir { open read getattr search };
+allow fingerprintd system_data_file:file { open read getattr lock };
+allow fingerprintd sysfs:file { open read write getattr };
+allow fingerprintd sysfs:dir { open read write getattr };

Property changes on: device/chipsailing/sepolicy/fingerprintd.te
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/sepolicy/servicemanager.te
===================================================================
--- device/chipsailing/sepolicy/servicemanager.te	(revision 0)
+++ device/chipsailing/sepolicy/servicemanager.te	(revision 2997)
@@ -0,0 +1,4 @@
+# add for chipsailing cs_fp
+allow servicemanager cs_fp:dir { search };
+allow servicemanager cs_fp:file { open read write };
+allow servicemanager cs_fp:process { getattr };

Property changes on: device/chipsailing/sepolicy/servicemanager.te
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing/csfinger_product_32bit.mk
===================================================================
--- device/chipsailing/csfinger_product_32bit.mk	(revision 0)
+++ device/chipsailing/csfinger_product_32bit.mk	(revision 2997)
@@ -0,0 +1,86 @@
+CS_LOCAL_PATH := device/chipsailing
+
+PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/cs_fp:system/bin/cs_fp
+PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/libcs_fp_binder.so:system/lib/libcs_fp_binder.so
+
+ifeq ($(strip $(ANDROID_VERSION)), Android6)
+	PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/Android6/libfp_hal.so:system/lib/libfp_hal.so
+	ifeq ($(FINGERPRINT_HARDWARE_MODULE_ID),chipsailing.fingerprint)
+		PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/Android6/chipsailing.fingerprint.default.so:system/lib/hw/chipsailing.fingerprint.default.so			
+	else
+		PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/Android6/fingerprint.default.so:system/lib/hw/fingerprint.default.so			
+	endif
+endif
+
+ifeq ($(strip $(ANDROID_VERSION)), Android7)
+	PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/Android7/libfp_hal.so:system/lib/libfp_hal.so
+	ifeq ($(FINGERPRINT_HARDWARE_MODULE_ID),chipsailing.fingerprint)
+		PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/Android7/chipsailing.fingerprint.default.so:system/lib/hw/chipsailing.fingerprint.default.so
+	else
+		PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/Android7/fingerprint.default.so:system/lib/hw/fingerprint.default.so
+	endif
+endif
+	
+ifeq ($(strip $(TEE_PLATFORM)), rsee)
+	PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/rsee/libfp_tac.so:system/lib/libfp_tac.so
+	
+	ifeq ($(strip $(CHIPS_IS_COATING)), true)
+		PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/rsee/coating_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta:system/lib/sec_modules/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
+	else 
+		PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/rsee/glass_ta/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta:system/lib/sec_modules/8aaaf200-2450-11e4-abe2-0002a5d5c51a.ta
+	endif
+endif
+
+ifeq ($(strip $(TEE_PLATFORM)), qsee)
+endif
+
+ifeq ($(strip $(TEE_PLATFORM)), isee)
+	PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/isee/libfp_tac.so:system/lib/libfp_tac.so
+endif
+
+ifeq ($(strip $(TEE_PLATFORM)), trustkernel)
+	PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/trustkernel/libfp_tac.so:system/lib/libfp_tac.so
+	
+	ifeq ($(strip $(CHIPS_IS_COATING)), true)
+		PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/trustkernel/coating_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta:system/app/t6/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
+	else 
+		PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/trustkernel/glass_ta/8aaaf200-2450-11e4-abe20002a5d5c51a.ta:system/app/t6/8aaaf200-2450-11e4-abe20002a5d5c51a.ta
+	endif
+endif
+
+ifeq ($(strip $(TEE_PLATFORM)), trustonic)
+	PRODUCT_COPY_FILES += $(CS_LOCAL_PATH)/32-bit/trustonic/libfp_tac.so:system/lib/libfp_tac.so
+endif
+
+PRODUCT_COPY_FILES += device/chipsailing/init.csfinger.rc:root/init.csfinger.rc
+
+
+ifeq ($(strip $(CS_IC_SENSOR)), 358)
+	include $(CS_LOCAL_PATH)/config/cs_cfg_358_glass.mk
+endif
+ifeq ($(strip $(CS_IC_SENSOR)), 3511)
+	include $(CS_LOCAL_PATH)/config/cs_cfg_3511_coating.mk
+endif
+ifeq ($(strip $(CS_IC_SENSOR)), 3716)
+	include $(CS_LOCAL_PATH)/config/cs_cfg_358_glass.mk
+endif
+ifeq ($(strip $(CS_IC_SENSOR)), 3711)
+	include $(CS_LOCAL_PATH)/config/cs_cfg_3711_coating.mk
+endif
+ifeq ($(strip $(CS_IC_SENSOR)), 336)	
+	include $(CS_LOCAL_PATH)/config/cs_cfg_336_glass.mk
+endif
+ifeq ($(strip $(CS_IC_SENSOR)), 351)
+	include $(CS_LOCAL_PATH)/config/cs_cfg_351_glass.mk
+endif
+ifeq ($(strip $(CS_IC_SENSOR)), 3516)
+	include $(CS_LOCAL_PATH)/config/cs_cfg_3516_glass.mk
+endif
+ifeq ($(strip $(CS_IC_SENSOR)), 356)
+	include $(CS_LOCAL_PATH)/config/cs_cfg_356_glass.mk
+endif
+ifeq ($(strip $(CS_IC_SENSOR)), 338)
+	include $(CS_LOCAL_PATH)/config/cs_cfg_338_glass.mk	
+endif
+
+

Property changes on: device/chipsailing/csfinger_product_32bit.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: device/chipsailing
===================================================================
--- device/chipsailing	(revision 0)
+++ device/chipsailing	(revision 2997)

Property changes on: device/chipsailing
___________________________________________________________________
Added: svn:mergeinfo
   Merged /L05A/Trunk/ALPS-MP-N1.MP18-V1_AUS6739_66_N1_INHOUSE/device/chipsailing:r2851
Index: device
===================================================================
--- device	(revision 2996)
+++ device	(revision 2997)

Property changes on: device
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /L05A/Trunk/ALPS-MP-N1.MP18-V1_AUS6739_66_N1_INHOUSE/device:r2850-2851
Index: kernel-4.4/arch/arm64/boot/dts/mediatek/aus6739_66_n1.dts
===================================================================
--- kernel-4.4/arch/arm64/boot/dts/mediatek/aus6739_66_n1.dts	(revision 2996)
+++ kernel-4.4/arch/arm64/boot/dts/mediatek/aus6739_66_n1.dts	(revision 2997)
@@ -895,7 +895,11 @@
 			vdd_ldo_enable = <1>;
 			vio_ldo_enable = <0>;
 			config_spi_pin = <1>;
-			netlink-event = <26>;			
+			netlink-event = <26>;
+			gpio-rst = <125>;
+			gpio-rst-std = <&pio 125 0x0>;
+			gpio-irq = <8>;
+			gpio-irq-std = <&pio 8 0x0>;
 			pinctrl-names = "spi_default","spi_cs_low","spi_cs_high","spi_mi_low","spi_mi_high",
 					"spi_mo_low","spi_mo_high","spi_mclk_low","spi_mclk_high",
 					"finger_rst_low","finger_rst_high",
Index: kernel-4.4/arch/arm64/boot/dts/mediatek/mt6739.dtsi
===================================================================
--- kernel-4.4/arch/arm64/boot/dts/mediatek/mt6739.dtsi	(revision 2996)
+++ kernel-4.4/arch/arm64/boot/dts/mediatek/mt6739.dtsi	(revision 2997)
@@ -1300,14 +1300,22 @@
 				<&topckgen CLK_TOP_SPI_SEL>,
 				<&infracfg_ao CLK_INFRA_SPI0>;
 		clock-names = "parent-clk", "sel-clk", "spi-clk";
-		finger: finger@0 {
+		
+		/* finger: finger@0 {
 			compatible = "cdfinger,fps1098";
 			reg = <0x0>;
 			spi-max-frequency = <6000000>;
 			status = "okay";
 			};
+		*/
+		finger: finger@0 {
+			compatible = "mediatek,cs_finger";
+			reg = <0x0>;
+			spi-max-frequency = <6000000>;
+			status = "okay";
+			};
 		};
-
+		
 	spi1: spi@11010000 {
 		compatible = "mediatek,mt6739-spi";
 		#address-cells = <1>;
Index: kernel-4.4/drivers/input/Makefile
===================================================================
--- kernel-4.4/drivers/input/Makefile	(revision 2996)
+++ kernel-4.4/drivers/input/Makefile	(revision 2997)
@@ -26,6 +26,7 @@
 obj-$(CONFIG_INPUT_MISC)	+= misc/
 obj-$(CONFIG_MTK_FINGERPRINT_SUPPORT)  += fingerprint/
 obj-y  += cdfinger/
+obj-y  += chipsailing/
 
 obj-$(CONFIG_INPUT_APMPOWER)	+= apm-power.o
 obj-$(CONFIG_INPUT_KEYRESET)	+= keyreset.o
Index: kernel-4.4/drivers/input/Kconfig
===================================================================
--- kernel-4.4/drivers/input/Kconfig	(revision 2996)
+++ kernel-4.4/drivers/input/Kconfig	(revision 2997)
@@ -215,6 +215,7 @@
 source "drivers/input/misc/Kconfig"
 source "drivers/input/fingerprint/Kconfig"
 source "drivers/input/cdfinger/Kconfig"
+source "drivers/input/chipsailing/Kconfig"
 
 endif
 
Index: kernel-4.4/drivers/input/cdfinger/cdfinger-mtk-tee.c
===================================================================
--- kernel-4.4/drivers/input/cdfinger/cdfinger-mtk-tee.c	(revision 2996)
+++ kernel-4.4/drivers/input/cdfinger/cdfinger-mtk-tee.c	(revision 2997)
@@ -42,9 +42,9 @@
 
 
 
-
+#define COMPAT_VENDOR
 #ifdef COMPAT_VENDOR
-#include "fp_vendor.h"
+#include <fp_vendor.h>
 #endif
 
 
@@ -211,8 +211,8 @@
 		goto parse_err;
 	}
 #ifdef DTS_PROBE
-	cdfinger->spi->dev.of_node = of_find_compatible_node(NULL,NULL,"cdfinger,fps1098");
-	//cdfinger->spi->dev.of_node = of_find_compatible_node(NULL,NULL,"mediatek,mtk_finger");
+	//cdfinger->spi->dev.of_node = of_find_compatible_node(NULL,NULL,"cdfinger,fps1098");
+	cdfinger->spi->dev.of_node = of_find_compatible_node(NULL,NULL,"mediatek,cs_finger");
 #endif
 
 	//cdfinger->vdd_ldo_enable = 0;
@@ -332,7 +332,7 @@
 
 	return ret;
 }
-#if 0
+#if 1
 static int spi_send_cmd(struct cdfinger_data *cdfinger,  u8 *tx, u8 *rx, u16 spilen)
 {
 	struct spi_message m;
@@ -876,7 +876,7 @@
 };
 struct of_device_id cdfinger_of_match[] = {
 	{ .compatible = "cdfinger,fps998e", },
-	{ .compatible = "cdfinger,fps1098", },
+	{ .compatible = "mediatek,cs_finger", },
 	{ .compatible = "cdfinger,fps998", },
 	{ .compatible = "cdfinger,fps980", },
 	{ .compatible = "cdfinger,fps956", },
Index: kernel-4.4/drivers/input/cdfinger/Makefile
===================================================================
--- kernel-4.4/drivers/input/cdfinger/Makefile	(revision 2996)
+++ kernel-4.4/drivers/input/cdfinger/Makefile	(revision 2997)
@@ -4,6 +4,6 @@
 ccflags-y += -I$(srctree)/drivers/misc/mediatek/
 ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat/$(MTK_PLATFORM)/include
 ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat/
-
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/teei/V1.0/tz_vfs/
 #obj-y += cdfinger.o
 obj-y += cdfinger-mtk-tee.o
Index: kernel-4.4/drivers/input/chipsailing/cf_ctl.c
===================================================================
--- kernel-4.4/drivers/input/chipsailing/cf_ctl.c	(revision 0)
+++ kernel-4.4/drivers/input/chipsailing/cf_ctl.c	(revision 2997)
@@ -0,0 +1,1316 @@
+/**
+ * ChipSailing Fingerprint sensor device driver
+ *
+ * This driver will control the platform resources that the ChipSailing fingerprint
+ * sensor needs to operate. The major things are probing the sensor to check
+ * that it is actually connected and let the Kernel know this and with that also
+ * enabling and disabling of regulators, enabling and disabling of platform
+ * clocks, controlling GPIOs such as SPI chip select, sensor reset line, sensor
+ * IRQ line, MISO and MOSI lines.
+ *
+ * The driver will expose most of its available functionality in sysfs which
+ * enables dynamic control of these features from eg. a user space process.
+ *
+ * The sensor's IRQ events will be pushed to Kernel's event handling system and
+ * are exposed in the drivers event node. This makes it possible for a user
+ * space process to poll the input node and receive IRQ events easily. Usually
+ * this node is available under /dev/input/eventX where 'X' is a number given by
+ * the event system. A user space process will need to traverse all the event
+ * nodes and ask for its parent's name (through EVIOCGNAME) which should match
+ * the value in device tree named input-device-name.
+ *
+ * This driver will NOT send any SPI commands to the sensor it only controls the
+ * electrical parts.
+ *
+ *
+ * Copyright (C) 2016 chipsailing Corporation. <http://www.chipsailing.com>
+ * Copyright (C) 2016 XXX <mailto:xxx@chipsailing.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+ * Public License for more details.
+ **/
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/of.h>
+#include <linux/err.h>
+#include <linux/of_platform.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/gpio.h>
+#include <linux/of_irq.h>
+#include <linux/input.h>
+#if defined(CONFIG_FB)
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#endif
+
+#include "cf_ctl.h"
+
+#if defined(BEANPOD)
+#include <fp_vendor.h>
+#endif
+
+
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+/* Early-suspend level */
+#define FT_SUSPEND_LEVEL 1
+#endif
+
+
+
+#define MODULE_NAME "cf_ctl"
+#ifndef CONFIG_OF
+# error "error: this driver 'MODULE_NAME' only support dts."
+#endif
+
+#define ANDROID_WAKELOCK 1
+#if ANDROID_WAKELOCK
+#include <linux/wakelock.h>
+#endif
+
+#define CF_RESET_LOW_US      1000
+#define CF_RESET_HIGH1_US    100
+#define PWR_ON_STEP_SLEEP    100
+#define PWR_ON_STEP_RANGE1   100
+#define PWR_ON_STEP_RANGE2   900
+#define CF_TTW_HOLD_TIME     1000
+
+extern int mtk_spi_clk_ctl(struct spi_device *spi, bool enable);
+
+typedef enum {
+	CF_PIN_STATE_RST_HIGH,
+	CF_PIN_STATE_RST_LOW,
+	CF_PIN_STATE_INT,
+	CF_PIN_STATE_CLK_HIGH,
+	CF_PIN_STATE_CLK_LOW,
+	CF_PIN_STATE_CS_HIGH,
+	CF_PIN_STATE_CS_LOW,
+	CF_PIN_STATE_MI_HIGH,
+	CF_PIN_STATE_MI_LOW,
+	CF_PIN_STATE_MO_HIGH,
+	CF_PIN_STATE_MO_LOW,
+	CF_PIN_STATE_POWER_HIGH,
+	CF_PIN_STATE_POWER_LOW,
+
+	/* Array size */
+	CF_PIN_STATE_MAX
+} cf_pin_state_t;
+
+static const char *const pctl_names[] = {
+	"finger_rst_high",
+	"finger_rst_low",
+	"eint",
+	"spi_mclk_high",
+	"spi_mclk_low",
+	"spi_cs_high",
+	"spi_cs_low",
+	"spi_mi_high",
+	"spi_mi_low",
+	"spi_mo_high",
+	"spi_mo_low",
+	"fp_pwr_high",
+	"fp_pwr_low"
+};
+
+struct vreg_config {
+	char *name;
+	unsigned long vmin;
+	unsigned long vmax;
+	int ua_load;
+};
+
+static const struct vreg_config const vreg_conf[] = {
+	{ "vdd_io", 1800000UL, 1800000UL, 6000, },
+};
+
+
+/**
+ * Define the driver version string.
+ * There is NO need to modify 'rXXXX_yyyymmdd', it should be updated automatically
+ * by the building script (see the 'Driver-revision' section in 'build.sh').
+ */
+#define CF_DRV_VERSION "v1.9.1-rXXXX_20160502"
+
+struct cf_device {
+	struct device *dev;
+	struct spi_device *spi;
+	struct cdev     cdev;
+	struct class *class;
+	struct device *device;
+	dev_t             devno;
+	struct pinctrl *fingerprint_pinctrl;
+	struct pinctrl_state *pinctrl_state[CF_PIN_STATE_MAX];
+	struct clk *iface_clk;
+	struct clk *core_clk;
+	struct regulator *vreg[ARRAY_SIZE(vreg_conf)];
+	struct input_dev *input;
+	struct fasync_struct *async;
+	struct work_struct work_queue;
+	struct platform_device *pf_dev;
+
+	/*struct mt_chip_conf spi_mcc;*/
+
+#if defined(CONFIG_FB)
+	struct notifier_block fb_notify;
+#endif
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	struct early_suspend early_suspend;
+#endif
+
+	struct wake_lock ttw_wl;
+	int irq;
+	int irq_gpio;
+	int rst_gpio;
+	int pwr_gpio;
+	int qup_id;
+	struct mutex lock;
+	spinlock_t spin_lock;
+	bool prepared;
+	atomic_t wakeup_enabled;
+	bool irq_enabled;
+	bool clocks_enabled;
+	bool clocks_suspended;
+	bool isPowerOn;
+	u8 *buf;
+};
+
+/**************************debug******************************/
+#define ERR_LOG  (0)
+#define INFO_LOG (1)
+#define DEBUG_LOG (2)
+
+/* debug log setting */
+u8 cf_debug_level = DEBUG_LOG;
+
+#define cf_debug(level, fmt, args...) do { \
+	if (cf_debug_level >= level) {\
+		printk("[chipsailing]%s line:%d  "fmt, __func__, __LINE__, ##args);\
+	} \
+} while (0)
+
+#define FUNC_ENTRY()  cf_debug(DEBUG_LOG, "entry\n")
+#define FUNC_EXIT()  cf_debug(DEBUG_LOG, "exit\n")
+
+/*************************************************************/
+# if 0
+static int vreg_setup(struct cf_device *cf_dev, const char *name, bool enable)
+{
+	size_t i;
+	int rc;
+	struct regulator *vreg;
+	struct device *dev = cf_dev->dev;
+
+	for (i = 0; i < ARRAY_SIZE(cf_dev->vreg); i++) {
+		const char *n = vreg_conf[i].name;
+
+		if (!strncmp(n, name, strlen(n)))
+			goto found;
+	}
+	cf_debug(ERR_LOG, "Regulator %s not found\n", name);
+	return -EINVAL;
+
+found:
+	vreg = cf_dev->vreg[i];
+	if (enable) {
+		if (!vreg) {
+			vreg = regulator_get(dev, name);
+			if (IS_ERR(vreg)) {
+				cf_debug(ERR_LOG, "Unable to get %s\n", name);
+				return PTR_ERR(vreg);
+			}
+		}
+		if (regulator_count_voltages(vreg) > 0) {
+			rc = regulator_set_voltage(vreg, vreg_conf[i].vmin,
+					vreg_conf[i].vmax);
+			if (rc)
+				cf_debug(ERR_LOG, "Unable to set voltage on %s, %d\n", name, rc);
+		}
+		rc = regulator_set_optimum_mode(vreg, vreg_conf[i].ua_load);
+		if (rc < 0)
+			cf_debug(ERR_LOG, "Unable to set current on %s, %d\n", name, rc);
+
+		rc = regulator_enable(vreg);
+		if (rc) {
+			cf_debug(ERR_LOG, "error enabling %s: %d\n", name, rc);
+			regulator_put(vreg);
+			vreg = NULL;
+		}
+		cf_dev->vreg[i] = vreg;
+
+	} else {
+		if (vreg) {
+			if (regulator_is_enabled(vreg)) {
+				regulator_disable(vreg);
+				cf_debug(ERR_LOG, "disabled %s\n", name);
+			}
+			regulator_put(vreg);
+			cf_dev->vreg[i] = NULL;
+		}
+		rc = 0;
+	}
+	return rc;
+}
+#endif
+
+
+static int select_pinctl(struct cf_device *cf_dev, cf_pin_state_t state)
+{
+	int rc;
+
+	rc = pinctrl_select_state(cf_dev->fingerprint_pinctrl, cf_dev->pinctrl_state[state]);
+	if (rc)
+		cf_debug(INFO_LOG, "pinctrl_select_state(..) '%s' fail\n", pctl_names[state]);
+	else
+		cf_debug(INFO_LOG, "pinctrl_select_state(..) '%s' pass\n", pctl_names[state]);
+
+	return rc;
+}
+
+
+static int hw_reset(struct cf_device *cf_dev)
+{
+	int irq_gpio;
+	int rst_gpio;
+
+	int rc = select_pinctl(cf_dev, CF_PIN_STATE_RST_HIGH);
+
+	if (rc)
+		goto exit;
+	usleep_range(CF_RESET_HIGH1_US, CF_RESET_HIGH1_US + 100);
+
+	rc = select_pinctl(cf_dev, CF_PIN_STATE_RST_LOW);
+	if (rc)
+		goto exit;
+	usleep_range(CF_RESET_LOW_US, CF_RESET_LOW_US + 100);
+
+	rc = select_pinctl(cf_dev, CF_PIN_STATE_RST_HIGH);
+	if (rc)
+		goto exit;
+	usleep_range(CF_RESET_HIGH1_US, CF_RESET_HIGH1_US + 100);
+
+	irq_gpio = gpio_get_value(cf_dev->irq_gpio);
+	rst_gpio = gpio_get_value(cf_dev->rst_gpio);
+	cf_debug(INFO_LOG, "IRQ after reset %d\n", irq_gpio);
+	cf_debug(INFO_LOG, "RST after reset %d\n", rst_gpio);
+
+exit:
+	return rc;
+}
+
+
+/**
+ * sysf node to check the interrupt status of the sensor, the interrupt
+ * handler should perform sysf_notify to allow userland to poll the node.
+ */
+static ssize_t irq_get(struct device *device,
+		struct device_attribute *attribute,
+		char *buffer)
+{
+	struct cf_device *cf_dev = dev_get_drvdata(device);
+	int irq = gpio_get_value(cf_dev->irq_gpio);
+
+	return scnprintf(buffer, PAGE_SIZE, "%i\n", irq);
+}
+
+
+/**
+ * writing to the irq node will just drop a printk message
+ * and return success, used for latency measurement.
+ */
+static ssize_t irq_ack(struct device *device,
+		struct device_attribute *attribute,
+		const char *buffer, size_t count)
+{
+	cf_debug(INFO_LOG, "irq_ack\n");
+	return count;
+}
+static DEVICE_ATTR(irq, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP, irq_get, irq_ack);
+
+static struct attribute *attributes[] = {
+	&dev_attr_irq.attr,
+	NULL
+};
+
+static const struct attribute_group attribute_group = {
+	.attrs = attributes,
+};
+
+static void cf_disable_irq(struct cf_device *cf_dev)
+{
+	FUNC_ENTRY();
+
+	if (cf_dev->irq_enabled) {
+		disable_irq_nosync(cf_dev->irq);
+		cf_dev->irq_enabled = false;
+	}
+}
+
+
+static void cf_enable_irq(struct cf_device *cf_dev)
+{
+	FUNC_ENTRY();
+
+	if (!cf_dev->irq_enabled) {
+		enable_irq(cf_dev->irq);
+		cf_dev->irq_enabled = true;
+	}
+}
+
+static void cf_spi_disable_clk(struct cf_device *cf_dev)
+{
+#if defined(BEANPOD)
+	mtk_spi_clk_ctl(cf_dev->spi, 0);
+#else
+	CF_debug(INFO_LOG, "not implemented!\n");
+#endif
+}
+
+static void cf_spi_enable_clk(struct cf_device *cf_dev)
+{
+#if defined(BEANPOD)
+	mtk_spi_clk_ctl(cf_dev->spi, 1);
+#else
+	CF_debug(INFO_LOG, "not implemented!\n");
+#endif
+}
+
+static void cf_device_event(struct work_struct *ws)
+{
+	struct cf_device *cf_dev = container_of(ws, struct cf_device, work_queue);
+
+	FUNC_ENTRY();
+	sysfs_notify(&cf_dev->pf_dev->dev.kobj, NULL, dev_attr_irq.attr.name);
+}
+
+static irqreturn_t cf_irq_handler(int irq, void *dev_id)
+{
+	struct cf_device *cf_dev = (struct cf_device *)dev_id;
+
+	FUNC_ENTRY();
+
+	/* Make sure 'wakeup_enabled' is updated before using it
+	** since this is interrupt context (other thread...) */
+	smp_rmb();
+
+	if (atomic_read(&cf_dev->wakeup_enabled))
+		wake_lock_timeout(&cf_dev->ttw_wl, msecs_to_jiffies(CF_TTW_HOLD_TIME));
+
+	schedule_work(&cf_dev->work_queue);
+
+	return IRQ_HANDLED;
+}
+
+static int cf_request_named_gpio(struct cf_device *cf_dev,
+		const char *label, int *gpio)
+{
+	int rc;
+	struct device *dev = cf_dev->dev;
+	struct device_node *np = dev->of_node;
+
+	rc = of_get_named_gpio(np, label, 0);
+	if (rc < 0) {
+		cf_debug(ERR_LOG, "failed to get '%s'\n", label);
+		return rc;
+	}
+
+	*gpio = rc;
+	if (gpio_is_valid(*gpio)) {
+		rc = gpio_request(*gpio, label);
+		if (rc) {
+			cf_debug(ERR_LOG, "failed to request gpio %d\n", *gpio);
+			return rc;
+		}
+
+	} else {
+		cf_debug(ERR_LOG, "not valid gpio: %d\n", *gpio);
+		rc = -EIO;
+		return rc;
+	}
+
+	cf_debug(ERR_LOG, "%s %d\n", label, *gpio);
+	return 0;
+}
+
+static int cf_gpio_init(struct cf_device *cf_dev)
+{
+	int rc;
+
+	rc = cf_request_named_gpio(cf_dev, "gpio-irq-std",
+		&cf_dev->irq_gpio);
+	if (rc)
+		goto exit;
+	rc = cf_request_named_gpio(cf_dev, "gpio-rst-std",
+		&cf_dev->rst_gpio);
+	if (rc)
+		goto exit;
+	/*
+	rc = cf_request_named_gpio(cf_dev, "chipsailing,gpio_pwr",
+		&cf_dev->pwr_gpio);
+	if (rc)
+		goto exit;
+	*/
+exit:
+	return rc;
+}
+
+/*power management*/
+static int cf_power_on(struct cf_device *cf_dev)
+{
+	int rc = select_pinctl(cf_dev, CF_PIN_STATE_POWER_HIGH);
+
+	cf_dev->isPowerOn = true;
+	msleep(20);
+	cf_debug(ERR_LOG, "power on\n");
+	return rc;
+}
+
+static int cf_power_off(struct cf_device *cf_dev)
+{
+	int rc = select_pinctl(cf_dev, CF_PIN_STATE_POWER_LOW);
+
+	cf_dev->isPowerOn = false;
+	msleep(20);
+	cf_debug(ERR_LOG, "power off\n");
+	return rc;
+}
+
+static int cf_gpio_deinit(struct cf_device *cf_dev)
+{
+	int rc = 0;
+
+	if (gpio_is_valid(cf_dev->irq_gpio))
+		gpio_free(cf_dev->irq_gpio);
+
+	if (gpio_is_valid(cf_dev->rst_gpio))
+		gpio_free(cf_dev->rst_gpio);
+
+	return rc;
+}
+
+static int cf_pinctrl_look_up_states(struct cf_device *cf_dev)
+{
+	int rc = 0;
+	size_t i;
+	struct device *dev = cf_dev->dev;
+
+	cf_dev->fingerprint_pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR(cf_dev->fingerprint_pinctrl)) {
+		cf_debug(ERR_LOG, "Target does not use pinctrl\n");
+		cf_dev->fingerprint_pinctrl = NULL;
+		rc = -EINVAL;
+		goto exit;
+	}
+
+	for (i = 0; i < CF_PIN_STATE_MAX; i++) {
+		const char *n = pctl_names[i];
+
+		struct pinctrl_state *state = pinctrl_lookup_state(cf_dev->fingerprint_pinctrl, n);
+
+		if (IS_ERR(state)) {
+			cf_debug(ERR_LOG, "cannot find '%s'\n", n);
+			rc = -EINVAL;
+			goto exit;
+		}
+
+		cf_debug(INFO_LOG, "found pin control %s\n", n);
+		cf_dev->pinctrl_state[i] = state;
+	}
+
+exit:
+	return rc;
+}
+
+
+static int cf_irq_init(struct cf_device *cf_dev)
+{
+	int rc;
+	int irqf;
+	struct device *dev = cf_dev->dev;
+	struct device_node *np = dev->of_node;
+	u32 ints[2];
+
+	irqf = IRQF_TRIGGER_RISING | IRQF_ONESHOT;
+	if (of_property_read_bool(np, "chipsailing,enable-wakeup")) {
+		irqf |= IRQF_NO_SUSPEND;
+		device_init_wakeup(dev, 1);
+	}
+
+	select_pinctl(cf_dev, CF_PIN_STATE_INT);
+	if (np) {
+		rc = of_property_read_u32_array(np, "debounce", ints, ARRAY_SIZE(ints));
+		if (rc == 0) {
+			cf_debug(ERR_LOG, "gpio_set_debounce\n");
+			gpio_set_debounce(ints[0], ints[1]);
+		}
+
+		cf_dev->irq = irq_of_parse_and_map(np, 0);
+		if (!cf_dev->irq) {
+			cf_debug(ERR_LOG, "irq_of_parse_and_map(..) fail\n");
+			rc = -EINVAL;
+			goto exit;
+		}
+
+	} else {
+		cf_debug(ERR_LOG, "device node is null\n");
+		rc = -ENODEV;
+		goto exit;
+	}
+
+	rc = devm_request_threaded_irq(dev, cf_dev->irq, NULL, cf_irq_handler, irqf, "cf_irq", cf_dev);
+	if (rc) {
+		cf_debug(ERR_LOG, "could not request irq %d\n", cf_dev->irq);
+		goto exit;
+	}
+
+	enable_irq_wake(cf_dev->irq);
+
+exit:
+	return rc;
+}
+
+
+static int cf_input_init(struct cf_device *cf_dev)
+{
+	int rc;
+
+	FUNC_ENTRY();
+
+	cf_dev->input = input_allocate_device();
+	if (!cf_dev->input) {
+		cf_debug(ERR_LOG, "input_allocate_device(..) fail\n");
+		return (-ENOMEM);
+	}
+
+	cf_dev->input->name = "cf-keys";
+	__set_bit(EV_KEY, cf_dev->input->evbit);
+	__set_bit(KEY_HOME, cf_dev->input->keybit);
+	__set_bit(KEY_MENU, cf_dev->input->keybit);
+	__set_bit(KEY_BACK, cf_dev->input->keybit);
+	__set_bit(KEY_F18, cf_dev->input->keybit);
+	__set_bit(KEY_F19, cf_dev->input->keybit);
+	__set_bit(KEY_F20, cf_dev->input->keybit);
+	__set_bit(KEY_F21, cf_dev->input->keybit);
+	__set_bit(KEY_ENTER, cf_dev->input->evbit);
+	__set_bit(KEY_UP, cf_dev->input->keybit);
+	__set_bit(KEY_LEFT, cf_dev->input->keybit);
+	__set_bit(KEY_RIGHT, cf_dev->input->keybit);
+	__set_bit(KEY_DOWN, cf_dev->input->keybit);
+	__set_bit(KEY_WAKEUP, cf_dev->input->keybit);
+
+	rc = input_register_device(cf_dev->input);
+	if (rc) {
+		cf_debug(ERR_LOG, "input_register_device fail\n");
+		input_free_device(cf_dev->input);
+		cf_dev->input = NULL;
+		return (-ENODEV);
+	}
+
+	FUNC_EXIT();
+	return rc;
+}
+
+
+static int cf_reset_gpio_set_value(struct cf_device *cf_dev, unsigned char th)
+{
+	int rc;
+
+	FUNC_ENTRY();
+
+	if (!!th)
+		rc = select_pinctl(cf_dev, CF_PIN_STATE_RST_HIGH);
+	else
+		rc = select_pinctl(cf_dev, CF_PIN_STATE_RST_LOW);
+
+	return rc;
+}
+
+static int cf_report_key_event(struct input_dev *input, cf_key_event_t *kevent)
+{
+	int rc = 0;
+	unsigned int key_code = KEY_UNKNOWN;
+
+	FUNC_ENTRY();
+
+	switch (kevent->key) {
+	case CF_KEY_HOME:
+		key_code = KEY_HOME;
+		break;
+	case CF_KEY_MENU:
+		key_code = KEY_MENU;
+		break;
+	case CF_KEY_BACK:
+		key_code = KEY_BACK;
+		break;
+	case CF_KEY_DOWNUP:
+		key_code = KEY_F18;
+		break;
+	case CF_KEY_ONETAP:
+		key_code = KEY_F19;
+		break;
+	case CF_KEY_DOUBLETAP:
+		key_code = KEY_F20;
+		break;
+	case CF_KEY_LONGTOUCH:
+		key_code = KEY_F21;
+		break;
+	case CF_KEY_ENTER:
+		key_code = KEY_ENTER;
+		break;
+	case CF_KEY_UP:
+		key_code = KEY_UP;
+		break;
+	case CF_KEY_LEFT:
+		key_code = KEY_LEFT;
+		break;
+	case CF_KEY_RIGHT:
+		key_code = KEY_RIGHT;
+		break;
+	case CF_KEY_DOWN:
+		key_code = KEY_DOWN;
+		break;
+	case CF_KEY_WAKEUP:
+		key_code = KEY_WAKEUP;
+		break;
+
+	default:
+		break;
+	}
+
+	if (kevent->value == 2) {
+		input_report_key(input, key_code, 1);
+		input_sync(input);
+		input_report_key(input, key_code, 0);
+		input_sync(input);
+	} else {
+		input_report_key(input, key_code, kevent->value);
+		input_sync(input);
+	}
+
+	FUNC_EXIT();
+	return rc;
+}
+
+
+static const char *cf_get_version(void)
+{
+	static char version[CF_DRV_VERSION_LEN] = {'\0', };
+
+	strncpy(version, CF_DRV_VERSION, CF_DRV_VERSION_LEN);
+	version[CF_DRV_VERSION_LEN - 1] = '\0';
+	return (const char *)version;
+}
+
+
+static int cf_open(struct inode *inode, struct file *file)
+{
+	struct cf_device *cf_dev;
+
+	FUNC_ENTRY();
+	cf_dev = container_of(inode->i_cdev, struct cf_device, cdev);
+	file->private_data = cf_dev;
+	return 0;
+}
+
+static int cf_release(struct inode *inode, struct file *file)
+{
+	FUNC_ENTRY();
+	return 0;
+}
+
+static ssize_t cf_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)
+{
+	struct cf_device *cf_dev = file->private_data;
+
+	FUNC_ENTRY();
+	hw_reset(cf_dev);
+
+	cf_debug(INFO_LOG, "irq_gpio = %d, goio_to_irq = %d, irq = %d\n", cf_dev->irq_gpio, gpio_to_irq(cf_dev->irq_gpio), cf_dev->irq);
+	cf_debug(INFO_LOG, "rst_gpio_value = %d, irq_gpio_value = %d\n", gpio_get_value(cf_dev->rst_gpio), gpio_get_value(cf_dev->irq_gpio));
+	FUNC_EXIT();
+	return count;
+}
+
+static long cf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+
+	struct cf_device *cf_dev = NULL;
+	int err = 0;
+	unsigned char th = 0;
+	cf_key_event_t kevent;
+
+	cf_dev = file->private_data;
+	FUNC_ENTRY();
+
+	if (_IOC_TYPE(cmd) != CF_IOC_MAGIC)
+		return -ENOTTY;
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+	if (err == 0 && _IOC_DIR(cmd)&_IOC_WRITE)
+		err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+	if (err)
+		return -EFAULT;
+
+	mutex_lock(&cf_dev->lock);
+	switch (cmd) {
+	case CF_IOC_INIT_GPIO: {
+		cf_debug(INFO_LOG, "CF_IOC_INIT_GPIO\n");
+		err = cf_gpio_init(cf_dev);
+		break;
+	}
+
+	case CF_IOC_DEINIT_GPIO: {
+		cf_debug(INFO_LOG, "CF_IOC_DEINIT_GPIO\n");
+		err = cf_gpio_deinit(cf_dev);
+		break;
+	}
+
+	case CF_IOC_RESET_DEVICE: {
+		cf_debug(INFO_LOG, "CF_IOC_RESET_DEVICE\n");
+		if (__get_user(th, (u8 __user *)arg)) {
+			cf_debug(ERR_LOG, "copy_from_user(..) fail\n");
+			err = (-EFAULT);
+			break;
+		}
+
+		cf_reset_gpio_set_value(cf_dev, th);
+		break;
+	}
+
+	case CF_IOC_ENABLE_IRQ: {
+		cf_debug(INFO_LOG, "CF_IOC_ENABLE_IRQ\n");
+		cf_enable_irq(cf_dev);
+		break;
+	}
+
+	case CF_IOC_DISABLE_IRQ: {
+		cf_debug(INFO_LOG, "CF_IOC_DISABLE_IRQ\n");
+		cf_disable_irq(cf_dev);
+		break;
+	}
+
+	case CF_IOC_REQ_IRQ: {
+		cf_debug(INFO_LOG, "CF_IOC_REQ_IRQ\n");
+		err = cf_irq_init(cf_dev);
+		break;
+	}
+
+	case CF_IOC_ENABLE_SPI_CLK: {
+		cf_spi_enable_clk(cf_dev);
+		cf_debug(INFO_LOG, "CF_IOC_ENABLE_SPI_CLK\n");
+		break;
+	}
+
+	case CF_IOC_DISABLE_SPI_CLK: {
+		cf_spi_disable_clk(cf_dev);
+		cf_debug(INFO_LOG, "CF_IOC_DISABLE_SPI_CLK\n");
+		break;
+	}
+
+	case CF_IOC_ENABLE_POWER: {
+		cf_debug(INFO_LOG, "CF_IOC_ENABLE_POWER\n");
+		err = cf_power_on(cf_dev);
+		break;
+	}
+
+	case CF_IOC_DISABLE_POWER: {
+		cf_debug(INFO_LOG, "CF_IOC_DISABLE_POWER\n");
+		err = cf_power_off(cf_dev);
+		break;
+	}
+
+	case CF_IOC_REPORT_KEY_EVENT: {
+		if (copy_from_user(&kevent, (cf_key_event_t *)arg, sizeof(cf_key_event_t))) {
+			cf_debug(ERR_LOG, "copy_from_user(..) failed\n");
+			err = (-EFAULT);
+			break;
+		}
+
+		err = cf_report_key_event(cf_dev->input, &kevent);
+		break;
+	}
+
+	case CF_IOC_GET_VERSION: {
+		if (copy_to_user((void *)arg, cf_get_version(), CF_DRV_VERSION_LEN)) {
+			cf_debug(ERR_LOG, "copy_to_user(..) failed\n");
+			err = (-EFAULT);
+			break;
+		}
+
+		break;
+	}
+
+	default:
+		err = (-EINVAL);
+		break;
+
+	}
+
+	mutex_unlock(&cf_dev->lock);
+	return err;
+}
+
+static int cf_fasync(int fd, struct file *fp, int mode)
+{
+	struct cf_device *cf_dev;
+
+	FUNC_ENTRY();
+	cf_dev = fp->private_data;
+	return fasync_helper(fd, fp, mode, &cf_dev->async);
+}
+
+static const struct file_operations cf_fops = {
+	.owner			= THIS_MODULE,
+	.open			= cf_open,
+	.release		= cf_release,
+	.unlocked_ioctl	= cf_ioctl,
+	.fasync         = cf_fasync,
+	.write          = cf_write,
+};
+
+
+#if 0
+static struct mt_chip_conf cf_spi_conf = {
+	.setuptime = 7,
+	.holdtime = 7,
+	.high_time = 16,
+	.low_time = 17,
+	.cs_idletime = 3,
+	.rx_mlsb = 1,
+	.tx_mlsb = 1,
+	.tx_endian = 0,
+	.rx_endian = 0,
+	.cpol = 0,
+	.cpha = 0,
+	.com_mod = FIFO_TRANSFER,
+	.pause = 0,
+	.finish_intr = 1,
+	.deassert = 0,
+	.ulthigh = 0,
+	.tckdly = 0,
+};
+#endif
+
+static struct spi_board_info spi_fp_board_info[] __initdata = {
+	[0] = {
+		.modalias = "FP_DEV_NAME",
+		.bus_num = 0,
+		.chip_select = 0,
+		.mode = SPI_MODE_0,
+		/*.controller_data = &cf_spi_conf, //&spi_conf*/
+	},
+};
+
+/* -------------------------------------------------------------------- */
+/* cf_spi_setup, configure spi speed and transfer mode in REE mode
+ *
+ * speed: 1, 4, 6, 8 unit:MHz
+ * mode: DMA mode or FIFO mode
+ */
+
+#if 0
+void cf_spi_setup(struct spi_device *spi, u32 speed, enum spi_transfer_mode mode)
+{
+	struct mt_chip_conf *mcc = &cf_spi_conf;
+
+	switch (speed) {
+	case 1:
+		/* set to 1MHz clock */
+		mcc->high_time = 50;
+		mcc->low_time = 50;
+		break;
+	case 4:
+		/* set to 4MHz clock */
+		mcc->high_time = 15;
+		mcc->low_time = 15;
+		break;
+	case 6:
+		/* set to 6MHz clock */
+		mcc->high_time = 10;
+		mcc->low_time = 10;
+		break;
+	case 8:
+		/* set to 8MHz clock */
+		mcc->high_time = 8;
+		mcc->low_time = 8;
+		break;
+	default:
+		/* default set to 1MHz clock */
+		mcc->high_time = 50;
+		mcc->low_time = 50;
+		break;
+	}
+
+	if ((mode == DMA_TRANSFER) || (mode == FIFO_TRANSFER))
+		mcc->com_mod = mode;
+	else
+		mcc->com_mod = FIFO_TRANSFER;
+
+	spi->controller_data = (void *)mcc;
+
+	if (spi_setup(spi))
+		cf_debug(ERR_LOG, "spi_setup(..)fail\n");
+}
+#endif
+
+
+#if defined(CONFIG_FB)
+static int fb_notifier_callback(struct notifier_block *self, unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+	struct cf_device *cf_dev = container_of(self, struct cf_device, fb_notify);
+
+	if (evdata && evdata->data && cf_dev) {
+
+		if (event == FB_EVENT_BLANK) {
+			blank = evdata->data;
+
+			if (*blank == FB_BLANK_UNBLANK)
+				cf_debug(INFO_LOG, "LCD on\n");
+
+			else if (*blank == FB_BLANK_POWERDOWN)
+				cf_debug(INFO_LOG, "LCD off\n");
+		}
+	}
+
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+static void cf_early_suspend(struct early_suspend *handler)
+{
+	struct cf_device *cf_dev = container_of(handler, struct cf_device, early_suspend);
+
+	cf_debug(INFO_LOG, "LCD off-3");
+}
+
+static void cf_late_resume(struct early_suspend *handler)
+{
+	struct cf_device *cf_dev = container_of(handler, struct cf_device, early_suspend);
+
+	cf_debug(INFO_LOG, "LCD on-3");
+}
+#endif
+
+static int get_and_check_chipid(struct cf_device *cf_dev)
+{
+	int rc;
+	uint8_t rx[2];
+
+	rc = cf_sfr_read(cf_dev->spi, 0x3e, &rx[0], 2);
+	if (rc != 0)
+		return 0;
+
+	if (rx[0] == 0x62 && rx[1] == 0xa0)
+		return 1;
+	else if (rx[0] == 0x31 && rx[1] == 0x01)
+		return 1;
+	else if (rx[0] == 0x31 && rx[1] == 0x06)
+		return 1;
+
+	cf_debug(ERR_LOG, "cf_check_chipid failed, rx[0] %x, rx[1] %x\n", rx[0], rx[1]);
+
+	return 0;
+
+}
+static int cf_probe(struct spi_device *spi)
+{
+	int rc = 0;
+	int ret = 0;
+	struct cf_device *cf_dev;
+	struct device *dev;
+
+	FUNC_ENTRY();
+
+	dev = &spi->dev;
+
+	cf_dev = devm_kzalloc(dev, sizeof(*cf_dev), GFP_KERNEL);
+	if (!cf_dev) {
+		cf_debug(ERR_LOG, "failed to allocate memory for struct cf_device\n");
+		rc = -ENOMEM;
+		goto exit;
+	}
+
+	cf_dev->dev = &spi->dev;
+	dev_set_drvdata(dev, cf_dev);
+	cf_dev->spi = spi;
+
+#if 0
+	cf_dev->spi->mode            = SPI_MODE_0;
+	cf_dev->spi->bits_per_word   = 8;
+	cf_dev->spi->max_speed_hz    = 1 * 1000 * 1000;
+	cf_dev->spi->controller_data = (void *)&cf_spi_conf;
+	spi_setup(cf_dev->spi);
+#endif
+
+
+#if defined(FP_VENDOR_HAL_COMPAT)
+	cf_debug(INFO_LOG, "do not request gpio\n");
+#else
+	rc = cf_gpio_init(cf_dev);
+	if (rc)
+		cf_debug(ERR_LOG, "Failed to get gpio\n");
+
+#endif
+
+	/*printk("  chipsailing start parse dts 20171115  ");*/
+	rc = cf_pinctrl_look_up_states(cf_dev);
+	if (rc)
+		goto exit;
+
+	rc = select_pinctl(cf_dev, CF_PIN_STATE_CLK_LOW);
+	if (rc)
+		goto exit;
+	rc = select_pinctl(cf_dev, CF_PIN_STATE_CS_LOW);
+	if (rc)
+		goto exit;
+	rc = select_pinctl(cf_dev, CF_PIN_STATE_MI_LOW);
+	if (rc)
+		goto exit;
+	rc = select_pinctl(cf_dev, CF_PIN_STATE_MO_LOW);
+	if (rc)
+		goto exit;
+
+#if defined(FP_VENDOR_HAL_COMPAT)
+	cf_debug(INFO_LOG, "do not power on\n");
+#else
+	/*printk("  chipsailing start power on 20171115   ");*/
+	rc = cf_power_on(cf_dev);
+	if (rc)
+		cf_debug(ERR_LOG, "Failed to power on\n");
+#endif
+
+	/*vreg_setup(cf_dev, "vdd_io", true);*/
+
+#if defined(FP_VENDOR_HAL_COMPAT)
+	cf_debug(INFO_LOG, "do not reset in kernel space\n");
+#else
+	/*printk("  chipsailing start reset 20171115  ");*/
+	hw_reset(cf_dev);
+#endif
+
+#if defined(BEANPOD)
+	cf_spi_enable_clk(cf_dev);
+
+	ret = get_fp_spi_enable();
+	if(ret == 1){
+		ret = get_and_check_chipid(cf_dev);
+		if(ret == 1){
+			set_fp_vendor(FP_VENDOR_CHIPSAILING);
+		} else {
+			cf_debug(ERR_LOG, "vednor is not chipsailing\n");
+			cf_spi_disable_clk(cf_dev);
+			return -1;
+		}
+	} else {
+		cf_debug(ERR_LOG, "get_fp_spi_enable failed\n");
+		cf_spi_disable_clk(cf_dev);
+		return -1;
+	}
+	cf_spi_disable_clk(cf_dev);
+	cf_debug(ERR_LOG, "vendor is chipsailing\n");
+#endif
+
+	/*printk("  chipsailing start creat node 20171115  ");*/
+	cf_dev->class = class_create(THIS_MODULE, FP_CLASS_NAME);
+	rc = alloc_chrdev_region(&cf_dev->devno, 0, 1, FP_DEV_NAME);
+	if (rc) {
+		cf_debug(ERR_LOG, "alloc_chrdev_region failed, error = %d\n", rc);
+		goto exit;
+	}
+	cf_dev->device = device_create(cf_dev->class, NULL, cf_dev->devno, NULL, "%s", FP_DEV_NAME);
+	cdev_init(&cf_dev->cdev, &cf_fops);
+	cf_dev->cdev.owner = THIS_MODULE;
+
+	rc = cdev_add(&cf_dev->cdev, cf_dev->devno, 1);
+	if (rc) {
+		cf_debug(ERR_LOG, "cdev_add failed, error = %d\n", rc);
+		goto exit;
+	}
+
+
+	cf_dev->clocks_enabled = false;
+	cf_dev->clocks_suspended = false;
+
+	mutex_init(&cf_dev->lock);
+	spin_lock_init(&cf_dev->spin_lock);
+	wake_lock_init(&cf_dev->ttw_wl, WAKE_LOCK_SUSPEND, "cf_ttw_wl");
+
+	atomic_set(&cf_dev->wakeup_enabled, 1);
+
+	INIT_WORK(&cf_dev->work_queue, cf_device_event);
+
+	cf_dev->pf_dev = platform_device_alloc(FP_DEV_NAME, -1);
+	if (!cf_dev->pf_dev) {
+		rc = -ENOMEM;
+		cf_debug(ERR_LOG, "platform_device_alloc failed\n");
+		goto exit;
+	}
+	rc = platform_device_add(cf_dev->pf_dev);
+
+	if (rc) {
+		cf_debug(ERR_LOG, "platform_device_add failed\n");
+		platform_device_del(cf_dev->pf_dev);
+		goto exit;
+
+	} else {
+		dev_set_drvdata(&cf_dev->pf_dev->dev, cf_dev);
+
+		rc = sysfs_create_group(&cf_dev->pf_dev->dev.kobj, &attribute_group);
+
+		if (rc) {
+			cf_debug(ERR_LOG, "sysfs_create_group failed\n");
+			goto exit;
+		}
+	}
+
+#if defined(FP_VENDOR_HAL_COMPAT)
+	cf_debug(INFO_LOG, "do not request irq in kernel space\n");
+#else
+	rc = cf_irq_init(cf_dev);
+	if (rc) {
+		cf_debug(ERR_LOG, "could not request irq\n");
+		goto exit;
+	}
+#endif
+
+	rc = cf_input_init(cf_dev);
+	if (rc) {
+		cf_debug(ERR_LOG, "could not register input\n");
+		goto exit;
+	}
+
+#if defined(CONFIG_FB)
+	cf_dev->fb_notify.notifier_call = fb_notifier_callback;
+	fb_register_client(&cf_dev->fb_notify);
+#endif
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	cf_dev->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN +
+		FT_SUSPEND_LEVEL;
+	cf_dev->early_suspend.suspend = cf_early_suspend;
+	cf_dev->early_suspend.resume = cf_late_resume;
+	register_early_suspend(&cf_dev->early_suspend);
+#endif
+
+	FUNC_EXIT();
+
+exit:
+	return rc;
+}
+
+static int cf_remove(struct spi_device *spi)
+{
+	struct cf_device *cf_dev = dev_get_drvdata(&spi->dev);
+
+#if defined(CONFIG_HAS_EARLYSUSPENDCONFIG_HAS_EARLYSUSPEND)
+	unregister_early_suspend(&cf_dev->early_suspend);
+#endif
+
+#if defined(CONFIG_FB)
+	if (cf_dev->fb_notify.notifier_call) {
+		cf_dev->fb_notify.notifier_call = NULL;
+		fb_unregister_client(&cf_dev->fb_notify);
+	}
+#endif
+
+	sysfs_remove_group(&cf_dev->pf_dev->dev.kobj, &attribute_group);
+	mutex_destroy(&cf_dev->lock);
+	wake_lock_destroy(&cf_dev->ttw_wl);
+
+	/*vreg_setup(cf_dev, "vdd_io", false);*/
+	cf_power_off(cf_dev);
+	FUNC_EXIT();
+	return 0;
+}
+
+static int cf_suspend(struct device *dev)
+{
+	cf_debug(INFO_LOG, "LCD off-2\n");
+	return 0;
+}
+
+static int cf_resume(struct device *dev)
+{
+	cf_debug(INFO_LOG, "LCD on-2\n");
+	return 0;
+}
+
+static const struct dev_pm_ops cf_pm_ops = {
+	.suspend = cf_suspend,
+	.resume = cf_resume,
+};
+
+
+static struct of_device_id cf_of_match[] = {
+	{ .compatible = "mediatek,cs_finger", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, cf_of_match);
+
+static struct spi_driver cf_driver = {
+	.driver = {
+		.name	= "FP_DEV_NAME",
+		.owner	= THIS_MODULE,
+		.of_match_table = cf_of_match,
+		.pm = &cf_pm_ops,
+	},
+	.probe	= cf_probe,
+	.remove	= cf_remove,
+};
+
+
+static int __init cf_driver_init(void)
+{
+	int rc;
+
+	FUNC_ENTRY();
+
+	spi_register_board_info(spi_fp_board_info, ARRAY_SIZE(spi_fp_board_info));
+
+	rc = spi_register_driver(&cf_driver);
+	if (!rc)
+		cf_debug(ERR_LOG, "spi_register_driver(..) pass\n");
+	else
+		cf_debug(ERR_LOG, "spi_register_driver(..) fail, error = %d\n", rc);
+
+	return rc;
+}
+
+static void __exit cf_driver_exit(void)
+{
+	FUNC_ENTRY();
+	spi_unregister_driver(&cf_driver);
+}
+
+module_init(cf_driver_init);
+module_exit(cf_driver_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("zwp@chipsailing.com");
+MODULE_DESCRIPTION("ChipSailing Fingerprint sensor device driver.");

Property changes on: kernel-4.4/drivers/input/chipsailing/cf_ctl.c
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: kernel-4.4/drivers/input/chipsailing/Makefile
===================================================================
--- kernel-4.4/drivers/input/chipsailing/Makefile	(revision 0)
+++ kernel-4.4/drivers/input/chipsailing/Makefile	(revision 2997)
@@ -0,0 +1,8 @@
+MTK_PLATFORM := $(subst ",,$(CONFIG_MTK_PLATFORM))
+ccflags-y += -I$(srctree)/drivers/spi/mediatek/$(MTK_PLATFORM)
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/include
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat/$(MTK_PLATFORM)/include
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/teei/V1.0/tz_vfs/
+
+obj-y += cf_ctl.o cf_spi.o

Property changes on: kernel-4.4/drivers/input/chipsailing/Makefile
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: kernel-4.4/drivers/input/chipsailing/Kconfig
===================================================================
--- kernel-4.4/drivers/input/chipsailing/Kconfig	(revision 0)
+++ kernel-4.4/drivers/input/chipsailing/Kconfig	(revision 2997)
@@ -0,0 +1,12 @@
+#
+#Fingerprint
+#
+
+config MTK_CDFINGER
+	tristate "Mediatek chipsailing"
+	default n
+	---help---
+	Fingerprint mtk driver enable/disable in the kernel.
+	Say Y here if you want to use mediatek fingerprint driver,
+	fingerprint driver will support fingerprint function in REE,
+	it supports fpsensor device.

Property changes on: kernel-4.4/drivers/input/chipsailing/Kconfig
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: kernel-4.4/drivers/input/chipsailing/cf_ctl.h
===================================================================
--- kernel-4.4/drivers/input/chipsailing/cf_ctl.h	(revision 0)
+++ kernel-4.4/drivers/input/chipsailing/cf_ctl.h	(revision 2997)
@@ -0,0 +1,123 @@
+/**
+ * User space driver API for chipsailing's fingerprint device.
+ * ATTENTION: Do NOT edit this file unless the corresponding driver changed.
+ *
+ * Copyright (C) 2016 chipsailing Corporation. <http://www.chipsailingcorp.com>
+ * Copyright (C) 2016 XXX <mailto:xxx@chipsailingcorp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+ * Public License for more details.
+ **/
+
+#ifndef __CF_CTRL_API_H__
+#define __CF_CTRL_API_H__
+
+/* Device node. */
+#define FP_DEV_NAME      "cs_spi"
+#define FP_CLASS_NAME    "fpsensor"
+
+/* Max driver version buffer length. */
+#define CF_DRV_VERSION_LEN 32
+
+/*#define FP_VENDOR_HAL_COMPAT*/
+
+#define BEANPOD
+
+/*#include <mt_spi.h>*/
+
+typedef enum {
+	CF_KEY_NONE = 0,
+	CF_KEY_HOME,
+	CF_KEY_MENU,
+	CF_KEY_BACK,
+	CF_KEY_DOWNUP,
+	CF_KEY_ONETAP,
+	CF_KEY_DOUBLETAP,
+	CF_KEY_LONGTOUCH,
+	CF_KEY_ENTER,
+	CF_KEY_UP,
+	CF_KEY_LEFT,
+	CF_KEY_RIGHT,
+	CF_KEY_DOWN,
+	CF_KEY_WAKEUP,
+} cf_key_type_t;
+
+typedef struct {
+	cf_key_type_t key;
+	int value; /* for key type, 0 means up, 1 means down. */
+} cf_key_event_t;
+
+struct param {
+	unsigned char cmd;
+	unsigned short addr;
+	unsigned short data;
+};
+
+struct config {
+	struct param *p_param;
+	int num;
+};
+
+struct cf_ioc_transfer {
+	unsigned char cmd;
+	unsigned short addr;
+	unsigned char *buf;
+	unsigned short actual_len;
+};
+
+/*SPI protocol*/
+#define CHIPS_W_SRAM 0xAA
+#define CHIPS_R_SRAM 0xBB
+#define CHIPS_W_SFR  0xCC
+#define CHIPS_R_SFR  0xDD
+
+
+/* Magic code for IOCTL-subsystem, 'k' means 'chipsailing'. */
+#define CF_IOC_MAGIC 'k'
+
+/* Androind system-wide key event, for navigation purpose. */
+#define CF_IOC_REPORT_KEY_EVENT _IOW(CF_IOC_MAGIC, 7, cf_key_event_t *)
+
+/* HW reset the fingerprint module. */
+#define CF_IOC_RESET_DEVICE     _IOW(CF_IOC_MAGIC, 8, unsigned char)
+
+/*HW sensor spi read/write*/
+#define CF_IOC_SPI_MESSAGE	         _IOWR(CF_IOC_MAGIC, 9, struct cf_ioc_transfer)
+#define CF_IOC_SPI_CMD               _IOW(CF_IOC_MAGIC, 10, unsigned char)
+
+/* Low-level IRQ control. */
+#define CF_IOC_ENABLE_IRQ       _IO(CF_IOC_MAGIC, 11)
+#define CF_IOC_DISABLE_IRQ      _IO(CF_IOC_MAGIC, 12)
+#define CF_IOC_SENSOR_CONFIG    _IOW(CF_IOC_MAGIC, 13, void*)
+
+/* Allocate/Release driver resource (GPIO/SPI etc.). */
+#define CF_IOC_INIT_GPIO        _IO(CF_IOC_MAGIC, 0x13)
+#define CF_IOC_REQ_IRQ          _IO(CF_IOC_MAGIC, 0x14)
+#define CF_IOC_DEINIT_GPIO      _IO(CF_IOC_MAGIC, 0x15)
+
+
+/* Sync 'cf_driver_config_t', the driver configuration. */
+#define CF_IOC_SYNC_CONFIG      _IOWR(CF_IOC_MAGIC, 0x0a, void *)
+
+/* Query the driver version string. */
+#define CF_IOC_GET_VERSION      _IOR(CF_IOC_MAGIC, 0x20, const char *)
+
+/* SPI bus clock control, for power-saving purpose. */
+#define CF_IOC_ENABLE_SPI_CLK   _IO(CF_IOC_MAGIC, 0x30)
+#define CF_IOC_DISABLE_SPI_CLK  _IO(CF_IOC_MAGIC, 0x40)
+
+/* Fingerprint module power control. */
+#define CF_IOC_ENABLE_POWER     _IO(CF_IOC_MAGIC, 0x50)
+#define CF_IOC_DISABLE_POWER    _IO(CF_IOC_MAGIC, 0x60)
+
+//extern void cf_spi_setup(struct spi_device *spi, u32 speed, enum spi_transfer_mode mode);
+int cf_sfr_read(struct spi_device *spi, unsigned short addr, unsigned char *recv_buf, unsigned short buflen);
+
+#endif /* __CF_CTRL_API_H__ */

Property changes on: kernel-4.4/drivers/input/chipsailing/cf_ctl.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: kernel-4.4/drivers/input/chipsailing/cf_spi.c
===================================================================
--- kernel-4.4/drivers/input/chipsailing/cf_spi.c	(revision 0)
+++ kernel-4.4/drivers/input/chipsailing/cf_spi.c	(revision 2997)
@@ -0,0 +1,318 @@
+/**
+ * User space driver API for chipsailing's fingerprint device.
+ * ATTENTION: Do NOT edit this file unless the corresponding driver changed.
+ *
+ * Copyright (C) 2016 chipsailing Corporation. <http://www.chipsailing.com>
+ * Copyright (C) 2016 XXX <mailto:xxx@chipsailing.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+ * Public License for more details.
+**/
+
+#include <linux/spi/spi.h>
+#include "cf_ctl.h"
+
+#define MTK_SPI_ALIGN_MASK_NUM  10
+#define MTK_SPI_ALIGN_MASK  ((0x1 << MTK_SPI_ALIGN_MASK_NUM) - 1)
+#define	SPI_BUFSIZ	32
+
+
+static void cf_spi_complete(void *arg)
+{
+	complete(arg);
+}
+
+DEFINE_SPINLOCK(mr_lock);
+static int cf_sync_read_and_write(struct spi_device *spi, struct spi_message *message)
+{
+
+	DECLARE_COMPLETION_ONSTACK(done);
+	int rc;
+
+	if (NULL == spi || NULL == message) {
+		pr_err("chipsailing: invalid arguments\n");
+		return -EINVAL;
+	}
+
+	message->complete = cf_spi_complete;
+	message->context = &done;
+
+	spin_lock_irq(&mr_lock);
+	if (NULL == spi) {
+		rc = -ESHUTDOWN;
+		pr_err("chipsailing: device is null\n");
+		goto exit;
+	}
+
+	rc = spi_async(spi, message);
+	spin_unlock_irq(&mr_lock);
+
+	if (rc) {
+		pr_err("chipsailing: fail to async message, error = %d\n", rc);
+		goto exit;
+	}
+
+	wait_for_completion(&done);
+	rc = message->status;
+
+exit:
+	return rc;
+}
+
+
+static unsigned char buf[SPI_BUFSIZ] = {0};
+
+static int cf_spi_read_and_write(struct spi_device *spi, void *txbuf, unsigned n_tx, void *rxbuf, unsigned n_rx)
+{
+	static DEFINE_MUTEX(lock);
+
+	int			rc;
+	struct spi_message	message;
+	struct spi_transfer x = {0};
+	unsigned char *local_buf;
+	uint32_t package_num = 0;
+	uint32_t remainder = 0;
+	uint32_t packet_size = 0;
+
+	/* Use preallocated DMA-safe buffer if we can.  We can't avoid
+	* copying here, (as a pure convenience thing), but we can
+	* keep heap costs out of the hot path unless someone else is
+	* using the pre-allocated buffer or the transfer is too large.
+	*/
+
+	if (NULL == spi) {
+		pr_err("chipsailing: invalid argument\n");
+		rc = -EINVAL;
+		goto exit;
+	}
+
+#if 0
+	/*switch to DMA if bytes larger than 32*/
+	if ((n_tx + n_rx + 1) > 32)
+		cf_spi_setup(spi, 0, DMA_TRANSFER);
+#endif
+
+	package_num = (n_tx + n_rx) >> MTK_SPI_ALIGN_MASK_NUM;
+	remainder = (n_tx + n_rx) & MTK_SPI_ALIGN_MASK;
+
+	if ((package_num > 0) && (remainder != 0))
+		packet_size = ((package_num + 1) << MTK_SPI_ALIGN_MASK_NUM);
+	else
+		packet_size = n_tx + n_rx;
+
+	if (packet_size > SPI_BUFSIZ || !mutex_trylock(&lock)) {
+
+		local_buf = kmalloc(max((unsigned)SPI_BUFSIZ, packet_size), GFP_KERNEL);
+
+		if (NULL == local_buf) {
+			pr_err("chipsailing: short of mem\n");
+			rc =  -ENOMEM;
+			goto exit;
+		}
+
+	} else
+		local_buf = buf;
+
+	spi_message_init(&message);
+
+	memset(&x, 0, sizeof(x));
+	memcpy(local_buf, txbuf, n_tx);
+
+	x.cs_change = 0;
+	x.delay_usecs = 1;
+	x.speed_hz = 7000000;
+	x.tx_buf = local_buf;
+	x.rx_buf = local_buf;
+	x.len = packet_size;
+
+	spi_message_add_tail(&x, &message);
+	rc = cf_sync_read_and_write(spi, &message);
+	if (rc)
+		pr_err("chipsailing: fail to sync message, error = %d", rc);
+
+	memcpy(rxbuf, local_buf+n_tx, n_rx);
+
+#if 0
+	/*switch back to FIFO after DMA transfer*/
+	if ((n_tx + n_rx + 1) > 32)
+		cf_spi_setup(spi, 0, FIFO_TRANSFER);
+#endif
+
+	if (x.tx_buf == buf)
+		mutex_unlock(&lock);
+	else
+		kfree(local_buf);
+
+exit:
+	return rc;
+}
+
+
+int cf_sfr_read(struct spi_device *spi, unsigned short addr, unsigned char *recv_buf, unsigned short buflen)
+{
+	int rc = -1;
+	unsigned char tx_buf[2] = {0};
+
+	tx_buf[0] = CHIPS_R_SFR;
+	tx_buf[1] = (unsigned char)(addr & 0x00FF);
+
+	rc = cf_spi_read_and_write(spi, tx_buf, 2, recv_buf, buflen);
+	if (rc)
+		pr_err("chipsailing: fail to read sfr,error = %d\n", rc);
+
+	return rc;
+}
+
+
+int cf_sfr_write(struct spi_device *spi, unsigned short addr, unsigned char *send_buf, unsigned short buflen)
+{
+	unsigned char *tx_buf = NULL;
+	int rc;
+
+	tx_buf = kmalloc(buflen+2, GFP_KERNEL);
+	if (NULL == tx_buf) {
+		pr_err("chipsailing: short of mem\n");
+		rc = -ENOMEM;
+		goto exit;
+	}
+
+	tx_buf[0] = CHIPS_W_SFR;
+	tx_buf[1] = (unsigned char)(addr & 0x00FF);
+	memcpy(tx_buf+2, send_buf, buflen);
+
+	rc = cf_spi_read_and_write(spi, tx_buf, buflen+2, NULL, 0);
+	if (rc)
+		pr_err("chipsailing: cf_spi_read_and_write fail, error = %d\n", rc);
+
+exit:
+	if (NULL != tx_buf) {
+		kfree(tx_buf);
+		tx_buf = NULL;
+	}
+
+	return rc;
+}
+
+
+int cf_sram_read(struct spi_device *spi, unsigned short addr, unsigned char *recv_buf, unsigned short buflen)
+{
+	unsigned char tx_buf[3] = {0};
+	int rc;
+	unsigned char *rx_buf = NULL;
+
+	rx_buf = kmalloc(buflen+1, GFP_KERNEL);/*first nop*/
+	if (NULL == rx_buf) {
+		pr_err("chipsailing: short of mem\n");
+		rc = -ENOMEM;
+		goto exit;
+	}
+
+	tx_buf[0] = CHIPS_R_SRAM;
+	tx_buf[1] = (unsigned char)((addr & 0xFF00) >> 8);
+	tx_buf[2] = (unsigned char)(addr & 0x00FF);
+
+	rc = cf_spi_read_and_write(spi, tx_buf, 3, rx_buf, buflen+1);
+	if (rc) {
+		pr_err("chipsailing: cf_spi_read_and_write fail, error = %d\n", rc);
+		goto exit;
+	}
+
+	memcpy(recv_buf, rx_buf+1, buflen);
+
+exit:
+	if (NULL != rx_buf) {
+		kfree(rx_buf);
+		rx_buf = NULL;
+	}
+
+	return rc;
+}
+
+
+
+int cf_sram_write(struct spi_device *spi, unsigned short addr, unsigned char *send_buf, unsigned short buflen)
+{
+	unsigned char *tx_buf = NULL;
+	int rc;
+
+	tx_buf = kmalloc(buflen+3, GFP_KERNEL);
+	if (NULL == tx_buf) {
+		pr_err("chipsailing: short of mem\n");
+		rc = -ENOMEM;
+		goto exit;
+	}
+
+	tx_buf[0] = CHIPS_W_SRAM;
+	tx_buf[1] = (unsigned char)((addr & 0xFF00) >> 8);
+	tx_buf[2] = (unsigned char)(addr & 0x00FF);
+	memcpy(tx_buf+3, send_buf, buflen);
+
+	rc = cf_spi_read_and_write(spi, tx_buf, buflen+3, NULL, 0);
+	if (rc)
+		pr_err("chipsailing: cf_spi_read_and_write fail, error = %d\n", rc);
+
+exit:
+	if (NULL != tx_buf) {
+		kfree(tx_buf);
+		tx_buf = NULL;
+	}
+
+	return rc;
+}
+
+
+
+int cf_spi_cmd(struct spi_device *spi, unsigned char *cmd, unsigned short cmdlen)
+{
+	int rc;
+
+	rc = cf_spi_read_and_write(spi, cmd, cmdlen, NULL, 0);
+	if (rc)
+		pr_err("chipsailing: cf_spi_read_and_write fail, error = %d\n", rc);
+
+	return rc;
+}
+
+
+int cf_write_configs(struct spi_device *spi, struct param *p_param, int num)
+{
+	struct param param;
+	unsigned char val;
+	int i = 0;
+	int rc = 0;
+	unsigned char tx_buf[2] = {0};
+
+	for (i = 0; i < num; i++) {
+		param = p_param[i];
+
+		if (param.cmd == CHIPS_W_SFR) {
+			val = (unsigned char)(param.data&0x00FF);
+			rc = cf_sfr_write(spi, param.addr, &val, 1);
+			if (rc) {
+				pr_err("chipsailing: cf_sfr_write fail, error = %d", rc);
+				goto exit;
+			}
+			pr_err("chipsailing: param.cmd = %x,param.addr = %x,param.data = %x\n", param.cmd, param.addr, val);
+
+		} else if (param.cmd == CHIPS_W_SRAM) {
+			tx_buf[0] = (unsigned char)(param.data & 0x00FF);
+			tx_buf[1] = (unsigned char)((param.data & 0xFF00)>>8);
+			rc = cf_sram_write(spi, param.addr, tx_buf, 2);
+			if (rc) {
+				pr_err("chipsailing: cf_sfr_write fail, error = %d\n", rc);
+				goto exit;
+			}
+			pr_info("chipsailing: param.cmd = %x,param.addr = %x,param.data = %x\n", param.cmd, param.addr,  param.data);
+		}
+	}
+
+exit:
+	return rc;
+}

Property changes on: kernel-4.4/drivers/input/chipsailing/cf_spi.c
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: kernel-4.4/drivers/input/chipsailing/mt_spi_hal.h
===================================================================
--- kernel-4.4/drivers/input/chipsailing/mt_spi_hal.h	(revision 0)
+++ kernel-4.4/drivers/input/chipsailing/mt_spi_hal.h	(revision 2997)
@@ -0,0 +1,45 @@
+/*
+* Copyright (C) 2016 MediaTek Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+*/
+#ifndef __MT_SPI_HAL_H__
+#define __MT_SPI_HAL_H__
+
+#if !defined(CONFIG_MTK_CLKMGR)
+#include <linux/clk.h>
+#endif				/* !defined(CONFIG_MTK_CLKMGR) */
+#include <linux/wakelock.h>
+//#include <mt_spi.h>
+
+struct mt_spi_t {
+	struct platform_device *pdev;
+	void __iomem *regs;
+	int irq;
+	int running;
+	struct wake_lock wk_lock;
+	struct mt_chip_conf *config;
+	struct spi_master *master;
+
+	struct spi_transfer *cur_transfer;
+	struct spi_transfer *next_transfer;
+
+	spinlock_t lock;
+	struct list_head queue;
+#if !defined(CONFIG_MTK_CLKMGR)
+	struct clk *clk_main;	/* main clock for spi bus */
+#endif				/* !defined(CONFIG_MTK_CLKMGR) */
+};
+
+extern void mt_spi_enable_clk(struct mt_spi_t *ms);
+extern void mt_spi_disable_clk(struct mt_spi_t *ms);
+
+#endif
+

Property changes on: kernel-4.4/drivers/input/chipsailing/mt_spi_hal.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/system/security/keystore_soterutils/keystore_soterutils.cpp
===================================================================
--- vendor/mediatek/proprietary/system/security/keystore_soterutils/keystore_soterutils.cpp	(revision 2996)
+++ vendor/mediatek/proprietary/system/security/keystore_soterutils/keystore_soterutils.cpp	(revision 2997)
@@ -30,14 +30,16 @@
 
 std::vector<keymaster_key_param_t> acquireSoterParams(KeyStore *mKeyStore,
         const KeymasterArguments& params, const uid_t uid) {
-    std::vector<keymaster_key_param_t> opParams; // Do the copy from params manually
+    //std::vector<keymaster_key_param_t> opParams; // Do the copy from params manually
+	std::vector<keymaster_key_param_t> opParams(params.params); // Do the copy from params manually
     keymaster_key_param_t ask = {KM_TAG_INVALID, {0}};
 
-    ALOGE("acquireSoterParams() ++ ask_blob %p", ask_blob);
+    // ALOGE("acquireSoterParams() ++ ask_blob %p", ask_blob);
 
     for (std::vector<const keymaster_key_param_t>::iterator param = params.params.cbegin();
             param != params.params.cend(); ++param) {
-        if ((*param).tag == KM_TAG_SOTER_AUTO_SIGNED_COMMON_KEY_WHEN_GET_PUBLIC_KEY) {
+        //if ((*param).tag == KM_TAG_SOTER_AUTO_SIGNED_COMMON_KEY_WHEN_GET_PUBLIC_KEY) {
+		if ((*param).tag == KM_TAG_SOTER_AUTO_SIGNED_COMMON_KEY_WHEN_GET_PUBLIC_KEY && NULL != (*param).blob.data) {
             Blob keyBlob;
             String8 keyName(reinterpret_cast<const char*>((*param).blob.data), (*param).blob.data_length);
 
@@ -48,7 +50,7 @@
                 continue;
             }
 
-            ask.tag = KM_TAG_SOTER_AUTO_SIGNED_COMMON_KEY_WHEN_GET_PUBLIC_KEY;
+            ask.tag = KM_TAG_SOTER_AUTO_SIGNED_COMMON_KEY_WHEN_GET_PUBLIC_KEY_BLOB;
             if (ask_blob == NULL) {
                 ask_blob = (uint8_t*) malloc(keyBlob.getLength());
             } else {
@@ -60,20 +62,18 @@
             ask.blob.data_length = keyBlob.getLength();
 
             opParams.push_back(ask);
-        } else {
-            opParams.push_back(*param);
         }
     }
 
-    ALOGE("acquireSoterParams() -- ask_blob %p", ask_blob);
+    //ALOGE("acquireSoterParams() -- ask_blob %p", ask_blob);
     return opParams;
 }
 
 void releaseSoterParams(std::vector<keymaster_key_param_t>) {
-    ALOGE("releaseSoterParams() ++ ask_blob %p", ask_blob);
+    //ALOGE("releaseSoterParams() ++ ask_blob %p", ask_blob);
     if (ask_blob != NULL) {
         free(ask_blob);
         ask_blob = NULL;
     }
-    ALOGE("releaseSoterParams() -- ask_blob %p", ask_blob);
+   // ALOGE("releaseSoterParams() -- ask_blob %p", ask_blob);
 }
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/soter.raw
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/alipayapp
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/alipayapp
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/alipayapp	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/alipayapp	(revision 2997)

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/alipayapp
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/fp_server_chipsailing
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/fp_server_chipsailing
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/fp_server_chipsailing	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/fp_server_chipsailing	(revision 2997)

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/fp_server_chipsailing
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/init_thh
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/init_thh
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/init_thh	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/init_thh	(revision 2997)

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/init_thh
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/uTAgent
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/uTAgent
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/uTAgent	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/uTAgent	(revision 2997)

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/uTAgent
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/fp_server_cdfinger
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/fp_server_cdfinger
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/fp_server_cdfinger	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/fp_server_cdfinger	(revision 2997)

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/teei/fp_server_cdfinger
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/Android.mk
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/Android.mk	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/Android.mk	(revision 2997)
@@ -0,0 +1,52 @@
+LOCAL_PATH := $(call my-dir)
+
+# --------------------------------------------------
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := libifaa_daemon
+LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include
+LOCAL_C_INCLUDES += \
+	$(LOCAL_PATH)/include \
+	$(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
+
+LOCAL_SRC_FILES := \
+	src/IIfaaDaemon.cpp \
+
+LOCAL_SHARED_LIBRARIES := \
+	libcutils \
+	libutils \
+	libc \
+	libbinder \
+	libimsg_log
+
+PLATFORM_VERSION_MAJOR := $(word 1,$(subst .,$(space),$(PLATFORM_VERSION)))
+ifneq ($(PLATFORM_VERSION_MAJOR), 6)
+LOCAL_PROPRIETARY_MODULE := true
+endif
+
+include $(BUILD_SHARED_LIBRARY)
+
+# --------------------------------------------------
+include $(CLEAR_VARS)
+LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include
+LOCAL_C_INCLUDES += \
+	$(LOCAL_PATH)/include \
+	$(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
+
+LOCAL_SRC_FILES := \
+	src/IfaaDaemonProxy.cpp \
+	src/ifaad.cpp
+
+LOCAL_MODULE := ifaad
+LOCAL_SHARED_LIBRARIES := \
+	libbinder \
+	libifaa_daemon \
+	libutils \
+	libteeclientjni \
+	libimsg_log
+
+PLATFORM_VERSION_MAJOR := $(word 1,$(subst .,$(space),$(PLATFORM_VERSION))) 
+ifneq ($(PLATFORM_VERSION_MAJOR), 6)
+LOCAL_PROPRIETARY_MODULE := true
+endif
+include $(BUILD_EXECUTABLE)

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/Android.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/src/IIfaaDaemon.cpp
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/src/IIfaaDaemon.cpp	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/src/IIfaaDaemon.cpp	(revision 2997)
@@ -0,0 +1,131 @@
+#include <inttypes.h>
+#include <imsg_log.h>
+#include <binder/IPCThreadState.h>
+#include <binder/IServiceManager.h>
+#include <utils/String16.h>
+#include <utils/Looper.h>
+#include "IIfaaDaemon.h"
+
+namespace android {
+
+enum {
+    PROCESSCMD = IBinder::FIRST_CALL_TRANSACTION + 0,
+};
+
+class BpIfaaDaemon: public BpInterface<IIfaaDaemon>
+{
+public:
+    BpIfaaDaemon(const sp<IBinder>& impl)
+        : BpInterface<IIfaaDaemon>(impl)
+    {
+    }
+
+    virtual status_t processCmd(const uint8_t* param,
+            size_t paramLength,
+            uint8_t** resp,
+            size_t* respLength)
+    {
+        Parcel data, reply;
+        status_t ret = NO_ERROR;
+        if ((NULL == param) || (paramLength <= 0)
+                || (NULL == resp) || (NULL == respLength)) {
+            return BAD_VALUE;
+        }
+
+        *resp = NULL;
+        *respLength = 0;
+
+        ret = data.writeInterfaceToken(IIfaaDaemon::getInterfaceDescriptor());
+        if (NO_ERROR != ret) {
+			IMSG_ERROR("BpIfaaDaemon ERROR: writeInterfaceToken failed! ret = %d", ret);
+            return ret;
+        }
+
+        ret = data.writeByteArray(paramLength, param);
+        if (NO_ERROR != ret) {
+			IMSG_ERROR("BpIfaaDaemon ERROR: writeByteArray failed! ret = %d, length = %d, param = %s", ret, paramLength, param);
+            return ret;
+        }
+
+        ret = remote()->transact(PROCESSCMD, data, &reply);
+        if (NO_ERROR != ret) {
+			IMSG_ERROR("BpIfaaDaemon ERROR: transact(PROCESSCMD) failed! ret = %d", ret);
+            return ret;
+        }
+
+        uint32_t r_length = 0;
+        ret = reply.readUint32(&r_length);
+        if (NO_ERROR != ret) {
+			IMSG_ERROR("BpIfaaDaemon ERROR: readUint32 failed! ret = %d", ret);
+            return ret;
+        }
+
+        (*resp) = (uint8_t*) malloc(r_length);
+        ret = reply.read(*resp, r_length);
+        if (NO_ERROR != ret) {
+			IMSG_ERROR("BpIfaaDaemon ERROR: read failed! ret = %d", ret);
+            return ret;
+        }
+        *respLength = (size_t)r_length;
+
+        return NO_ERROR;
+    }
+
+};
+
+IMPLEMENT_META_INTERFACE(IfaaDaemon, "android.hardware.ifaa.IIfaaDaemon");
+
+// ----------------------------------------------------------------------
+status_t BnIfaaDaemon::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
+{
+    status_t ret = UNKNOWN_ERROR;
+	switch (code) {
+		case PROCESSCMD: {
+            CHECK_INTERFACE(IIfaaDaemon, data, reply);
+
+		    uint8_t* param = NULL;
+		    uint32_t length = data.readInt32();
+            if (!length) {
+                ret = BAD_VALUE;
+                IMSG_ERROR("BnIfaaDaemon ERROR: onTransact length == 0 !!");
+                goto release;
+            }
+
+            param = (uint8_t*) malloc(length);
+            if (NULL == param) {
+                ret = NO_MEMORY;
+                IMSG_ERROR("BnIfaaDaemon ERROR: malloc failed!");
+                goto release;
+            }
+            ret = data.read(param, length);
+            if (NO_ERROR == ret) {
+                /**
+                 * TODO:
+                 *    Invoke Proxy's processCmd()...
+                 */
+                uint8_t* r_param = NULL;
+                size_t r_length = 0;
+                processCmd(param, length, &r_param, &r_length);
+                ret = reply->writeByteArray(r_length, r_param);
+
+                if (r_param) {
+                    free (r_param);
+                }
+            }
+        release:
+            if (param) {
+                free (param);
+            }
+			IMSG_INFO("PROCESSCMD!!!!, flags = %d, ret = %d", flags, ret);
+			break;
+		 }
+    default:
+        ret = UNKNOWN_ERROR;
+        break;
+	}
+
+    return ret;
+}
+
+// ----------------------------------------------------------------------
+} // namespace android

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/src/IIfaaDaemon.cpp
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/src/ifaad.cpp
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/src/ifaad.cpp	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/src/ifaad.cpp	(revision 2997)
@@ -0,0 +1,21 @@
+#include <binder/IPCThreadState.h>
+#include <binder/IServiceManager.h>
+#include <binder/PermissionCache.h>
+#include <utils/String16.h>
+#include  "IfaaDaemonProxy.h"
+#include <imsg_log.h>
+
+int main() {
+	IMSG_INFO("Starting ifaad");
+	android::sp<android::IServiceManager> serviceManager = android::defaultServiceManager();
+	android::sp<android::IfaaDaemonProxy> proxy = android::IfaaDaemonProxy::getInstance();
+	android::status_t ret = serviceManager->addService(android::IfaaDaemonProxy::descriptor, proxy);
+	if (ret != android::OK) {
+		IMSG_ERROR("Could not register ifaad binder service!");
+		return -1;
+	}
+
+	android::IPCThreadState::self()->joinThreadPool();
+	IMSG_INFO("Done");
+	return 0;
+}

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/src/ifaad.cpp
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/src/IfaaDaemonProxy.cpp
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/src/IfaaDaemonProxy.cpp	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/src/IfaaDaemonProxy.cpp	(revision 2997)
@@ -0,0 +1,31 @@
+#include <imsg_log.h>
+#include <binder/IServiceManager.h>
+#include "IfaaDaemonProxy.h"
+#include <nativeTeeClient.h>
+
+namespace android {
+	IfaaDaemonProxy* IfaaDaemonProxy::sInstance = NULL;
+	IfaaDaemonProxy::IfaaDaemonProxy() {
+		IMSG_INFO("IfaaDaemonProxy instances");
+	}
+	IfaaDaemonProxy::~IfaaDaemonProxy() { }
+
+	status_t IfaaDaemonProxy::processCmd(const uint8_t* param, size_t paramLength, uint8_t** resp, size_t *respLength)
+	{
+		if (param == NULL || paramLength == 0 || resp == NULL || respLength == 0) {
+			IMSG_ERROR("parameter error");
+		}
+		IMSG_ERROR("Calling processCmd");
+		*respLength = 5120;
+        *resp = (unsigned char*)malloc(*respLength);
+		invoke_command((void*)param, paramLength, *resp, (uint32_t *)respLength);
+		return NO_ERROR;
+	}
+
+	void IfaaDaemonProxy::binderDied(const wp<IBinder>& who) {
+		if (who == who) {
+			IMSG_INFO("SKIP");
+		}
+	}
+
+}

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/src/IfaaDaemonProxy.cpp
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/include/IIfaaDaemon.h
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/include/IIfaaDaemon.h	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/include/IIfaaDaemon.h	(revision 2997)
@@ -0,0 +1,30 @@
+#ifndef IIFAA_DAEMON_H_
+#define IIFAA_DAEMON_H_
+
+#include <binder/IInterface.h>
+#include <binder/Parcel.h>
+
+namespace android {
+
+/*
+ * Abstract base class for native implementation of IFAA
+ */
+
+class IIfaaDaemon : public IInterface
+{
+	public:
+        DECLARE_META_INTERFACE(IfaaDaemon);
+
+		virtual status_t processCmd(const uint8_t* param,
+								size_t paramLength,
+								uint8_t** resp,
+								size_t* respLength) = 0;
+};
+
+class BnIfaaDaemon: public BnInterface<IIfaaDaemon> {
+	public:
+		virtual status_t onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags = 0);
+};
+
+}
+#endif

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/include/IIfaaDaemon.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/include/IfaaDaemonProxy.h
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/include/IfaaDaemonProxy.h	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/include/IfaaDaemonProxy.h	(revision 2997)
@@ -0,0 +1,28 @@
+#ifndef IFAA_DAEMON_PROXY_H_
+#define IFAA_DAEMON_PROXY_H_
+#include "IIfaaDaemon.h"
+
+namespace android {
+
+	class IfaaDaemonProxy : public BnIfaaDaemon {
+		public:
+			static IfaaDaemonProxy* getInstance() {
+				if (sInstance == NULL) {
+					sInstance = new IfaaDaemonProxy();
+				}
+				return sInstance;
+			}
+
+			//These reflect binder methods.
+			virtual status_t processCmd(const uint8_t* param,
+									size_t paramLength,
+									uint8_t** resp,
+									size_t* respLenght);
+		private:
+			IfaaDaemonProxy();
+			virtual ~IfaaDaemonProxy();
+			void binderDied(const wp<IBinder>& who);
+			static IfaaDaemonProxy* sInstance;
+	};
+} // namespace android
+#endif

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/ifaad/include/IfaaDaemonProxy.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/ifaa_common.h
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/ifaa_common.h	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/ifaa_common.h	(revision 2997)
@@ -0,0 +1,269 @@
+#ifndef IFAA_COMMON_H
+#define IFAA_COMMON_H
+#include "stdint.h"
+#include "stddef.h"
+#include <string.h>
+
+
+
+//是否开启测试模式
+#define __IFAA_TEST_MODE__
+
+
+#define IFAA_DEVICE_VENDOR 0xAAAA
+#define  IFAA_CHIP_VENDOR 0xBBBB
+#define IFAA_TEE_VENDOR 0xCCCC
+#define IFAA_SENSOR_VENDOR 0xDDDD
+
+
+
+#define EXTERNC_BEGIN  extern "C"{
+#define EXTERNC_END }
+#if defined(__cplusplus)
+#define EXTERNC extern "C"
+#else
+#define EXTERNC
+#endif  // defined(__cplusplus)
+
+
+
+#define SHA1_HASH_LEN 20
+#define SHA256_HASH_LEN 32
+#define RSA2048_LEN 256
+
+#define MAX_FILE_PATH 255
+
+#define HOTP_LEN 8
+#define KEY_ID_LEN 41
+#define DEVICE_ID_LEN 48//40
+#define MAX_FP_ID_COUNT 10
+#define __LEN_PORTOCAL_VERSION        4
+#define __LEN_INDEX             32 //  4
+#define __LEN_RSA2048           256
+#define __LEN_AUTH_VERSION      4
+#define __LEN_PUB_ALG_ENCODE    4
+#define __LEN_KEY_TYPE          4
+#define __LEN_SIGN_ALGORITHM    4
+#define __MAX_COUNT_ID_LIST     10
+#define __LEN_SHA256_DIGEST     32
+#define __MAX_CERT_LEVEL        4
+
+#define IFAA_RETURN_CODE(code)                \
+    if (ret != TEE_SUCCESS){                  \
+        return code;                          \
+    }                                         \
+    else{                                     \
+        return IFAA_ERR_SUCCESS;              \
+    }
+
+
+
+
+
+#ifndef NULL
+#ifdef __cplusplus
+#define NULL 0
+#else
+#define NULL ((void*)0)
+#endif
+#endif
+
+
+#if !defined(__cplusplus)
+typedef unsigned char bool;
+#define false ((bool)0)
+#define true  ((bool)1)
+#endif
+
+
+///////////////////////////////////////////////
+///// 客户端安全等级(从低到高)
+///////////////////////////////////////////////
+typedef enum {
+    //obligate
+    SECURITY_LEVEL_TA_PER_MODULE_   = 1 << 4,
+    SECURITY_LEVEL_RPMB_PER_MODULE  = 1 << 5,
+    SECURITY_LEVEL_RPMB_PER_DEVICE  = 1 << 6,
+    SECURITY_LEVEL_SE_PER_DEVICE    = 1 << 7,
+    //more in considering...
+} IFAA_SecureLevel;
+
+
+
+/**
+ * 入口函数接受的command
+ */
+typedef enum {
+    IFAA_TA_CMD_GET_DEVICE_ID           = 1 << 0,  //获取设备ID
+    IFAA_TA_CMD_REGISTER                = 1 << 1,  //注册
+    IFAA_TA_CMD_AUTHENTICATE            = 1 << 2,  //验证
+    IFAA_TA_CMD_DEREGISTER              = 1 << 3,  //注销
+    IFAA_TA_CMD_QUERY_STATUS            = 1 << 4,  //查询本地免密开通状态
+    IFAA_TA_CMD_GEN_ASYMMETRIC_KEY      = 1 << 5,  //预生成非对称秘钥
+    IFAA_TA_CMD_GET_PROTOCOL_VERSION    = 1 << 6,  //获取协议版本号
+	IFAA_TA_CMD_GET_CERT_ALG_ENCODE     = 1 << 7   //获取TA支持证书编码
+
+#ifdef __IFAA_TEST_MODE__
+    ,
+    /////文件操作
+    IFAA_TA_CMD_READ_FILE,                      //读文件
+    IFAA_TA_CMD_WRITE_FILE,                     //写文件
+    IFAA_TA_CMD_DELETE_FILE,                    //删除文件10
+
+    IFAA_GET_LAST_IDENTIFIED_RESULT,
+    IFAA_GET_AUTHENTICATOR_VERSION,
+    IFAA_GET_ID_LIST,
+    IFAA_BIO_ID_COMPARE,
+
+    IFAA_INTERNAL_SHA256,                       //SHA256
+    IFAA_INTERNAL_SIGN,                         //签名
+    IFAA_INTERNAL_VERIFY,                       //验证签名
+    IFAA_INTERNAL_KEY_GENERATE,                 //生成公私钥
+    IFAA_INTERNAL_HMAC_SHA1,                    //HmacSha1
+
+    IFAA_INTERNAL_AUTHENTICATOR_SIGN,           //校验器签名(可暂不实现)
+    IFAA_INTERNAL_AUTHENTICATOR_VERIFY         //校验器验签
+#endif
+} ifaa_ta_cmd;
+
+
+
+
+
+typedef enum {
+    IFAA_BIO_FINGERPRINT = 1 << 0,              //指纹
+    IFAA_BIO_IRIS        = 1 << 1,              //虹膜
+    IFAA_BIO_FACE        = 1 << 2,              //人脸
+    IFAA_BIO_UNKNOWN     = 1 << 31              //未知
+    //more
+} IFAA_BioType;
+#define IFAA_BioType_Total 3
+
+typedef enum {
+    IFAA_ENTRYLAST_IDENTIFIED_RESULT_GETTER     = 0x01, //获取最近一次认证通过的id
+    IFAA_ENTRY_AUTHENTICATOR_VERSION_GETTER,            //获取对应Authenticator的版本
+    IFAA_ENTRY_ID_LIST_GETTER,                          //获取系统中录入的生物特征的id列表
+    IFAA_ENTRY_EQUATOR                                 //生物特征id的比较符
+} IFAA_TaEntry;
+#define IFAA_ENTRY_TOTAL 4
+
+typedef enum {
+    IFAA_NO = 0,
+    IFAA_YES
+} IFAABoolean;
+
+
+typedef struct{
+    uint8_t* buf;
+    uint32_t len;
+} vlb_t;
+
+///////////////////////////////////////////////
+///// 证书编码格式
+///////////////////////////////////////////////
+
+typedef enum {
+    CERT_ENCODE_ALG_X509 = 0x01,    //X509格式
+    CERT_ENCODE_ALG_IFAA            //自定义格式，待后面算法评估
+    //more here...
+} IFAA_CertEncodeAlgorithm;
+
+
+
+
+
+typedef struct {
+    vlb_t n;
+    vlb_t d;
+    vlb_t e;
+} IFAA_RsaKey;
+// /**
+//  * IFAA山寨证书格式
+//  * +-----------------------------------+
+//  * | n_len | n | e_len | e | signature |
+//  * +-----------------------------------+
+//  */
+// typedef struct {
+//     /**
+//      * 公钥格式
+//      * +-----------------------+
+//      * | n_len | n | e_len | e |
+//      * +-----------------------+
+//      */
+//     vlb_t pub_key; //公钥buffer
+//     vlb_t s;       //签名
+// } IFAA_Certificate;
+
+
+
+
+///**
+// * IFAA自定义证书格式
+// * +----------------------------------------------------+
+// * | n_len |  n   | e_len |   e   | sig_len | signature |
+// * +-4bytes--------4bytes------------4bytes-------------+
+// */
+//typedef struct {
+//    /**
+//     * 公钥格式
+//     * +-----------------------+
+//     * | n_len | n | e_len | e |
+//     * +-4bytes-----4bytes-----+
+//     */
+//    vlb_t pub_key;      //公钥buffer
+//    vlb_t sig;          //签名
+//} IFAA_Certificate;
+
+
+/**
+ * 证书统一编码格式 tag-union
+ * +---------------------------------------+
+ * | cert_enc_alg | content of certificate |
+ * +----4 bytes----------------------------+
+ */
+typedef struct x509 x509; //forward declaration
+
+typedef struct {
+    IFAA_CertEncodeAlgorithm cert_enc_alg; //证书类型
+
+    union {
+         //////////////////////////////////////////////////
+         // IFAA自定义证书序列化格式
+         // +---------------------------------------------+
+         // | n_len | n | e_len | e | sig_len | signature |
+         // +---------------------------------------------+
+         //////////////////////////////////////////////////
+        struct {
+            /**
+             * 公钥序列化格式
+             * +-----------------------+
+             * | n_len | n | e_len | e |
+             * +-----------------------+
+             */
+            struct {
+                vlb_t n;    //大整数n
+                vlb_t e;    //大整数e
+            } pub_key;
+            vlb_t sig;      //签名
+        } ifaa_cert;
+
+        //////////////////////////////////////////////////
+        // X509标准证书,格式暂参考DER编码
+        //////////////////////////////////////////////////
+        struct {
+             vlb_t x509;
+             //x509 *certificate;
+        } x509_cert;
+
+        //more others...
+    } body;
+} IFAA_Certificate;
+
+
+typedef enum {
+    RSA_BITS_2048,
+    RSA_BITS_4096
+} IFAA_RsaBit;
+
+
+#endif

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/ifaa_common.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/JNIHelp.h
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/JNIHelp.h	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/JNIHelp.h	(revision 2997)
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * JNI helper functions.
+ *
+ * This file may be included by C or C++ code, which is trouble because jni.h
+ * uses different typedefs for JNIEnv in each language.
+ *
+ * TODO: remove C support.
+ */
+#ifndef NATIVEHELPER_JNIHELP_H_
+#define NATIVEHELPER_JNIHELP_H_
+
+#include "jni.h"
+#include <unistd.h>
+
+#ifndef NELEM
+# define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))
+#endif
+
+// TODO: the build system doesn't ensure the standard C++ library header files are on the include
+// path when compiling C++, and this file is included all over the place.
+#ifdef LIBCORE_CPP_JNI_HELPERS
+#include <string>
+#endif // LIBCORE_CPP_JNI_HELPERS
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Register one or more native methods with a particular class.
+ * "className" looks like "java/lang/String". Aborts on failure.
+ * TODO: fix all callers and change the return type to void.
+ */
+int jniRegisterNativeMethods(C_JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods);
+
+/*
+ * Throw an exception with the specified class and an optional message.
+ *
+ * The "className" argument will be passed directly to FindClass, which
+ * takes strings with slashes (e.g. "java/lang/Object").
+ *
+ * If an exception is currently pending, we log a warning message and
+ * clear it.
+ *
+ * Returns 0 on success, nonzero if something failed (e.g. the exception
+ * class couldn't be found, so *an* exception will still be pending).
+ *
+ * Currently aborts the VM if it can't throw the exception.
+ */
+int jniThrowException(C_JNIEnv* env, const char* className, const char* msg);
+
+/*
+ * Throw a java.lang.NullPointerException, with an optional message.
+ */
+int jniThrowNullPointerException(C_JNIEnv* env, const char* msg);
+
+/*
+ * Throw a java.lang.RuntimeException, with an optional message.
+ */
+int jniThrowRuntimeException(C_JNIEnv* env, const char* msg);
+
+/*
+ * Throw a java.io.IOException, generating the message from errno.
+ */
+int jniThrowIOException(C_JNIEnv* env, int errnum);
+
+/*
+ * Return a pointer to a locale-dependent error string explaining errno
+ * value 'errnum'. The returned pointer may or may not be equal to 'buf'.
+ * This function is thread-safe (unlike strerror) and portable (unlike
+ * strerror_r).
+ */
+const char* jniStrError(int errnum, char* buf, size_t buflen);
+
+/*
+ * Returns a new java.io.FileDescriptor for the given int fd.
+ */
+jobject jniCreateFileDescriptor(C_JNIEnv* env, int fd);
+
+/*
+ * Returns the int fd from a java.io.FileDescriptor.
+ */
+int jniGetFDFromFileDescriptor(C_JNIEnv* env, jobject fileDescriptor);
+
+/*
+ * Sets the int fd in a java.io.FileDescriptor.
+ */
+void jniSetFileDescriptorOfFD(C_JNIEnv* env, jobject fileDescriptor, int value);
+
+/*
+ * Returns the reference from a java.lang.ref.Reference.
+ */
+jobject jniGetReferent(C_JNIEnv* env, jobject ref);
+
+/*
+ * Log a message and an exception.
+ * If exception is NULL, logs the current exception in the JNI environment.
+ */
+void jniLogException(C_JNIEnv* env, int priority, const char* tag, jthrowable exception);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+/*
+ * For C++ code, we provide inlines that map to the C functions.  g++ always
+ * inlines these, even on non-optimized builds.
+ */
+#if defined(__cplusplus)
+inline int jniRegisterNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods) {
+    return jniRegisterNativeMethods(&env->functions, className, gMethods, numMethods);
+}
+
+inline int jniThrowException(JNIEnv* env, const char* className, const char* msg) {
+    return jniThrowException(&env->functions, className, msg);
+}
+
+extern "C" int jniThrowExceptionFmt(C_JNIEnv* env, const char* className, const char* fmt, va_list args);
+
+/*
+ * Equivalent to jniThrowException but with a printf-like format string and
+ * variable-length argument list. This is only available in C++.
+ */
+inline int jniThrowExceptionFmt(JNIEnv* env, const char* className, const char* fmt, ...) {
+    va_list args;
+    va_start(args, fmt);
+    return jniThrowExceptionFmt(&env->functions, className, fmt, args);
+    va_end(args);
+}
+
+inline int jniThrowNullPointerException(JNIEnv* env, const char* msg) {
+    return jniThrowNullPointerException(&env->functions, msg);
+}
+
+inline int jniThrowRuntimeException(JNIEnv* env, const char* msg) {
+    return jniThrowRuntimeException(&env->functions, msg);
+}
+
+inline int jniThrowIOException(JNIEnv* env, int errnum) {
+    return jniThrowIOException(&env->functions, errnum);
+}
+
+inline jobject jniCreateFileDescriptor(JNIEnv* env, int fd) {
+    return jniCreateFileDescriptor(&env->functions, fd);
+}
+
+inline int jniGetFDFromFileDescriptor(JNIEnv* env, jobject fileDescriptor) {
+    return jniGetFDFromFileDescriptor(&env->functions, fileDescriptor);
+}
+
+inline void jniSetFileDescriptorOfFD(JNIEnv* env, jobject fileDescriptor, int value) {
+    jniSetFileDescriptorOfFD(&env->functions, fileDescriptor, value);
+}
+
+inline jobject jniGetReferent(JNIEnv* env, jobject ref) {
+    return jniGetReferent(&env->functions, ref);
+}
+
+inline void jniLogException(JNIEnv* env, int priority, const char* tag, jthrowable exception = NULL) {
+    jniLogException(&env->functions, priority, tag, exception);
+}
+
+#ifdef LIBCORE_CPP_JNI_HELPERS
+
+extern "C" std::string jniGetStackTrace(C_JNIEnv* env, jthrowable exception);
+
+inline std::string jniGetStackTrace(JNIEnv* env, jthrowable exception = NULL) {
+  return jniGetStackTrace(&env->functions, exception);
+}
+
+#endif // LIBCORE_CPP_JNI_HELPERS
+
+#endif
+
+/*
+ * TEMP_FAILURE_RETRY is defined by some, but not all, versions of
+ * <unistd.h>. (Alas, it is not as standard as we'd hoped!) So, if it's
+ * not already defined, then define it here.
+ */
+#ifndef TEMP_FAILURE_RETRY
+/* Used to retry syscalls that can return EINTR. */
+#define TEMP_FAILURE_RETRY(exp) ({         \
+    typeof (exp) _rc;                      \
+    do {                                   \
+        _rc = (exp);                       \
+    } while (_rc == -1 && errno == EINTR); \
+    _rc; })
+#endif
+
+#endif  /* NATIVEHELPER_JNIHELP_H_ */

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/JNIHelp.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/tc_common.h
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/tc_common.h	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/tc_common.h	(revision 2997)
@@ -0,0 +1,183 @@
+#ifndef __TC_COMMON__
+#define __TC_COMMON__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define TC_TEEC_TAG	    "TCORE_TEEC"
+#define DEBUG
+
+//#define TCORE_INVOKE_LISTENER
+
+#define SESSION_ID_FROM_TCORE
+
+//#define TCORE_TZ_MGR_BIN_BUILD_IN
+
+//#define TCORE_APP_SAVE_SAVE_RPMB
+
+#define TCORE_PASS_NULL_SHARED_MEM
+
+#ifdef DEBUG
+  #define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, TC_TEEC_TAG, __VA_ARGS__)
+  #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,   TC_TEEC_TAG, __VA_ARGS__) //do {} while (0)//
+  #define LOGI(...) __android_log_print(ANDROID_LOG_INFO,    TC_TEEC_TAG, __VA_ARGS__)
+  #define LOGW(...) __android_log_print(ANDROID_LOG_WARN,    TC_TEEC_TAG, __VA_ARGS__)
+  #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,    TC_TEEC_TAG, __VA_ARGS__)
+#else
+  #define LOGV(...) do {} while (0)
+  #define LOGD(...) do {} while (0)
+  #define LOGI(...) do {} while (0)
+  #define LOGW(...) do {} while (0)
+#endif
+
+#define TCORE_APP_SAVE_PATH               "/sdcard/" //  "/sdcard/TCoreApp/"       ///system/etc/firmware
+#define TCORE_APP_PATH                     "/sdcard"               //"/sdcard/"///system/etc/firmware
+#define TCORE_TAMGR_APPNAME                "tcore_mgr"
+
+#define TCORE_APP_MAP_TB                    "TaUuidMap"
+
+#define     TCORE_GET_APP_IOB_MAX_LEN              1024*128
+
+#define     TCORE_IOB_MAX_LEN                      1024*16
+#define     TCORE_ION_BUF_MAX_LEN                  1024*4
+
+
+#define TCORE_TRANSMIT_CMD_GETAPP           0x1FFF0000
+#define TCORE_TRANSMIT_CMD_OPENSESSION      0xFFFF0000
+#define TCORE_TRANSMIT_CMD_INVOKE           0xFFFF0001
+#define TCORE_TRANSMIT_CMD_CLOSESESSION     0xFFFF0002
+
+typedef enum tcore_pkg_type
+{
+    pkg_file_info = 0x12,
+    pkg_file_data = 0x13,
+    pkg_file_del = 0x14,
+}tcore_pkg_type;
+
+
+typedef struct
+{
+    uint32_t timeLow;
+    uint16_t timeMid;
+    uint16_t timeHiAndVersion;
+    uint8_t clockSeqAndNode[8];
+}teec_uuid;
+
+
+typedef struct tcore_file_info
+{
+    char filename[64];
+    unsigned int filelen;
+    teec_uuid uuid;
+    unsigned char md5[16];
+}tcore_file_info;
+
+typedef struct tcore_file_data
+{
+    unsigned int pkgindex;
+    unsigned char data[TCORE_ION_BUF_MAX_LEN];
+    unsigned int datalen;
+}tcore_file_data;
+
+typedef struct tcore_ivk_pkg
+{
+    tcore_pkg_type type;
+    union
+    {
+        tcore_file_info info;
+        tcore_file_data data;
+    };
+}tcore_ivk_pkg;
+
+typedef struct tcore_ivk_req_s
+{
+ unsigned int  cmd;
+ unsigned int  data;
+ tcore_ivk_pkg  pkg;
+} __attribute__ ((packed)) tcore_ivk_req_s;
+
+typedef struct tcore_ivk_res_s
+{
+    unsigned int  	cmd_id;
+    unsigned int		status;
+} tcore_ivk_res_s;
+
+//__attribute__ ((packed))
+
+typedef struct tcore_teec_cmd
+{
+    unsigned char *open;
+    unsigned int openlen;
+    unsigned char *invoke;
+    unsigned int ivklen;
+}tcore_teec_cmd;
+
+typedef struct transmit_send_cmd {
+       unsigned int cmd_id;
+       unsigned int data;
+       unsigned int data2;
+       unsigned int len;
+       unsigned int start_pkt;
+       unsigned int end_pkt;
+       unsigned int test_buf_size;
+       unsigned int tcore_invoke_len;
+       unsigned char tcore_invoke_buf[TCORE_ION_BUF_MAX_LEN];
+}transmit_send_cmd;
+
+
+
+typedef struct getapp_send_cmd {
+       unsigned int cmd_id;
+       unsigned int data;
+       unsigned int len;
+       unsigned char tauuid[16];
+}getapp_send_cmd;
+
+typedef struct getapp_cmd_rsp {
+    int data;
+    int status;
+    char appname[32];
+    unsigned int applen;
+    unsigned char md5[16];
+}getapp_cmd_rsp;
+
+
+typedef struct loadapp_send_cmd {
+       unsigned char tauuid[16];
+}loadapp_send_cmd;
+
+typedef struct loadapp_cmd_rsp {
+    char appname[32];
+    unsigned char tauuid[16];
+    unsigned int applen;
+    unsigned char md5[16];
+}loadapp_cmd_rsp;
+
+
+
+typedef struct transmit_send_cmd_rsp {
+    int data;
+    int status;
+}transmit_send_cmd_rsp;
+
+#define TCORE_IVK_STARTAPP_ERR              -1
+#define TCORE_IVK_SENDCMD_ERR               -2
+#define TCORE_IVK_MEM_ERR                   -3
+#define TCORE_IVK_FOPEN_ERR                 -4
+#define TCORE_IVK_FWRITE_ERR                 -5
+#define TCORE_IVK_PARSER_ERR                 -6
+#define TCORE_IVK_VERIFY_ERR                 -7
+#define TCORE_IVK_PARAM_ERR                 -8
+#define TCORE_IVK_PERM_ERR                 -9
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/tc_common.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/utils.h
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/utils.h	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/utils.h	(revision 2997)
@@ -0,0 +1,7 @@
+#ifndef UTILS_H
+#define UTILS_H
+
+void get_cmd_str(int cmd_id,char* cmd_str);
+
+
+#endif

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/utils.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/kpi.h
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/kpi.h	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/kpi.h	(revision 2997)
@@ -0,0 +1,11 @@
+#ifndef KPI_H
+#define KPI_H
+
+extern long kpi_start_time_ms;
+extern long kpi_end_time_ms;
+/* return current time in milliseconds */
+long get_current_ms();
+void print_result(int cmd_id,char* p_rev_buf);
+
+
+#endif

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/kpi.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/nativeTeeClient.h
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/nativeTeeClient.h	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/nativeTeeClient.h	(revision 2997)
@@ -0,0 +1,6 @@
+#ifndef __NATIVETEECLIENT_H__
+#define __NATIVETEECLIENT_H__
+
+int invoke_command(void* send_buf, uint32_t sbuf_len,void* rcv_buf, uint32_t* rbuf_len);
+
+#endif // end of __NATIVETEECLIENT_H__

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/include/nativeTeeClient.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/Android.mk
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/Android.mk	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/Android.mk	(revision 2997)
@@ -0,0 +1,17 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := libteeclientjni
+LOCAL_SRC_FILES := \
+				src/nativeTeeClient.cpp \
+				src/kpi.cpp \
+				src/utils.cpp
+
+LOCAL_CFLAGS += -Wunused -DKPI_SUPPORTED -DDEBUG_DO -DIMSG_TAG='"IFAA_CA"'
+LOCAL_C_INCLUDES += $(LOCAL_PATH)/include
+LOCAL_SHARED_LIBRARIES := libmtee libimsg_log
+LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include
+
+LOCAL_PROPRIETARY_MODULE := true
+
+include $(BUILD_SHARED_LIBRARY)

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/Android.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/src/utils.cpp
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/src/utils.cpp	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/src/utils.cpp	(revision 2997)
@@ -0,0 +1,106 @@
+#include <ifaa_common.h>
+#include <string.h>
+#include <imsg_log.h>
+
+void get_cmd_str(int cmd_id,char* cmd_str)
+{
+    if (cmd_str == NULL) {
+        IMSG_ERROR("cmd_str == NULL");
+        return ;
+    }
+    switch (cmd_id) {
+        case IFAA_TA_CMD_GET_DEVICE_ID: {
+            strcat(cmd_str,"IFAA_TA_CMD_GET_DEVICE_ID");
+            break;
+        }
+        case IFAA_TA_CMD_REGISTER: {
+            strcat(cmd_str,"IFAA_TA_CMD_REGISTER");
+            break;
+        }
+        case IFAA_TA_CMD_AUTHENTICATE: {
+            strcat(cmd_str,"IFAA_TA_CMD_AUTHENTICATE");
+            break;
+        }
+        case IFAA_TA_CMD_DEREGISTER: {
+            strcat(cmd_str,"IFAA_TA_CMD_DEREGISTER");
+            break;
+        }
+        case IFAA_TA_CMD_QUERY_STATUS: {
+            strcat(cmd_str,"IFAA_TA_CMD_QUERY_STATUS");
+            break;
+        }
+        case IFAA_TA_CMD_GEN_ASYMMETRIC_KEY: {
+            strcat(cmd_str,"IFAA_TA_CMD_GEN_ASYMMETRIC_KEY");
+            break;
+        }
+        case IFAA_TA_CMD_GET_PROTOCOL_VERSION: {
+            strcat(cmd_str,"IFAA_TA_CMD_GET_PROTOCOL_VERSION");
+            break;
+        }
+        case IFAA_TA_CMD_GET_CERT_ALG_ENCODE: {
+            strcat(cmd_str,"IFAA_TA_CMD_GET_CERT_ALG_ENCODE");
+            break;
+        }
+        case IFAA_TA_CMD_READ_FILE: {
+            strcat(cmd_str,"IFAA_TA_CMD_READ_FILE");
+            break;
+        }
+        case IFAA_TA_CMD_WRITE_FILE: {
+            strcat(cmd_str,"IFAA_TA_CMD_WRITE_FILE");
+            break;
+        }
+        case IFAA_TA_CMD_DELETE_FILE: {
+            strcat(cmd_str,"IFAA_TA_CMD_DELETE_FILE");
+            break;
+        }
+        case IFAA_GET_LAST_IDENTIFIED_RESULT: {
+            strcat(cmd_str,"IFAA_GET_LAST_IDENTIFIED_RESULT");
+            break;
+        }
+        case IFAA_GET_AUTHENTICATOR_VERSION: {
+            strcat(cmd_str,"IFAA_GET_AUTHENTICATOR_VERSION");
+            break;
+        }
+        case IFAA_GET_ID_LIST: {
+            strcat(cmd_str,"IFAA_GET_ID_LIST");
+            break;
+        }
+        case IFAA_BIO_ID_COMPARE: {
+            strcat(cmd_str,"IFAA_BIO_ID_COMPARE");
+            break;
+        }
+        case IFAA_INTERNAL_SHA256: {
+            strcat(cmd_str,"IFAA_INTERNAL_SHA256");
+            break;
+        }
+        case IFAA_INTERNAL_SIGN: {
+            strcat(cmd_str,"IFAA_INTERNAL_SIGN");
+            break;
+        }
+        case IFAA_INTERNAL_VERIFY: {
+            strcat(cmd_str,"IFAA_INTERNAL_VERIFY");
+            break;
+        }
+        case IFAA_INTERNAL_KEY_GENERATE: {
+            strcat(cmd_str,"IFAA_INTERNAL_KEY_GENERATE");
+            break;
+        }
+        case IFAA_INTERNAL_HMAC_SHA1: {
+            strcat(cmd_str,"IFAA_INTERNAL_HMAC_SHA1");
+            break;
+        }
+        case IFAA_INTERNAL_AUTHENTICATOR_SIGN: {
+            strcat(cmd_str,"IFAA_INTERNAL_AUTHENTICATOR_SIGN");
+            break;
+        }
+        case IFAA_INTERNAL_AUTHENTICATOR_VERIFY: {
+            strcat(cmd_str,"IFAA_INTERNAL_AUTHENTICATOR_VERIFY");
+            break;
+        }
+        default: {
+            IMSG_ERROR("called unknow id : %d",cmd_id);
+            strcat(cmd_str,"unknow_id");
+            break;
+        }
+    }
+}

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/src/utils.cpp
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/src/kpi.cpp
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/src/kpi.cpp	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/src/kpi.cpp	(revision 2997)
@@ -0,0 +1,35 @@
+#include <time.h>
+#include <string.h>
+#include <imsg_log.h>
+#include <utils.h>
+#include "ifaa_common.h"
+
+
+long kpi_start_time_ms = 0;
+long kpi_end_time_ms = 0;
+
+long get_current_ms()
+{
+    struct timespec res;
+    clock_gettime(CLOCK_REALTIME, &res);
+    return 1000 * res.tv_sec + res.tv_nsec / 1e6;
+}
+
+/*
+   4bytes | 4bytes     | 4bytes
+   return | status_len | status
+*/
+
+void print_result(int cmd_id,char* p_rev_buf)
+{
+    char cmd_str[64] = { 0 };
+    get_cmd_str(cmd_id,cmd_str);
+    int* p_result = (int*)p_rev_buf;
+    int* p_buf_len = (int*)(p_rev_buf+4);
+    if(cmd_id==IFAA_TA_CMD_QUERY_STATUS) {
+        int* p_status = (int*)(p_rev_buf+8);
+        IMSG_INFO("ifaa_kpi : called %s ,used time : %ld ms , result = %d , p_buf_len = %d status = %d ",cmd_str,kpi_end_time_ms-kpi_start_time_ms,*p_result,*p_buf_len,*p_status);
+    } else {
+        IMSG_INFO("ifaa_kpi : called %s ,used time : %ld ms , result = %d , buf_len = %d",cmd_str,kpi_end_time_ms-kpi_start_time_ms,*p_result,*p_buf_len);
+    }
+}

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/src/kpi.cpp
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/src/nativeTeeClient.cpp
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/src/nativeTeeClient.cpp	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/src/nativeTeeClient.cpp	(revision 2997)
@@ -0,0 +1,216 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+#include <jni.h>
+#include <JNIHelp.h>
+#include "tee_client_api.h"
+#include <imsg_log.h>
+#include <kpi.h>
+
+
+
+
+////////////////////////////////////////////////////////
+////IFAA TA的UUID为: 08010203-0000-0000-0000000000000000
+////////////////////////////////////////////////////////
+static const TEEC_UUID IFAA_MANAGER_TA_UUID =  { 0x08010203, 0x0000, 0x0000, \
+		                            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} };
+
+/*
+static const TEEC_UUID uuid = { 0x01020304, 0x0506, 0x0708, { 0x09,
+		0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x11 } };
+*/
+static const char* host_name = "ifaa";
+
+
+
+static const char*  gNativeTeecIFAAManagerClassName = "org/ifaa/android/manager/IFAAManager";
+
+#ifndef NELEM
+	#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))
+#endif
+
+static const int SIZE_OF_SHARED_BUFFER_RETURN = 1024 * 8;
+static const int MAX_SHARED_MEMORY = 1024 * 1024 * 2;
+
+unsigned int bytetoInt(char* bytes) {
+	int result;
+	result = ((unsigned int) bytes[0] & 0xff) << 0;
+	result += ((unsigned int) bytes[1] & 0xff) << 8;
+	result += ((unsigned int) bytes[2] & 0xff) << 16;
+	result += ((unsigned int) bytes[3] & 0xff) << 24;
+	return result;
+}
+
+int invoke_command(void* send_buf, uint32_t sbuf_len,void* rcv_buf, uint32_t* rbuf_len)
+{
+	IMSG_INFO("invoke_command sbuf_len=%d rbuf_len=%d", sbuf_len, *rbuf_len);
+	if (send_buf == NULL || sbuf_len > MAX_SHARED_MEMORY
+			|| rcv_buf == NULL || rbuf_len == NULL || *rbuf_len > MAX_SHARED_MEMORY) {
+		IMSG_ERROR("invoke_command params invaild.");
+		return -1;
+	}
+    TEEC_Context context = { 0 };
+    TEEC_Session session = { 0 };
+    TEEC_Operation session_operation = { 0 };
+    TEEC_Operation operation = { 0 };
+	TEEC_SharedMemory inputSM, outputSM;
+    TEEC_Result result;
+    int ret = 0;
+
+	if(sbuf_len<=0){
+		IMSG_ERROR("sbuf_len = ％d",sbuf_len);
+		return -1;
+	}
+
+#ifdef KPI_SUPPORTED
+/*
+*     +----------------------------------------------------------+
+*     | version | sig_len | sig | pkg_len | pkg | cmd | params.. |
+*     +----------------------------------------------------------+
+
+*/
+	char* p_send_buf_temp = (char*)(send_buf);
+	int sig_len = *(p_send_buf_temp+4);
+	int pkg_len = *(p_send_buf_temp+8+sig_len);
+	int kpi_cmd_id = *(p_send_buf_temp+12+sig_len+pkg_len);
+	char* p_rcv_buf = (char*)rcv_buf;
+	kpi_start_time_ms = get_current_ms();
+#endif
+    result = TEEC_InitializeContext(host_name,&context);
+    if(result != TEEC_SUCCESS) {
+		IMSG_ERROR("TEEC_InitializeContext FAILED");
+        goto cleanup_1;
+    }
+
+    result = TEEC_OpenSession(
+            &context,
+            &session,
+            &IFAA_MANAGER_TA_UUID,
+            TEEC_LOGIN_PUBLIC,
+            NULL,
+            NULL,
+            NULL);
+    if(result != TEEC_SUCCESS) {
+		IMSG_ERROR("TEEC_OpenSession FAILED");
+        goto cleanup_2;
+    }
+
+
+	inputSM.size = sbuf_len;
+	inputSM.flags = 3;
+	result = TEEC_AllocateSharedMemory(&context, &inputSM);
+	if (result != TEEC_SUCCESS || inputSM.buffer == 0) {
+		IMSG_ERROR("TEEC_AllocateSharedMemory FAILED");
+		goto cleanup_4;
+	}
+	if (sbuf_len > 0) {
+		memcpy(inputSM.buffer, send_buf, sbuf_len);
+	}
+
+	outputSM.size = *rbuf_len;
+	outputSM.flags = 3;
+	result = TEEC_AllocateSharedMemory(&context, &outputSM);
+	if (result != TEEC_SUCCESS || outputSM.buffer == 0) {
+		IMSG_ERROR("TEEC_AllocateSharedMemory FAILED");
+		goto cleanup_5;
+	}
+
+	operation.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_PARTIAL_INPUT,
+			TEEC_MEMREF_PARTIAL_INOUT, TEEC_VALUE_OUTPUT, TEEC_NONE);
+
+	operation.params[0].memref.parent = &inputSM;
+	operation.params[0].memref.offset = 0;
+	operation.params[0].memref.size = sbuf_len;
+
+	operation.params[1].memref.parent = &outputSM;
+	operation.params[1].memref.offset = 0;
+	operation.params[1].memref.size = *rbuf_len;
+    operation.started = 1;
+
+    result = TEEC_InvokeCommand(&session,0,&operation,NULL);
+    if (result != TEEC_SUCCESS)
+    {
+		IMSG_ERROR("TEEC_InvokeCommand FAILED , result = 0x%08x",result);
+        goto cleanup_5;
+    }
+
+	memcpy(rcv_buf, outputSM.buffer, *rbuf_len);
+	*rbuf_len = operation.params[1].memref.size;
+#ifdef KPI_SUPPORTED
+	kpi_end_time_ms = get_current_ms();
+	print_result(kpi_cmd_id,p_rcv_buf);
+#endif
+    cleanup_5:
+        TEEC_ReleaseSharedMemory(&outputSM);
+	cleanup_4:
+        TEEC_ReleaseSharedMemory(&inputSM);
+    cleanup_3:
+        TEEC_CloseSession(&session);
+    cleanup_2:
+        TEEC_FinalizeContext(&context);
+    cleanup_1:
+        return 0;
+
+}
+
+static jbyteArray ifaa_processCmd(JNIEnv *env, jobject thiz,
+		                          jobject context, jbyteArray buf) {
+	IMSG_INFO("ifaa_processCmd");
+	if (NULL == env){
+		return NULL;
+	}
+
+
+
+	int sbuf_len = env->GetArrayLength(buf);
+	IMSG_INFO("sbuf_len:%d", sbuf_len);
+	unsigned char* send_buf = (unsigned char*)malloc(sbuf_len);
+	env->GetByteArrayRegion(buf, 0, sbuf_len, (jbyte*) send_buf);
+
+	uint32_t rbuf_len = SIZE_OF_SHARED_BUFFER_RETURN;
+	IMSG_INFO("rbuf_len:%d", rbuf_len);
+	unsigned char* rcv_buf = (unsigned char*)malloc(rbuf_len);
+	memset(rcv_buf, 0, rbuf_len);
+	int ret = invoke_command(send_buf, sbuf_len, rcv_buf, &rbuf_len);
+	if(send_buf !=NULL ) {
+		free(send_buf);
+	}
+    if (ret != 0 || rbuf_len <= 0 || NULL== rcv_buf) {
+		free(rcv_buf);
+    	return NULL;
+    }
+
+    jbyteArray resultByteArray = { 0 };
+    resultByteArray = env->NewByteArray(rbuf_len);
+
+    env->SetByteArrayRegion(resultByteArray, 0, rbuf_len, (const jbyte*)rcv_buf);
+	free(rcv_buf);
+	return resultByteArray;
+}
+
+static JNINativeMethod gTeecClientIfaaMethods[] =
+{
+		{"processCmd"   , "(Landroid/content/Context;[B)[B",       (void *)ifaa_processCmd},
+};
+
+
+jint JNI_OnLoad(JavaVM* jvm, void* reserved)
+{
+    JNIEnv *e;
+    // Check JNI version
+	IMSG_INFO("JNI_OnLoad");
+    if(jvm->GetEnv((void **)&e, JNI_VERSION_1_6)){
+		return JNI_ERR;
+	}
+
+    jclass clsIfaaManager = e->FindClass(gNativeTeecIFAAManagerClassName);
+    if(clsIfaaManager){
+		IMSG_INFO ("%s: gNativeTeecIFAAManagerClassName  OK ", __FUNCTION__);
+	}
+    e->RegisterNatives(clsIfaaManager,
+    gTeecClientIfaaMethods, NELEM(gTeecClientIfaaMethods));
+
+    return JNI_VERSION_1_6;
+}

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libteeclientjni/src/nativeTeeClient.cpp
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/Android.mk
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/Android.mk	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/Android.mk	(revision 2997)
@@ -0,0 +1 @@
+include $(call all-subdir-makefiles)

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/Android.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libmtee/include/tee_client_api.h
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libmtee/include/tee_client_api.h	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libmtee/include/tee_client_api.h	(revision 2997)
@@ -0,0 +1,1359 @@
+#ifndef __NEU_TEE_CLIENT_API_H_
+#define __NEU_TEE_CLIENT_API_H_
+
+#define TEEC_CLIENT_API_VERSION 1
+
+#define MAX_SESSIONS_PER_DEVICE 16
+#define MAX_OPERATIONS_PER_SESSION 16
+#define MAX_MEMBLOCKS_PER_SESSION 16
+#define MAX_MEMBLOCKS_PER_OPERATION 4
+
+#define TEEC_CONFIG_SHAREDMEM_MAX_SIZE 0x80000
+
+#ifndef TYPE_UINT_DEFINED
+typedef unsigned int uint32_t;
+typedef unsigned short uint16_t;
+#ifndef _STDINT_H
+typedef char uint8_t;
+#endif
+#endif
+
+enum TEEIC_Result {
+/*!The operation succeeded. \n*/
+    TEEC_SUCCESS = 0x0,
+    TEEIC_SUCCESS = 0x0,
+    TEEC_ERROR_INTERNAL	= 0x00000001, //内部错误
+    TEEC_ERROR_RESOURCE_LIMIT = 0x00000002, //资源限制
+    TEEC_ERROR_DEVICE_BUSY = 0x00000003, //设备忙
+    TEEC_ERROR_DEVICE_HANDLE_INVALID = 0x00000004, //设备句柄不合法
+    TEEC_ERROR_DEVICE_OVERFLOW = 0x00000005 ,//超出设备能力
+    TEEC_ERROR_DEVICE_EVENT_INVALID	= 0x00000006, //设备事件不合法
+    TEEC_ERROR_TA_NOT_EXIST = 0x00000009, //TA不存在
+    TEEC_ERROR_HOST_NAME_EXIST = 0x0000000a, //同名主机已经存在
+    TEEC_ERROR_HOST_NOT_EXIST = 0x0000000b, //主机不存在
+    TEEC_ERROR_GATE_NOT_EXIST = 0x0000000c, //Gate不存在
+    TEEC_ERROR_PIPE_CREATE_DENIED = 0x0000000d, //同名主机已经存在
+    TEEC_ERROR_PIPE_BUSY = 0x0000000e, //Pipe正在使用中
+    TEEC_ERROR_NETWORK_ERROR = 0x00000010 ,//网络不可用
+    TEEC_ERROR_CIPHERTEXT_ERROR = 0x00000011, //密文错误
+    TEEC_ERROR_UNIQUE_CONFLICT = 0x00000012 ,//唯一性冲突
+/*!Non-specific cause.*/
+    TEEC_ERROR_GENERIC = 0xFFFF0000,
+    TEEIC_ERROR_GENERIC = 0xFFFF0000,
+/*!Access privileges are not sufficient.*/
+    TEEC_ERROR_ACCESS_DENIED = 0xFFFF0001 ,
+    TEEIC_ERROR_ACCESS_DENIED = 0xFFFF0001 ,
+/*!The operation was cancelled.*/
+    TEEC_ERROR_CANCEL = 0xFFFF0002 ,
+    TEEIC_ERROR_CANCEL = 0xFFFF0002 ,
+/*!Concurrent accesses caused conflict.*/
+    TEEC_ERROR_ACCESS_CONFLICT = 0xFFFF0003 ,
+    TEEIC_ERROR_ACCESS_CONFLICT = 0xFFFF0003 ,
+/*!Too much data for the requested operation was passed.*/
+    TEEC_ERROR_EXCESS_DATA = 0xFFFF0004 ,
+    TEEIC_ERROR_EXCESS_DATA = 0xFFFF0004 ,
+/*!Input data was of invalid format.*/
+    TEEC_ERROR_BAD_FORMAT = 0xFFFF0005 ,
+    TEEIC_ERROR_BAD_FORMAT = 0xFFFF0005 ,
+/*!Input parameters were invalid.*/
+    TEEC_ERROR_BAD_PARAMETERS = 0xFFFF0006 ,
+    TEEIC_ERROR_BAD_PARAMETERS = 0xFFFF0006 ,
+/*!Operation is not valid in the current state.*/
+    TEEC_ERROR_BAD_STATE = 0xFFFF0007,
+    TEEIC_ERROR_BAD_STATE = 0xFFFF0007,
+/*!The requested data item is not found.*/
+    TEEC_ERROR_ITEM_NOT_FOUND = 0xFFFF0008,
+    TEEIC_ERROR_ITEM_NOT_FOUND = 0xFFFF0008,
+/*!The requested operation should exist but is not yet implemented.*/
+    TEEC_ERROR_NOT_IMPLEMENTED = 0xFFFF0009,
+    TEEIC_ERROR_NOT_IMPLEMENTED = 0xFFFF0009,
+/*!The requested operation is valid but is not supported in this
+* Implementation.*/
+    TEEC_ERROR_NOT_SUPPORTED = 0xFFFF000A,
+    TEEIC_ERROR_NOT_SUPPORTED = 0xFFFF000A,
+/*!Expected data was missing.*/
+    TEEC_ERROR_NO_DATA = 0xFFFF000B,
+    TEEIC_ERROR_NO_DATA = 0xFFFF000B,
+/*!System ran out of resources.*/
+    TEEC_ERROR_OUT_OF_MEMORY = 0xFFFF000C,
+    TEEIC_ERROR_OUT_OF_MEMORY = 0xFFFF000C,
+/*!The system is busy working on something else. */
+    TEEC_ERROR_BUSY = 0xFFFF000D,
+    TEEIC_ERROR_BUSY = 0xFFFF000D,
+/*!Communication with a remote party failed.*/
+    TEEC_ERROR_COMMUNICATION = 0xFFFF000E,
+    TEEIC_ERROR_COMMUNICATION = 0xFFFF000E,
+/*!A security fault was detected.*/
+    TEEC_ERROR_SECURITY = 0xFFFF000F,
+    TEEIC_ERROR_SECURITY = 0xFFFF000F,
+/*!The supplied buffer is too short for the generated output.*/
+    TEEC_ERROR_SHORT_BUFFER = 0xFFFF0010,
+    TEEIC_ERROR_SHORT_BUFFER = 0xFFFF0010,
+/*! The MAC value supplied is different from the one calculated */
+    TEEC_ERROR_MAC_INVALID = 0xFFFF3071,
+    TEEIC_ERROR_MAC_INVALID = 0xFFFF3071,
+
+    // add by luocl start
+    TEEC_ERROR_VNET_INVALID = 0xFFFF6000,
+    TEEIC_ERROR_VNET_INVALID = 0xFFFF6000,
+    TEEC_ERROR_REEAGENT_INVALID = 0xFFFF6001,
+    TEEIC_ERROR_REEAGENT_INVALID = 0xFFFF6001,
+    // add by luocl end
+
+    // add for GP
+    TEEIC_UNDEFINED_ERROR = 0xFFFF7001,
+    TEEC_UNDEFINED_ERROR = 0xFFFF7001,
+
+ };
+
+#ifndef TEE_RESULT
+#define TEE_RESULT
+typedef uint32_t TEE_Result;
+#endif
+typedef TEE_Result TEEC_Result;
+
+typedef unsigned int size_type;
+
+#define TEEC_PARAM_TYPES( param0Type, param1Type, param2Type, param3Type) \
+    (param3Type << 12 | param2Type << 8 | param1Type << 4 | param0Type)
+
+#define TEEC_VALUE_UNDEF 0xffffffff
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define LIST_POISON_PREV    0xDEADBEEF
+#define LIST_POISON_NEXT    0xFADEBABE
+
+/**
+ * @brief 
+ */
+struct list {
+    struct list *next, *prev;
+};
+
+#define INIT_HEAD(__lname)  { &(__lname), &(__lname) }
+#define LIST_HEAD(_lname)   struct list _lname = INIT_HEAD(_lname)
+#define INIT_LIST_HEAD(ptr)  do { \
+        (ptr)->next = ptr; (ptr)->prev = ptr;   \
+    }while (0);
+
+#define list_entry(ptr, type, member) \
+    ((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
+
+#define list_for_each(curr, head) \
+    for (curr = (head)->next; curr != head; curr = (curr)->next)
+
+#define list_for_each_entry(ptr, head ,member) \
+    for(ptr = list_entry((head)->next, typeof(*ptr), member); \
+            &ptr->member != (head); \
+            ptr = list_entry(ptr->member.next , typeof(*ptr), member))\
+            
+
+/**
+ * list_for_each_entry_safe - iterate over list of given type 
+ * safe against removal of list entry
+ * @param pos:    the type * to use as a loop cursor.
+ * @param n:      another type * to use as temporary storage
+ * @param head:   the head for your list.
+ * @param member: the name of the list_struct within the struct.
+ */
+#define list_for_each_entry_safe(pos, n, head, member)          \
+    for (pos = list_entry((head)->next, typeof(*pos), member),  \
+        n = list_entry(pos->member.next, typeof(*pos), member); \
+         &pos->member != (head);                    \
+         pos = n, n = list_entry(n->member.next, typeof(*n), member))
+
+/**
+ * @brief 
+ *
+ * @param prev
+ * @param next
+ * @param new
+ */
+static inline void __list_add(struct list *prev,
+                  struct list *next, struct list *new0)
+{
+    new0->prev = prev;
+    new0->next = next;
+    prev->next = new0;
+    next->prev = new0;
+}
+
+/**
+ * @brief
+ * Adds the new node after the given head.
+ * @param head: List head after which the "new" node should be added.
+ * @param new: New node that needs to be added to list.
+ * @note Please note that new node is added after the head.
+ */
+static inline void list_add(struct list *head, struct list *new0)
+{
+    __list_add(head, head->next, new0);
+}
+
+/**
+ * Adds a node at the tail where tnode points to tail node.
+ * @param tnode: The current tail node.
+ * @param new: The new node to be added before tail.
+ * @note: Please note that new node is added before tail node.
+ */
+static inline void list_add_tail(struct list *tnode, struct list *new0)
+{
+    __list_add(tnode->prev, tnode, new0);
+}
+
+/**
+ * @brief 
+ *
+ * @param node
+ * @param prev
+ * @param next
+ */
+static inline void __list_del(struct list *node,
+                  struct list *prev, struct list *next)
+{
+    prev->next = node->next;
+    next->prev = node->prev;
+//    node->next = (void *)LIST_POISON_NEXT;
+//    node->prev = (void *)LIST_POISON_PREV;
+    node->next = (struct list *)LIST_POISON_NEXT;
+    node->prev = (struct list *)LIST_POISON_PREV;
+
+}
+
+/**
+ * @brief 
+ * Deletes a given node from list.
+ * @param node: Node to be deleted.
+ *
+ * @param node
+ */
+static inline void list_del(struct list *node)
+{
+    __list_del(node, node->prev, node->next);
+}
+
+/**
+ * @brief 
+ *
+ * @param head
+ *
+ * @return 
+ */
+static inline struct list *list_pop_tail(struct list *head)
+{
+    struct list *dnode = head->prev;
+    list_del(head->prev);
+    return dnode;
+}
+
+/**
+ * @brief 
+ *
+ * @param head
+ *
+ * @return 
+ */
+static inline struct list *list_pop(struct list *head)
+{
+    struct list *dnode = head->next;
+    list_del(head->next);
+    return dnode;
+}
+
+/**
+ * @brief 
+ *
+ * @param head
+ *
+ * @return 
+ */
+static inline int list_empty(struct list *head)
+{
+    return (head->next == head);
+}
+
+#if 0
+#define D(fmt,...) \
+fprintf(stderr,"[%s-%d/%s][D]"fmt"\n",\
+strrchr(__FILE__,'/')+1,__LINE__,__func__,##__VA_ARGS__);
+
+#define E(fmt,...) \
+fprintf(stderr,"[%s-%d/%s][E]"fmt"\n",\
+strrchr(__FILE__,'/')+1,__LINE__,__func__,##__VA_ARGS__);
+
+#define I(fmt,...) \
+fprintf(stderr,"[%s-%d/%s][I]"fmt"\n",\
+strrchr(__FILE__,'/')+1,__LINE__,__func__,##__VA_ARGS__);
+#endif
+#define D(...) \
+__android_log_print(ANDROID_LOG_INFO, "uTClient",##__VA_ARGS__) ;
+
+#define E(...) \
+__android_log_print(ANDROID_LOG_INFO, "uTClient",##__VA_ARGS__) ;
+
+#define I(...) \
+__android_log_print(ANDROID_LOG_INFO, "uTClient",##__VA_ARGS__) ;
+
+/**
+* @brief Return code origin
+*
+*
+*/
+// mod by luocl 20150112
+#ifndef TEEC_RETURN_CODE
+#define TEEC_RETURN_CODE
+enum TEEC_return_code_origin {
+/*! The return code is an error that originated within the TEE Client API
+* implementation. */
+    TEEC_ORIGIN_API = 0x1,
+    TEEIC_ORIGIN_API = 0x1,
+/*! The return code is an error that originated within the underlying
+* communications stack linking the rich OS with the TEE. */
+    TEEC_ORIGIN_COMMS = 0x2,
+    TEEIC_ORIGIN_COMMS = 0x2,
+/*! The return code is an error that originated within the common TEE code. */
+    TEEC_ORIGIN_TEE = 0x3,
+    TEEIC_ORIGIN_TEE = 0x3,
+/*! The return code is an error that originated within the Trusted application
+* code. This includes the case where the return code is a success. */
+    TEEC_ORIGIN_TRUSTED_APP = 0x4,
+    TEEIC_ORIGIN_TRUSTED_APP = 0x4,
+
+    // add by luocl start
+    //TEEC_ORIGIN_VNET = 0x5,
+    //TEEIC_ORIGIN_VNET = 0x5,
+
+    TEEC_ORIGIN_TEEI = 0x5,
+    TEEIC_ORIGIN_TEEI = 0x5,
+    // add by luocl end
+
+    // add for GP
+    TEEC_ORIGIN_ANY_NOT_TRUSTED_APP = 0x10,
+    TEEIC_ORIGIN_ANY_NOT_TRUSTED_APP = 0x10,
+};
+#endif
+
+
+/**
+* @brief Login flag constants
+*
+*
+*/
+enum TEEC_login_flags {
+/*! No login is to be used.*/
+    TEEC_LOGIN_PUBLIC = 0x0,
+    TEEIC_LOGIN_PUBLIC = 0x0,
+/*! The user executing the application is provided.*/
+    TEEC_LOGIN_USER = 0x1,
+    TEEIC_LOGIN_USER = 0x1,
+/*! The user group executing the application is provided.*/
+    TEEC_LOGIN_GROUP = 0x2,
+    TEEIC_LOGIN_GROUP = 0x2,
+/*! Login data about the running Client Application itself is provided. */
+    TEEC_LOGIN_APPLICATION = 0x4 ,
+    TEEIC_LOGIN_APPLICATION = 0x4 ,
+/*! Login data about the user running the Client Application and about the
+* Client Application itself is provided. */
+    TEEC_LOGIN_USER_APPLICATION = 0x5 ,
+    TEEIC_LOGIN_USER_APPLICATION = 0x5 ,
+/*! Login data about the group running the Client Application and about the
+* Client Application itself is provided. */
+    TEEC_LOGIN_GROUP_APPLICATION = 0x6 ,
+    TEEIC_LOGIN_GROUP_APPLICATION = 0x6 ,
+};
+
+/**
+* @brief Shared memory flag constants
+*
+*
+*/
+enum TEEC_shared_mem_flags {
+/*! The Shared Memory can carry data from the Client Application 
+* to the Trusted Application. */
+    TEEC_MEM_INPUT = 0x1,
+    TEEIC_MEM_INPUT = 0x1,
+/*! The Shared Memory can carry data from the Trusted Application 
+* to the Client Application. */
+    TEEC_MEM_OUTPUT = 0x2,
+    TEEIC_MEM_OUTPUT = 0x2,
+};
+
+/**
+* @brief Param type constants
+*
+*/
+enum TEEC_param_type {
+/*! The Parameter is not used. */
+    TEEC_NONE = 0x0,
+    TEEIC_NONE = 0x0,
+/*! The Parameter is a TEEC_Value tagged as input. */
+    TEEC_VALUE_INPUT = 0x1,
+    TEEIC_VALUE_INPUT = 0x1,
+/*! The Parameter is a TEEC_Value tagged as output. */
+    TEEC_VALUE_OUTPUT = 0x2,
+    TEEIC_VALUE_OUTPUT = 0x2,
+/*! The Parameter is a TEEC_Value tagged as both as input and output, 
+* i.e., for which both the behaviors of TEEC_VALUE_INPUT and 
+* TEEC_VALUE_OUTPUT apply. */
+    TEEC_VALUE_INOUT = 0x3,
+    TEEIC_VALUE_INOUT = 0x3,
+/*! The Parameter is a TEEC_TempMemoryReference describing a region of memory 
+* which needs to be temporarily registered for the duration of the Operation 
+and is tagged as input. */
+    TEEC_MEMREF_TEMP_INPUT = 0x5,
+    TEEIC_MEMREF_TEMP_INPUT = 0x5,
+/*! Same as TEEC_MEMREF_TEMP_INPUT, but the Memory Reference is tagged as
+* output. The Implementation may update the size field to reflect the 
+* required output size in some use cases. */
+    TEEC_MEMREF_TEMP_OUTPUT = 0x6,
+    TEEIC_MEMREF_TEMP_OUTPUT = 0x6,
+/*! A Temporary Memory Reference tagged as both input and output, 
+* i.e., for which both the behaviors of TEEC_MEMREF_TEMP_INPUT and
+* TEEC_MEMREF_TEMP_OUTPUT apply. */
+    TEEC_MEMREF_TEMP_INOUT = 0x7,
+    TEEIC_MEMREF_TEMP_INOUT = 0x7,
+/*! The Parameter is a Registered Memory Reference that refers to the 
+* entirety of its parent Shared Memory block. The parameter structure is a
+* TEEC_MemoryReference. In this structure, the Implementation MUST read
+* only the parent field and MAY update the size field when the 
+* operation completes. */
+    TEEC_MEMREF_WHOLE = 0xc,
+    TEEIC_MEMREF_WHOLE = 0xc,
+
+/*! A Registered Memory Reference structure that refers to a partial region 
+* of its parent Shared Memory block and is tagged as input.
+*/
+    TEEC_MEMREF_PARTIAL_INPUT = 0xd,
+    TEEIC_MEMREF_PARTIAL_INPUT = 0xd,
+
+/*! A Registered Memory Reference structure that refers to a partial region 
+* of its parent Shared Memory block and is tagged as output.
+*/
+    TEEC_MEMREF_PARTIAL_OUTPUT = 0xe,
+    TEEIC_MEMREF_PARTIAL_OUTPUT = 0xe,
+
+/*! A Registered Memory Reference structure that refers to a partial region 
+* of its parent Shared Memory block and is tagged as both input and output.
+*/
+    TEEC_MEMREF_PARTIAL_INOUT = 0xf,
+    TEEIC_MEMREF_PARTIAL_INOUT = 0xf,
+};
+
+#if 0 /* all these have been moved to neu_tee_api.h */
+typedef unsigned int uint32_t;
+typedef unsigned short uint16_t;
+typedef char uint8_t;
+
+typedef uint32_t TEEC_Result;
+#endif
+/**
+ * @brief 
+ */
+typedef struct TEEC_Operation TEEC_Operation;
+/**
+ * @brief 
+ */
+typedef struct TEEC_Session TEEC_Session;
+/**
+ * @brief 
+ */
+typedef struct TEEC_Context TEEC_Context;
+/**
+ * @brief 
+ */
+typedef struct TEEC_SharedMemory TEEC_SharedMemory;
+/**
+ * @brief 
+ */
+typedef struct TEEC_TempMemoryReference TEEC_TempMemoryReference;
+/**
+ * @brief 
+ */
+typedef struct TEEC_RegisteredMemoryReference TEEC_RegisteredMemoryReference;
+/**
+ * @brief 
+ */
+typedef struct TEEC_Value TEEC_Value;
+
+/**
+* @brief The TEEC_Context structure is used to contain control information
+* related to the TEE
+*
+*/
+typedef struct UT_TEEC_Context
+{
+	// Device identifier
+    uint32_t fd;
+
+	// Sessions list of the device
+    struct list session_list;
+
+    // Shared memory list
+    struct list shared_mem_list;
+
+    // Error number from the client driver
+    int s_errno;
+
+    // host name
+    char tee_name[255];
+
+} UT_TEEC_Context;
+
+struct TEEC_Context
+{
+    UT_TEEC_Context* imp;
+};
+
+///**
+//* @brief Universally Unique IDentifier (UUID) type as defined in 
+//* [RFC4122].A
+//*
+//* UUID is the mechanism by which a service is identified.
+//*/
+typedef struct
+{
+   uint32_t timeLow;
+   uint16_t timeMid;
+   uint16_t timeHiAndVersion;
+   uint8_t clockSeqAndNode[8];
+} TEEC_UUID;
+
+/**
+* @brief The TEEC_Session structure is used to contain control information
+* related to a session between a client and a service.
+*
+*/
+typedef struct UT_TEEC_Session
+{
+    // Session id obtained for the  service
+    int session_id;
+
+    // Device context
+    UT_TEEC_Context* device;
+
+    // Service error number
+    int s_errno;
+
+    // List head used by Context
+    struct list head;
+
+} UT_TEEC_Session;
+
+struct TEEC_Session
+{
+    UT_TEEC_Session *imp;
+};
+
+/**
+* @brief The TEEC_SharedMemory structure is used to contain control information
+* related to a block of shared memory that is mapped between the client and the
+* service.
+*
+*/
+
+typedef struct UT_TEEC_SharedMemory
+{
+    // Device context
+    UT_TEEC_Context* context;
+
+    // Shared memory type
+    uint32_t allocated;
+
+    // List head used by Context
+    struct list head_ref;
+
+    // Service error number
+    int s_errno;
+
+    // The pointer to the block of allocate shared memory.
+    void* buffer;
+
+    // The pointer to the block of register shared memory.
+    void* saved_buffer;
+
+    // buffer or saved buffer size
+    size_type size;
+
+    // Prevent memory overflow
+    //unsigned char tmp[1024];
+
+} UT_TEEC_SharedMemory;
+
+typedef struct TEEC_SharedMemory
+{
+    void* buffer;
+    size_type size;
+    uint32_t flags;
+    UT_TEEC_SharedMemory* imp;
+} TEEC_SharedMemory;
+
+/**
+* @brief Small raw data value type
+*
+* This type defines a parameter that is not referencing shared memory, 
+* but carries instead small raw data passed by value. 
+* It is used as a TEEC_Operation parameter when the corresponding 
+* parameter type is one of 
+* TEEC_VALUE_INPUT, TEEC_VALUE_OUTPUT, or TEEC_VALUE_INOUT.
+*/
+struct TEEC_Value
+{
+/*! The two fields of this structure do not have a particular meaning. 
+* It is up to the protocol between the Client Application and 
+* the Trusted Application to assign a semantic to those two integers.
+*/
+   uint32_t a;
+   uint32_t b;
+};
+
+
+/**
+* @brief Temporary shared memory reference 
+*
+*/
+struct TEEC_TempMemoryReference
+{
+/*! "buffer" is a pointer to the first byte of a region of memory which needs \n
+* to be temporarily registered for the duration of the Operation. \n
+* This field can be NULL to specify a null Memory Reference. */
+    void            *buffer;
+/*! Size of the referenced memory region. When the operation completes, and \n
+*   unless the parameter type is TEEC_MEMREF_TEMP_INPUT, \n
+*   the Implementation must update this field to reflect the actual or \n
+*   required size of the output: \n
+*   If the Trusted Application has actually written some data in the 
+*   output buffer, then the Implementation MUST update the size field with 
+*   the actual number of bytes written.\n\n
+*   If the output buffer was not large enough to contain the whole output, 
+*   or if it is null, the Implementation MUST update the size field with 
+*   the size of the output buffer requested by the Trusted Application. 
+*   In this case, no data has been written into the output buffer
+*/
+    size_type        size;
+};
+
+/**
+* @brief Registered memory reference 
+*
+* A pre-registered or pre-allocated Shared Memory block. 
+* It is used as a TEEC_Operation parameter when the corresponding 
+* parameter type is one of TEEC_MEMREF_WHOLE, 
+* TEEC_MEMREF_PARTIAL_INPUT, TEEC_MEMREF_PARTIAL_OUTPUT, or
+* TEEC_MEMREF_PARTIAL_INOUT.
+*/
+struct TEEC_RegisteredMemoryReference
+{
+/*! Pointer to the shared memory structure. \n
+* The memory reference refers either to the whole Shared Memory or 
+* to a partial region within the Shared Memory block, depending of the
+* parameter type. The data flow direction of the memory reference 
+* must be consistent with the flags defined in the parent Shared Memory Block. 
+* Note that the parent field MUST NOT be NULL. To encode a null 
+* Memory Reference, the Client Application must use a Temporary Memory
+* Reference with the buffer field set to NULL. */
+    TEEC_SharedMemory* parent;
+
+/*! Size of the referenced memory region, in bytes. \n
+* The Implementation MUST only interpret this field if the Memory Reference 
+* type in the operation structure is not TEEC_MEMREF_WHOLE. Otherwise, 
+* the size is read from the parent Shared Memory structure.\n
+* When an operation completes, and if the Memory Reference is 
+* tagged as “output”, the Implementation must update this field to reflect 
+* the actual or required size of the output. This applies even if the 
+* parameter type is TEEC_MEMREF_WHOLE:\n
+* If the Trusted Application has actually written some data in the 
+* output buffer, then the Implementation MUST update the size field with the 
+* actual number of bytes written.\n
+* If the output buffer was not large enough to contain the 
+* whole output, the Implementation MUST update the size field with the size of 
+* the output buffer requested by the Trusted Application. In this case, 
+* no data has been written into the output buffer.
+*/
+    size_type        size;
+
+/*! Offset from the allocated Shared memory for reference \n
+* The Implementation MUST only interpret this field if the 
+* Memory Reference type in the operation structure is not TEEC_MEMREF_WHOLE. 
+* Otherwise, the Implementation MUST use the base address of the 
+* Shared Memory block.
+*/
+    size_type        offset;
+};
+
+/**
+* @brief Parameter of a TEEC_Operation
+*
+* It can be a Temporary Memory Reference, a Registered Memory Reference, 
+* or a Value Parameter.
+*/
+typedef union
+{
+/*! For parameter type:\n
+*   TEEC_MEMREF_TEMP_INPUT \n
+*   TEEC_MEMREF_TEMP_OUTPUT \n
+*   TEEC_MEMREF_TEMP_INOUT \n
+*/
+    TEEC_TempMemoryReference       tmpref;
+
+/*! For parameter type:\n
+*   TEEC_MEMREF_WHOLE \n
+*   TEEC_MEMREF_PARTIAL_INPUT \n
+*   TEEC_MEMREF_PARTIAL_OUTPUT \n
+*   TEEC_MEMREF_PARTIAL_INOUT \n
+*/
+    TEEC_RegisteredMemoryReference memref;
+
+/*! For parameter type:\n
+*   TEEC_VALUE_INPUT \n
+*   TEEC_VALUE_OUTPUT \n
+*   TEEC_VALUE_INOUT \n
+*/
+    TEEC_Value                     value;
+} TEEC_Parameter;
+
+/**
+* @brief The TEEC_Operation structure is used to contain control information
+* related to an operation that is to be invoked with the security environment.
+*
+* This type defines the payload of either an open Session operation or 
+* an invoke Command operation. It is also used for cancellation of operations, 
+* which may be desirable even if no payload is passed.
+*/
+struct TEEC_Operation
+{
+/*! 
+* This field which MUST be initialized to zero by the Client Application 
+* before each use in an operation if the Client Application may need to 
+* cancel the operation about to be performed.
+*/
+    uint32_t started;
+
+/*! paramTypes field encodes the type of each of the Parameters in the 
+* operation. The layout of these types within a 32-bit integer is 
+* implementation-defined and the Client Application MUST use the
+* macro TEEC_PARAMS_TYPE to construct a constant value for this field. 
+* As a special case, if the Client Application sets paramTypes to 0, 
+* then the Implementation MUST interpret it as meaning that the type for each 
+* Parameter is set to TEEC_NONE.\n
+* The type of each Parameter can take one of the following values\n
+* TEEC_NONE\n
+* TEEC_VALUE_INPUT\n
+* TEEC_VALUE_OUTPUT\n
+* TEEC_VALUE_INOUT\n
+* TEEC_MEMREF_TEMP_INPUT\n
+* TEEC_MEMREF_TEMP_OUTPUT\n
+* TEEC_MEMREF_TEMP_INOUT\n
+* TEEC_MEMREF_WHOLE\n
+* TEEC_MEMREF_PARTIAL_INPUT\n
+* TEEC_MEMREF_PARTIAL_OUTPUT\n
+* TEEC_MEMREF_PARTIAL_INOUT\n
+*/
+    uint32_t paramTypes;
+
+/*! params is an array of four Parameters. For each parameter, one of the 
+* memref, tmpref, or value fields must be used depending on the corresponding 
+* parameter type passed in paramTypes as described in the specification 
+* of TEEC_Parameter
+*/
+    TEEC_Parameter params[4];
+};
+
+
+/**
+* @brief Shared memory flag constants
+*
+*
+*/
+enum shared_mem_flags {
+/*! Service can only read from the memory block.*/
+    MEM_SERVICE_RO = 0x0,
+/*! Service can only write from the memory block.*/
+    MEM_SERVICE_WO ,
+/*! Service can read and write from the memory block.*/
+    MEM_SERVICE_RW,
+/*! Invalid flag */
+    MEM_SERVICE_UNDEFINED
+};
+
+
+/**
+* @brief Initialize Context
+*
+* This function initializes a new TEE Context, forming a connection between 
+* this Client Application and the TEE identified by the string identifier 
+* name.\n
+* The Client Application MAY pass a NULL name, which means that the 
+* Implementation MUST select a default TEE to connect to. 
+* The supported name strings, the mapping of these names to a specific TEE,
+* and the nature of the default TEE are implementation-defined.\n
+* The caller MUST pass a pointer to a valid TEEC Context in context. 
+* The Implementation MUST assume that all fields of the TEEC_Context structure 
+* are in an undefined state.\n
+* 
+* \b Programmer \b Error \n
+* The following usage of the API is a programmer error: \n
+* Attempting to initialize the same TEE Context structure concurrently 
+* from multiple threads. Multi-threaded Client Applications must use 
+* platform-provided locking mechanisms to ensure that this case 
+* does not occur. \n \n
+* \b Implementers’ \b Notes \n
+* It is valid Client Application behavior to concurrently initialize 
+* different TEE Contexts, so the Implementation MUST support this.
+*
+* @param name: A zero-terminated string that describes the TEE to connect to. 
+* If this parameter is set to NULL the Implementation MUST select a default TEE.
+* 
+* @param context: A TEEC_Context structure that MUST be initialized by the 
+* Implementation.
+*
+* @return TEEC_Result:
+* TEEC_SUCCESS: The initialization was successful. \n
+* TEEC_ERROR_*: An implementation-defined error code for any other error.
+*
+*
+*/
+TEEC_Result TEEC_InitializeContext(
+    const char*   name,
+    TEEC_Context* context
+);
+
+
+
+/**
+* @brief Finalizes an initialized TEE context.
+* 
+* This function finalizes an initialized TEE Context, 
+* closing the connection between the Client Application and the TEE. 
+* The Client Application MUST only call this function when all Sessions 
+* inside this TEE Context have been closed and all 
+* Shared Memory blocks have been released. \n
+* The implementation of this function MUST NOT be able to fail: 
+* after this function returns the Client Application must be able to 
+* consider that the Context has been closed.\n
+* The function implementation MUST do nothing if context is NULL.
+*
+* \b Programmer \b Error \n
+* The following usage of the API is a programmer error:\n
+*       Calling with a context which still has sessions opened.\n
+*       Calling with a context which contains unreleased Shared Memory blocks.\n
+*       Attempting to finalize the same TEE Context structure concurrently 
+* from multiple threads.\n
+*       Attempting to finalize the same TEE Context structure more than once, 
+* without an intervening call to TEEC_InitalizeContext.
+*
+* @param context: An initialized TEEC_Context structure which is to be 
+* finalized.
+*
+*/
+void TEEC_FinalizeContext(
+    TEEC_Context* context);
+
+/**
+* @brief Register a allocated shared memory block.
+* 
+* This function registers a block of existing Client Application memory as a 
+* block of Shared Memory within the scope of the specified TEE Context, 
+* in accordance with the parameters which have been set by the 
+* Client Application inside the \a sharedMem structure.
+*
+* The parameter \a context MUST point to an initialized TEE Context.
+*
+* The parameter \a sharedMem MUST point to the Shared Memory structure 
+* defining the memory region to register. 
+* The Client Application MUST have populated the following fields of the 
+* Shared Memory structure before calling this function: \n
+* The \a buffer field MUST point to the memory region to be shared, 
+* and MUST not be NULL.\n
+* The \a size field MUST contain the size of the buffer, in bytes. 
+* Zero is a valid length for a buffer. \n
+* The \a flags field indicates the intended directions of data flow 
+* between the Client Application and the TEE. \n
+* The Implementation MUST assume that all other fields in the Shared Memory 
+* structure have undefined content.
+* 
+* An Implementation MAY put a hard limit on the size of a single 
+* Shared Memory block, defined by the constant TEEC_CONFIG_SHAREDMEM_MAX_SIZE. 
+* However note that this function may fail to register a
+* block smaller than this limit due to a low resource condition 
+* encountered at run-time.
+*
+* \b Programmer \b Error \n
+* The following usage of the API is a programmer error:\n
+*       Calling with a \a context which is not initialized.\n
+*       Calling with a \a sharedMem which has not be correctly populated 
+*       in accordance with the specification.\n
+*       Attempting to initialize the same Shared Memory structure concurrently 
+*       from multiple threads.Multi-threaded Client Applications must use 
+*       platform-provided locking mechanisms to ensure that
+*       this case does not occur.
+*
+* \b Implementor's \b Notes \n
+* This design allows a non-NULL buffer with a size of 0 bytes to allow 
+* trivial integration with any implementations of the C library malloc, 
+* in which is valid to allocate a zero byte buffer and receive a non-
+* NULL pointer which may not be de-referenced in return.
+* Once successfully registered, the Shared Memory block can be used for 
+* efficient data transfers between the Client Application and the 
+* Trusted Application. The TEE Client API implementation and the underlying
+* communications infrastructure SHOULD attempt to transfer data in to the 
+* TEE without using copies, if this is possible on the underlying 
+* implementation, but MUST fall back on data copies if zero-copy cannot be
+* achieved. Client Application developers should be aware that, 
+* if the Implementation requires data copies,
+* then Shared Memory registration may allocate a block of memory of the 
+* same size as the block being registered.
+*
+* @param context: A pointer to an initialized TEE Context
+* @param sharedMem:  A pointer to a Shared Memory structure to register: \n
+* the \a buffer, \a size, and \a flags fields of the sharedMem structure 
+* MUST be set in accordance with the specification described above
+*
+* @return TEEC_Result:
+* TEEC_SUCCESS: The device was successfully opened. \n
+* TEEC_ERROR_*: An implementation-defined error code for any other error.
+*
+*/
+TEEC_Result TEEC_RegisterSharedMemory(
+    TEEC_Context*      context,
+    TEEC_SharedMemory* sharedMem);
+
+
+/**
+* @brief Allocate a shared memory block.
+* 
+* This function allocates a new block of memory as a block of Shared Memory 
+* within the scope of the specified TEE Context, in accordance with the 
+* parameters which have been set by the Client Application inside the 
+* \a sharedMem structure.
+*
+* The parameter \a context MUST point to an initialized TEE Context.
+*
+* The \a sharedMem parameter MUST point to the Shared Memory structure 
+* defining the region to allocate. 
+* Client Application MUST have populated the following fields of the 
+* Shared Memory structure: \n
+* The \a size field MUST contain the desired size of the buffer, in bytes. 
+* The size is allowed to be zero. In this case memory is allocated and 
+* the pointer written in to the buffer field on return MUST not be NULL 
+* but MUST never be de-referenced by the Client Application. In this case
+* however, the Shared Memory block can be used in 
+* Registered Memory References. \n
+* The \a flags field indicates the allowed directions of data flow 
+* between the Client Application and the TEE. \n
+* The Implementation MUST assume that all other fields in the Shared Memory 
+* structure have undefined content.
+* 
+* An Implementation MAY put a hard limit on the size of a single 
+* Shared Memory block, defined by the constant 
+* \a TEEC_CONFIG_SHAREDMEM_MAX_SIZE. 
+* However note that this function may fail to allocate a
+* block smaller than this limit due to a low resource condition 
+* encountered at run-time.
+* 
+* If this function returns any code other than \a TEEC_SUCCESS 
+* the Implementation MUST have set the \a buffer field of \a sharedMem to NULL.
+*
+*
+* \b Programmer \b Error \n
+* The following usage of the API is a programmer error:\n
+*       Calling with a \a context which is not initialized.\n
+*       Calling with a \a sharedMem which has not be correctly populated 
+*       in accordance with the specification.\n
+*       Attempting to initialize the same Shared Memory structure concurrently 
+*       from multiple threads.Multi-threaded Client Applications must use 
+*       platform-provided locking mechanisms to ensure that
+*       this case does not occur.
+*
+* \b Implementor's \b Notes \n
+* Once successfully allocated the Shared Memory block can be used for 
+* efficient data transfers between the Client Application and the 
+* Trusted Application. The TEE Client API and the underlying communications
+* infrastructure should attempt to transfer data in to the TEE 
+* without using copies, if this is possible on the underlying implementation, 
+* but may have to fall back on data copies if zero-copy cannot be achieved.
+* The memory buffer allocated by this function must have sufficient 
+* alignment to store any fundamental C data type at a natural alignment. 
+* For most platforms this will require the memory buffer to have 8-byte
+* alignment, but refer to the Application Binary Interface (ABI) of the 
+* target platform for details.
+*
+* @param context: A pointer to an initialized TEE Context
+* @param sharedMem:  A pointer to a Shared Memory structure to allocate: \n
+* Before calling this function, the Client Application MUST have set 
+* the \a size, and \a flags fields. \n
+* On return, for a successful allocation the Implementation 
+* MUST have set the pointer buffer to the address of the allocated block, 
+* otherwise it MUST set buffer to NULL.
+*
+* @return TEEC_Result:
+* TEEC_SUCCESS: The allocation was successful. \n
+* TEEC_ERROR_*: An implementation-defined error code for any other error.
+*
+*/
+TEEC_Result TEEC_AllocateSharedMemory(
+    TEEC_Context*      context,
+    TEEC_SharedMemory* sharedMem);
+
+
+/**
+* @brief Release a shared memory block.
+* 
+* This function deregisters or deallocates a previously initialized block of 
+* Shared Memory.
+* For a memory buffer allocated using \a TEEC_AllocateSharedMemory the 
+* Implementation MUST free the underlying memory and the Client Application 
+* MUST NOT access this region after this function has been called. 
+* In this case the Implementation MUST set the \a buffer and \a size fields 
+* of the \a sharedMem structure to NULL and 0 respectively before returning.
+*
+* For memory registered using \a TEEC_RegisterSharedMemory 
+* the Implementation MUST deregister the underlying memory from the TEE, 
+* but the memory region will stay available to the Client Application for
+* other purposes as the memory is owned by it.
+*
+* The Implementation MUST do nothing if the \a sharedMem parameter is \a NULL.
+*
+* \b Programmer \b Error \n
+* The following usage of the API is a programmer error:\n
+*       Attempting to release Shared Memory which is used by a 
+*       pending operation. \n
+*       Attempting to release the same Shared Memory structure concurrently 
+*       from multiple threads. Multi-threaded Client Applications 
+*       must use platform-provided locking mechanisms to ensure that
+*       this case does not occur.
+*
+* @param sharedMem:  A pointer to a valid Shared Memory structure \n
+*
+*/
+void TEEC_ReleaseSharedMemory(
+    TEEC_SharedMemory* sharedMem);
+
+
+/**
+* @brief Opens a new session between client and trusted application
+*
+*
+* This function opens a new Session between the Client Application and 
+* the specified Trusted Application.
+* 
+* The Implementation MUST assume that all fields of this \a session structure 
+* are in an \a undefined state. When this function returns \a TEEC_SUCCESS 
+* the Implementation MUST have populated this structure with any information 
+* necessary for subsequent operations within the Session.
+*
+* The target Trusted Application is identified by a UUID passed in the 
+* parameter destination.
+*
+* The Session MAY be opened using a specific connection method that can carry 
+* additional connection data, such as data about the user or user-group running
+* the Client Application, or about the Client Application itself. 
+* This allows the Trusted Application to implement access control methods 
+* which separate functionality or data accesses for different actors
+* in the rich environment outside of the TEE. The additional data associated 
+* with each connection method is passed in via the pointer \a connectionData. 
+* For the core login types the following connection data is required:
+*
+* \a TEEC_LOGIN_PUBLIC - \a connectionData SHOULD be \a NULL.\n
+* \a TEEC_LOGIN_USER - \a connectionData SHOULD be \a NULL.\n
+* \a TEEC_LOGIN_GROUP - \a connectionData MUST point to a uint32_t 
+* which contains the group which this Client Application wants to connect as. 
+* The Implementation is responsible for securely ensuring that the 
+* Client Application instance is actually a member of this group.\n
+* \a TEEC_LOGIN_APPLICATION - \a connectionData SHOULD be \a NULL.\n
+* \a TEEC_LOGIN_USER_APPLICATION - \a connectionData SHOULD be \a NULL.\n
+* \a TEEC_LOGIN_GROUP_APPLICATION - \a connectionData MUST point to a uint32_t 
+* which contains the group which this Client Application wants to connect as. 
+* The Implementation is responsible for securely ensuring that the 
+* Client Application instance is actually a member of this group.\n
+*
+* An open-session operation MAY optionally carry an Operation Payload, 
+* and MAY also be cancellable. When the payload is present the parameter 
+* \a operation MUST point to a \a TEEC_Operation structure populated by the 
+* Client Application. If \a operation is NULL then no data buffers are 
+* exchanged with the Trusted Application, and the operation cannot be 
+* cancelled by the Client Application.
+*
+* The result of this function is returned both in the function 
+* \a TEEC_Result return code and the return origin, stored in the variable 
+* pointed to by \a returnOrigin: \n
+* If the return origin is different from \a TEEC_ORIGIN_TRUSTED_APP, 
+* then the return code MUST be  one of the defined error codes . 
+* If the return code is \a TEEC_ERROR_CANCEL then it means that the 
+* operation was cancelled before it reached the Trusted Application.\n
+* If the return origin is \a TEEC_ORIGIN_TRUSTED_APP, the meaning of the 
+* return code depends on the protocol between the Client Application 
+* and the Trusted Application. However, if \a TEEC_SUCCESS is returned, 
+* it always means that the session was successfully opened and if the
+* function returns a code different from \a TEEC_SUCCESS, 
+* it means that the session opening failed.
+*
+* \b Programmer \b Error \n
+* The following usage of the API is a programmer error:\n
+*       Calling with a \a context which is not yet initialized. \n
+*       Calling with a connectionData set to NULL if connection data is 
+*  required by the specified connection method. \n
+*       Calling with an operation containing an invalid paramTypes field, 
+* i.e., containing a reserved parameter type or where a parameter type 
+* that conflicts with the parent Shared Memory. \n
+*       Encoding Registered Memory References which refer to 
+* Shared Memory blocks allocated within the scope of a different TEE Context. \n
+*       Attempting to open a Session using the same Session structure 
+* concurrently from multiple threads. Multi-threaded Client Applications 
+* must use platform-provided locking mechanisms, to ensure that this 
+* case does not occur.\n
+*      Using the same Operation structure for multiple concurrent operations. \n
+*
+* @param context: A pointer to an initialized TEE Context.
+* @param session: A pointer to a Session structure to open.
+* @param destination: A pointer to a structure containing the UUID of the 
+* destination Trusted Application
+* @param connectionMethod:  The method of connection to use
+* @param connectionData: Any necessary data required to support the 
+* connection method chosen.
+* @param operation: A pointer to an Operation containing a set of Parameters 
+* to exchange with the Trusted Application, or \a NULL if no Parameters 
+* are to be exchanged or if the operation cannot be cancelled
+* @param returnOrigin: A pointer to a variable which will contain the 
+* return origin. This field may be \a NULL if the return origin is not needed.
+*
+* @return TEEC_Result:
+* TEEC_SUCCESS: The session was successfully opened. \n
+* TEEC_ERROR_*: An implementation-defined error code for any other error.
+*/
+TEEC_Result TEEC_OpenSession (
+    TEEC_Context*    context,
+    TEEC_Session*    session,
+    const TEEC_UUID* destination,
+    uint32_t         connectionMethod,
+    const void*      connectionData,
+    TEEC_Operation* operation,
+    uint32_t*        returnOrigin);
+
+
+/**
+* @brief Close a opened session between client and trusted application
+*
+*
+* This function closes a Session which has been opened with a 
+* Trusted Application.
+* 
+* All Commands within the Session MUST have completed before 
+* calling this function.
+*
+* The Implementation MUST do nothing if the session parameter is NULL.
+*
+* The implementation of this function MUST NOT be able to fail: 
+* after this function returns the Client Application must be able to 
+* consider that the Session has been closed.
+*
+* \b Programmer \b Error \n
+* The following usage of the API is a programmer error:\n
+*       Calling with a session which still has commands running.\n
+*       Attempting to close the same Session concurrently from multiple 
+* threads. \n
+*       Attempting to close the same Session more than once.
+*
+* @param session: Session to close
+*/
+void TEEC_CloseSession (
+    TEEC_Session*    session);
+
+
+/**
+* @brief Invokes a command within the session
+*
+*
+* This function invokes a Command within the specified Session.
+* 
+* The parameter \a session MUST point to a valid open Session.
+*
+* The parameter \a commandID is an identifier that is used to indicate 
+* which of the exposed Trusted Application functions should be invoked. 
+* The supported command identifiers are defined by the Trusted Application‟s 
+* protocol.
+*
+* \b Operation \b Handling \n
+* A Command MAY optionally carry an Operation Payload. 
+* When the payload is present the parameter \a operation MUST point to a 
+* \a TEEC_Operation structure populated by the Client Application. 
+* If \a operation is NULL then no parameters are exchanged with the 
+* Trusted Application, and only the Command ID is exchanged.
+*
+* The \a operation structure is also used to manage cancellation of the 
+* Command. If cancellation is required then \a the operation pointer MUST be 
+* \a non-NULL and the Client Application MUST have zeroed the \a started 
+* field of the \a operation structure before calling this function. 
+* The \a operation structure MAY contain no Parameters if no data payload 
+* is to be exchanged.
+*
+* The Operation Payload is handled as described by the following steps, 
+* which are executed sequentially: \n
+* 1. Each Parameter in the Operation Payload is examined. 
+* If the parameter is a Temporary Memory Reference, then it is registered 
+* for the duration of the Operation in accordance with the fields set in
+* the \a TEEC_TempMemoryReference structure and the data flow direction 
+* specified in the parameter type. Refer to the \a TEEC_RegisterSharedMemory 
+* function for error conditions which can be triggered during 
+* temporary registration of a memory region. \n
+* 2. The contents of all the Memory Regions which are exchanged 
+* with the TEE are synchronized \n
+* 3. The fields of all Value Parameters tagged as input are read by the 
+* Implementation. This applies to Parameters of type \a TEEC_VALUE_INPUT or 
+* \a TEEC_VALUE_INOUT. \n
+* 4. The Operation is issued to the Trusted Application. 
+* During the execution of the Command, the Trusted Application may read 
+* the data held within the memory referred to by input Memory References. 
+* It may also write data in to the memory referred to by 
+* output Memory References, but these modifications are not guaranteed 
+* to be observable by the Client Application until the command completes. \n
+* 5. After the Command has completed, the Implementation MUST update the 
+* \a size field of the Memory Reference structures flagged as output: \n
+*
+* a. For Memory References that are non-null and marked as output, 
+* the updated size field MAY be less than or equal to original size field. 
+* In this case this indicates the number of bytes actually written by the 
+* Trusted Application, and the Implementation MUST synchronize this region 
+* with the Client Application memory space. \n
+* b. For all Memory References marked as output, the updated size 
+* field MAY be larger than the original size field. 
+* For null Memory References, a required buffer size MAY be specified by
+* the Trusted Application. In these cases the passed output buffer was 
+* too small or absent, and the returned size indicates the size of the 
+* output buffer which is necessary for the operation to succeed. 
+* In these cases the Implementation SHOULD NOT synchronize any 
+* shared data with the Client Application.\n\n
+*
+* 6. When the Command completes, the Implementation MUST update the fields 
+* of all Value Parameters tagged as output, 
+* i.e., of type \a TEEC_VALUE_OUTPUT or \a TEEC_VALUE_INOUT. \n
+* 7. All memory regions that were temporarily registered at the 
+* beginning of the function are deregistered as if the function 
+* \a TEEC_ReleaseSharedMemory was called on each of them.
+* 8. Control is passed back to the calling Client Application code. \n
+* \b Programmer \b Error \n.
+*
+* The result of this function is returned both in the function 
+* \a TEEC_Result return code and the return origin, stored in the 
+* variable pointed to by \a returnOrigin: \n
+*       If the return origin is different from \a TEEC_ORIGIN_TRUSTED_APP, 
+* then the return code MUST be one of the error codes. 
+* If the return code is TEEC_ERROR_CANCEL then it means that the operation 
+* was cancelled before it reached the Trusted Application.\n
+* If the return origin is \a TEEC_ORIGIN_TRUSTED_APP, then the 
+* meaning of the return code is determined by the protocol exposed by the 
+* Trusted Application. It is recommended that the Trusted Application 
+* developer chooses TEEC_SUCCESS (0) to indicate success in their protocol,
+* as this means that it is possible for the Client Application developer 
+* to determine success or failure without looking at the return origin.
+*
+* \b Programmer \n Error \n
+* The following usage of the API is a programmer error:\n
+*       Calling with a \a session which is not an open session. \n
+*       Calling with invalid content in the \a paramTypes field of the 
+* \a operation structure. This invalid behavior includes types which are 
+* \a Reserved for future use or which conflict with the \a flags 
+* of the parent Shared Memory block. \n
+*       Encoding Registered Memory References which refer to 
+* Shared Memory blocks allocated or registered within the scope of a 
+* different TEE Context. \n
+*       Using the same operation structure concurrently for 
+* multiple operations, whether open Session operations or Command invocations.
+*
+* @param session: The open Session in which the command will be invoked.
+* @param commandID: The identifier of the Command within the 
+* Trusted Application to invoke. The meaning of each Command Identifier 
+* must be defined in the protocol exposed by the Trusted Application
+* @param operation: A pointer to a Client Application initialized 
+* \a TEEC_Operation structure, or NULL if there is no payload to send or 
+* if the Command does not need to support cancellation.
+* @param returnOrigin: A pointer to a variable which will contain the 
+* return origin. This field may be \a NULL if the return origin is not needed.
+*
+* @return TEEC_Result:
+* TEEC_SUCCESS: The command was successfully invoked. \n
+* TEEC_ERROR_*: An implementation-defined error code for any other error.
+*/
+TEEC_Result TEEC_InvokeCommand(
+    TEEC_Session*     session,
+    uint32_t          commandID,
+    TEEC_Operation*   operation,
+    uint32_t*         returnOrigin);
+
+
+/**
+* @brief Request cancellation of pending open session or command invocation.
+* 
+* This function requests the cancellation of a pending open Session operation 
+* or a Command invocation operation. As this is a synchronous API, 
+* this function must be called from a thread other than the one executing the 
+* \a TEEC_OpenSession or \a TEEC_InvokeCommand function.
+* 
+* This function just sends a cancellation signal to the TEE and returns 
+* immediately; the operation is not guaranteed to have been cancelled 
+* when this function returns. In addition, the cancellation request is just
+* a hint; the TEE or the Trusted Application MAY ignore the 
+* cancellation request.
+*
+* It is valid to call this function using a \a TEEC_Operation structure 
+* any time after the Client Application has set the \a started field of an 
+* Operation structure to zero. In particular, an operation can be 
+* cancelled before it is actually invoked, during invocation, and 
+* after invocation. Note that the Client Application MUST reset
+* the started field to zero each time an Operation structure is used 
+* or re-used to open a Session or invoke a Command if the new operation 
+* is to be cancellable.
+*
+* Client Applications MUST NOT reuse the Operation structure for another 
+* Operation until the cancelled command has actually returned in the thread 
+* executing the \a TEEC_OpenSession or \a TEEC_InvokeCommand function.
+*
+* \b Detecting \b cancellation \n
+* In many use cases it will be necessary for the Client Application 
+* to detect whether the operation was actually cancelled, or whether it 
+* completed normally. \n
+* In some implementations it MAY be possible for part of the infrastructure 
+* to cancel the operation before it reaches the Trusted Application. 
+* In these cases the return origin returned by \a TEEC_OpenSession or
+* \a TEEC_InvokeCommand MUST be either or \a TEEC_ORIGIN_API, 
+* \a TEEC_ORIGIN_COMMS, \a TEEC_ORIGIN_TEE, and the return code MUST be 
+* \a TEEC_ERROR_CANCEL. \n
+* If the cancellation request is handled by the Trusted Application itself 
+* then the return origin returned by \a TEEC_OpenSession or 
+* \a TEEC_InvokeCommand MUST be \a TEE_ORIGIN_TRUSTED_APP, 
+* and the return code is defined by the Trusted Application‟s protocol. 
+* If possible, Trusted Applications SHOULD use \a TEEC_ERROR_CANCEL 
+* for their return code, but it is accepted that this is not always 
+* possible due to conflicts with existing return code definitions in 
+* other standards.
+*
+* @param operation: A pointer to a Client Application instantiated 
+* Operation structure.
+*/
+void TEEC_RequestCancellation(
+    TEEC_Operation* operation);
+
+/**
+* @brief Returns error string.
+* 
+* This function returns the error string value based on error number and 
+* return origin.
+*
+* @param error:  Error number.
+* @param returnOrigin:  Origin of the return.
+*
+* @return char*: Error string value.
+* 
+*/
+
+void allow(TEEC_Operation* operation);
+void block(TEEC_Operation* operation);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libmtee/include/tee_client_api.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libmtee/include/teei_client_api.h
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libmtee/include/teei_client_api.h	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libmtee/include/teei_client_api.h	(revision 2997)
@@ -0,0 +1,67 @@
+#ifndef __TEEI_CLIENT_API_H_
+#define __TEEI_CLIENT_API_H_
+#include "tee_client_api.h"
+#define TEEIC_PARAM_TYPES( param0Type, param1Type, param2Type, param3Type) \
+    (param3Type << 12 | param2Type << 8 | param1Type << 4 | param0Type)
+
+typedef uint32_t TEEIC_Result;
+typedef TEEC_UUID TEEIC_UUID;
+typedef TEEC_Context TEEIC_Context;
+typedef TEEC_Session TEEIC_Session;
+typedef TEEC_SharedMemory TEEIC_SharedMemory;
+typedef TEEC_TempMemoryReference TEEIC_TempMemoryReference;
+typedef TEEC_Value TEEIC_Value;
+typedef TEEC_Parameter TEEIC_Parameter;
+typedef TEEC_Operation TEEIC_Operation;
+
+
+TEEIC_Result TEEIC_InitializeContext(
+    const char*   name,
+    TEEIC_Context* context
+);
+
+
+
+void TEEIC_FinalizeContext(
+    TEEIC_Context* context);
+
+TEEIC_Result TEEIC_RegisterSharedMemory(
+    TEEIC_Context*      context,
+    TEEIC_SharedMemory* sharedMem);
+
+
+TEEIC_Result TEEIC_AllocateSharedMemory(
+    TEEIC_Context*      context,
+    TEEIC_SharedMemory* sharedMem);
+
+
+void TEEIC_ReleaseSharedMemory(
+    TEEIC_SharedMemory* sharedMem);
+
+TEEIC_Result TEEIC_OpenSession (
+    TEEIC_Context*    context,
+    TEEIC_Session*    session,
+    const TEEIC_UUID* destination,
+    uint32_t         connectionMethod,
+    const void*      connectionData,
+    TEEIC_Operation* operation,
+    uint32_t*        returnOrigin);
+
+void TEEIC_CloseSession (
+    TEEIC_Session*    session);
+
+TEEIC_Result TEEIC_InvokeCommand(
+    TEEIC_Session*     session,
+    uint32_t          commandID,
+    TEEIC_Operation*   operation,
+    uint32_t*         returnOrigin);
+
+
+void TEEIC_RequestCancellation(
+    TEEIC_Operation* operation);
+
+void allow(TEEC_Operation* operation);
+void block(TEEC_Operation* operation);
+
+#endif
+

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libmtee/include/teei_client_api.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libmtee/Android.mk
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libmtee/Android.mk	(revision 0)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libmtee/Android.mk	(revision 2997)
@@ -0,0 +1,17 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := libmtee
+LOCAL_MODULE_CLASS := SHARED_LIBRARIES
+LOCAL_SRC_FILES_arm := lib/armeabi/libmtee.so
+LOCAL_SRC_FILES_arm64 := lib/arm64-v8a/libmtee.so
+LOCAL_MODULE_SUFFIX := .so
+LOCAL_MULTILIB := both
+LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include
+
+PLATFORM_VERSION_MAJOR := $(word 1,$(subst .,$(space),$(PLATFORM_VERSION)))
+ifneq ($(PLATFORM_VERSION_MAJOR), 6)
+LOCAL_PROPRIETARY_MODULE := true
+endif
+
+include $(BUILD_PREBUILT)

Property changes on: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/ifaa_ca/libmtee/Android.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/Android.mk
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/Android.mk	(revision 2996)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/Android.mk	(revision 2997)
@@ -3,4 +3,4 @@
 LOCAL_PATH:= $(call my-dir)
 include $(call all-makefiles-under,$(LOCAL_PATH))
 
-endif
\ No newline at end of file
+endif
Index: vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/teei_daemon/main.c
===================================================================
--- vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/teei_daemon/main.c	(revision 2996)
+++ vendor/mediatek/proprietary/trustzone/microtrust/source/platform/mt6739/external/teei_daemon/main.c	(revision 2997)
@@ -43,7 +43,7 @@
 #define BUFFER_SIZE (512 * 1024)
 #define DEV_FILE "/dev/tz_vfs"
 
-//#define FP_TA_COMPATIBLE_SUPPORT
+#define FP_TA_COMPATIBLE_SUPPORT
 
 #define TEEI_IOC_MAGIC 'T'
 #define TEEI_CONFIG_IOC_MAGIC TEEI_IOC_MAGIC
Index: vendor
===================================================================
--- vendor	(revision 2996)
+++ vendor	(revision 2997)

Property changes on: vendor
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /L05A/Trunk/ALPS-MP-N1.MP18-V1_AUS6739_66_N1_INHOUSE/vendor:r2850-2851
Index: libcore/ojluni/src/main/java/java/security/Signature.java
===================================================================
--- libcore/ojluni/src/main/java/java/security/Signature.java	(revision 2996)
+++ libcore/ojluni/src/main/java/java/security/Signature.java	(revision 2997)
@@ -1306,6 +1306,11 @@
 
         @Override
         public SignatureSpi getCurrentSpi() {
+            //MICROTRUST_WECHATPAY_BEGIN
+            if (sigSpi != null) {
+                return sigSpi;
+            }
+            //MICROTRUST_WECHATPAY_END
             synchronized (lock) {
                 return sigSpi;
             }
Index: frameworks/base/ifaa_fw/Android.mk
===================================================================
--- frameworks/base/ifaa_fw/Android.mk	(revision 0)
+++ frameworks/base/ifaa_fw/Android.mk	(revision 2997)
@@ -0,0 +1,37 @@
+LOCAL_PATH := $(call my-dir)
+
+IFAA_JNI_PATH := src/jni
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := libifaa_jni
+
+LOCAL_CFLAGS := -Wall -Wextra -Werror -Wunused
+LOCAL_C_INCLUDES += \
+	$(JNI_H_INCLUDE)
+
+LOCAL_SRC_FILES := \
+	$(IFAA_JNI_PATH)/org_ifaa_android_manager_IFAAManager.cpp
+
+LOCAL_SHARED_LIBRARIES := \
+	liblog \
+	libcutils \
+	libutils \
+	libc \
+	libbinder \
+	libifaa_daemon
+
+include $(BUILD_SHARED_LIBRARY)
+
+
+
+############################ build ifaa_fw ############################
+# 
+# include $(CLEAR_VARS)
+#
+# LOCAL_MODULE := ifaa_fw
+# LOCAL_SRC_FILES := $(call all-java-files-under, $(IFAA_JAVA_PATH))
+# LOCAL_SHARED_LIBRARIES := libifaa_jni
+# LOCAL_MODULE_TAGS := optional
+#
+# include $(BUILD_JAVA_LIBRARY)

Property changes on: frameworks/base/ifaa_fw/Android.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/ifaa_fw/src/jni/org_ifaa_android_manager_IFAAManager.cpp
===================================================================
--- frameworks/base/ifaa_fw/src/jni/org_ifaa_android_manager_IFAAManager.cpp	(revision 0)
+++ frameworks/base/ifaa_fw/src/jni/org_ifaa_android_manager_IFAAManager.cpp	(revision 2997)
@@ -0,0 +1,202 @@
+/**
+ * @author yangzh6
+ *
+ * Reference:
+ *         [frameworks/base/services/core/jni/onload.cpp]
+ */
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "IFAAManager-JNI"
+
+#include <binder/IServiceManager.h>
+#include <JNIHelp.h>
+#include <jni.h>
+#include <utils/Log.h>
+#include <utils/misc.h>
+#include <utils/threads.h>
+
+#include "IIfaaDaemon.h"
+
+using namespace android;
+
+static const char* JNI_REG_CLASS_NAME = "org/ifaa/android/manager/IFAAManager";
+static const char* IIfaaDaemonDescriptor = "android.hardware.ifaa.IIfaaDaemon";
+
+class IfaaDaemonClient; // Forward declaration.
+Mutex gLock;
+sp<IIfaaDaemon> gIfaaDaemon;
+sp<IfaaDaemonClient> gIfaaDaemonClient;
+
+// -----------------------------------------------------------------------------------------
+class IfaaDaemonClient : public IBinder::DeathRecipient
+{
+public:
+    // DeathRecipient
+    virtual void binderDied(const wp<IBinder>& who);
+};
+
+void IfaaDaemonClient::binderDied(const wp<IBinder>& who __unused)
+{
+    Mutex::Autolock _l(gLock);
+    gIfaaDaemon.clear();
+    ALOGW("IfaaDaemon server died!");
+}
+
+// -----------------------------------------------------------------------------------------
+static jbyteArray newByteArray(JNIEnv* env, uint8_t* array, uint32_t size_array)
+{
+    jbyteArray jarray = env->NewByteArray(size_array);
+    if(NULL == jarray) {
+        ALOGE("NewByteArray(%u) returned NULL", size_array);
+        return NULL;
+    }
+
+    env->SetByteArrayRegion(jarray, 0, size_array, (jbyte*) array);
+
+    if (env->ExceptionCheck()) {
+        return NULL;
+    }
+
+    return jarray;
+}
+
+const sp<IIfaaDaemon> getIfaaDaemon()
+{
+    sp<IIfaaDaemon> daemon;
+    {
+        Mutex::Autolock _l(gLock);
+        if (gIfaaDaemon == 0) {
+            sp<IServiceManager> sm = defaultServiceManager();
+            sp<IBinder> binder;
+            do {
+                binder = sm->getService(String16(IIfaaDaemonDescriptor));
+                if (binder != 0) {
+                    break;
+                } else {
+                    ALOGW("IIfaaDaemon not published, waiting...");
+                    usleep(500000); // 0.5s
+                }
+            } while (true);
+            if (gIfaaDaemonClient == NULL) {
+                gIfaaDaemonClient = new IfaaDaemonClient();
+            }
+            binder->linkToDeath(gIfaaDaemonClient);
+            gIfaaDaemon = interface_cast<IIfaaDaemon>(binder);
+            LOG_ALWAYS_FATAL_IF(gIfaaDaemon == 0);
+        }
+        daemon = gIfaaDaemon;
+    }
+    return daemon;
+}
+
+static int daemonProcessCmd(const uint8_t* param, size_t size_param, uint8_t** result, size_t* size_result)
+{
+    int err = 0;
+
+    const sp<IIfaaDaemon>& daemon = getIfaaDaemon();
+    if (daemon != 0) {
+        err = daemon->processCmd(param, size_param, result, size_result);
+    }
+
+    return err;
+}
+
+static jbyteArray processCmd(JNIEnv* env, jobject /* clazz */,
+        jobject /* jcontext */, jbyteArray jparam)
+{
+    /** result related */
+    int result = 0;
+    uint8_t* result_blob = NULL;
+    size_t size_result_blob = 0;
+    jbyteArray jresult_blob = NULL;
+
+    /** convert param */
+    uint32_t size_param = env->GetArrayLength(jparam);
+    jbyte* param = (jbyte*) env->GetByteArrayElements(jparam, NULL);
+
+    if (NULL == param) {
+        ALOGE("%s GetByteArrayElements returned NULL", __func__);
+        goto out;
+    }
+
+    /**
+     * invoke daemon method.
+     *      int processCmd(const uint8_t *param, size_t paramLength, uint8_t **resp, size_t *respLength);
+     */
+    result = daemonProcessCmd((uint8_t*)param, size_param, &result_blob, &size_result_blob);
+    if (result || (NULL == result_blob)) {
+        ALOGE("processCmd, result = %d, result_blob = %p", result, result_blob);
+        goto out;
+    }
+
+    jresult_blob = newByteArray(env, result_blob, (uint32_t)size_result_blob);
+
+out:
+    //ALOGE("zyang---, jparam = %s, param = %s, result_blob = %s, jresult_blob = %s", (char*)jparam, (char*)param, (char*)result_blob, (char*)jresult_blob);
+    if (result_blob) {
+        free(result_blob);
+    }
+    if (param) {
+        env->ReleaseByteArrayElements(jparam, param, 0);
+    }
+
+    return jresult_blob;
+}
+
+class ScopedLocalRef {
+    public:
+        ScopedLocalRef(JNIEnv* env, jobject ref) :
+            ref_(ref), env_(env) {}
+
+        ~ScopedLocalRef() {
+            if (ref_)
+                env_->DeleteLocalRef(ref_);
+        }
+
+        jobject ref() const {
+            return ref_;
+        }
+
+    private:
+        jobject ref_;
+        JNIEnv* env_;
+};
+
+static int registerMethods(JNIEnv* env, const char* className, const JNINativeMethod* methodList, int length)
+{
+    ScopedLocalRef clazz(env, env->FindClass(className));
+    if (!clazz.ref()) {
+        ALOGE("Can't find class %s", className);
+        return -1;
+    }
+
+    jint result = env->RegisterNatives((jclass) clazz.ref(), methodList, length);
+    if (result != JNI_OK) {
+        ALOGE("registerNatives failed, className: %s", className);
+        return -1;
+    }
+
+    return 0;
+}
+
+static JNINativeMethod method_table[] = {
+        { "processCmd", "(Landroid/content/Context;[B)[B", (void*) processCmd },
+};
+
+extern "C" jint JNI_OnLoad(JavaVM* vm, void* /* reserved */) {
+    JNIEnv* env = NULL;
+
+    if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) {
+        ALOGE("GetEnv failed!");
+        return -1;
+    }
+    ALOG_ASSERT(env, "Could not retrieve the env!");
+
+    //jniRegisterNativeMethods(env, JNI_REG_CLASS_NAME, method_table,
+    //        NELEM(method_table));
+    if (registerMethods(env, JNI_REG_CLASS_NAME, method_table, NELEM(method_table))) {
+        ALOGE("JNI_OnLoad, registerMethods failed!");
+    }
+
+    return JNI_VERSION_1_4;
+}

Property changes on: frameworks/base/ifaa_fw/src/jni/org_ifaa_android_manager_IFAAManager.cpp
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAManager.java
===================================================================
--- frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAManager.java	(revision 0)
+++ frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAManager.java	(revision 2997)
@@ -0,0 +1,105 @@
+/**
+ * @author yangzh6
+ *
+ * Reference: <<IFAA 标准: REE 系统框架部分>>
+ * Description: IFAAManager为抽象类，需要放到系统framework中，通过IFAAManager生成实例。
+ */
+
+package org.ifaa.android.manager;
+
+import android.content.Context;
+import android.hardware.fingerprint.FingerprintManager;
+import android.os.Build;
+import android.util.Log;
+public abstract class IFAAManager {
+    static
+    {
+        System.loadLibrary("ifaa_jni");
+    }
+	//String TAG = "IFAA_JAR";
+	/** Internal Functions */
+	private boolean isFpSupported(Context context) {
+		if (null != context) {
+			FingerprintManager fpManager = (FingerprintManager) context
+					.getSystemService(Context.FINGERPRINT_SERVICE);
+			if (null != fpManager) {
+				return fpManager.isHardwareDetected();
+			}
+		}
+		return false;
+	}
+
+	private boolean isIrisSupported(Context context) {
+		if (null != context) {
+			/**
+			 * TODO: ...
+			 */
+			return false;
+		}
+		return false;
+	}
+
+	// APIs
+	// ------------------------------------------------------------------------
+	/**
+	 * Description: 返回系统手机型号， model字段用于标记手机的型号，主要是指的一个系列。例如一个厂商的各个MODLE，
+	 * 例如三星的S6有可能叫SAMSUNG-SM9200， SAMSUNG-SM9201等等，其实都是指的一个系列，
+	 * 但是他们都是使用的同一个方案，例如TA和芯片和指纹芯片。所以对model的定义就是一个系列，他们对应了一个内置的厂商TA私钥。
+	 */
+	public String getDeviceModel() {
+		
+		String model_name = Build.MODEL;
+		String realModel = model_name.replace(' ','-');
+		//Log.w(TAG,"test" + realModel);
+		
+		//return realModel;
+		return "bptest-mod1";
+	}
+
+	/**
+	 * * Description: 返回Manager接口版本，目前为1。
+	 */
+	public int getVersion() {
+		return 1;
+	}
+
+	/**
+	 * Description: 返回手机上支持的校验方式，
+	 * 目前IFAF协议1.0版本指纹为0x01、虹膜为0x02，验证类型可以为多种不同方式组合，用‘或’操作符拼接。
+	 */
+	public int getSupportBIOTypes(Context context) {
+		int types = 0;
+		if (isFpSupported(context)) {
+			types |= IFAAUtils.BIO_TYPE_FINGERPRINT;
+		}
+		if (isIrisSupported(context)) {
+			types |= IFAAUtils.BIO_TYPE_IRIS;
+		}
+		return types;
+	}
+
+	/**
+	 * Description: 启动系统的指纹管理应用界面，让用户进行指纹录入。
+	 * 指纹录入是在系统的指纹管理应用中实现的，本函数的作用只是将指纹管理应用运行起来，直接进行页面跳转，方便用户录入。
+	 *
+	 * @param context
+	 *            上下文环境
+	 * @param authType
+	 *            生物特征识别类型，指纹为1，虹膜为2
+	 * @return COMMAND_OK(0): 成功启动指纹管理应用； COMMAND_FAIL(-1): 其他值，启动指纹管理应用失败。
+	 */
+	public int startBIOManager(Context context, int authType) {
+		return IFAAUtils.COMMAND_FAIL;
+	}
+
+	/**
+	 * Description: 通过ifaateeclient的so文件实现REE到TAA的通道。
+	 *
+	 * @param context
+	 * @param param
+	 *            用于传输到IFAA TA的数据buffer。
+	 * @return 返回IFAA TA返回REE的数据buffer。
+	 */
+	public native byte[] processCmd(Context context, byte[] param);
+
+}

Property changes on: frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAManager.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAManagerFp.java
===================================================================
--- frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAManagerFp.java	(revision 0)
+++ frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAManagerFp.java	(revision 2997)
@@ -0,0 +1,45 @@
+/**
+ * @author yangzh6
+ * 
+ * Reference: <<IFAA标准-REE系统框架部分.pdf>>
+ */
+
+package org.ifaa.android.manager;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.hardware.fingerprint.FingerprintManager;
+import android.os.Build;
+import android.util.Log;
+
+public class IFAAManagerFp extends IFAAManager {
+	private static final String TAG = IFAAManagerFp.class.getSimpleName();
+
+	/** Internal Attributes */
+	private static final int VERSION = 1;
+
+	// Overrides APIs
+	// ------------------------------------------------------------------------
+	@Override
+	public int getVersion() {
+		return VERSION;
+	}
+
+	@Override
+	public int startBIOManager(Context context, int authType) {
+		if ((null == context) || (authType != IFAAUtils.BIO_TYPE_FINGERPRINT)) {
+			Log.e(TAG, "context = " + context + ", authType = " + authType);
+			return IFAAUtils.COMMAND_FAIL;
+		}
+
+		final String pkgName = context.getPackageName();
+		Log.d(TAG, "pkgName = " + pkgName + ", authType = " + authType);
+
+		Intent intent = new Intent(IFAAUtils.ACTION_FP_SETTINGS);
+		context.startActivity(intent);
+
+		return IFAAUtils.COMMAND_OK;
+	}
+
+}

Property changes on: frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAManagerFp.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAUtils.java
===================================================================
--- frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAUtils.java	(revision 0)
+++ frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAUtils.java	(revision 2997)
@@ -0,0 +1,34 @@
+/**
+ * @author yangzh6
+ * 
+ * Reference: <<IFAA 标准: REE 系统框架部分>>
+ */
+
+package org.ifaa.android.manager;
+
+public class IFAAUtils {
+
+	/** BIO TYPES */
+	public static final int BIO_TYPE_FINGERPRINT	= 1 << 0; //0x01;
+	public static final int BIO_TYPE_IRIS			= 1 << 1; //0x02;
+
+	/** Return Values */
+	public static final int COMMAND_OK				= 0;
+	public static final int COMMAND_FAIL			= -1;
+
+	/** Start Activity */
+	public static final String ACTION_FP_SETTINGS	= "android.settings.FINGERPRINT_SETUP";
+	public static final String ACTION_IRIS_SETTINGS	= "android.settings.IRIS_SETUP";
+
+	/** Functions */
+	public static boolean authTypeValid(int authType) {
+		switch (authType) {
+		case IFAAUtils.BIO_TYPE_FINGERPRINT:
+		case IFAAUtils.BIO_TYPE_IRIS: {
+			return true;
+		}
+		}
+		return false;
+	}
+
+}

Property changes on: frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAUtils.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAManagerFactory.java
===================================================================
--- frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAManagerFactory.java	(revision 0)
+++ frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAManagerFactory.java	(revision 2997)
@@ -0,0 +1,40 @@
+/**
+ * @author yangzh6
+ *
+ * Reference: <<IFAA标准-REE系统框架部分.pdf>>
+ */
+
+package org.ifaa.android.manager;
+
+import android.content.Context;
+import android.util.Log;
+
+public class IFAAManagerFactory {
+	private static final String TAG = IFAAManagerFactory.class.getSimpleName();
+
+	/**
+	 * Description: 返回对应的IFAAManager实例
+	 *
+	 * @param context
+	 *            上下文环境
+	 * @param authType
+	 *            生物特征识别类型,指纹为1,虹膜为2
+	 * @return 返回对应的IFAAManager实例
+	 */
+	public static IFAAManager getIFAAManager(Context context, int authType) {
+		if ((null == context) || !IFAAUtils.authTypeValid(authType)) {
+			Log.e(TAG, "context = " + context + ", authType = " + authType);
+			return null;
+		}
+
+		switch (authType) {
+		case IFAAUtils.BIO_TYPE_FINGERPRINT: {
+			return new IFAAManagerFp();
+		}
+		case IFAAUtils.BIO_TYPE_IRIS: {
+			// return new IFAAManagerIris();
+		}
+		}
+		return null;
+	}
+}

Property changes on: frameworks/base/ifaa_fw/src/java/org/ifaa/android/manager/IFAAManagerFactory.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/keystore/java/android/security/keystore/SoterKeyStoreProvider.java
===================================================================
--- frameworks/base/keystore/java/android/security/keystore/SoterKeyStoreProvider.java	(revision 2996)
+++ frameworks/base/keystore/java/android/security/keystore/SoterKeyStoreProvider.java	(revision 2997)
@@ -1,17 +1,7 @@
 package android.security.keystore;
 
-import android.annotation.NonNull;
-import android.security.keymaster.KeyCharacteristics;
-import android.security.keymaster.ExportResult;
-import android.security.keymaster.KeymasterDefs;
+import android.nfc.Tag;
 import android.security.KeyStore;
-import android.security.keystore.AndroidKeyStoreECPrivateKey;
-import android.security.keystore.AndroidKeyStoreECPublicKey;
-import android.security.keystore.AndroidKeyStorePrivateKey;
-import android.security.keystore.AndroidKeyStorePublicKey;
-import android.security.keystore.AndroidKeyStoreRSAPrivateKey;
-import android.security.keystore.AndroidKeyStoreRSAPublicKey;
-import android.security.keystore.KeyProperties;
 import android.util.Base64;
 import android.util.Log;
 
@@ -18,10 +8,6 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
-import java.security.interfaces.ECKey;
-import java.security.interfaces.ECPublicKey;
-import java.security.interfaces.RSAKey;
-import java.security.interfaces.RSAPublicKey;
 import java.security.KeyFactory;
 import java.security.KeyPair;
 import java.security.NoSuchAlgorithmException;
@@ -29,23 +15,39 @@
 import java.security.ProviderException;
 import java.security.PublicKey;
 import java.security.Security;
+import java.security.UnrecoverableKeyException;
+import java.security.interfaces.ECKey;
+import java.security.interfaces.ECPublicKey;
+import java.security.interfaces.RSAKey;
+import java.security.interfaces.RSAPublicKey;
 import java.security.spec.InvalidKeySpecException;
 import java.security.spec.X509EncodedKeySpec;
-import java.security.UnrecoverableKeyException;
-
+import android.annotation.NonNull;
+import android.security.keymaster.KeyCharacteristics;
+import android.security.keymaster.ExportResult;
+import android.security.keymaster.KeymasterDefs;
+import android.security.keystore.AndroidKeyStorePublicKey;
+import android.security.keystore.AndroidKeyStorePrivateKey;
+import android.security.keystore.AndroidKeyStoreECPrivateKey;
+import android.security.keystore.AndroidKeyStoreRSAPrivateKey;
+import android.security.keystore.KeyProperties;
+import android.security.keystore.AndroidKeyStoreECPublicKey;
+import android.security.keystore.AndroidKeyStoreRSAPublicKey;
 /**
+ * Created by henryye on 15/9/14.
  * The provider which supports SOTER-RSA-Generation method
  * @hide
  */
-public class SoterKeyStoreProvider extends Provider {
+public class SoterKeyStoreProvider extends Provider{
     public static final String PROVIDER_NAME = "SoterKeyStore";
 
+    private static final String SOTER_PACKAGE_NAME = "android.security.keystore";
     private static final String ANDROID_PACKAGE_NAME = "android.security.keystore";
 
     public SoterKeyStoreProvider() {
         super(PROVIDER_NAME, 1.0, "provider for soter");
-        put("KeyPairGenerator.RSA", ANDROID_PACKAGE_NAME + ".SoterKeyStoreKeyPairRSAGeneratorSpi");
-        put("KeyStore.SoterKeyStore", ANDROID_PACKAGE_NAME + ".SoterKeyStoreSpi");
+        put("KeyPairGenerator.RSA", SOTER_PACKAGE_NAME + ".SoterKeyStoreKeyPairRSAGeneratorSpi");
+        put("KeyStore.SoterKeyStore", SOTER_PACKAGE_NAME + ".SoterKeyStoreSpi");
         putKeyFactoryImpl("RSA");
     }
 
@@ -62,10 +64,10 @@
     public static AndroidKeyStorePrivateKey getAndroidKeyStorePrivateKey(
             @NonNull AndroidKeyStorePublicKey publicKey) {
         String keyAlgorithm = publicKey.getAlgorithm();
-        if (KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(keyAlgorithm)) {
+        if (android.security.keystore.KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(keyAlgorithm)) {
             return new AndroidKeyStoreECPrivateKey(
                     publicKey.getAlias(), KeyStore.UID_SELF, ((ECKey) publicKey).getParams());
-        } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
+        } else if (android.security.keystore.KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
             return new AndroidKeyStoreRSAPrivateKey(
                     publicKey.getAlias(), KeyStore.UID_SELF, ((RSAKey) publicKey).getModulus());
         } else {
@@ -88,8 +90,7 @@
         }
         ExportResult exportResult = keyStore.exportKey(
                 privateKeyAlias, KeymasterDefs.KM_KEY_FORMAT_X509, null, null);
-        /// M: [ALPS03097826] Dereference null return value
-        if (exportResult == null || exportResult.resultCode != KeyStore.NO_ERROR) {
+        if (exportResult.resultCode != KeyStore.NO_ERROR) {
             throw (UnrecoverableKeyException)
                     new UnrecoverableKeyException("Failed to obtain X.509 form of public key")
                             .initCause(KeyStore.getKeyStoreException(errorCode));
@@ -130,13 +131,12 @@
     @NonNull
     public static AndroidKeyStorePublicKey getAndroidKeyStorePublicKey(
             @NonNull String alias,
-            @NonNull @KeyProperties.KeyAlgorithmEnum String keyAlgorithm,
+            @NonNull String keyAlgorithm,
             @NonNull byte[] x509EncodedForm) {
         PublicKey publicKey;
         try {
             KeyFactory keyFactory = KeyFactory.getInstance(keyAlgorithm);
-            byte[] realPublicKey = SoterUtil.getDataFromRaw(x509EncodedForm,
-                    SoterUtil.JSON_KEY_PUBLIC);
+            byte[] realPublicKey = SoterUtil.getDataFromRaw(x509EncodedForm, SoterUtil.JSON_KEY_PUBLIC);
             if (realPublicKey != null) {
                 publicKey = keyFactory.generatePublic(new X509EncodedKeySpec(realPublicKey));
             } else {
@@ -150,28 +150,27 @@
         } catch (JSONException e) {
             throw new ProviderException("Not in json format");
         }
-        if (KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(keyAlgorithm)) {
-            Log.d(SoterUtil.TAG, "getAndroidKeyStorePublicKey: AndroidKeyStoreECPublicKey");
-            return new AndroidKeyStoreECPublicKey(alias, KeyStore.UID_SELF,
-                    (ECPublicKey) publicKey);
-        } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
-            Log.d(SoterUtil.TAG, "getAndroidKeyStorePublicKey: AndroidKeyStoreRSAPublicKey");
+        if (android.security.keystore.KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(keyAlgorithm)) {
+			// Log.d("Soter", "AndroidKeyStoreECPublicKey");
+            return new AndroidKeyStoreECPublicKey(alias, KeyStore.UID_SELF, (ECPublicKey) publicKey);
+        } else if (android.security.keystore.KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
+			// Log.d("Soter", "AndroidKeyStoreRSAPublicKey");
             RSAPublicKey rsaPubKey = (RSAPublicKey) publicKey;
-            //generate certificate need decoded realPublicKey, because need give the to
-            //android certificate generator
-            //but Soter ui get key need encode json string, soter ui need
-            //resolve all information from json string
-            //so maybe we should have two ways to meet all request
-            //en, this in soter provider, so it's under control
-            return new AndroidKeyStoreRSAPublicKey(alias, KeyStore.UID_SELF,
-                    rsaPubKey);
+			//generate certificate need decoded realPublicKey, because need give the to
+			//android certificate generator
+			//but Soter ui get key need encode json string, soter ui need 
+			//resolve all information from json string
+			//so maybe we should have two ways to meet all request
+			//en, this in soter provider, so it's under control
+            return new AndroidKeyStoreRSAPublicKey(alias, KeyStore.UID_SELF, rsaPubKey);//x509EncodedForm, rsaPubKey.getModulus(), rsaPubKey.getPublicExponent());
         } else {
             throw new ProviderException("Unsupported Android Keystore public key algorithm: "
                     + keyAlgorithm);
         }
     }
-
-    @NonNull
+	
+	//chenlingyun copied begin
+	@NonNull
     public static AndroidKeyStorePrivateKey loadAndroidKeyStorePrivateKeyFromKeystore(
             @NonNull KeyStore keyStore, @NonNull String privateKeyAlias)
             throws UnrecoverableKeyException {
@@ -178,8 +177,8 @@
         KeyPair keyPair = loadAndroidKeyStoreKeyPairFromKeystore(keyStore, privateKeyAlias);
         return (AndroidKeyStorePrivateKey) keyPair.getPrivate();
     }
-
-    @NonNull
+	
+	    @NonNull
     public static AndroidKeyStorePublicKey loadJsonPublicKeyFromKeystore(
             @NonNull KeyStore keyStore, @NonNull String privateKeyAlias)
             throws UnrecoverableKeyException {
@@ -193,8 +192,7 @@
         }
         ExportResult exportResult = keyStore.exportKey(
                 privateKeyAlias, KeymasterDefs.KM_KEY_FORMAT_X509, null, null);
-        /// M: [ALPS03097827] Dereference null return value
-        if (exportResult == null || exportResult.resultCode != KeyStore.NO_ERROR) {
+        if (exportResult.resultCode != KeyStore.NO_ERROR) {
             throw (UnrecoverableKeyException)
                     new UnrecoverableKeyException("Failed to obtain X.509 form of public key")
                             .initCause(KeyStore.getKeyStoreException(errorCode));
@@ -219,8 +217,8 @@
         return getJsonPublicKey(
                 privateKeyAlias, jcaKeyAlgorithm, x509EncodedPublicKey);
     }
-
-    @NonNull
+	
+	@NonNull
     public static AndroidKeyStorePublicKey getJsonPublicKey(
             @NonNull String alias,
             @NonNull String keyAlgorithm,
@@ -228,8 +226,7 @@
         PublicKey publicKey;
         try {
             KeyFactory keyFactory = KeyFactory.getInstance(keyAlgorithm);
-            byte[] realPublicKey = SoterUtil.getDataFromRaw(x509EncodedForm,
-                    SoterUtil.JSON_KEY_PUBLIC);
+            byte[] realPublicKey = SoterUtil.getDataFromRaw(x509EncodedForm, SoterUtil.JSON_KEY_PUBLIC);
             if (realPublicKey != null) {
                 publicKey = keyFactory.generatePublic(new X509EncodedKeySpec(realPublicKey));
             } else {
@@ -243,24 +240,23 @@
         } catch (JSONException e) {
             throw new ProviderException("Not in json format");
         }
-        if (KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(keyAlgorithm)) {
-            Log.d(SoterUtil.TAG, "AndroidKeyStoreECPublicKey");
-            return new AndroidKeyStoreECPublicKey(alias, KeyStore.UID_SELF,
-                    (ECPublicKey) publicKey);
-        } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
-            Log.d(SoterUtil.TAG, "getJsonPublicKey");
+        if (android.security.keystore.KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(keyAlgorithm)) {
+			// Log.d("Soter", "AndroidKeyStoreECPublicKey");
+            return new AndroidKeyStoreECPublicKey(alias, KeyStore.UID_SELF, (ECPublicKey) publicKey);
+        } else if (android.security.keystore.KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
+			// Log.d("Soter", "getJsonPublicKey");
             RSAPublicKey rsaPubKey = (RSAPublicKey) publicKey;
-            //generate certificate need decoded realPublicKey, because need give the to
-            //android certificate generator
-            //but Soter ui get key need encode json string, soter ui need
-            //resolve all information from json string
-            //so maybe we should have two ways to meet all request
-            //en, this in soter provider, so it's under control
-            return new AndroidKeyStoreRSAPublicKey(alias, KeyStore.UID_SELF, x509EncodedForm,
-                    rsaPubKey.getModulus(), rsaPubKey.getPublicExponent());
+			//generate certificate need decoded realPublicKey, because need give the to
+			//android certificate generator
+			//but Soter ui get key need encode json string, soter ui need 
+			//resolve all information from json string
+			//so maybe we should have two ways to meet all request
+			//en, this in soter provider, so it's under control
+            return new AndroidKeyStoreRSAPublicKey(alias, KeyStore.UID_SELF, x509EncodedForm, rsaPubKey.getModulus(), rsaPubKey.getPublicExponent());
         } else {
             throw new ProviderException("Unsupported Android Keystore public key algorithm: "
                     + keyAlgorithm);
         }
     }
+	//chenlingyun copied end
 }
Index: frameworks/base/keystore/java/android/security/keystore/SoterKeyStoreSpi.java
===================================================================
--- frameworks/base/keystore/java/android/security/keystore/SoterKeyStoreSpi.java	(revision 2996)
+++ frameworks/base/keystore/java/android/security/keystore/SoterKeyStoreSpi.java	(revision 2997)
@@ -1,47 +1,52 @@
 package android.security.keystore;
 
-import android.security.Credentials;
-import android.security.KeyStore;
-import android.text.TextUtils;
-import android.util.Log;
-
 import java.security.Key;
-import java.security.KeyStoreException;
 import java.security.NoSuchAlgorithmException;
 import java.security.UnrecoverableKeyException;
+import java.security.KeyStoreException;
 
+import android.security.Credentials;
+import android.security.KeyStore;
+import android.security.keystore.AndroidKeyStoreProvider;
+
 /**
+ * Created by henryye on 15/10/13.
+ * If need any edit necessary, please contact him by RTX
  * @hide
  */
-public class SoterKeyStoreSpi extends AndroidKeyStoreSpi {
+public class SoterKeyStoreSpi extends android.security.keystore.AndroidKeyStoreSpi{
 
     private KeyStore mKeyStore = null;
 
-    public SoterKeyStoreSpi() {
-        mKeyStore = KeyStore.getInstance();
-    }
-
+	public SoterKeyStoreSpi(){
+		mKeyStore = KeyStore.getInstance();//chenlingyun move init mKeyStore to here
+	}
     @Override
-    public Key engineGetKey(String alias, char[] password)
-            throws NoSuchAlgorithmException, UnrecoverableKeyException {
+    public Key engineGetKey(String alias, char[] password) throws NoSuchAlgorithmException,
+            UnrecoverableKeyException {
+        //mKeyStore = KeyStore.getInstance();
         if (isPrivateKeyEntry(alias)) {
             String privateKeyAlias = Credentials.USER_PRIVATE_KEY + alias;
-
-            if (password != null && "from_soter_ui".equals(String.valueOf(password))) {
-                Log.d(SoterUtil.TAG, "engineGetKey: loadJsonPublicKeyFromKeystore");
-                return SoterKeyStoreProvider.loadJsonPublicKeyFromKeystore(mKeyStore,
-                        privateKeyAlias);
-            } else {
-                Log.d(SoterUtil.TAG, "engineGetKey: loadAndroidKeyStorePrivateKeyFromKeystore");
-                return SoterKeyStoreProvider.loadAndroidKeyStorePrivateKeyFromKeystore(mKeyStore,
-                        privateKeyAlias);
-            }
+			
+			//chenlingyun we should continue our native layer work, 
+			//so we use an ugly special password "from_soter_ui"
+			//to distinguish need private key or json string public key
+			if(password != null && "from_soter_ui".equals(String.valueOf(password)))
+			{
+				return SoterKeyStoreProvider.loadJsonPublicKeyFromKeystore(
+                    mKeyStore, privateKeyAlias);
+			}
+			else
+			{
+				return SoterKeyStoreProvider.loadAndroidKeyStorePrivateKeyFromKeystore(
+                    mKeyStore, privateKeyAlias);
+			}       
         } else if (isSecretKeyEntry(alias)) {
             String secretKeyAlias = Credentials.USER_SECRET_KEY + alias;
-            return AndroidKeyStoreProvider.loadAndroidKeyStoreSecretKeyFromKeystore(mKeyStore,
-                    secretKeyAlias, KeyStore.UID_SELF);
+            return AndroidKeyStoreProvider.loadAndroidKeyStoreSecretKeyFromKeystore(
+                    mKeyStore, secretKeyAlias, KeyStore.UID_SELF);
         } else {
-            Log.w(SoterUtil.TAG, "engineGetKey: key not found");
+            // Key not found
             return null;
         }
     }
@@ -53,33 +58,38 @@
 
         return mKeyStore.contains(Credentials.USER_PRIVATE_KEY + alias);
     }
-
-    private boolean isSecretKeyEntry(String alias) {
+	
+	private boolean isSecretKeyEntry(String alias) {
         if (alias == null) {
             throw new NullPointerException("alias == null");
         }
         return mKeyStore.contains(Credentials.USER_SECRET_KEY + alias);
     }
+	
+	@Override
+	public void engineDeleteEntry(String alias) throws KeyStoreException 
+	{
+		if (!engineContainsAlias(alias)) 
+		{
+			return;
+		}
+		// At least one entry corresponding to this alias exists in keystore
 
-    @Override
-    public void engineDeleteEntry(String alias) throws KeyStoreException {
-        Log.d(SoterUtil.TAG, "engineDeleteEntry: alias = " + alias);
-        if (!engineContainsAlias(alias)) {
-            return;
-        }
-        if (!(mKeyStore.delete(Credentials.USER_PRIVATE_KEY + alias)
-                | mKeyStore.delete(Credentials.USER_CERTIFICATE + alias))) {
-            throw new KeyStoreException("Failed to delete entry: " + alias);
-        }
-    }
+		if (!(mKeyStore.delete(Credentials.USER_PRIVATE_KEY + alias) | mKeyStore.delete(Credentials.USER_CERTIFICATE + alias)))
+		{
+			throw new KeyStoreException("Failed to delete entry: " + alias);
+		}
+	}
+	
+	@Override
+	public boolean engineContainsAlias(String alias)
+	{
+		if (alias == null) 
+		{
+			throw new NullPointerException("alias == null");
+		}
 
-    @Override
-    public boolean engineContainsAlias(String alias) {
-        if (alias == null) {
-            throw new NullPointerException("alias == null");
-        }
-
-        return mKeyStore.contains(Credentials.USER_PRIVATE_KEY + alias)
-                || mKeyStore.contains(Credentials.USER_CERTIFICATE + alias);
-    }
+		return mKeyStore.contains(Credentials.USER_PRIVATE_KEY + alias) || 
+				mKeyStore.contains(Credentials.USER_CERTIFICATE + alias);
+	}
 }
Index: frameworks/base/keystore/java/android/security/keystore/SoterKeyStoreKeyPairRSAGeneratorSpi.java
===================================================================
--- frameworks/base/keystore/java/android/security/keystore/SoterKeyStoreKeyPairRSAGeneratorSpi.java	(revision 2996)
+++ frameworks/base/keystore/java/android/security/keystore/SoterKeyStoreKeyPairRSAGeneratorSpi.java	(revision 2997)
@@ -1,16 +1,36 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package android.security.keystore;
 
+import android.app.ActivityThread;
+import android.app.Application;
+import android.content.Context;
+import android.hardware.fingerprint.FingerprintManager;
+import android.nfc.Tag;
+import android.os.UserHandle;
 import android.annotation.Nullable;
 import android.security.Credentials;
 import android.security.KeyPairGeneratorSpec;
 import android.security.KeyStore;
-import android.security.keystore.KeyGenParameterSpec;
-import android.security.keystore.KeyProperties;
 import android.security.keymaster.KeyCharacteristics;
 import android.security.keymaster.KeymasterArguments;
 import android.security.keymaster.KeymasterDefs;
-import android.text.TextUtils;
-import android.util.Log;
+import android.security.keystore.KeyGenParameterSpec;
+import android.util.Base64;
 
 import com.android.org.bouncycastle.asn1.ASN1EncodableVector;
 import com.android.org.bouncycastle.asn1.ASN1InputStream;
@@ -34,8 +54,9 @@
 
 import libcore.util.EmptyArray;
 
-import java.io.IOException;
 import java.math.BigInteger;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 import java.security.InvalidAlgorithmParameterException;
 import java.security.KeyPair;
 import java.security.KeyPairGeneratorSpi;
@@ -45,82 +66,89 @@
 import java.security.SecureRandom;
 import java.security.UnrecoverableKeyException;
 import java.security.cert.CertificateEncodingException;
-import java.security.cert.CertificateParsingException;
 import java.security.cert.X509Certificate;
 import java.security.spec.AlgorithmParameterSpec;
 import java.security.spec.RSAKeyGenParameterSpec;
 import java.util.HashSet;
 import java.util.Set;
+import android.security.keystore.KeyProperties;
+import android.util.Log;
 
 /**
  * @hide
  **/
 public class SoterKeyStoreKeyPairRSAGeneratorSpi extends KeyPairGeneratorSpi {
-
+    
     /*
      * These must be kept in sync with system/security/keystore/defaults.h
      */
-
+    
     /* RSA */
     private static final int RSA_DEFAULT_KEY_SIZE = 2048;
     private static final int RSA_MIN_KEY_SIZE = 512;
     private static final int RSA_MAX_KEY_SIZE = 8192;
-
+    
     private final int mOriginalKeymasterAlgorithm;
-
+    
     private KeyStore mKeyStore;
-
+    
     private KeyGenParameterSpec mSpec;
-
+    
     private String mEntryAlias;
     private boolean mEncryptionAtRestRequired;
     private
-    @KeyProperties.KeyAlgorithmEnum String mJcaKeyAlgorithm;
+    @KeyProperties.KeyAlgorithmEnum
+    String mJcaKeyAlgorithm;
     private int mKeymasterAlgorithm = -1;
     private int mKeySizeBits;
     private SecureRandom mRng;
-
+    
     private int[] mKeymasterPurposes;
     private int[] mKeymasterBlockModes;
     private int[] mKeymasterEncryptionPaddings;
     private int[] mKeymasterSignaturePaddings;
     private int[] mKeymasterDigests;
-
+    
     private BigInteger mRSAPublicExponent;
     //for soter
     private boolean isForSoter = false;
+    
     private boolean isAutoSignedWithAttkWhenGetPublicKey = false;
+    
     private boolean isAutoSignedWithCommonkWhenGetPublicKey = false;
+    
     private String mAutoSignedKeyNameWhenGetPublicKey = "";
+    
     private boolean isSecmsgFidCounterSignedWhenSign = false;
+    
     private boolean isAutoAddCounterWhenGetPublicKey = false;
+    
     private boolean isNeedNextAttk = false;
-
+    
     //protected
     public SoterKeyStoreKeyPairRSAGeneratorSpi() {
         mOriginalKeymasterAlgorithm = KeymasterDefs.KM_ALGORITHM_RSA;
     }
-
+    
     @Override
     public void initialize(int keysize, SecureRandom random) {
         throw new IllegalArgumentException(
-                KeyGenParameterSpec.class.getName() +
-                " required to initialize this KeyPairGenerator");
+                                           KeyGenParameterSpec.class.getName() + " required to initialize this KeyPairGenerator");
     }
-
+    
     @Override
     public void initialize(AlgorithmParameterSpec params, SecureRandom random)
-            throws InvalidAlgorithmParameterException {
+    throws InvalidAlgorithmParameterException {
         resetAll();
-
+        
         boolean success = false;
         try {
             if (params == null) {
                 throw new InvalidAlgorithmParameterException(
-                        "Must supply params of type " + KeyGenParameterSpec.class.getName()
-                        + " or " + KeyPairGeneratorSpec.class.getName());
+                                                             "Must supply params of type " + KeyGenParameterSpec.class.getName()
+                                                             + " or " + KeyPairGeneratorSpec.class.getName());
             }
-
+            
             KeyGenParameterSpec spec;
             boolean encryptionAtRestRequired = false;
             int keymasterAlgorithm = mOriginalKeymasterAlgorithm;
@@ -128,11 +156,11 @@
                 spec = (KeyGenParameterSpec) params;
             } else {
                 throw new InvalidAlgorithmParameterException(
-                        "Unsupported params class: " + params.getClass().getName()
-                        + ". Supported: " + KeyGenParameterSpec.class.getName()
-                        + ", " + KeyPairGeneratorSpec.class.getName());
+                                                             "Unsupported params class: " + params.getClass().getName()
+                                                             + ". Supported: " + KeyGenParameterSpec.class.getName()
+                                                             + ", " + KeyPairGeneratorSpec.class.getName());
             }
-
+            
             mEntryAlias = SoterUtil.getPureKeyAliasFromKeyName(spec.getKeystoreAlias());
             mSpec = spec;
             mKeymasterAlgorithm = keymasterAlgorithm;
@@ -143,55 +171,52 @@
                 mKeySizeBits = getDefaultKeySize(keymasterAlgorithm);
             }
             checkValidKeySize(keymasterAlgorithm, mKeySizeBits);
-
+            
             if (spec.getKeystoreAlias() == null) {
                 throw new InvalidAlgorithmParameterException("KeyStore entry alias not provided");
             }
-
+            
             String jcaKeyAlgorithm;
             try {
                 jcaKeyAlgorithm = KeyProperties.KeyAlgorithm.fromKeymasterAsymmetricKeyAlgorithm(
-                        keymasterAlgorithm);
+                                                                                                 keymasterAlgorithm);
                 mKeymasterPurposes = KeyProperties.Purpose.allToKeymaster(spec.getPurposes());
                 mKeymasterBlockModes = KeyProperties.BlockMode.allToKeymaster(spec.getBlockModes());
                 mKeymasterEncryptionPaddings = KeyProperties.EncryptionPadding.allToKeymaster(
-                        spec.getEncryptionPaddings());
+                                                                                              spec.getEncryptionPaddings());
                 if (((spec.getPurposes() & KeyProperties.PURPOSE_ENCRYPT) != 0)
-                        && (spec.isRandomizedEncryptionRequired())) {
+                    && (spec.isRandomizedEncryptionRequired())) {
                     for (int keymasterPadding : mKeymasterEncryptionPaddings) {
-                        if (!KeymasterUtils
-                                .isKeymasterPaddingSchemeIndCpaCompatibleWithAsymmetricCrypto(
-                                        keymasterPadding)) {
+                        if (!isKeymasterPaddingSchemeIndCpaCompatibleWithAsymmetricCrypto(
+                                                                                          keymasterPadding)) {
                             throw new InvalidAlgorithmParameterException(
-                                    "Randomized encryption (IND-CPA) required but may be violated"
-                                    + " by padding scheme: "
-                                    + KeyProperties.EncryptionPadding.fromKeymaster(
-                                            keymasterPadding)
-                                    + ". See " + KeyGenParameterSpec.class.getName()
-                                    + " documentation.");
+                                                                         "Randomized encryption (IND-CPA) required but may be violated"
+                                                                         + " by padding scheme: "
+                                                                         + KeyProperties.EncryptionPadding.fromKeymaster(
+                                                                                                                         keymasterPadding)
+                                                                         + ". See " + KeyGenParameterSpec.class.getName()
+                                                                         + " documentation.");
                         }
                     }
                 }
                 mKeymasterSignaturePaddings = KeyProperties.SignaturePadding.allToKeymaster(
-                        spec.getSignaturePaddings());
+                                                                                            spec.getSignaturePaddings());
                 if (spec.isDigestsSpecified()) {
                     mKeymasterDigests = KeyProperties.Digest.allToKeymaster(spec.getDigests());
                 } else {
                     mKeymasterDigests = EmptyArray.INT;
                 }
-
+                
                 // Check that user authentication related parameters are acceptable. This method
                 // will throw an IllegalStateException if there are issues (e.g., secure lock screen
                 // not set up).
                 KeymasterUtils.addUserAuthArgs(new KeymasterArguments(),
                                 mSpec.isUserAuthenticationRequired(),
-                                mSpec.getUserAuthenticationValidityDurationSeconds(),
-                                false,
-                                true);
+                                mSpec.getUserAuthenticationValidityDurationSeconds(), false, true);
             } catch (IllegalArgumentException | IllegalStateException e) {
                 throw new InvalidAlgorithmParameterException(e);
             }
-
+            
             mJcaKeyAlgorithm = jcaKeyAlgorithm;
             mRng = random;
             mKeyStore = KeyStore.getInstance();
@@ -202,7 +227,7 @@
             }
         }
     }
-
+    
     private void resetAll() {
         mEntryAlias = null;
         mJcaKeyAlgorithm = null;
@@ -218,91 +243,157 @@
         mEncryptionAtRestRequired = false;
         mRng = null;
         mKeyStore = null;
-
-        // soter
         isForSoter = false;
+        
         isAutoSignedWithAttkWhenGetPublicKey = false;
+        
         isAutoSignedWithCommonkWhenGetPublicKey = false;
+        
         mAutoSignedKeyNameWhenGetPublicKey = "";
+        
         isSecmsgFidCounterSignedWhenSign = false;
+        
         isAutoAddCounterWhenGetPublicKey = false;
+        
         isNeedNextAttk = false;
     }
-
+    
     private void initAlgorithmSpecificParameters() throws InvalidAlgorithmParameterException {
         AlgorithmParameterSpec algSpecificSpec = mSpec.getAlgorithmParameterSpec();
         BigInteger publicExponent = RSAKeyGenParameterSpec.F4;
         if (algSpecificSpec instanceof RSAKeyGenParameterSpec) {
-            Log.i(SoterUtil.TAG,
-                    "initAlgorithmSpecificParameters: starting initing RSAKeyGenParameterSpec");
+            //Log.i(TAG, "hy: starting initing RSAKeyGenParameterSpec...");
             RSAKeyGenParameterSpec rsaSpec = (RSAKeyGenParameterSpec) algSpecificSpec;
             if (mKeySizeBits == -1) {
                 mKeySizeBits = rsaSpec.getKeysize();
             } else if (mKeySizeBits != rsaSpec.getKeysize()) {
                 throw new InvalidAlgorithmParameterException("RSA key size must match "
-                        + " between " + mSpec + " and " + algSpecificSpec
-                        + ": " + mKeySizeBits + " vs " + rsaSpec.getKeysize());
+                                                             + " between " + mSpec + " and " + algSpecificSpec
+                                                             + ": " + mKeySizeBits + " vs " + rsaSpec.getKeysize());
             }
             publicExponent = rsaSpec.getPublicExponent();
             if (publicExponent.compareTo(BigInteger.ZERO) < 1) {
                 throw new InvalidAlgorithmParameterException(
-                        "RSA public exponent must be positive: " + publicExponent);
+                                                             "RSA public exponent must be positive: " + publicExponent);
             }
-            if (publicExponent.compareTo(KeymasterArguments.UINT64_MAX_VALUE) > 0) {
+            if (publicExponent.compareTo(UINT64_MAX_VALUE) > 0) {
                 throw new InvalidAlgorithmParameterException(
-                        "Unsupported RSA public exponent: " + publicExponent
-                        + ". Maximum supported value: " + KeymasterArguments.UINT64_MAX_VALUE);
+                                                             "Unsupported RSA public exponent: " + publicExponent
+                                                             + ". Maximum supported value: " + UINT64_MAX_VALUE);
             }
         }
         mRSAPublicExponent = publicExponent;
-        SoterRSAKeyGenParameterSpec soterSpec =
-                SoterUtil.convertKeyNameToParameterSpec(mSpec.getKeystoreAlias());
+        SoterRSAKeyGenParameterSpec soterSpec = SoterUtil.convertKeyNameToParameterSpec(mSpec.getKeystoreAlias());
         if (soterSpec != null) {
             isForSoter = soterSpec.isForSoter();
             isAutoSignedWithAttkWhenGetPublicKey = soterSpec.isAutoSignedWithAttkWhenGetPublicKey();
-            isAutoSignedWithCommonkWhenGetPublicKey =
-                    soterSpec.isAutoSignedWithCommonkWhenGetPublicKey();
+            isAutoSignedWithCommonkWhenGetPublicKey = soterSpec.isAutoSignedWithCommonkWhenGetPublicKey();
             mAutoSignedKeyNameWhenGetPublicKey = soterSpec.getAutoSignedKeyNameWhenGetPublicKey();
             isSecmsgFidCounterSignedWhenSign = soterSpec.isSecmsgFidCounterSignedWhenSign();
             isAutoAddCounterWhenGetPublicKey = soterSpec.isAutoAddCounterWhenGetPublicKey();
             isNeedNextAttk = soterSpec.isNeedUseNextAttk();
         }
+        
     }
-
+    
     @Override
     public KeyPair generateKeyPair() {
         if (mKeyStore == null || mSpec == null) {
             throw new IllegalStateException("Not initialized");
         }
-
+        
         final int flags = (mEncryptionAtRestRequired) ? KeyStore.FLAG_ENCRYPTED : 0;
         if (((flags & KeyStore.FLAG_ENCRYPTED) != 0)
-                && (mKeyStore.state() != KeyStore.State.UNLOCKED)) {
+            && (mKeyStore.state() != KeyStore.State.UNLOCKED)) {
             throw new IllegalStateException(
-                    "Encryption at rest using secure lock screen credential requested for key pair"
-                    + ", but the user has not yet entered the credential");
+                                            "Encryption at rest using secure lock screen credential requested for key pair"
+                                            + ", but the user has not yet entered the credential");
         }
-
+        
+        KeymasterArguments args = new KeymasterArguments();
+        args.addUnsignedInt(KeymasterDefs.KM_TAG_KEY_SIZE, mKeySizeBits);
+        args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM, mKeymasterAlgorithm);
+        args.addEnums(KeymasterDefs.KM_TAG_PURPOSE, mKeymasterPurposes);
+        args.addEnums(KeymasterDefs.KM_TAG_BLOCK_MODE, mKeymasterBlockModes);
+        args.addEnums(KeymasterDefs.KM_TAG_PADDING, mKeymasterEncryptionPaddings);
+        args.addEnums(KeymasterDefs.KM_TAG_PADDING, mKeymasterSignaturePaddings);
+        args.addEnums(KeymasterDefs.KM_TAG_DIGEST, mKeymasterDigests);
+        
+        KeymasterUtils.addUserAuthArgs(args,
+                        mSpec.isUserAuthenticationRequired(),
+                        mSpec.getUserAuthenticationValidityDurationSeconds(), false, true);
+        if(mSpec.getKeyValidityStart() != null) {
+            args.addDate(KeymasterDefs.KM_TAG_ACTIVE_DATETIME, mSpec.getKeyValidityStart());
+        }
+        if(mSpec.getKeyValidityForOriginationEnd() != null) {
+            args.addDate(KeymasterDefs.KM_TAG_ORIGINATION_EXPIRE_DATETIME,
+                         mSpec.getKeyValidityForOriginationEnd());
+        }
+        if(mSpec.getKeyValidityForConsumptionEnd() != null) {
+            args.addDate(KeymasterDefs.KM_TAG_USAGE_EXPIRE_DATETIME,
+                         mSpec.getKeyValidityForConsumptionEnd());
+        }
+        addAlgorithmSpecificParameters(args);
+        
         byte[] additionalEntropy =
-                KeyStoreCryptoOperationUtils.getRandomBytesToMixIntoKeystoreRng(
-                        mRng, (mKeySizeBits + 7) / 8);
-
+        getRandomBytesToMixIntoKeystoreRng(
+                                           mRng, (mKeySizeBits + 7) / 8);
+        
         final String privateKeyAlias = Credentials.USER_PRIVATE_KEY + mEntryAlias;
         boolean success = false;
         try {
             Credentials.deleteAllTypesForAlias(mKeyStore, mEntryAlias);
-            generateKeystoreKeyPair(
-                    privateKeyAlias, constructKeyGenerationArguments(), additionalEntropy, flags);
-            KeyPair keyPair = loadKeystoreKeyPair(privateKeyAlias);
+            KeyCharacteristics resultingKeyCharacteristics = new KeyCharacteristics();
+            int errorCode = mKeyStore.generateKey(
+                                                  privateKeyAlias,
+                                                  args,
+                                                  additionalEntropy,
+                                                  flags,
+                                                  resultingKeyCharacteristics);
+            if (errorCode != KeyStore.NO_ERROR) {
+                throw new ProviderException(
+                                            "Failed to generate key pair", KeyStore.getKeyStoreException(errorCode));
+            }
+            
+            KeyPair result;
+            try {
+                result = SoterKeyStoreProvider.loadAndroidKeyStoreKeyPairFromKeystore(
+                                                                                      mKeyStore, privateKeyAlias);
+            } catch (UnrecoverableKeyException e) {
+                throw new ProviderException("Failed to load generated key pair from keystore", e);
+            }
+            
+            if (!mJcaKeyAlgorithm.equalsIgnoreCase(result.getPrivate().getAlgorithm())) {
+                throw new ProviderException(
+                                            "Generated key pair algorithm does not match requested algorithm: "
+                                            + result.getPrivate().getAlgorithm() + " vs " + mJcaKeyAlgorithm);
+            }
+            
+            final X509Certificate cert;
+            try {
+                cert = generateSelfSignedCertificate(result.getPrivate(), result.getPublic());
+            } catch (Exception e) {
+                throw new ProviderException("Failed to generate self-signed certificate", e);
+            }
 
-            storeCertificate(
-                    Credentials.USER_CERTIFICATE,
-                    generateSelfSignedCertificateBytes(keyPair),
-                    flags,
-                    "Failed to store certificate");
+            byte[] certBytes;
+            try {
+                certBytes = cert.getEncoded();
+            } catch (CertificateEncodingException e) {
+                throw new ProviderException(
+                                            "Failed to obtain encoded form of self-signed certificate", e);
+            }
 
+            if (!mKeyStore.put(
+                               Credentials.USER_CERTIFICATE + mEntryAlias,
+                               certBytes,
+                               KeyStore.UID_SELF,
+                               flags)) {
+                throw new ProviderException("Failed to store self-signed certificate");
+            }
+
             success = true;
-            return keyPair;
+            return result;
         } finally {
             if (!success) {
                 Credentials.deleteAllTypesForAlias(mKeyStore, mEntryAlias);
@@ -309,67 +400,93 @@
             }
         }
     }
-
+    
+    
+    /**
+     * Returns the requested number of random bytes to mix into keystore/keymaster RNG.
+     *
+     * @param rng RNG from which to obtain the random bytes or {@code null} for the platform-default
+     *        RNG.
+     */
+    static byte[] getRandomBytesToMixIntoKeystoreRng(SecureRandom rng, int sizeBytes) {
+        if (sizeBytes <= 0) {
+            return EmptyArray.BYTE;
+        }
+        if (rng == null) {
+            rng = getRng();
+        }
+        byte[] result = new byte[sizeBytes];
+        rng.nextBytes(result);
+        return result;
+    }
+    
+    private static SecureRandom getRng() {
+        // IMPLEMENTATION NOTE: It's OK to share a SecureRandom instance because SecureRandom is
+        // required to be thread-safe.
+        if (sRng == null) {
+            sRng = new SecureRandom();
+        }
+        return sRng;
+    }
+    
     private static volatile SecureRandom sRng;
-
+    
     private void addAlgorithmSpecificParameters(KeymasterArguments keymasterArgs) {
         if(mRSAPublicExponent != null) {
             keymasterArgs.addUnsignedLong(
                                   KeymasterDefs.KM_TAG_RSA_PUBLIC_EXPONENT, mRSAPublicExponent);
         }
-
+		
         if (isForSoter) {
             keymasterArgs.addBoolean(KeymasterDefs.KM_TAG_SOTER_IS_FROM_SOTER);
-            keymasterArgs.addUnsignedInt(KeymasterDefs.KM_TAG_SOTER_UID,
-                    (long) android.os.Process.myUid());
+            keymasterArgs.addUnsignedInt(KeymasterDefs.KM_TAG_SOTER_UID, (long)android.os.Process.myUid());
         }
-
+        
         if (isAutoSignedWithAttkWhenGetPublicKey) {
-            keymasterArgs.addBoolean(
-                    KeymasterDefs.KM_TAG_SOTER_IS_AUTO_SIGNED_WITH_ATTK_WHEN_GET_PUBLIC_KEY);
+            keymasterArgs.addBoolean(KeymasterDefs.KM_TAG_SOTER_IS_AUTO_SIGNED_WITH_ATTK_WHEN_GET_PUBLIC_KEY);
         }
-
+        
         if (isAutoSignedWithCommonkWhenGetPublicKey) {
-            keymasterArgs.addBoolean(
-                    KeymasterDefs.KM_TAG_SOTER_IS_AUTO_SIGNED_WITH_COMMON_KEY_WHEN_GET_PUBLIC_KEY);
-
-            if (!TextUtils.isEmpty(mAutoSignedKeyNameWhenGetPublicKey)) {
-                // Here just pass the key alias to KeyStore daemon and
-                // it will retrieve the real key. Charset is UTF-8.
-                keymasterArgs.addBytes(
-                        KeymasterDefs.KM_TAG_SOTER_AUTO_SIGNED_COMMON_KEY_WHEN_GET_PUBLIC_KEY,
-                        (Credentials.USER_PRIVATE_KEY + mAutoSignedKeyNameWhenGetPublicKey)
-                        .getBytes());
-            }
+            keymasterArgs.addBoolean(KeymasterDefs.KM_TAG_SOTER_IS_AUTO_SIGNED_WITH_COMMON_KEY_WHEN_GET_PUBLIC_KEY);
+			
+			if(!SoterUtil.isNullOrNil(mAutoSignedKeyNameWhenGetPublicKey)) {
+            // Here just pass the key alias to KeyStore daemon and it will retrieve the real key. Charset is UTF-8.
+            keymasterArgs.addBytes(KeymasterDefs.KM_TAG_SOTER_AUTO_SIGNED_COMMON_KEY_WHEN_GET_PUBLIC_KEY, (Credentials.USER_PRIVATE_KEY + mAutoSignedKeyNameWhenGetPublicKey).getBytes());
+			}
         }
-
+        
         if (isAutoAddCounterWhenGetPublicKey) {
-            keymasterArgs.addBoolean(
-                    KeymasterDefs.KM_TAG_SOTER_AUTO_ADD_COUNTER_WHEN_GET_PUBLIC_KEY);
+            keymasterArgs.addBoolean(KeymasterDefs.KM_TAG_SOTER_AUTO_ADD_COUNTER_WHEN_GET_PUBLIC_KEY);
         }
-
+        
+        
         if (isSecmsgFidCounterSignedWhenSign) {
-            keymasterArgs.addBoolean(
-                    KeymasterDefs.KM_TAG_SOTER_IS_SECMSG_FID_COUNTER_SIGNED_WHEN_SIGN);
+            keymasterArgs.addBoolean(KeymasterDefs.KM_TAG_SOTER_IS_SECMSG_FID_COUNTER_SIGNED_WHEN_SIGN);
         }
-
+        
         if (isNeedNextAttk) {
             keymasterArgs.addBoolean(KeymasterDefs.KM_TAG_SOTER_USE_NEXT_ATTK);
         }
+        
     }
-
-    private X509Certificate generateSelfSignedCertificate(PrivateKey privateKey,
-            PublicKey publicKey) throws CertificateParsingException, IOException {
+    
+    private X509Certificate generateSelfSignedCertificate(
+                                                          PrivateKey privateKey, PublicKey publicKey) throws Exception {
+															  
+		// Log.d("Soter", "generateSelfSignedCertificate");
+															  
         String signatureAlgorithm =
-                getCertificateSignatureAlgorithm(mKeymasterAlgorithm, mKeySizeBits, mSpec);
+        getCertificateSignatureAlgorithm(mKeymasterAlgorithm, mKeySizeBits, mSpec);
         if (signatureAlgorithm == null) {
+			// Log.d("Soter", "generateSelfSignedCertificateWithFakeSignature1");
             // Key cannot be used to sign a certificate
             return generateSelfSignedCertificateWithFakeSignature(publicKey);
         } else {
             // Key can be used to sign a certificate
             try {
+				// Log.d("Soter", "generateSelfSignedCertificateWithValidSignature");
                 return generateSelfSignedCertificateWithValidSignature(
-                        privateKey, publicKey, signatureAlgorithm);
+                                                                       privateKey, publicKey, signatureAlgorithm);
             } catch (Exception e) {
                 // Failed to generate the self-signed certificate with valid signature. Fall back
                 // to generating a self-signed certificate with a fake signature. This is done for
@@ -376,33 +493,23 @@
                 // all exception types because we prefer key pair generation to succeed and end up
                 // producing a self-signed certificate with an invalid signature to key pair
                 // generation failing.
+				// Log.d("Soter", "generateSelfSignedCertificateWithFakeSignature2");
                 return generateSelfSignedCertificateWithFakeSignature(publicKey);
             }
         }
     }
 
-    private byte[] generateSelfSignedCertificateBytes(KeyPair keyPair) throws ProviderException {
-        try {
-            return generateSelfSignedCertificate(keyPair.getPrivate(), keyPair.getPublic())
-                    .getEncoded();
-        } catch (IOException | CertificateParsingException e) {
-            throw new ProviderException("Failed to generate self-signed certificate", e);
-        } catch (CertificateEncodingException e) {
-            throw new ProviderException(
-                    "Failed to obtain encoded form of self-signed certificate", e);
-        }
-    }
-
     private byte[] getRealKeyBlobByKeyName(String keyName) {
-        Log.d(SoterUtil.TAG, "getRealKeyBlobByKeyName: keyName = " + keyName);
+        // Log.d("Soter", "start retrieve key blob by key name: " + keyName);
 
         return mKeyStore.get(Credentials.USER_PRIVATE_KEY + keyName);
     }
 
+    
     @SuppressWarnings("deprecation")
     private X509Certificate generateSelfSignedCertificateWithValidSignature(
-            PrivateKey privateKey, PublicKey publicKey, String signatureAlgorithm)
-                    throws Exception {
+                                                                            PrivateKey privateKey, PublicKey publicKey, String signatureAlgorithm) throws
+    Exception {
         final X509V3CertificateGenerator certGen = new X509V3CertificateGenerator();
         certGen.setPublicKey(publicKey);
         certGen.setSerialNumber(mSpec.getCertificateSerialNumber());
@@ -416,7 +523,7 @@
 
     @SuppressWarnings("deprecation")
     private X509Certificate generateSelfSignedCertificateWithFakeSignature(
-            PublicKey publicKey) throws IOException, CertificateParsingException {
+                                                                           PublicKey publicKey) throws Exception {
         V3TBSCertificateGenerator tbsGenerator = new V3TBSCertificateGenerator();
         ASN1ObjectIdentifier sigAlgOid;
         AlgorithmIdentifier sigAlgId;
@@ -441,11 +548,11 @@
 
         try (ASN1InputStream publicKeyInfoIn = new ASN1InputStream(publicKey.getEncoded())) {
             tbsGenerator.setSubjectPublicKeyInfo(
-                    SubjectPublicKeyInfo.getInstance(publicKeyInfoIn.readObject()));
+                                                 SubjectPublicKeyInfo.getInstance(publicKeyInfoIn.readObject()));
         }
         tbsGenerator.setSerialNumber(new ASN1Integer(mSpec.getCertificateSerialNumber()));
         X509Principal subject =
-                new X509Principal(mSpec.getCertificateSubject().getEncoded());
+        new X509Principal(mSpec.getCertificateSubject().getEncoded());
         tbsGenerator.setSubject(subject);
         tbsGenerator.setIssuer(subject);
         tbsGenerator.setStartDate(new Time(mSpec.getCertificateNotBefore()));
@@ -459,19 +566,19 @@
         result.add(new DERBitString(signature));
         return new X509CertificateObject(Certificate.getInstance(new DERSequence(result)));
     }
-
+    
     private static int getDefaultKeySize(int keymasterAlgorithm) {
         return RSA_DEFAULT_KEY_SIZE;
     }
-
+    
     private static void checkValidKeySize(int keymasterAlgorithm, int keySize)
-            throws InvalidAlgorithmParameterException {
+    throws InvalidAlgorithmParameterException {
         if (keySize < RSA_MIN_KEY_SIZE || keySize > RSA_MAX_KEY_SIZE) {
             throw new InvalidAlgorithmParameterException("RSA key size must be >= "
-                    + RSA_MIN_KEY_SIZE + " and <= " + RSA_MAX_KEY_SIZE);
+                                                         + RSA_MIN_KEY_SIZE + " and <= " + RSA_MAX_KEY_SIZE);
         }
     }
-
+    
     /**
      * Returns the {@code Signature} algorithm to be used for signing a certificate using the
      * specified key or {@code null} if the key cannot be used for signing a certificate.
@@ -478,9 +585,9 @@
      */
     @Nullable
     private static String getCertificateSignatureAlgorithm(
-            int keymasterAlgorithm,
-            int keySizeBits,
-            KeyGenParameterSpec spec) {
+                                                           int keymasterAlgorithm,
+                                                           int keySizeBits,
+                                                           KeyGenParameterSpec spec) {
         // Constraints:
         // 1. Key must be authorized for signing without user authentication.
         // 2. Signature digest must be one of key's authorized digests.
@@ -506,10 +613,10 @@
         // only supports RSA certificates signed using PKCS#1 padding scheme. The key needs
         // to be authorized for PKCS#1 padding or padding NONE which means any padding.
         boolean pkcs1SignaturePaddingSupported =
-                com.android.internal.util.ArrayUtils.contains(
-                        KeyProperties.SignaturePadding.allToKeymaster(
-                                spec.getSignaturePaddings()),
-                        KeymasterDefs.KM_PAD_RSA_PKCS1_1_5_SIGN);
+        com.android.internal.util.ArrayUtils.contains(
+                                                      KeyProperties.SignaturePadding.allToKeymaster(
+                                                                                                    spec.getSignaturePaddings()),
+                                                      KeymasterDefs.KM_PAD_RSA_PKCS1_1_5_SIGN);
         if (!pkcs1SignaturePaddingSupported) {
             // Key not authorized for PKCS#1 signature padding -- can't sign
             return null;
@@ -516,8 +623,8 @@
         }
 
         Set<Integer> availableKeymasterDigests = getAvailableKeymasterSignatureDigests(
-                spec.getDigests(),
-                AndroidKeyStoreBCWorkaroundProvider.getSupportedEcdsaSignatureDigests());
+                                                                                       spec.getDigests(),
+                                                                                       getSupportedEcdsaSignatureDigests());
 
         // The amount of space available for the digest is less than modulus size by about
         // 30 bytes because padding must be at least 11 bytes long (00 || 01 || PS || 00,
@@ -528,7 +635,7 @@
         int bestKeymasterDigest = -1;
         int bestDigestOutputSizeBits = -1;
         for (int keymasterDigest : availableKeymasterDigests) {
-            int outputSizeBits = KeymasterUtils.getDigestOutputSizeBits(keymasterDigest);
+            int outputSizeBits = getDigestOutputSizeBits(keymasterDigest);
             if (outputSizeBits > maxDigestOutputSizeBits) {
                 // Digest too long (signature generation will fail) -- skip
                 continue;
@@ -549,16 +656,16 @@
             return null;
         }
         return KeyProperties.Digest.fromKeymasterToSignatureAlgorithmDigest(
-                bestKeymasterDigest) + "WithRSA";
+                                                                            bestKeymasterDigest) + "WithRSA";
     }
-
+    
     private static String[] getSupportedEcdsaSignatureDigests() {
         return new String[] {"NONE", "SHA-1", "SHA-224", "SHA-256", "SHA-384", "SHA-512"};
     }
-
+    
     private static Set<Integer> getAvailableKeymasterSignatureDigests(
-            @KeyProperties.DigestEnum String[] authorizedKeyDigests,
-            @KeyProperties.DigestEnum String[] supportedSignatureDigests) {
+                                                                      @KeyProperties.DigestEnum String[] authorizedKeyDigests,
+                                                                      @KeyProperties.DigestEnum String[] supportedSignatureDigests) {
         Set<Integer> authorizedKeymasterKeyDigests = new HashSet<Integer>();
         for (int keymasterDigest : KeyProperties.Digest.allToKeymaster(authorizedKeyDigests)) {
             authorizedKeymasterKeyDigests.add(keymasterDigest);
@@ -573,67 +680,74 @@
         return result;
     }
 
-    private void generateKeystoreKeyPair(final String privateKeyAlias, KeymasterArguments args,
-            byte[] additionalEntropy, final int flags) throws ProviderException {
-        KeyCharacteristics resultingKeyCharacteristics = new KeyCharacteristics();
-        int errorCode = mKeyStore.generateKey(privateKeyAlias, args, additionalEntropy,
-                flags, resultingKeyCharacteristics);
-        if (errorCode != KeyStore.NO_ERROR) {
-            throw new ProviderException(
-                    "Failed to generate key pair", KeyStore.getKeyStoreException(errorCode));
+    public static int getDigestOutputSizeBits(int keymasterDigest) {
+        switch (keymasterDigest) {
+            case KeymasterDefs.KM_DIGEST_NONE:
+                return -1;
+            case KeymasterDefs.KM_DIGEST_MD5:
+                return 128;
+            case KeymasterDefs.KM_DIGEST_SHA1:
+                return 160;
+            case KeymasterDefs.KM_DIGEST_SHA_2_224:
+                return 224;
+            case KeymasterDefs.KM_DIGEST_SHA_2_256:
+                return 256;
+            case KeymasterDefs.KM_DIGEST_SHA_2_384:
+                return 384;
+            case KeymasterDefs.KM_DIGEST_SHA_2_512:
+                return 512;
+            default:
+                throw new IllegalArgumentException("Unknown digest: " + keymasterDigest);
         }
     }
-
-    private KeymasterArguments constructKeyGenerationArguments() {
-        KeymasterArguments args = new KeymasterArguments();
-        args.addUnsignedInt(KeymasterDefs.KM_TAG_KEY_SIZE, mKeySizeBits);
-        args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM, mKeymasterAlgorithm);
-        args.addEnums(KeymasterDefs.KM_TAG_PURPOSE, mKeymasterPurposes);
-        args.addEnums(KeymasterDefs.KM_TAG_BLOCK_MODE, mKeymasterBlockModes);
-        args.addEnums(KeymasterDefs.KM_TAG_PADDING, mKeymasterEncryptionPaddings);
-        args.addEnums(KeymasterDefs.KM_TAG_PADDING, mKeymasterSignaturePaddings);
-        args.addEnums(KeymasterDefs.KM_TAG_DIGEST, mKeymasterDigests);
-
-        KeymasterUtils.addUserAuthArgs(args,
-                mSpec.isUserAuthenticationRequired(),
-                mSpec.getUserAuthenticationValidityDurationSeconds(),
-                false,
-                true);
-        args.addDateIfNotNull(KeymasterDefs.KM_TAG_ACTIVE_DATETIME, mSpec.getKeyValidityStart());
-        args.addDateIfNotNull(KeymasterDefs.KM_TAG_ORIGINATION_EXPIRE_DATETIME,
-                mSpec.getKeyValidityForOriginationEnd());
-        args.addDateIfNotNull(KeymasterDefs.KM_TAG_USAGE_EXPIRE_DATETIME,
-                mSpec.getKeyValidityForConsumptionEnd());
-        addAlgorithmSpecificParameters(args);
-
-        return args;
+    
+    
+    private static final long UINT32_RANGE = 1L << 32;
+    public static final long UINT32_MAX_VALUE = UINT32_RANGE - 1;
+    
+    private static final BigInteger UINT64_RANGE = BigInteger.ONE.shiftLeft(64);
+    public static final BigInteger UINT64_MAX_VALUE = UINT64_RANGE.subtract(BigInteger.ONE);
+    /**
+     * Converts the provided value to non-negative {@link BigInteger}, treating the sign bit of the
+     * provided value as the most significant bit of the result.
+     */
+    public static BigInteger toUint64(long value) {
+        if (value >= 0) {
+            return BigInteger.valueOf(value);
+        } else {
+            return BigInteger.valueOf(value).add(UINT64_RANGE);
+        }
     }
-
-    private KeyPair loadKeystoreKeyPair(final String privateKeyAlias) throws ProviderException {
-        try {
-            KeyPair result  = SoterKeyStoreProvider.loadAndroidKeyStoreKeyPairFromKeystore(
-                    mKeyStore, privateKeyAlias);
-            if (!mJcaKeyAlgorithm.equalsIgnoreCase(result.getPrivate().getAlgorithm())) {
-                throw new ProviderException(
-                        "Generated key pair algorithm does not match requested algorithm: "
-                                + result.getPrivate().getAlgorithm() + " vs " + mJcaKeyAlgorithm);
-            }
-            return result;
-        } catch (UnrecoverableKeyException e) {
-            throw new ProviderException("Failed to load generated key pair from keystore", e);
+    
+    
+    public static boolean isKeymasterPaddingSchemeIndCpaCompatibleWithAsymmetricCrypto(
+                                                                                       int keymasterPadding) {
+        switch (keymasterPadding) {
+            case KeymasterDefs.KM_PAD_NONE:
+                return false;
+            case KeymasterDefs.KM_PAD_RSA_OAEP:
+            case KeymasterDefs.KM_PAD_RSA_PKCS1_1_5_ENCRYPT:
+                return true;
+            default:
+                throw new IllegalArgumentException(
+                                                   "Unsupported asymmetric encryption padding scheme: " + keymasterPadding);
         }
     }
-
-    private void storeCertificate(String prefix, byte[] certificateBytes, final int flags,
-            String failureMessage) throws ProviderException {
-        int insertErrorCode = mKeyStore.insert(
-                prefix + mEntryAlias,
-                certificateBytes,
-                KeyStore.UID_SELF,
-                flags);
-        if (insertErrorCode != KeyStore.NO_ERROR) {
-            throw new ProviderException(failureMessage,
-                    KeyStore.getKeyStoreException(insertErrorCode));
+    
+    
+    public static Context getApplicationContext() {
+        Application application = ActivityThread.currentApplication();
+        if (application == null) {
+            throw new IllegalStateException(
+                                            "Failed to obtain application Context from ActivityThread");
         }
+        return application;
     }
+    
+    public static byte[] intToByteArray(int value) {
+        ByteBuffer converter = ByteBuffer.allocate(4);
+        converter.order(ByteOrder.nativeOrder());
+        converter.putInt(value);
+        return converter.array();
+    }
 }
Index: frameworks/base/keystore/java/android/security/keystore/SoterRSAKeyGenParameterSpec.java
===================================================================
--- frameworks/base/keystore/java/android/security/keystore/SoterRSAKeyGenParameterSpec.java	(revision 2996)
+++ frameworks/base/keystore/java/android/security/keystore/SoterRSAKeyGenParameterSpec.java	(revision 2997)
@@ -4,6 +4,7 @@
 import java.security.spec.RSAKeyGenParameterSpec;
 
 /**
+ * Created by yexuan on 15/9/14.
  * @hide
  */
 public class SoterRSAKeyGenParameterSpec extends RSAKeyGenParameterSpec {
@@ -45,10 +46,10 @@
             boolean isNeedNextAttkcKey) {
         this(2048, RSAKeyGenParameterSpec.F4, isForSoter, isAutoSignedWithAttkWhenGetPublicKey,
                 isAutoSignedWithCommonkWhenGetPublicKey,
-                signedKeyNameWhenGetPublicKey, isSecmsgFidCounterSignedWhenSign,
-                isAutoAddCounterWhenGetPubli, isNeedNextAttkcKey);
+                signedKeyNameWhenGetPublicKey, isSecmsgFidCounterSignedWhenSign, isAutoAddCounterWhenGetPubli, isNeedNextAttkcKey);
     }
 
+
     public boolean isForSoter() {
         return isForSoter;
     }
@@ -61,8 +62,7 @@
         return isAutoSignedWithAttkWhenGetPublicKey;
     }
 
-    public void setIsAutoSignedWithAttkWhenGetPublicKey(
-            boolean isAutoSignedWithAttkWhenGetPublicKey) {
+    public void setIsAutoSignedWithAttkWhenGetPublicKey(boolean isAutoSignedWithAttkWhenGetPublicKey) {
         this.isAutoSignedWithAttkWhenGetPublicKey = isAutoSignedWithAttkWhenGetPublicKey;
     }
 
@@ -70,8 +70,7 @@
         return isAutoSignedWithCommonkWhenGetPublicKey;
     }
 
-    public void setIsAutoSignedWithCommonkWhenGetPublicKey(
-            boolean isAutoSignedWithCommonkWhenGetPublicKey) {
+    public void setIsAutoSignedWithCommonkWhenGetPublicKey(boolean isAutoSignedWithCommonkWhenGetPublicKey) {
         this.isAutoSignedWithCommonkWhenGetPublicKey = isAutoSignedWithCommonkWhenGetPublicKey;
     }
 
@@ -106,7 +105,7 @@
     public void setIsNeedUseNextAttk(boolean isNeedUseNextAttk) {
         this.isNeedUseNextAttk = isNeedUseNextAttk;
     }
-
+    
     @Override
     public String toString() {
         return "SoterRSAKeyGenParameterSpec{" +
Index: frameworks/base/keystore/java/android/security/keystore/SoterUtil.java
===================================================================
--- frameworks/base/keystore/java/android/security/keystore/SoterUtil.java	(revision 2996)
+++ frameworks/base/keystore/java/android/security/keystore/SoterUtil.java	(revision 2997)
@@ -1,50 +1,40 @@
 package android.security.keystore;
 
-import android.os.SystemProperties;
-import android.text.TextUtils;
-import android.util.Base64;
 import android.util.Log;
 
-import com.android.internal.util.ArrayUtils;
-
+import android.os.SystemProperties;
 import org.json.JSONException;
 import org.json.JSONObject;
 
+import android.util.Base64;
+
 /**
+ * Created by henryye on 15/9/16.
+ * The utility to handle SOTER-Related common operations
  * @hide
  */
 public class SoterUtil {
-    public static final String TAG = "Soter";
+    public static final String TAG = "Soter.Util";
 
-    private static final boolean FEATURE_SUPPORTED =
-            SystemProperties.get("ro.mtk_soter_support").equals("1");
+    private static final boolean FEATURE_SUPPORTED = SystemProperties.get("ro.mtk_soter_support").equals("1");
+    private static final String PARAM_NEED_AUTO_SIGNED_WITH_ATTK_WHEN_GET_PUBLIC_KEY = "auto_signed_when_get_pubkey_attk";
+    private static final String PARAM_NEED_AUTO_SIGNED_WITH_COMMON_KEY_WHEN_GET_PUBLIC_KEY = "auto_signed_when_get_pubkey";
+    private static final String PARAM_NEED_AUTO_ADD_COUNTER_WHEN_GET_PUBLIC_KEY = "addcounter";
+    private static final String PARAM_NEED_AUTO_ADD_SECMSG_FID_COUNTER_WHEN_SIGN = "secmsg_and_counter_signed_when_sign";
+    private static final String PARAM_NEED_NEXT_ATTK = "next_attk";
 
-    private static final String PARAM_NEED_AUTO_SIGNED_WITH_ATTK_WHEN_GET_PUBLIC_KEY =
-            "auto_signed_when_get_pubkey_attk";
-    private static final String PARAM_NEED_AUTO_SIGNED_WITH_COMMON_KEY_WHEN_GET_PUBLIC_KEY =
-            "auto_signed_when_get_pubkey";
-    private static final String PARAM_NEED_AUTO_ADD_COUNTER_WHEN_GET_PUBLIC_KEY =
-            "addcounter";
-    private static final String PARAM_NEED_AUTO_ADD_SECMSG_FID_COUNTER_WHEN_SIGN =
-            "secmsg_and_counter_signed_when_sign";
-    private static final String PARAM_NEED_NEXT_ATTK =
-            "next_attk";
-
-    private static final int RAW_LENGTH_PREFIX = 4;
-    public static final String JSON_KEY_PUBLIC = "pub_key";
-
     public static boolean isSupported() {
         return FEATURE_SUPPORTED;
     }
 
     public static SoterRSAKeyGenParameterSpec convertKeyNameToParameterSpec(String name) {
-        if (TextUtils.isEmpty(name)) {
-            Log.e(TAG, "convertKeyNameToParameterSpec: name is empty");
+        if(isNullOrNil(name)) {
+            Log.e(TAG, "hy: null or nil when convert key name to parameter");
             return null;
         }
         String[] splits = name.split("\\.");
-        if (ArrayUtils.isEmpty(splits)) {
-            Log.w(TAG, "convertKeyNameToParameterSpec: pure alias, no parameter");
+        if(splits == null || splits.length <= 1) {
+            Log.w(TAG, "hy: pure alias, no parameter");
             return null;
         }
         boolean isForSoter = true;
@@ -55,53 +45,67 @@
         boolean isAutoAddCounterWhenGetPublicKey = false;
         boolean isNeedNextAttk = false;
 
-        if (ArrayUtils.contains(splits, PARAM_NEED_AUTO_SIGNED_WITH_ATTK_WHEN_GET_PUBLIC_KEY)) {
+        if(contains(PARAM_NEED_AUTO_SIGNED_WITH_ATTK_WHEN_GET_PUBLIC_KEY, splits)) {
             isAutoSignedWithAttkWhenGetPublicKey = true;
-        } else {
-            String entireCommonKeyExpr = retrieveItemWithPrefix(
-                    PARAM_NEED_AUTO_SIGNED_WITH_COMMON_KEY_WHEN_GET_PUBLIC_KEY, splits);
-            if (!TextUtils.isEmpty(entireCommonKeyExpr)) {
+        }
+        else {
+            String entireCommonKeyExpr = containsPrefix(PARAM_NEED_AUTO_SIGNED_WITH_COMMON_KEY_WHEN_GET_PUBLIC_KEY, splits);
+            if(!isNullOrNil(entireCommonKeyExpr)) {
                 String commonKeyName = retrieveKeyNameFromExpr(entireCommonKeyExpr);
-                if(!TextUtils.isEmpty(commonKeyName)) {
+                if(!isNullOrNil(commonKeyName)) {
                     isAutoSignedWithCommonkWhenGetPublicKey = true;
                     mAutoSignedKeyNameWhenGetPublicKey = commonKeyName;
                 }
             }
         }
-
-        if (ArrayUtils.contains(splits, PARAM_NEED_AUTO_ADD_SECMSG_FID_COUNTER_WHEN_SIGN)) {
+        
+        if(contains(PARAM_NEED_AUTO_ADD_SECMSG_FID_COUNTER_WHEN_SIGN, splits)) {
             isSecmsgFidCounterSignedWhenSign = true;
         }
-        if (ArrayUtils.contains(splits, PARAM_NEED_AUTO_ADD_COUNTER_WHEN_GET_PUBLIC_KEY)) {
+        if(contains(PARAM_NEED_AUTO_ADD_COUNTER_WHEN_GET_PUBLIC_KEY, splits)) {
             isAutoAddCounterWhenGetPublicKey = true;
 
-            if(ArrayUtils.contains(splits, PARAM_NEED_NEXT_ATTK)) {
-                isNeedNextAttk = true;
-            }
-        }
+        if(contains(PARAM_NEED_NEXT_ATTK, splits)) {
+            isNeedNextAttk = true;
+        }       }
         SoterRSAKeyGenParameterSpec spec = new SoterRSAKeyGenParameterSpec(isForSoter,
                 isAutoSignedWithAttkWhenGetPublicKey,isAutoSignedWithCommonkWhenGetPublicKey,
                 mAutoSignedKeyNameWhenGetPublicKey, isSecmsgFidCounterSignedWhenSign,
                 isAutoAddCounterWhenGetPublicKey, isNeedNextAttk);
-        Log.i(TAG, "convertKeyNameToParameterSpec: spec: " + spec.toString());
+        //Log.i(TAG, "hy: spec: " + spec.toString());
         return spec;
     }
 
     private static String retrieveKeyNameFromExpr(String expr) {
-        if (!TextUtils.isEmpty(expr)) {
+        if(!isNullOrNil(expr)) {
             int startPos = expr.indexOf("(");
             int endPos = expr.indexOf(")");
-            if (startPos >= 0 && endPos > startPos) {
+            if(startPos >= 0 && endPos > startPos) {
                 return expr.substring(startPos + 1, endPos);
             }
-            Log.e(TAG, "retrieveKeyNameFromExpr: no key name");
+            Log.e(TAG, "hy: no key name");
             return null;
-        } else {
-            Log.e(TAG, "retrieveKeyNameFromExpr: expr is null");
+        }
+        else {
+            Log.e(TAG, "hy: expr is null");
             return null;
         }
     }
 
+
+    private static boolean contains(String target, String[] src) {
+        if(src == null || src.length == 0 || isNullOrNil(target)) {
+            Log.e(TAG, "hy: param error");
+            throw new IllegalArgumentException("param error");
+        }
+        for(String item : src) {
+            if(target.equals(item)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
     /**
      *
      * @param prefix the target prefix
@@ -108,9 +112,13 @@
      * @param src the source array
      * @return the entire str
      */
-    private static String retrieveItemWithPrefix(String prefix, String[] src) {
-        for (String item : src) {
-            if (!TextUtils.isEmpty(item) && item.startsWith(prefix)) {
+    private static String containsPrefix(String prefix, String[] src) {
+        if(src == null || src.length == 0 || isNullOrNil(prefix)) {
+            Log.e(TAG, "hy: param error");
+            throw new IllegalArgumentException("param error");
+        }
+        for(String item : src) {
+            if(!isNullOrNil(item) && item.startsWith(prefix)) {
                 return item;
             }
         }
@@ -118,41 +126,50 @@
     }
 
     public static String getPureKeyAliasFromKeyName(String name) {
-        Log.i(TAG, "getPureKeyAliasFromKeyName: name = " + name);
-        if (TextUtils.isEmpty(name)) {
-            Log.e(TAG, "getPureKeyAliasFromKeyName: name is null");
+        //Log.i(TAG, "hy: retrieving pure name from: " + name);
+        if(isNullOrNil(name)) {
+            Log.e(TAG, "hy: null or nil when get pure key alias");
             return null;
         }
         String[] splits = name.split("\\.");
-        if (splits == null || splits.length <= 1) {
-            Log.d(TAG, "getPureKeyAliasFromKeyName: pure alias");
+        if(splits == null || splits.length <= 1) {
+            // Log.d(TAG, "hy: pure alias");
             return name;
         }
         return splits[0];
     }
 
+    public static boolean isNullOrNil(String str) {
+        return str == null || str.equals("");
+    }
+
+
+    private static final int RAW_LENGTH_PREFIX = 4;
+    public static final String JSON_KEY_PUBLIC = "pub_key";
+
     public static byte[] getDataFromRaw(byte[] origin, String jsonKey) throws JSONException {
-        if (TextUtils.isEmpty(jsonKey)) {
-            Log.e(TAG, "getDataFromRaw: jsonKey is null");
+        if (SoterUtil.isNullOrNil(jsonKey)) {
+            Log.e("Soter", "hy: json keyname error");
             return null;
         }
         if (origin == null) {
-            Log.e(TAG, "getDataFromRaw: json origin is null");
+            Log.e("Soter", "hy: json origin null");
             return null;
         }
         JSONObject jsonObj = retriveJsonFromExportedData(origin);
         if (jsonObj != null && jsonObj.has(jsonKey)) {
-
-            String base64pubkey = jsonObj.getString(jsonKey);
-            Log.d(TAG, "getDataFromRaw: base64 encoded public key: " + base64pubkey);
-
-            // filter head and tail and lf
-            String pureBase64pubkey = base64pubkey.replace("-----BEGIN PUBLIC KEY-----", "")
-                    .replace("-----END PUBLIC KEY-----", "").replace("\\n", "");
-            Log.d(TAG, "getDataFromRaw: pure base64 encoded public key: " + pureBase64pubkey);
-
-            byte[] decoded = Base64.decode(pureBase64pubkey, Base64.DEFAULT);
-            return decoded;
+			
+			String base64pubkey = jsonObj.getString(jsonKey);
+			// Log.d("Soter", "base64 encoded public key: " + base64pubkey);
+			
+			//filter head and tail and lf
+			String pureBase64pubkey = base64pubkey.replace("-----BEGIN PUBLIC KEY-----", "").replace("-----END PUBLIC KEY-----", "").replace("\\n","");
+			// Log.d("Soter", "pure base64 encoded public key: " + pureBase64pubkey);
+			
+			byte[] decoded = Base64.decode(pureBase64pubkey, Base64.DEFAULT);
+			return decoded;
+			
+            // return jsonObj.getString(jsonKey).getBytes();
         }
         return null;
     }
@@ -159,44 +176,51 @@
 
     private static JSONObject retriveJsonFromExportedData(byte[] origin) {
         if (origin == null) {
-            Log.e(TAG, "retriveJsonFromExportedData: raw data is null");
+            Log.e("Soter", "raw data is null");
             return null;
         }
         if (origin.length < RAW_LENGTH_PREFIX) {
-            Log.e(TAG, "retriveJsonFromExportedData: raw data length smaller than 4");
+            Log.e("Soter", "raw data length smaller than 4");
         }
+        // StringBuilder lengthBytes = new StringBuilder();
+        // for (int i = RAW_LENGTH_PREFIX - 1; i >= 0; i--) {
+            // lengthBytes.append(origin[i]);
+        // }
+        // int rawLength = Integer.parseInt(lengthBytes.toString(), 2);
+		
 
-        byte[] lengthBytes = new byte[4];
-        System.arraycopy(origin, 0, lengthBytes, 0, 4);
-        int rawLength = toInt(lengthBytes);
-        Log.d(TAG, "retriveJsonFromExportedData: parsed raw length: " + rawLength +
-                ", origin.length = " + origin.length);
+		byte[] lengthBytes = new byte[4];
+		System.arraycopy(origin, 0, lengthBytes, 0, 4);
+		int rawLength = toInt(lengthBytes);
+		// Log.d("Soter", "parsed raw length: " + rawLength);
 
+		
         byte[] rawJsonBytes = new byte[rawLength];
         if (origin.length <= RAW_LENGTH_PREFIX + rawLength) {
-            Log.e(TAG, "retriveJsonFromExportedData: length not correct");
+            Log.e("Soter", "length not correct 2");
             return null;
         }
         System.arraycopy(origin, RAW_LENGTH_PREFIX, rawJsonBytes, 0, rawLength);
         String jsonStr = new String(rawJsonBytes);
-        Log.d(TAG, "retriveJsonFromExportedData: converted json: " + jsonStr);
+        // Log.d("Soter", "to convert json: " + jsonStr);
         try {
             return new JSONObject(jsonStr);
         } catch (JSONException e) {
-            Log.e(TAG, "retriveJsonFromExportedData: convert to json fail", e);
+            Log.e("Soter", "hy: can not convert to json");
         }
         return null;
     }
+	
+	public static int toInt(byte[] bRefArr) 
+	{
+		int iOutcome = 0;
+		byte bLoop;
 
-    public static int toInt(byte[] bRefArr) {
-        int iOutcome = 0;
-        byte bLoop;
+		for (int i = 0; i < bRefArr.length; i++) {
+			bLoop = bRefArr[i];
+			iOutcome += (bLoop & 0xFF) << (8 * i);
+		}
+		return iOutcome;
+	}
 
-        for (int i = 0; i < bRefArr.length; i++) {
-            bLoop = bRefArr[i];
-            iOutcome += (bLoop & 0xFF) << (8 * i);
-        }
-        return iOutcome;
-    }
-
 }
Index: frameworks/base/services/core/java/com/android/server/fingerprint/FingerprintService.java
===================================================================
--- frameworks/base/services/core/java/com/android/server/fingerprint/FingerprintService.java	(revision 2996)
+++ frameworks/base/services/core/java/com/android/server/fingerprint/FingerprintService.java	(revision 2997)
@@ -1110,6 +1110,16 @@
     public long getAuthenticatorId(String opPackageName) {
         /// M: Soter support @{
         if (FingerprintUtils.isSoterSimulated()) return 295219575L;
+    //MICROTRUST_WECHATPAY_BEGIN
+        IFingerprintDaemon daemon = getFingerprintDaemon();
+        if (daemon != null){
+            try{
+                mCurrentAuthenticatorId = daemon.getAuthenticatorId();
+            } catch (RemoteException e) {
+                Slog.e(TAG, "Failed to setActiveGroup():", e);
+            }
+        }
+        //MICROTRUST_WECHATPAY_END
         /// M: Soter support @}
         return mCurrentAuthenticatorId;
     }
Index: frameworks/base/services
===================================================================
--- frameworks/base/services	(revision 2996)
+++ frameworks/base/services	(revision 2997)

Property changes on: frameworks/base/services
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /L05A/Trunk/ALPS-MP-N1.MP18-V1_AUS6739_66_N1_INHOUSE/frameworks/base/services:r2850-2851
Index: frameworks/base
===================================================================
--- frameworks/base	(revision 2996)
+++ frameworks/base	(revision 2997)

Property changes on: frameworks/base
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /L05A/Trunk/ALPS-MP-N1.MP18-V1_AUS6739_66_N1_INHOUSE/frameworks/base:r2850-2851
Index: frameworks
===================================================================
--- frameworks	(revision 2996)
+++ frameworks	(revision 2997)

Property changes on: frameworks
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /L05A/Trunk/ALPS-MP-N1.MP18-V1_AUS6739_66_N1_INHOUSE/frameworks:r2850-2851
Index: system/core/rootdir/init.rc
===================================================================
--- system/core/rootdir/init.rc	(revision 2996)
+++ system/core/rootdir/init.rc	(revision 2997)
@@ -5,6 +5,7 @@
 #
 
 import /init.cdfinger.rc
+import /init.csfinger.rc
 import /init.environ.rc
 import /init.usb.rc
 import /init.${ro.hardware}.rc
Index: system/core/fingerprintd/Android.mk
===================================================================
--- system/core/fingerprintd/Android.mk	(revision 2996)
+++ system/core/fingerprintd/Android.mk	(revision 2997)
@@ -27,6 +27,7 @@
 LOCAL_SHARED_LIBRARIES := \
 	libbinder \
 	liblog \
+	libcutils\
 	libhardware \
 	libutils \
 	libkeystore_binder
Index: system/core/fingerprintd/FingerprintDaemonProxy.cpp
===================================================================
--- system/core/fingerprintd/FingerprintDaemonProxy.cpp	(revision 2996)
+++ system/core/fingerprintd/FingerprintDaemonProxy.cpp	(revision 2997)
@@ -24,10 +24,35 @@
 #include <keystore/keystore.h> // for error codes
 #include <utils/Log.h>
 
+#include <cutils/properties.h>
+
+
 #include "FingerprintDaemonProxy.h"
 
 namespace android {
 
+ //## add by chipsailing finger 20171207  start
+typedef struct fingerprint_dev {
+	const char *dev_name;
+	const char *dev_id;
+} fingerprint_dev_t;
+
+
+fingerprint_dev_t fingerprint_list[] = {
+		{
+			.dev_name = "/dev/fpsdev0",
+			.dev_id = "cdfinger.fingerprint",
+		},
+		{
+			.dev_name = "/dev/cs_spi",
+			.dev_id = "chipsailing.fingerprint",
+		},
+		{
+			.dev_name = "/dev/madev0",
+			.dev_id = "madev.fingerprint",
+		}
+};
+ //## add by chipsailing finger 20171207  end
 FingerprintDaemonProxy* FingerprintDaemonProxy::sInstance = NULL;
 
 // Supported fingerprint HAL version
@@ -195,9 +220,24 @@
     ALOG(LOG_VERBOSE, LOG_TAG, "nativeOpenHal()\n");
     int err;
     const hw_module_t *hw_module = NULL;
-    if (0 != (err = hw_get_module(FINGERPRINT_HARDWARE_MODULE_ID, &hw_module))) {
-        ALOGE("Can't open fingerprint HW Module, error: %d", err);
-        return 0;
+	int i;
+	const char *fingerprint_id = "fingerprint";
+	int len = sizeof(fingerprint_list)/sizeof(fingerprint_dev_t);
+
+	for(i=0;i<len;i++){
+		if(!access(fingerprint_list[i].dev_name, F_OK)) {
+			fingerprint_id = fingerprint_list[i].dev_id;
+			ALOG(LOG_VERBOSE,LOG_TAG,"Detect fingerprint id: %s \n", fingerprint_id);
+		}
+	}
+
+    ALOG(LOG_VERBOSE, LOG_TAG, "hw fingerprint id: %s\n", fingerprint_id);
+    if (0 != (err = hw_get_module(fingerprint_id, &hw_module))) {
+        ALOGE("Can't open fingerprint HW Module[%s], error: %d \n",fingerprint_id, err);
+		if(0 != (err = hw_get_module(FINGERPRINT_HARDWARE_MODULE_ID, &hw_module))){
+			ALOGE("Can't open fingerprint HW Module[%s], error: %d \n",FINGERPRINT_HARDWARE_MODULE_ID, err);
+			return 0;
+		}
     }
     if (NULL == hw_module) {
         ALOGE("No valid fingerprint module");
Index: .
===================================================================
--- .	(revision 2996)
+++ .	(revision 2997)

Property changes on: .
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /L05A/Trunk/ALPS-MP-N1.MP18-V1_AUS6739_66_N1_INHOUSE:r2850-2851
