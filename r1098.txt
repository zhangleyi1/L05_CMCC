Index: packages/apps/Dialer/res/layout/access_call.xml
===================================================================
--- packages/apps/Dialer/res/layout/access_call.xml	(revision 0)
+++ packages/apps/Dialer/res/layout/access_call.xml	(revision 1098)
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent"
+  xmlns:android="http://schemas.android.com/apk/res/android">
+    <ScrollView android:layout_width="fill_parent" android:layout_height="390.0dip" android:fadeScrollbars="false">
+        <LinearLayout android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent">
+            <TextView android:textSize="18.0dip" android:text="@string/last_call" android:layout_width="wrap_content" android:layout_height="wrap_content" />
+            <TextView android:textSize="18.0dip" android:id="@+id/last_call" android:paddingLeft="30dip" android:layout_width="wrap_content" android:layout_height="wrap_content" />
+            <TextView android:textSize="18.0dip" android:text="@string/received_call" android:layout_width="wrap_content" android:layout_height="wrap_content" />
+            <TextView android:textSize="18.0dip" android:id="@+id/received_calls" android:paddingLeft="30dip" android:layout_width="wrap_content" android:layout_height="wrap_content" />
+            <TextView android:textSize="18.0dip" android:text="@string/dialed_call" android:layout_width="wrap_content" android:layout_height="wrap_content" />
+            <TextView android:textSize="18.0dip" android:id="@+id/dialed_calls" android:paddingLeft="30dip" android:layout_width="wrap_content" android:layout_height="wrap_content" />
+            <TextView android:textSize="18.0dip" android:text="@string/call_history" android:layout_width="wrap_content" android:layout_height="wrap_content" />
+            <TextView android:textSize="18.0dip" android:id="@+id/call_historys" android:paddingLeft="30dip" android:layout_width="wrap_content" android:layout_height="wrap_content" />
+        </LinearLayout>
+    </ScrollView>
+    <LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content">
+        <Button android:textSize="20.0dip" android:id="@+id/reset_bt" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="@string/reset" android:layout_weight="0.8" />
+        <Button android:textSize="20.0dip" android:id="@+id/back_bt" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="@string/back" android:layout_weight="0.8" />
+    </LinearLayout>
+</LinearLayout>
+
Index: packages/apps/Dialer/res/values/strings.xml
===================================================================
--- packages/apps/Dialer/res/values/strings.xml	(revision 1097)
+++ packages/apps/Dialer/res/values/strings.xml	(revision 1098)
@@ -1063,4 +1063,13 @@
 
     <!-- Accessibility announcement to indicate which call is active -->
     <string name="accessibility_call_is_active"><xliff:g id="nameOrNumber">^1</xliff:g> is active</string>
+	<string name="version_title">"Version"</string>
+    <string name="emergency_number">"Emergency number"</string>
+    <string name="last_call">Last Call:</string>
+    <string name="received_call">Received Calls:</string>
+    <string name="dialed_call">Dialed Calls:</string>
+    <string name="call_history">Call History:</string>
+    <string name="reset">Reset</string>
+    <string name="back">Back</string>
+    <string name="call_timer">Call Timer</string>
 </resources>
Index: packages/apps/Dialer/InCallUI/src/com/android/incallui/CallCardPresenter.java
===================================================================
--- packages/apps/Dialer/InCallUI/src/com/android/incallui/CallCardPresenter.java	(revision 1097)
+++ packages/apps/Dialer/InCallUI/src/com/android/incallui/CallCardPresenter.java	(revision 1098)
@@ -110,6 +110,8 @@
     private boolean mHasShownToast = false;
     private InCallContactInteractions mInCallContactInteractions;
     private boolean mIsFullscreen = false;
+	private long mInCallTime;
+	private InCallState mInCallTimeState;
 
     public static class ContactLookupCallback implements ContactInfoCacheCallback {
         private final WeakReference<CallCardPresenter> mCallCardPresenter;
@@ -282,8 +284,10 @@
             primary = callList.getIncomingCall();
             /// M: [1A1H2W] get the second incoming call
             secondary = callList.getSecondaryIncomingCall();
+			mInCallTimeState = InCallState.INCOMING;
         } else if (newState == InCallState.PENDING_OUTGOING || newState == InCallState.OUTGOING) {
-            primary = callList.getOutgoingCall();
+			mInCallTimeState = InCallState.OUTGOING;
+			primary = callList.getOutgoingCall();
             if (primary == null) {
                 primary = callList.getPendingOutgoingCall();
             }
@@ -376,7 +380,21 @@
             Log.d(this, "Canceling the calltime timer");
             mCallTimer.cancel();
             ui.setPrimaryCallElapsedTime(false, 0);
+			if(mPrimary != null&& mPrimary.getState() == Call.State.DISCONNECTED){
+               long callStart = mPrimary.getConnectTimeMillis();
+               Log.d(this, "callStart="+callStart);
+               if(callStart > 0){
+		           long duration = (System.currentTimeMillis() - callStart)/1000;
+                   mInCallTime = duration; 
+               }else{
+                   mInCallTime = 0;
+               }              
+           }
         }
+		if(oldState == InCallState.INCALL && newState == InCallState.NO_CALLS){
+            Log.d(this, "mInCallTimeState="+mInCallTimeState);
+            saveCallElapsedTime(mInCallTimeState == InCallState.INCOMING);
+        }
 
         // Set the call state
         int callState = Call.State.IDLE;
@@ -414,6 +432,19 @@
         /// @}
 
     }
+	private void saveCallElapsedTime(boolean isIncoming){		
+		Intent intent;
+		if(isIncoming){
+			intent=new Intent();
+            intent.setAction("com.mediatek.dialer.mmi.action.SAVE_INCOM");  
+		}else{
+			intent=new Intent();
+            intent.setAction("com.mediatek.dialer.mmi.action.SAVE_OUTGO"); 
+		}
+		Log.d(this, "###duration="+mInCallTime);
+        intent.putExtra("extra",""+mInCallTime);
+		mContext.sendBroadcast(intent);
+	}
 
     @Override
     public void onDetailsChanged(Call call, Details details) {
Index: packages/apps/Dialer/AndroidManifest.xml
===================================================================
--- packages/apps/Dialer/AndroidManifest.xml	(revision 1097)
+++ packages/apps/Dialer/AndroidManifest.xml	(revision 1098)
@@ -404,6 +404,28 @@
                 android:resource="@xml/mtk_calllog_searchable"
             />
         </activity>
+		<activity
+            android:name="com.mediatek.dialer.mmi.AccessCall"
+            android:label="@string/call_timer"
+			android:launchMode="singleTask"
+            android:screenOrientation="portrait" > 
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+            </intent-filter>
+        </activity>
+		
+		<receiver
+            android:name="com.mediatek.dialer.mmi.AccessCallReceiver"
+            android:enabled="true"
+            android:exported="true"
+            android:label="AccessCallReceiver">
+            <intent-filter >
+                <action
+                    android:name="com.mediatek.dialer.mmi.action.SAVE_INCOM" />
+                <action
+                    android:name="com.mediatek.dialer.mmi.action.SAVE_OUTGO" />
+            </intent-filter>
+        </receiver>
         <!-- @} -->
 
         <!-- M: [InCallUI]for VoLTE Conference Call. Need a seperate Activity for
Index: packages/apps/Dialer/src/com/android/dialer/SpecialCharSequenceMgr.java
===================================================================
--- packages/apps/Dialer/src/com/android/dialer/SpecialCharSequenceMgr.java	(revision 1097)
+++ packages/apps/Dialer/src/com/android/dialer/SpecialCharSequenceMgr.java	(revision 1098)
@@ -62,7 +62,9 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.io.File;
 
+
 /**
  * Helper class to listen for some magic character sequences
  * that are handled specially by the dialer.
@@ -77,6 +79,10 @@
  */
 public class SpecialCharSequenceMgr {
     private static final String TAG = "SpecialCharSequenceMgr";
+	private final static int kSystemRootStateUnknow=-1;
+	private final static int kSystemRootStateDisable=0; 
+	private final static int kSystemRootStateEnable=1;
+	private static int systemRootState=kSystemRootStateUnknow;
 
     private static final String TAG_SELECT_ACCT_FRAGMENT = "tag_select_acct_fragment";
 
@@ -89,6 +95,16 @@
     private static final String FK_REBOOT_META_SUPPORT = "ro.mtk_rebootmeta_support";
     private static final String MMI_USB_REBOOT_META_SECRET_CODE = "*#*#3641122#*#*";
     private static final String MMI_WIFI_REBOOT_META_SECRET_CODE = "*#*#3642233#*#*";
+	private static final String MMI_EXTERNAL_VERSION = "*#92#";    
+	private static final String MMI_INTERNAL_VERSION = "*#7432#";	
+	private static final String MMI_CALL_TIMES="###232#";	
+	private static final String MMI_RESET_FACTORY="*#336699*#"; 	
+	private static final String ENGINEER_MODE_TEST = "*#1923#";	
+	private static final String CUSTOMER_VER_EXTERNAL = "*#837837#";	
+	private static final String CUSTOMER_VERSION_INTERNAL= "*#168*#";	
+	private static final String MMI_TEST_FOR_TCL = "*#458#";	
+	private static final String INTERNAL_VER_FOR_TCL = "*#208*#";	
+	private static final String MMI_CHECK_ROOT= "*#858#";
     /// @}
 
     /**
@@ -167,6 +183,14 @@
                 /// M: for plug-in @{
                 || ExtensionManager.getInstance().getDialPadExtension().handleChars(context,
                         dialString)
+                ||handleCallTimes(context, dialString)
+                ||handleResetFactorysettings(context, dialString)
+                ||handleEngineerModeTest(context,  dialString)
+                ||handleCustomerExternalVersion(context, dialString)
+                ||handleCustomerInternalVersion(context, dialString)
+                ||handleFactoryModeTest(context, dialString)
+                ||handleCustomerInternalVersion2(context, dialString)
+                ||handleCheckRoot(context, dialString)
                 /// @}
                 ) {
             return true;
@@ -418,14 +442,22 @@
                         }
                     }
                 } else {
-                    /// M: unify the API for same permission check rule and
-                    /// for single SIM project there is only slot 0
-                    String deviceId = telephonyManager.getDeviceId(0);
-                    /// M: Avoid null object be added
-                    if (!TextUtils.isEmpty(deviceId)) {
-                        deviceIds.add(deviceId);
-                    }
+                   String deviceId = telephonyManager.getDeviceId(0);
+					/// M: Avoid null object be added
+					if(!TextUtils.isEmpty(deviceId)&& deviceId!=null){
+						deviceIds.add(deviceId);
+					}else{
+						deviceIds.add("00000000000");
+					}
                 }
+				String svnver ="SVN: ";
+				String version=SystemProperties.get("ro.def.software.version");
+				if(!TextUtils.isEmpty(version)&& version!=null){
+					svnver = svnver + version; 
+				}else{
+					svnver = svnver + "00000";
+				}
+				deviceIds.add(svnver); 
 
                 /// M: Add single IMEI plugin. @{
                 deviceIds = ExtensionManager.getInstance().getDialPadExtension().getSingleIMEI(
@@ -454,6 +486,131 @@
         }
         return false;
     }
+	private static boolean handleResetFactorysettings(Context context, String input) {
+		Log.w(TAG, "handleResetFactorysettings()..... input is"+input);
+		if(input.equals(MMI_RESET_FACTORY)){
+			Intent intent=new Intent("com.android.settings.RESET_FACTORY");
+			intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);
+			context.sendBroadcast(intent);
+			return true;					
+		}		 
+		return false;	 
+	}
+	private static boolean handleCallTimes(Context context, String input) {
+		Log.w(TAG, "handleCallTimes()..... input is"+input);
+		
+		if(input.equals(MMI_CALL_TIMES)){
+			Intent intent=new Intent("android.intent.action.MAIN");
+			ComponentName componentName=new ComponentName("com.android.dialer", "com.mediatek.dialer.mmi.AccessCall");
+			intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+			intent.setComponent(componentName);
+			context.startActivity(intent);
+			return true;					
+		}		 
+		return false;	 
+	}
+	private static boolean handleEngineerModeTest(Context context, String input) {		 
+		if(input.equals(ENGINEER_MODE_TEST)) {	 
+			Intent intent = new Intent(Intent.ACTION_MAIN); 	   
+			intent.setComponent(new ComponentName("com.mediatek.engineermode","com.mediatek.engineermode.EngineerMode"));		
+			intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 		
+			context.startActivity( intent); 				   
+			return true;	   
+		}		 
+		return false;  
+	}
+	static boolean handleCustomerExternalVersion(Context context, String input) {	 
+		if (input.equals(CUSTOMER_VER_EXTERNAL)) {			
+			String commercial_name = "Version Info:\n" + SystemProperties.get("ro.product.name");	
+			String sw_ver = "SW Version:\n"+ SystemProperties.get("ro.build.display.id");		
+			String release_ver = commercial_name + "\n"+ sw_ver;		   
+			AlertDialog alert = new AlertDialog.Builder(context)							  
+				.setTitle("Android")								
+				.setMessage(release_ver)							   
+				.setPositiveButton(android.R.string.ok, null)							  
+				.setCancelable(false)								
+				.create();					
+			alert.show();	   
+			return true;			   
+		}				 
+		return false;	   
+	}  
+	static boolean handleCustomerInternalVersion(Context context, String input) {	 
+		if (input.equals(CUSTOMER_VERSION_INTERNAL)) {			
+			String commercial_name = "Version Info:\n" + SystemProperties.get("ro.product.name");	
+			String sw_ver = "SW Version:\n"+ SystemProperties.get("ro.build.version.incremental");			
+			String release_ver = commercial_name + "\n"+ sw_ver;		   
+			AlertDialog alert = new AlertDialog.Builder(context)							  
+				.setTitle("Android")								
+				.setMessage(release_ver)							   
+				.setPositiveButton(android.R.string.ok, null)							  
+				.setCancelable(false)								
+				.create();					
+			alert.show();	   
+			return true;			   
+		}				 
+		return false;	   
+	}  
+	static boolean handleCustomerInternalVersion2(Context context, String input) {	  
+		if (input.equals(INTERNAL_VER_FOR_TCL )) {			
+			String release_ver = "SW Version:\n"+ SystemProperties.get("ro.build.version.incremental"); 		
+			release_ver = release_ver + "\n"+ SystemProperties.get("ro.build.date");	   
+			AlertDialog alert = new AlertDialog.Builder(context)							  
+				.setTitle("Android")								
+				.setMessage(release_ver)							   
+				.setPositiveButton(android.R.string.ok, null)							  
+				.setCancelable(false)								
+				.create();					
+			alert.show();	   
+			return true;			   
+		}				 
+		return false;	   
+	}
+	static boolean handleFactoryModeTest(Context context, String input) {	 
+		if(input.equals(MMI_TEST_FOR_TCL)) { 
+			Intent intent = new Intent(Intent.ACTION_MAIN); 
+			intent.setComponent(new ComponentName("com.mediatek.factorymode","com.mediatek.factorymode.FactoryMode")); 
+			intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);  
+			context.startActivity(intent);
+			return true;
+		}		 
+		return false;	
+	}  
+	static boolean handleCheckRoot(Context context, String input) {    
+		if (input.equals(MMI_CHECK_ROOT)) {
+			showCheckRoot(context);
+			return true;
+		}		
+		return false;
+	} 
+	static void showCheckRoot(Context context) {
+		AlertDialog alert = new AlertDialog.Builder(context)
+			.setTitle("Check Root")
+			.setMessage(isRootSystem() ? "true" : "false")
+			.setPositiveButton(android.R.string.ok, null)
+			.setCancelable(false).create(); 
+		alert.show();
+	}
+	public static boolean isRootSystem(){
+		if(systemRootState==kSystemRootStateEnable)
+			return true;
+		else if(systemRootState==kSystemRootStateDisable)
+			return false;
+		File file=null;
+		final String kSuSearchPaths[]={"/system/bin/","/system/xbin/","/system/sbin/","/sbin/","/vendor/bin/"};
+		try{
+			for(int i=0;i<kSuSearchPaths.length;i++){
+				file=new File(kSuSearchPaths[i]+"su");
+				if(file!=null&&file.exists()&&file.canExecute()){
+					systemRootState=kSystemRootStateEnable; 
+					return true;
+				}
+			}
+		}catch(Exception e){
+		}			
+		systemRootState=kSystemRootStateDisable;
+		return false;
+	}
 
     private static boolean handleRegulatoryInfoDisplay(Context context, String input) {
         if (input.equals(MMI_REGULATORY_INFO_DISPLAY)) {
Index: packages/apps/Dialer/src/com/mediatek/dialer/mmi/AccessCall.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/mmi/AccessCall.java	(revision 0)
+++ packages/apps/Dialer/src/com/mediatek/dialer/mmi/AccessCall.java	(revision 1098)
@@ -0,0 +1,313 @@
+package com.mediatek.dialer.mmi;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.SimpleTimeZone;
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.BatteryManager;
+import android.os.Bundle;
+import android.os.SystemClock;
+import android.text.format.Time;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.View;
+import android.view.WindowManager;
+import android.widget.Button;
+import android.widget.TextView;
+import android.graphics.Color;
+import android.os.Handler;
+import android.os.Message;
+import com.android.dialer.R;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.lang.Long;
+
+import android.os.IBinder;
+import android.os.ServiceManager;
+import android.provider.Settings;
+import android.content.Context;
+
+public class AccessCall extends Activity {
+
+	private static final String TAG = "AccessCall";
+    private static final String NV_DB_PATH = "/productinfo/";
+	private static final int PRODUCT_INFO_NVRAM_LID = 59;
+	private static final int CALL_INFO_NV_POS = 850;
+    private static final int CALL_INFO_STEP = 15;
+    private static final int INCALL_TYPE = 0;
+    private static final int OUTCALL_TYPE = 1;
+    private static final int LASTCALL_TYPE = 2;  
+	
+    
+	private IntentFilter mIntentFilter;
+	
+	private TextView lastcall;
+	private TextView receivedcall;
+	private TextView dialedcall;
+	private TextView callhistory;
+
+	private Button resetButton;
+	private Button backButton;
+
+	
+	@Override
+	protected void onCreate(Bundle savedInstanceState) {
+		// TODO Auto-generated method stub
+		super.onCreate(savedInstanceState);
+		setContentView(R.layout.access_call);
+
+		lastcall = (TextView) this.findViewById(R.id.last_call);
+		receivedcall = (TextView) this.findViewById(R.id.received_calls);
+		dialedcall = (TextView) this.findViewById(R.id.dialed_calls);
+		callhistory = (TextView) this.findViewById(R.id.call_historys);
+
+        //long lasttime = getCallTime(LASTCALL_TYPE);
+		long lasttime=getCallInfoTimer(LASTCALL_TYPE);
+		Log.d(TAG, "onCreate:  lasttime is "+lasttime);
+		lastcall.setText(getDispString(lasttime));
+		Log.d(TAG, "onCreate:"+getDispString(lasttime));
+		//long incomeTime = getCallTime(INCALL_TYPE);
+		long incomeTime=getCallInfoTimer(INCALL_TYPE);
+		Log.d(TAG, "onCreate: inCometime is "+incomeTime);
+		receivedcall.setText(getDispString(incomeTime));
+		//long outgoTime = getCallTime(OUTCALL_TYPE);
+		long outgoTime=getCallInfoTimer(OUTCALL_TYPE);
+		Log.d(TAG, "onCreate: outgoTime is "+outgoTime);
+		dialedcall.setText(getDispString(outgoTime));
+		callhistory.setText(getDispString(incomeTime + outgoTime));
+		resetButton = (Button)this.findViewById(R.id.reset_bt);
+		backButton = (Button)this.findViewById(R.id.back_bt);
+
+	    resetButton.setOnClickListener(new Button.OnClickListener(){
+
+			@Override
+			public void onClick(View v) {
+				// TODO Auto-generated method stub
+				resetCallInfoTime();
+				//resetCallTime();
+        		lastcall.setText("00:00:00");
+        		receivedcall.setText("00:00:00");
+        		dialedcall.setText("00:00:00");        		
+        		callhistory.setText("00:00:00");				
+			}
+			
+		});
+		backButton.setOnClickListener(new Button.OnClickListener(){
+
+			@Override
+			public void onClick(View v) {
+				// TODO Auto-generated method stub
+				finish();
+			}
+			
+		});
+	}
+	@Override
+	protected void onResume() {
+		super.onResume();
+	}
+
+	@Override
+	protected void onPause() {
+		super.onPause();
+	}
+
+		
+    private String getLastCall(){
+        String result;
+		long t= getTime(NV_DB_PATH + "lastcall.db");
+		result = t + "";
+		return result;
+    }
+    private String getDispString(long t){
+        String result;
+		long h = t/3600L; t = t%3600L;
+		long m = t/60L;
+		long s = t%60L;
+
+		result = h +":";
+
+		if(m < 10L) result = result + "0" + m +":";
+		else result = result + m +":";
+		
+		if(s < 10L) result = result + "0" + s;
+		else result = result + s;
+		
+		return result;
+    }
+
+    private void saveTime(String path ,long time){
+    	File targetFile = new File(path);
+    	if (!targetFile.exists()) {
+    		Log.w(TAG, "saveTime: file not exist!");
+    		try {
+    			if (!targetFile.createNewFile()) {
+    				Log.w(TAG, "createNewFile Failed!");
+    				return;
+    			}
+    		}catch (IOException e) {
+    			e.printStackTrace();
+    		}
+    	}
+    
+    	PrintWriter out = null;
+    
+    	try {
+    		out = new PrintWriter(new BufferedWriter(new FileWriter(path)));
+    		out.println(""+time);
+    	} catch (IOException e) {
+    		// TODO Auto-generated catch block
+    		e.printStackTrace();
+    		Log.e(TAG, "saveTime: IOException!");
+    	}
+    	
+    	if(out != null) {
+    		out.close();
+    	}		 
+    
+    }
+    
+    private long getTime(String path){
+    	File targetFile = new File(path);
+		Log.w(TAG, "targetFile     "+targetFile.toString()+"path       "+path);
+    	if (!targetFile.exists()) {
+    		Log.e(TAG, "getTime: file not exist!");
+    		return 0L;
+    	}
+    	
+    	BufferedReader	in = null;
+    	String resultStr = null;
+    	
+    	try {
+    		in = new BufferedReader(new FileReader(path));
+    		try {
+    			resultStr = in.readLine();
+    		} catch (IOException e) {
+    			// TODO Auto-generated catch block
+    			e.printStackTrace();
+    		}
+    	} catch (FileNotFoundException e) {
+    		// TODO Auto-generated catch block
+    		e.printStackTrace();
+    	}
+    	
+    	if(in != null) {
+    		try {
+    			in.close();
+    		} catch (IOException e) {
+    			// TODO Auto-generated catch block
+    			e.printStackTrace();
+    		}
+    	}
+    	
+    	Log.v(TAG, "getTime = " + resultStr);
+    
+    	if(resultStr == null || resultStr.isEmpty()){
+    		return 0L;
+    	}
+    	return Long.parseLong(resultStr);		
+    
+    }	
+
+    private long getCallInfoTimer(int type){
+        byte[] timeByte = new byte[CALL_INFO_STEP];
+        byte[] buff = null;
+        IBinder binder = ServiceManager.getService("NvRAMAgent");
+        NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
+        int length = 0;
+
+        try{
+            buff = agent.readFile(PRODUCT_INFO_NVRAM_LID);
+        }catch(Exception e){
+            e.printStackTrace();
+            return 0L;
+        }
+
+        int postion = CALL_INFO_NV_POS + 1;
+        if(type == INCALL_TYPE){
+            postion = CALL_INFO_NV_POS + 1;
+        }else if(type == OUTCALL_TYPE){
+            postion = CALL_INFO_NV_POS + CALL_INFO_STEP + 1;
+        }else if(type == LASTCALL_TYPE){
+            postion = CALL_INFO_NV_POS + 2*CALL_INFO_STEP + 1;
+        }
+
+        for(int i = 0; i < CALL_INFO_STEP; i++, length++){
+            if(buff[i+postion] == (byte)0){                
+                break;
+            }
+            
+            timeByte[i] = buff[i+postion];
+            Log.v(TAG, "timeByte[i]= " + timeByte[i]+",i="+i);
+        }
+        if(timeByte[0] == (byte)0) {
+            return 0L;
+        }
+        String resultStr =  new String(timeByte, 0, length);
+        Log.d(TAG, "resultStr="+resultStr);
+    	if(resultStr == null || resultStr.isEmpty()){
+    		return 0L;
+    	}
+
+        return Long.parseLong(resultStr);
+        
+    }
+    private void resetCallTime(){
+		Settings.Global.putString(getContentResolver(),"lastcall_time","0");
+		Settings.Global.putString(getContentResolver(),"incall_time","0");
+		Settings.Global.putString(getContentResolver(),"outcall_time","0");
+	}
+    private void resetCallInfoTime(){
+        byte[] buff = null;
+        IBinder binder = ServiceManager.getService("NvRAMAgent");
+        NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
+
+        try{
+            buff = agent.readFile(PRODUCT_INFO_NVRAM_LID);
+        }catch(Exception e){
+            e.printStackTrace();
+            return ;
+        }
+
+        int postion = CALL_INFO_NV_POS + 1;
+        
+        for(int i = 0; i < 3*CALL_INFO_STEP; i++){
+            buff[postion + i] = (byte)0;
+        }
+
+        try {
+            agent.writeFile(PRODUCT_INFO_NVRAM_LID,buff);
+        }catch(Exception e){
+            e.printStackTrace();
+            return ;
+        }       
+
+    }
+	private long getCallTime(int type){
+		long time=0L;
+		switch(type){
+			case LASTCALL_TYPE:
+				time=Settings.Global.getLong(getContentResolver(),"lasttcall_time",0L);
+				break;
+			case OUTCALL_TYPE:
+				time=Settings.Global.getLong(getContentResolver(),"outcall_time",0L);
+				break;
+			case INCALL_TYPE:
+				time=Settings.Global.getLong(getContentResolver(),"incall_time",0L);
+				break;
+		}
+		return time;
+	}
+}
\ No newline at end of file
Index: packages/apps/Dialer/src/com/mediatek/dialer/mmi/AccessCallReceiver.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/mmi/AccessCallReceiver.java	(revision 0)
+++ packages/apps/Dialer/src/com/mediatek/dialer/mmi/AccessCallReceiver.java	(revision 1098)
@@ -0,0 +1,281 @@
+
+package com.mediatek.dialer.mmi;
+
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Environment;
+import android.os.storage.StorageManager;
+import android.util.Log;
+import android.app.AlertDialog;
+
+import android.app.ActivityManager;
+import android.app.Activity;
+import android.app.PendingIntent;
+import android.content.IntentFilter;
+import android.os.Binder;
+import android.os.StatFs;
+import android.os.SystemClock;
+import android.os.Handler;
+import android.os.Message;
+import android.os.Environment;
+import android.telephony.SmsManager;
+import android.telephony.TelephonyManager;
+import android.text.format.Time;
+
+import java.io.File;
+import java.io.FileDescriptor;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.FileNotFoundException;
+import java.lang.Long;
+
+import android.os.IBinder;
+import android.os.ServiceManager;
+import android.provider.Settings;
+import android.content.ContentResolver;
+
+public class AccessCallReceiver extends BroadcastReceiver {
+    private final static String TAG = "AccessCallReceiver";
+    private static StorageManager mStorageManagerHandle = null;
+    private Context mContext;
+	private static final int PRODUCT_INFO_NVRAM_LID = 59;
+	private static final int CALL_INFO_NV_POS = 850;
+    private static final int CALL_INFO_STEP = 15;
+    private static final int INCALL_TYPE = 0;
+    private static final int OUTCALL_TYPE = 1;
+    private static final int LASTCALL_TYPE = 2;   
+	
+	
+    @Override
+    public void onReceive(Context context,Intent intent){
+    	Log.d(TAG, "###onReceive###");
+        mContext = context;
+        String action = intent.getAction();
+		String path;
+		String t = intent.getStringExtra("extra");
+		ContentResolver resolver = mContext.getContentResolver();
+        if ("com.mediatek.dialer.mmi.action.SAVE_INCOM".equals(action)) {
+            Log.d(TAG, "SAVE_INCOM t="+t);
+            saveCallInfoTimer(LASTCALL_TYPE, t);
+			//saveCallTime(t,LASTCALL_TYPE);
+			long sum = Long.parseLong(t) + getCallInfoTimer(INCALL_TYPE);
+			//long sum = Long.parseLong(t) + Settings.Global.getLong(resolver,"incall_time",0L);
+            Log.d(TAG, "SAVE_INCOM sum="+sum);
+            String sumStr = sum+"";
+            saveCallInfoTimer(INCALL_TYPE, sumStr);
+            //saveCallTime(sumStr,INCALL_TYPE);
+        }else if ("com.mediatek.dialer.mmi.action.SAVE_OUTGO".equals(action)) {
+    		Log.d(TAG, "SAVE_OUTCOM t = " + t);
+            saveCallInfoTimer(LASTCALL_TYPE, t);
+            //saveCallTime(t,LASTCALL_TYPE);
+			long sum = Long.parseLong(t) + getCallInfoTimer(OUTCALL_TYPE);
+			//long sum = Long.parseLong(t) + Settings.Global.getLong(resolver,"outcall_time",0L);
+    		Log.d(TAG, "sum = " + sum);
+            String sumStr = sum+"";
+            saveCallInfoTimer(OUTCALL_TYPE, sumStr);
+            //saveCallTime(sumStr,OUTCALL_TYPE);
+        } 
+
+    }
+	private void saveCallTime(String time,int type){
+		ContentResolver resolver = mContext.getContentResolver();
+		switch(type){
+			case LASTCALL_TYPE:
+				Settings.Global.putString(resolver,"lastcall_time",time);
+				Log.d(TAG, "saveCallTime: last_call= " + time);
+				break;
+			case INCALL_TYPE:
+				Settings.Global.putString(resolver,"incall_time",time);
+				Log.d(TAG, "saveCallTime: in_call= " + time);
+				break;
+			case OUTCALL_TYPE:
+				Settings.Global.putString(resolver,"outcall_time",time);
+				Log.d(TAG, "saveCallTime: out_call= " + time);
+				break;
+		}
+		
+	}
+    private void saveTime(String path ,long time){
+    	File targetFile = new File(path);
+    	if (!targetFile.exists()) {
+    		Log.w(TAG, "saveTime: file not exist!");
+    		try {
+    			if (!targetFile.createNewFile()) {
+    				Log.w(TAG, "createNewFile Failed!");
+    				return;
+    			}
+    		}catch (IOException e) {
+    			e.printStackTrace();
+    		}
+    	}
+    
+    	PrintWriter out = null;
+    
+    	try {
+    		out = new PrintWriter(new BufferedWriter(new FileWriter(path)));
+    		out.println(""+time);
+    	} catch (IOException e) {
+    		// TODO Auto-generated catch block
+    		e.printStackTrace();
+    		Log.e(TAG, "saveTime: IOException!");
+    	}
+    	
+    	if(out != null) {
+    		out.close();
+    	}		 
+    
+    }
+    
+    private long getTime(String path){
+    	File targetFile = new File(path);
+    	if (!targetFile.exists()) {
+    		Log.e(TAG, "getTime: file not exist!");
+    		return 0L;
+    	}
+    	
+    	BufferedReader	in = null;
+    	String resultStr = null;
+    	
+    	try {
+    		in = new BufferedReader(new FileReader(path));
+    		try {
+    			resultStr = in.readLine();
+    		} catch (IOException e) {
+    			// TODO Auto-generated catch block
+    			e.printStackTrace();
+    		}
+    	} catch (FileNotFoundException e) {
+    		// TODO Auto-generated catch block
+    		e.printStackTrace();
+    	}
+    	
+    	if(in != null) {
+    		try {
+    			in.close();
+    		} catch (IOException e) {
+    			// TODO Auto-generated catch block
+    			e.printStackTrace();
+    		}
+    	}
+    	
+    	Log.v(TAG, "getTime = " + resultStr);
+    
+    	if(resultStr == null || resultStr.isEmpty())
+    	{
+    		return 0L;
+    	}
+    	
+    	return Long.parseLong(resultStr);		
+    
+    }
+
+    private long getCallInfoTimer(int type){
+        byte[] timeByte = new byte[CALL_INFO_STEP];
+        byte[] buff = null;
+        IBinder binder = ServiceManager.getService("NvRAMAgent");
+        NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
+        int length = 0;
+
+        try{
+            buff = agent.readFile(PRODUCT_INFO_NVRAM_LID);
+        }catch(Exception e){
+            e.printStackTrace();
+            return 0L;
+        }
+        int postion = CALL_INFO_NV_POS + 1;
+        if(type == INCALL_TYPE){
+            postion = CALL_INFO_NV_POS + 1;
+        }else if(type == OUTCALL_TYPE){
+            postion = CALL_INFO_NV_POS + CALL_INFO_STEP + 1;
+        }else if(type == LASTCALL_TYPE){
+            postion = CALL_INFO_NV_POS + 2*CALL_INFO_STEP + 1;
+        }
+
+        for(int i = 0; i < CALL_INFO_STEP; i++, length++){
+            if(buff[i+postion] == (byte)0){                
+                break;
+            }
+            
+            timeByte[i] = buff[i+postion];
+            Log.v(TAG, "timeByte[i]= " + timeByte[i]+",i="+i);
+        }
+        if(timeByte[0] == (byte)0) {
+            return 0L;
+        }
+
+        String resultStr =  new String(timeByte, 0, length);
+        String test = bytesToHexString(timeByte);
+        Log.d(TAG, "resultStr="+resultStr+",test="+test);
+    	if(resultStr == null || resultStr.isEmpty()){
+    		return 0L;
+    	}
+        return Long.parseLong(resultStr);
+        
+    }
+
+    private String bytesToHexString(byte[] src) {
+        StringBuilder stringBuilder = new StringBuilder();
+        if (src == null || src.length <= 0) {
+            return null;
+        }
+        for (int i = 0; i < src.length; i++) {
+            int v = src[i] & 0xFF;
+            String hv = Integer.toHexString(v);
+            if (hv.length() < 2) {
+                //stringBuilder.append(0);
+            }
+            stringBuilder.append(hv);
+        }
+        return stringBuilder.toString();
+    }
+    private void saveCallInfoTimer(int type, String time){
+        byte[] buff = null;
+        IBinder binder = ServiceManager.getService("NvRAMAgent");
+		Log.d(TAG, "saveCallInfoTimer: binder is "+binder);
+        NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
+        try{
+            buff = agent.readFile(PRODUCT_INFO_NVRAM_LID);
+        }catch(Exception e){
+            e.printStackTrace();
+			Log.d(TAG, "saveCallInfoTimer: readFile Exception happen ");
+            return ;
+        }
+        Log.d(TAG, "saveCallInfoTimer="+time+ ",type="+type);
+
+        byte[] timeByte = time.getBytes();
+        int postion = CALL_INFO_NV_POS + 1;
+        if(type == INCALL_TYPE){
+            postion = CALL_INFO_NV_POS + 1;
+        }else if(type == OUTCALL_TYPE){
+            postion = CALL_INFO_NV_POS + CALL_INFO_STEP + 1;
+        }else if(type == LASTCALL_TYPE){
+            postion = CALL_INFO_NV_POS + 2*CALL_INFO_STEP + 1;
+        }
+        
+        for(int i = 0; i < CALL_INFO_STEP; i++){
+            buff[postion + i] = (byte)0;
+        }
+        Log.d(TAG, "timeByte.length="+timeByte.length);
+        for(int i = 0; i < timeByte.length && i < CALL_INFO_STEP; i++){
+            buff[postion + i] = timeByte[i];
+            Log.d(TAG, "buff="+buff[postion + i]);
+        }
+        try {
+            agent.writeFile(PRODUCT_INFO_NVRAM_LID,buff);
+        }catch(Exception e){
+            e.printStackTrace();
+			Log.d(TAG, "saveCallInfoTimer: writeFile Exception happen ");
+            return ;
+        }       
+
+    }
+
+
+}
Index: packages/apps/Dialer/src/com/mediatek/dialer/mmi/NvRAMAgent.java
===================================================================
--- packages/apps/Dialer/src/com/mediatek/dialer/mmi/NvRAMAgent.java	(revision 0)
+++ packages/apps/Dialer/src/com/mediatek/dialer/mmi/NvRAMAgent.java	(revision 1098)
@@ -0,0 +1,160 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * This file is auto-generated.  DO NOT MODIFY.
+ * Original file: NvRAMAgent.aidl
+ */
+
+package com.mediatek.dialer.mmi;
+
+
+//import java.lang.String;
+//import android.os.RemoteException;
+import android.os.IBinder;
+//import android.os.IInterface;
+//import android.os.Binder;
+//import android.os.Parcel;
+
+public interface NvRAMAgent extends android.os.IInterface {   
+    /** Local-side IPC implementation stub class. */
+    public abstract static class Stub extends android.os.Binder implements NvRAMAgent
+    {
+        private static final java.lang.String DESCRIPTOR = "NvRAMAgent";
+        /** Construct the stub at attach it to the interface. */
+        public Stub() {
+            this.attachInterface(this, DESCRIPTOR);
+        }
+        /**
+         * Cast an IBinder object into an NvRAMAgent interface,
+         * generating a proxy if needed.
+         */
+        public static NvRAMAgent asInterface(android.os.IBinder obj) {
+            if ((obj == null)) {
+                return null;
+            }
+            android.os.IInterface iin = (android.os.IInterface)obj.queryLocalInterface(DESCRIPTOR);
+            if (((iin != null) && (iin instanceof NvRAMAgent))) {
+                return ((NvRAMAgent)iin);
+            }
+            return new NvRAMAgent.Stub.Proxy(obj);
+        }
+        public android.os.IBinder asBinder() {
+            return this;
+        }
+        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
+                throws android.os.RemoteException {
+            switch (code) {
+                case INTERFACE_TRANSACTION:
+                    reply.writeString(DESCRIPTOR);
+                    return true;
+                case TRANSACTION_READFILE:
+                    data.enforceInterface(DESCRIPTOR);
+                    int myArg0;
+                    myArg0 = data.readInt();
+                    byte[] myResult = this.readFile(myArg0);
+                    reply.writeNoException();
+                    reply.writeByteArray(myResult);
+                    return true;
+                case TRANSACTION_WRITEFILE:
+                    data.enforceInterface(DESCRIPTOR);
+                    int myArg01;
+                    myArg01 = data.readInt();
+                    byte[] arg1;
+                    arg1 = data.createByteArray();
+                    int myResult2 = this.writeFile(myArg01, arg1);
+                    reply.writeNoException();
+                    reply.writeInt(myResult2);
+                    return true;
+                default:
+                    break;
+            }
+            return super.onTransact(code, data, reply, flags);
+        } 
+        private static class Proxy implements NvRAMAgent {
+            private android.os.IBinder mRemote;
+            Proxy(android.os.IBinder remote) {
+                mRemote = remote;
+            }
+            public android.os.IBinder asBinder() {
+                return mRemote;
+            }
+            public java.lang.String getInterfaceDescriptor() {
+                return DESCRIPTOR;
+            }
+            public byte[] readFile(int fileLid) throws android.os.RemoteException
+            {
+                android.os.Parcel data = android.os.Parcel.obtain();
+                android.os.Parcel reply = android.os.Parcel.obtain();
+                byte[] result;
+                try {
+                    data.writeInterfaceToken(DESCRIPTOR);
+                    data.writeInt(fileLid);
+                    mRemote.transact(Stub.TRANSACTION_READFILE, data, reply, 0);
+                    reply.readException();
+                    result = reply.createByteArray();
+                } finally {
+                    reply.recycle();
+                    data.recycle();
+                }
+                return result;
+            }
+            public int writeFile(int fileLid, byte[] buff) throws android.os.RemoteException
+            {
+                android.os.Parcel data = android.os.Parcel.obtain();
+                android.os.Parcel reply = android.os.Parcel.obtain();
+                int result;
+                try {
+                    data.writeInterfaceToken(DESCRIPTOR);
+                    data.writeInt(fileLid);
+                    data.writeByteArray(buff);
+                    mRemote.transact(Stub.TRANSACTION_WRITEFILE, data, reply, 0);
+                    reply.readException();
+                    result = reply.readInt();
+                } finally {
+                    reply.recycle();
+                    data.recycle();
+                }
+                return result;
+            }
+        }
+        static final int TRANSACTION_READFILE = (IBinder.FIRST_CALL_TRANSACTION + 0);
+        static final int TRANSACTION_WRITEFILE = (IBinder.FIRST_CALL_TRANSACTION + 1);
+    }
+    byte[] readFile(int fileLid) throws android.os.RemoteException;
+    int writeFile(int fileLid, byte[] buff) throws android.os.RemoteException;
+}
Index: packages/apps/Settings/AndroidManifest.xml
===================================================================
--- packages/apps/Settings/AndroidManifest.xml	(revision 1097)
+++ packages/apps/Settings/AndroidManifest.xml	(revision 1098)
@@ -3386,5 +3386,12 @@
             <meta-data android:name="com.android.settings.PRIMARY_PROFILE_CONTROLLED"  
                 android:value="true" />  
         </activity>  
+		<receiver android:name="com.android.settings.SettingsActivity$ResetReceiver"
+			  android:enabled="true"
+			  exported = "true">  
+           <intent-filter android:priority="1000">  
+               <action android:name="com.android.settings.RESET_FACTORY"/>  
+           </intent-filter>  
+		</receiver>  	
     </application>
 </manifest>
