Index: frameworks/base/packages/Keyguard/Android.mk
===================================================================
--- frameworks/base/packages/Keyguard/Android.mk	(revision 6856)
+++ frameworks/base/packages/Keyguard/Android.mk	(revision 6857)
@@ -27,12 +27,15 @@
 
 LOCAL_STATIC_JAVA_LIBRARIES := com.mediatek.keyguard.ext
 LOCAL_STATIC_JAVA_LIBRARIES += joylockscren-sdk
+
+#LOCAL_STATIC_JAVA_AAR_LIBRARIES := unlocksdk
+LOCAL_STATIC_JAVA_LIBRARIES += unlocksdk1
 # added by zengjie for JoyLockScreen feature task 5429900 on 2017/10/20 start
 ifeq (yes,$(strip $(TCL_LSCREEN_SUPPORT)))
 LOCAL_STATIC_JAVA_LIBRARIES += gson-sdk
  
 #LOCAL_STATIC_JAVA_AAR_LIBRARIES += mytarget_sdk
-LOCAL_STATIC_JAVA_AAR_LIBRARIES := duapps_sdk
+LOCAL_STATIC_JAVA_AAR_LIBRARIES += duapps_sdk
 LOCAL_STATIC_JAVA_AAR_LIBRARIES += hawk_sdk
 LOCAL_STATIC_JAVA_AAR_LIBRARIES += vlife_sdk
 LOCAL_STATIC_JAVA_AAR_LIBRARIES += play-services-ads
@@ -42,7 +45,6 @@
 
 # added by zengjie for JoyLockScreen feature task 5429900 on 2017/10/20 start
 ifeq (yes,$(strip $(TCL_LSCREEN_SUPPORT)))
-	LOCAL_AAPT_FLAGS += --auto-add-overlay --extra-packages com.hawk.android.adsdk
 	LOCAL_AAPT_FLAGS += --auto-add-overlay --extra-packages com.duapps.ad
 	#LOCAL_AAPT_FLAGS += --auto-add-overlay --extra-packages com.my.target
 	LOCAL_AAPT_FLAGS += --auto-add-overlay --extra-packages com.summit.sdk.magazine
@@ -51,6 +53,8 @@
 endif
 # added by zengjie for JoyLockScreen feature task 5429900 on 2017/10/20 end
 
+
+
 LOCAL_PRIVILEGED_MODULE := true
 
 LOCAL_PROGUARD_FLAG_FILES := proguard.flags
@@ -58,6 +62,7 @@
 LOCAL_RESOURCE_DIR := $(LOCAL_PATH)/res
 LOCAL_RESOURCE_DIR += $(LOCAL_PATH)/res_ext
 LOCAL_AAPT_FLAGS := --auto-add-overlay
+LOCAL_AAPT_FLAGS += --auto-add-overlay --extra-packages com.summit.sdk.magazine
 
 include $(BUILD_STATIC_JAVA_LIBRARY)
 include $(CLEAR_VARS) 
@@ -70,6 +75,9 @@
 	LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES += play-services-ads-lite:libs/play-services-ads-lite-10.2.0.aar
 	LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES += gson-sdk:libs/gson-2.7.jar
 endif
+
+#LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES += unlocksdk:libs/UnlockSdk1.2.105.10733.aar
+LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES += unlocksdk1:libs/UnlockSdk1.2.105.10733.jar
 include $(BUILD_MULTI_PREBUILT) 
 
 include $(call all-makefiles-under,$(LOCAL_PATH))
Index: frameworks/base/packages/Keyguard/AndroidManifest.xml
===================================================================
--- frameworks/base/packages/Keyguard/AndroidManifest.xml	(revision 6856)
+++ frameworks/base/packages/Keyguard/AndroidManifest.xml	(revision 6857)
@@ -20,7 +20,7 @@
     package="com.android.keyguard"
     android:sharedUserId="android.uid.systemui"
     coreApp="true">
-    <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="23"/>
+    <uses-sdk android:minSdkVersion="15" android:targetSdkVersion="25"/>
     <uses-permission android:name="android.permission.VIBRATE" />
     <uses-permission android:name="android.permission.MODIFY_PHONE_STATE" />
     <uses-permission android:name="android.permission.GET_ACCOUNTS" />
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/LicenseHelper.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/LicenseHelper.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/LicenseHelper.java	(revision 6857)
@@ -1,13 +0,0 @@
-package com.sensetime.faceapi;
-
-public class LicenseHelper {
-
-	public static int initLicense(byte[] license){
-		return FaceLibrary.initLiscence(license);
-	}
-	
-	public static int initLicense(String license){
-		return FaceLibrary.initLiscenceStr(license);
-	}
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceLibrary.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceLibrary.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceLibrary.java	(revision 6857)
@@ -1,90 +0,0 @@
-package com.sensetime.faceapi;
-
-import android.graphics.Bitmap;
-
-import com.sensetime.faceapi.model.CvPixelFormat;
-import com.sensetime.faceapi.model.FaceInfo;
-
-public class FaceLibrary {
-
-    static {
-        System.loadLibrary("cvface_api");
-        System.loadLibrary("jni_cvface_api");
-    }
-
-    public static native void setDebug(boolean debug);
-
-    // license
-    public static native int initLiscence(byte[] license);
-
-    public static native int initLiscenceStr(String license);
-
-    // detector
-    public static native long cvFaceCreateDetector(String path, int config);
-
-    public static native void cvFaceDestroyDetector(long handle);
-
-    public static native float getDetectThreshold(long handle, int[] resultCode);
-
-    public static native void setDetectThreshold(long handle, float threshold, int[] resultCode);
-
-    public static native FaceInfo[] cvFaceDetectBytes(long handle, byte[] image, int pixelFormat, int width,
-                                                      int height, int stride, int orientation, int[] resultCode);
-
-    public static native FaceInfo[] cvFaceDetectInts(long handle, int[] image, int pixelFormat, int width, int height,
-                                                     int stride, int orientation, int[] resultCode);
-
-    // tracker
-    public static native void cvFaceShowInsideModel();
-
-    public static native long cvFaceCreateTracker(String detectModelPath, String alignModelPath, int config);
-
-    public static native void cvFaceDestroyTracker(long handle);
-
-    public static native FaceInfo[] cvFaceTrackBytes(long handle, byte[] image, int pixelFormat, int width, int height,
-                                                     int stride, int orientation, int[] resultCode);
-
-    public static native FaceInfo[] cvFaceTrackInts(long handle, int[] image, int pixelFormat, int width, int height,
-                                                    int stride, int orientation, int[] resultCode);
-
-    public static native void cvFaceResetTracker(long handle);
-
-    public static native int cvFaceTrackSetDetectFaceCntLimit(long handle, int count);
-
-    public static native int cvFaceTrackSetDetectInterval(long handle, int count);
-
-    // Verify
-    public static native long cvFaceCreateVerify(final String modelPath);
-
-    public static native int cvFaceGetVerifyVersion(long handle);
-
-    public static native int cvFaceGetVerifyLength(long handle);
-
-    public static native long cvFaceDeserialize(byte[] feature);
-
-    public static native float cvFaceCompareFeature(long handle, byte[] feature1, byte[] feature2, int[] resultCode);
-
-    public static native byte[] cvFaceGetFeatureInts(long handle, int[] image, int format, int width, int height,
-                                                     int stride, FaceInfo cvFace, int[] resultCode);
-
-    public static native byte[] cvFaceGetFeatureBytes(long handle, byte[] image, int format, int width, int height,
-                                                      int stride, FaceInfo cvFace, int[] resultCode);
-
-    public static native void cvFaceDestroyVerify(long handle);
-
-    // hackness
-    public static native long cvFaceCreateHackness(final String modelPath);
-
-    public static native float cvFaceHackness(long handle, byte[] image, int format, int width, int height, int stride,
-                                              int orientation, FaceInfo cvFace, int[] resultCode);
-
-    public static native void cvFaceDestroyHackness(long handle);
-
-    // other
-	public static native void getBGRFromBitmap(Bitmap bitmap, byte[] bgr);
-
-    public static native void cropNv21Data(byte[] in, int width, int height, int x, int y, int w, int h, byte[] out);
-
-    public static native float averageBrightness(byte[] imageData,CvPixelFormat format,int width,int height,int x,int y,int areaW,int areaH);
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceTrack.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceTrack.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceTrack.java	(revision 6857)
@@ -1,205 +0,0 @@
-package com.sensetime.faceapi;
-
-import com.sensetime.faceapi.model.FaceConfig;
-import com.sensetime.faceapi.model.FaceInfo;
-import com.sensetime.faceapi.model.FaceOrientation;
-import com.sensetime.faceapi.model.CvPixelFormat;
-import com.sensetime.faceapi.utils.ColorConvertUtil;
-
-import android.graphics.Bitmap;
-import android.graphics.Bitmap.Config;
-import android.util.Log;
-
-public class FaceTrack extends FaceHandleBase {
-
-    private static final boolean DEBUG = true;
-    private static final String TAG = "FaceTrack";
-
-    public FaceTrack() {
-        this(null, null, null, null, null);
-    }
-
-    public FaceTrack(FaceConfig.FaceImageResize resize, FaceConfig.FaceKeyPointCount pointCount,
-                     FaceConfig.TrackThreadCount threadCount) {
-        this(null, null, resize, pointCount, threadCount);
-    }
-
-    /**
-     * @param detectModelPath track模型文件的路径
-     * @param alignModelPath  关键点模型文件的路径
-     * @param resize          resize图片的大小 {@link FaceConfig.FaceImageResize}
-     * @param pointCount      关键点的数量 {@link FaceConfig.FaceKeyPointCount}
-     * @param threadCount     track开启的线程数 {@link FaceConfig.TrackThreadCount}
-     */
-    public FaceTrack(String detectModelPath, String alignModelPath, FaceConfig.FaceImageResize resize,
-                     FaceConfig.FaceKeyPointCount pointCount, FaceConfig.TrackThreadCount threadCount) {
-        if (resize == null) {
-            resize = FaceConfig.FaceImageResize.RESIZE_320W; // 默认使用了压缩为320
-        }
-        if (pointCount == null) {
-            pointCount = FaceConfig.FaceKeyPointCount.POINT_COUNT_21;
-        }
-        if (threadCount == null) {
-            threadCount = FaceConfig.TrackThreadCount.DEFAULT_CONFIG;
-        }
-        int config = resize.getValue() | pointCount.getValue() | threadCount.getValue();
-        init(detectModelPath, alignModelPath, config);
-    }
-
-    /**
-     * Initialize the Native Handler
-     */
-    private void init(String detectModelPath, String alignModelPath, int config) {
-        mCvFaceHandle = FaceLibrary.cvFaceCreateTracker(detectModelPath, alignModelPath, config);
-    }
-
-    /**
-     * Given the Image by Int Array to track face
-     *
-     * @param colorImage    Input image color int[] 输入的图片
-     * @param cvPixelFormat Input image cvImageFormat which you can select the value from CvImageFormat Class 图片格式
-     * @param imageWidth    Input image Width 图片宽度
-     * @param imageHeight   Input image Height 图片高度
-     * @param imageStride   Input bytes of rows 图片跨度，即每行有多少个字节数
-     * @param orientation   Input image orientation 图片方向
-     * @return FaceInfo array, each one in array is tracked by SDK native API
-     */
-    public FaceInfo[] track(int[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight,
-                            int imageStride, FaceOrientation orientation) {
-        FaceInfo[] faces = FaceLibrary.cvFaceTrackInts(mCvFaceHandle, colorImage, cvPixelFormat.getValue(), imageWidth,
-                imageHeight, imageStride, orientation.getValue(), mResultCode);
-        checkResultCode();
-        return faces;
-    }
-
-    /**
-     * Given the Image by Byte Array to track face
-     *
-     * @param colorImage    Input image color byte[] 输入的图片
-     * @param cvPixelFormat Input image cvImageFormat which you can select the value from CvImageFormat Class 图片格式
-     * @param imageWidth    Input image Width 图片宽度
-     * @param imageHeight   Input image Height 图片高度
-     * @param imageStride   Input bytes of rows 图片跨度，即每行有多少个字节数
-     * @param orientation   Input image orientation 图片方向
-     * @return FaceInfo array, each one in array is tracked by SDK native API
-     */
-    public FaceInfo[] track(byte[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight,
-                            int imageStride, FaceOrientation orientation) {
-        FaceInfo[] faces = FaceLibrary.cvFaceTrackBytes(mCvFaceHandle, colorImage, cvPixelFormat.getValue(), imageWidth,
-                imageHeight, imageStride, orientation.getValue(), mResultCode);
-        checkResultCode();
-        return faces;
-    }
-
-    /**
-     * @see #track(Bitmap, FaceOrientation)
-     */
-    public FaceInfo[] track(Bitmap bitmap) {
-        return track(bitmap, FaceOrientation.UP);
-    }
-
-    /**
-     * @see #track(Bitmap, FaceOrientation, byte[])
-     */
-    public FaceInfo[] track(Bitmap bitmap, FaceOrientation orientation) {
-        return track(bitmap, orientation, null);
-    }
-
-    /**
-     * @see #track(byte[], CvPixelFormat, int, int, int, FaceOrientation)
-     */
-    public FaceInfo[] track(Bitmap bitmap, FaceOrientation orientation, byte[] buffer) {
-        if (bitmap == null || bitmap.isRecycled()) {
-            if (DEBUG) {
-                Log.w(TAG, "track image is null or Recycled");
-            }
-            return null;
-        }
-        if (bitmap.getConfig() != Config.ARGB_8888) {
-        	bitmap = bitmap.copy(Config.ARGB_8888, false);
-        }
-        if (buffer == null) {
-            buffer = createBufferIfNeed(bitmap.getWidth(), bitmap.getHeight());
-        } else if (buffer.length != bitmap.getWidth() * bitmap.getHeight() * 3) {
-            throw new RuntimeException("detect buffer is illegal !");
-        }
-        ColorConvertUtil.getBGRFromBitmap(bitmap, buffer);
-        return track(buffer, CvPixelFormat.BGR888, bitmap.getWidth(), bitmap.getHeight(), bitmap.getWidth() * 3,
-                orientation);
-    }
-
-    /**
-     * @see #track(byte[], CvPixelFormat, int, int, FaceOrientation)
-     */
-    public FaceInfo[] track(byte[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight) {
-        return track(colorImage, cvPixelFormat, imageWidth, imageHeight, FaceOrientation.UP);
-    }
-
-    /**
-     * @see #track(byte[], CvPixelFormat, int, int, int, FaceOrientation)
-     */
-    public FaceInfo[] track(byte[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight,
-                            FaceOrientation orientation) {
-        return track(colorImage, cvPixelFormat, imageWidth, imageHeight, imageWidth, orientation);
-    }
-
-    /**
-     * @see #track(int[], CvPixelFormat, int, int, FaceOrientation)
-     */
-    public FaceInfo[] track(int[] colorImage, int imageWidth, int imageHeight, FaceOrientation orientation) {
-        return track(colorImage, CvPixelFormat.BGR888, imageWidth, imageHeight, orientation);
-    }
-
-    /**
-     * @see #track(int[], CvPixelFormat, int, int, int, FaceOrientation)
-     */
-    public FaceInfo[] track(int[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight,
-                            FaceOrientation orientation) {
-        return track(colorImage, cvPixelFormat, imageWidth, imageHeight, imageWidth * 4, orientation);
-    }
-
-    /**
-     * Reset track ,Sometimes,video frame is not discontinuous,when frame
-     * restart you can reset track to avoid tracking face discontinuity
-     */
-    public void reset() {
-        if (!isHandleInitialized()) {
-            if (DEBUG) {
-                Log.e(TAG, "reset Handle not Initialized");
-            }
-            return;
-        }
-        FaceLibrary.cvFaceResetTracker(mCvFaceHandle);
-    }
-
-    public void showInsideModelVersion() {
-        FaceLibrary.cvFaceShowInsideModel();
-    }
-
-    /**
-     * 设置全检测帧数，默认20帧，如果对人脸出框速度有特殊需求，建议：前置无人脸：3  有人脸8  后置无人脸：5 有人脸10
-     */
-    public void setFaceTrackInterval(int count){
-    	FaceLibrary.cvFaceTrackSetDetectInterval(mCvFaceHandle, count);
-    }
-    /**
-     * Set the current face count of track
-     *
-     * @param count of face limit,no limit if count = -1
-     */
-    public void setFaceLimit(int count) {
-        if (!isHandleInitialized()) {
-            if (DEBUG) {
-                Log.e(TAG, "setFaceLimit Handle not Initialized");
-            }
-            return;
-        }
-        int rst = FaceLibrary.cvFaceTrackSetDetectFaceCntLimit(mCvFaceHandle, count <= 0 ? -1 : count);
-        checkResultCode(rst);
-    }
-
-    @Override
-    protected void releaseHandle() {
-        FaceLibrary.cvFaceDestroyTracker(mCvFaceHandle);
-    }
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceVerify.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceVerify.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceVerify.java	(revision 6857)
@@ -1,116 +0,0 @@
-package com.sensetime.faceapi;
-
-import android.graphics.Bitmap;
-import android.graphics.Bitmap.Config;
-import android.text.TextUtils;
-import android.util.Log;
-
-import com.sensetime.faceapi.model.CvPixelFormat;
-import com.sensetime.faceapi.model.FaceInfo;
-import com.sensetime.faceapi.utils.ColorConvertUtil;
-
-/**
- * 人脸认证
- */
-public class FaceVerify extends FaceHandleBase {
-
-    private static final boolean DEBUG = true;
-    private static final String TAG = "FaceVerify";
-
-    /**
-     * @param modelPath The verify model file path 比对模型文件路径
-     */
-    public FaceVerify(String modelPath) {
-        init(modelPath);
-    }
-
-    private void init(String modelPath) {
-        if (TextUtils.isEmpty(modelPath)) {
-            throw new RuntimeException("verify model path is null!");
-        }
-        mCvFaceHandle = FaceLibrary.cvFaceCreateVerify(modelPath);
-    }
-
-    /**
-     * @see #getFeature(Bitmap, FaceInfo, byte[])
-     */
-    public byte[] getFeature(Bitmap image, FaceInfo faceInfo) {
-        return getFeature(image, faceInfo, null);
-    }
-
-    /**
-     * @see #getFeature(byte[], CvPixelFormat, int, int, int, FaceInfo)
-     */
-    public byte[] getFeature(Bitmap image, FaceInfo faceInfo, byte[] buffer) {
-        if (image == null || image.isRecycled()) {
-            if (DEBUG) {
-                Log.w(TAG, "image is null or Recycled");
-            }
-            return null;
-        }
-        if (image.getConfig() != Config.ARGB_8888) {
-            image = image.copy(Config.ARGB_8888, false);
-        }
-        if (buffer == null) {
-            buffer = createBufferIfNeed(image.getWidth(), image.getHeight());
-        } else if (buffer.length != image.getWidth() * image.getHeight() * 3) {
-            throw new RuntimeException("detect buffer is illegal !");
-        }
-        ColorConvertUtil.getBGRFromBitmap(image, buffer);
-        return getFeature(buffer, CvPixelFormat.BGR888, image.getWidth(), image.getHeight(), image.getWidth() * 3,
-                faceInfo);
-    }
-
-    /**
-     * @param colorImage    Input image color int[] 输入的图片
-     * @param cvPixelFormat Input image cvImageFormat which you can select the value from CvImageFormat Class 图片格式
-     * @param imageWidth    Input image Width 图片宽度
-     * @param imageHeight   Input image Height 图片高度
-     * @param imageStride   Input bytes of rows 图片跨度，即每行有多少个字节数
-     * @param faceInfo      人脸检测后得到的人脸信息 {@link FaceInfo}
-     * @return 人脸特征数组
-     */
-    public byte[] getFeature(int[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight, int
-            imageStride, FaceInfo faceInfo) {
-        byte[] feature = FaceLibrary.cvFaceGetFeatureInts(mCvFaceHandle, colorImage, cvPixelFormat.getValue(),
-                imageWidth, imageHeight, imageStride, faceInfo, mResultCode);
-        checkResultCode(mResultCode[0]);
-        return feature;
-    }
-
-    /**
-     * @param colorImage    Input image color byte[] 输入的图片
-     * @param cvPixelFormat Input image cvImageFormat which you can select the value from CvImageFormat Class 图片格式
-     * @param imageWidth    Input image Width 图片宽度
-     * @param imageHeight   Input image Height 图片高度
-     * @param imageStride   Input bytes of rows 图片跨度，即每行有多少个字节数
-     * @param faceInfo      人脸检测后得到的人脸信息 {@link FaceInfo}
-     * @return 人脸特征数组
-     */
-    public byte[] getFeature(byte[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight, int
-            imageStride, FaceInfo faceInfo) {
-        byte[] feature = FaceLibrary.cvFaceGetFeatureBytes(mCvFaceHandle, colorImage, cvPixelFormat.getValue(),
-                imageWidth, imageHeight, imageStride, faceInfo, mResultCode);
-        checkResultCode(mResultCode[0]);
-        return feature;
-    }
-
-    /**
-     * Given the two byte[] feature to get similar of two face,
-     *
-     * @param feature1 of first face
-     * @param feature2 of other face
-     * @return similar of two face (float[0-1])
-     */
-    public float compareFeature(byte[] feature1, byte[] feature2) {
-        float similar = FaceLibrary.cvFaceCompareFeature(mCvFaceHandle, feature1, feature2, mResultCode);
-        checkResultCode(mResultCode[0]);
-        return similar;
-    }
-
-    @Override
-    protected void releaseHandle() {
-        FaceLibrary.cvFaceDestroyVerify(mCvFaceHandle);
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceHandleBase.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceHandleBase.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceHandleBase.java	(revision 6857)
@@ -1,52 +0,0 @@
-package com.sensetime.faceapi;
-
-import com.sensetime.faceapi.model.ResultCode;
-
-public abstract class FaceHandleBase {
-
-	protected long mCvFaceHandle;
-	protected byte[] mBuffer;
-	protected int[] mResultCode = new int[1];
-	
-	protected boolean isHandleInitialized(){
-		return mCvFaceHandle != 0;
-	}
-
-	protected abstract void releaseHandle();
-	
-	protected void checkResultCode(int resultCode){
-		if (resultCode != ResultCode.OK.getValue()) {
-	        throw new RuntimeException("Calling native method failed! ResultCode : " + resultCode + " Reason : " + ResultCode.getDescription(resultCode));
-	    }
-	}
-	
-	protected void checkResultCode() {
-		checkResultCode(mResultCode[0]);
-	}
-	
-	protected byte[] createBufferIfNeed(int width, int height) {
-		int size = width * height*4;
-		if(mBuffer != null && mBuffer.length == size){
-			return mBuffer;
-		}
-		mBuffer = new byte[size];
-		return mBuffer;
-	}
-	
-	@Override
-	protected void finalize() throws Throwable {
-		release();
-	}
-	
-    /**
-     * release handle in native
-     */
-	public void release(){
-		if(mCvFaceHandle == 0){
-			return;
-		}
-		mBuffer = null;
-		releaseHandle();
-		mCvFaceHandle = 0;
-	}
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/filter/IFaceFilter.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/filter/IFaceFilter.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/filter/IFaceFilter.java	(revision 6857)
@@ -1,9 +0,0 @@
-package com.sensetime.faceapi.filter;
-
-import com.sensetime.faceapi.model.FaceInfo;
-
-public interface IFaceFilter {
-
-	boolean onFilter(FaceInfo faceInfo , int width, int height);
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/filter/FaceFilterGroup.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/filter/FaceFilterGroup.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/filter/FaceFilterGroup.java	(revision 6857)
@@ -1,47 +0,0 @@
-package com.sensetime.faceapi.filter;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import com.sensetime.faceapi.model.FaceInfo;
-
-import android.util.Log;
-
-public class FaceFilterGroup implements IFaceFilter{
-	private static final boolean DEBUG = true;
-	private static final String TAG = "FaceFilterGroup";
-	private List<IFaceFilter> mFaceFilters = new ArrayList<IFaceFilter>();
-	
-	public void addFilter(IFaceFilter filter){
-		if(filter == null){
-			Log.w(TAG, "addFilter filter is null !");
-			return;
-		}
-		mFaceFilters.add(filter);
-	}
-	
-	public void removeFilter(IFaceFilter filter){
-		if(filter == null){
-			Log.w(TAG, "removeFilter filter is null !");
-			return;
-		}
-		mFaceFilters.add(filter);
-	}
-
-	@Override
-	public boolean onFilter(FaceInfo faceInfo, int width, int height) {
-		if(mFaceFilters == null || mFaceFilters.size() == 0){
-			Log.w(TAG, "onFilter mFaceFilters is empty !");
-			return true;
-		}
-		for(IFaceFilter filter: mFaceFilters){
-			if(!filter.onFilter(faceInfo, width, height)){
-				return false;
-			}
-		}
-		return true;
-	}
-	
-	
-	
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceDetect.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceDetect.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceDetect.java	(revision 6857)
@@ -1,144 +0,0 @@
-package com.sensetime.faceapi;
-
-import android.graphics.Bitmap;
-import android.graphics.Bitmap.Config;
-import android.util.Log;
-
-import com.sensetime.faceapi.model.FaceConfig;
-import com.sensetime.faceapi.model.FaceInfo;
-import com.sensetime.faceapi.model.FaceOrientation;
-import com.sensetime.faceapi.model.CvPixelFormat;
-import com.sensetime.faceapi.utils.ColorConvertUtil;
-
-/**
- * 人脸检测
- */
-public class FaceDetect extends FaceHandleBase {
-
-    private static final boolean DEBUG = true;
-    private static final String TAG = "FaceDetect";
-
-    public FaceDetect() {
-        this(null, null, null);
-    }
-
-    public FaceDetect(FaceConfig.FaceImageResize resize, FaceConfig.FaceKeyPointCount pointCount) {
-        this(null, resize, pointCount);
-    }
-
-    /**
-     * @param modelPath  detect模型文件的路径
-     * @param resize     resize图片的大小 {@link FaceConfig.FaceImageResize}
-     * @param pointCount 关键点的数量 {@link FaceConfig.FaceKeyPointCount}
-     */
-    public FaceDetect(String modelPath, FaceConfig.FaceImageResize resize, FaceConfig.FaceKeyPointCount
-            pointCount) {
-        if (resize == null) {
-            resize = FaceConfig.FaceImageResize.DEFAULT_CONFIG;
-        }
-        if (pointCount == null) {
-            pointCount = FaceConfig.FaceKeyPointCount.POINT_COUNT_21;
-        }
-        int config = resize.getValue() | pointCount.getValue();
-        init(modelPath, config);
-    }
-
-    /**
-     * Initialize the Native Handler
-     */
-    private void init(String modelPath, int config) {
-        mCvFaceHandle = FaceLibrary.cvFaceCreateDetector(modelPath, config);
-    }
-
-    public float getFaceThreshold() {
-        return FaceLibrary.getDetectThreshold(mCvFaceHandle, mResultCode);
-    }
-
-    public void setFaceThreshold(float threshold) {
-        FaceLibrary.setDetectThreshold(mCvFaceHandle, threshold, mResultCode);
-        checkResultCode(mResultCode[0]);
-    }
-
-    /**
-     * @see #detect(Bitmap, FaceOrientation)
-     */
-    public FaceInfo[] detect(Bitmap image) {
-        return detect(image, FaceOrientation.UP);
-    }
-
-    /**
-     * @see #detect(Bitmap, FaceOrientation, byte[])
-     */
-    public FaceInfo[] detect(Bitmap image, FaceOrientation orientation) {
-        return detect(image, orientation, null);
-    }
-
-    /**
-     * @see #detect(byte[], CvPixelFormat, int, int, int, FaceOrientation)
-     */
-    public FaceInfo[] detect(Bitmap image, FaceOrientation orientation, byte[] buffer) {
-        if (image == null || image.isRecycled()) {
-            if (DEBUG) {
-                Log.w(TAG, "detect image is null or recycled");
-            }
-            return null;
-        }
-        if (image.getConfig() != Config.ARGB_8888) {
-            image = image.copy(Config.ARGB_8888, false);
-        }
-        if (buffer == null) {
-            buffer = createBufferIfNeed(image.getWidth(), image.getHeight());
-        }
-        ColorConvertUtil.getBGRFromBitmap(image, buffer);
-        return detect(buffer, CvPixelFormat.BGR888, image.getWidth(), image.getHeight(), image.getWidth() * 3,
-                orientation);
-    }
-
-    /**
-     * Given the Image by Int Array to detect face
-     *
-     * @param colorImage    Input image color int[] 输入的图片
-     * @param cvPixelFormat Input image cvImageFormat which you can select the value from CvImageFormat Class 图片格式
-     * @param imageWidth    Input image Width 图片宽度
-     * @param imageHeight   Input image Height 图片高度
-     * @param imageStride   Input bytes of rows 图片跨度，即每行有多少个字节数
-     * @param orientation   Input image orientation 图片方向
-     * @return FaceInfo array, each one in array is detected by SDK native API
-     */
-    public FaceInfo[] detect(int[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight,
-                             int imageStride, FaceOrientation orientation) {
-        FaceInfo[] faces = FaceLibrary.cvFaceDetectInts(mCvFaceHandle, colorImage, cvPixelFormat.getValue(),
-                imageWidth, imageHeight, imageStride, orientation.getValue(), mResultCode);
-        checkResultCode();
-        return faces;
-    }
-
-    /**
-     * Given the Image by Byte Array to detect face
-     *
-     * @param colorImage    Input image color byte[] 输入的图片
-     * @param cvPixelFormat Input image cvImageFormat which you can select the value from CvImageFormat Class 图片格式
-     * @param imageWidth    Input image Width 图片宽度
-     * @param imageHeight   Input image Height 图片高度
-     * @param imageStride   Input bytes of rows 图片跨度，即每行有多少个字节数
-     * @param orientation   Input image orientation 图片方向
-     * @return FaceInfo array, each one in array is detected by SDK native API
-     */
-    public FaceInfo[] detect(byte[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight,
-                             int imageStride, FaceOrientation orientation) {
-        FaceInfo[] faces = FaceLibrary.cvFaceDetectBytes(mCvFaceHandle, colorImage, cvPixelFormat.getValue(),
-                imageWidth, imageHeight, imageStride, orientation.getValue(), mResultCode);
-        checkResultCode();
-        return faces;
-    }
-
-    public static void showInsideModel() {
-        FaceLibrary.cvFaceShowInsideModel();
-    }
-
-    @Override
-    protected void releaseHandle() {
-        FaceLibrary.cvFaceDestroyDetector(mCvFaceHandle);
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceHacker.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceHacker.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/FaceHacker.java	(revision 6857)
@@ -1,42 +0,0 @@
-package com.sensetime.faceapi;
-
-import com.sensetime.faceapi.model.CvPixelFormat;
-import com.sensetime.faceapi.model.FaceInfo;
-import com.sensetime.faceapi.model.FaceOrientation;
-
-/**
- * 活体检测
- */
-public class FaceHacker extends FaceHandleBase {
-
-    /**
-     * @param modelPath The FaceHackness model file path 活体检测模型文件路径
-     */
-    public FaceHacker(final String modelPath) {
-        mCvFaceHandle = FaceLibrary.cvFaceCreateHackness(modelPath);
-    }
-
-    /**
-     * 活体检测的方法
-     *
-     * @param image       输入的图片
-     * @param format      图片格式 {@link CvPixelFormat}
-     * @param width       图片宽度
-     * @param height      图片高度
-     * @param stride      图片跨度，即每行有多少个字节数
-     * @param orientation 人脸方向 {@link FaceOrientation}
-     * @param info        人脸信息 {@link FaceInfo}
-     * @return
-     */
-    public float faceHackness(byte[] image, CvPixelFormat format, int width, int height, int stride, FaceOrientation
-            orientation, FaceInfo info) {
-        return FaceLibrary.cvFaceHackness(mCvFaceHandle, image, format.getValue(), width, height, stride, orientation
-                .getValue(), info, mResultCode);
-    }
-
-    @Override
-    protected void releaseHandle() {
-        FaceLibrary.cvFaceDestroyHackness(mCvFaceHandle);
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/IFaceFeatureInfo.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/IFaceFeatureInfo.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/IFaceFeatureInfo.java	(revision 6857)
@@ -1,9 +0,0 @@
-package com.sensetime.faceapi.model;
-
-public interface IFaceFeatureInfo{
-
-	byte[] getFeature();
-	void setGroupId(int groupId);
-	int getGroupId();
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/ColorConvertType.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/ColorConvertType.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/ColorConvertType.java	(revision 6857)
@@ -1,25 +0,0 @@
-package com.sensetime.faceapi.model;
-
-public enum ColorConvertType {
-
-    NV212BGRA(1),
-    NV212RGBA(2),
-    RGBA2NV21(3),
-    NV122BGRA(5),
-    BGRA2RGBA(14),
-    RGBA2NV12(20),
-    NV122RGBA(21),
-    RGBA2BGRA(101),
-    NV212BGR(1001);
-
-    final int nativeInt;
-
-    ColorConvertType(int i) {
-        this.nativeInt = i;
-    }
-
-    public int getValue() {
-        return nativeInt;
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/CvPixelFormat.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/CvPixelFormat.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/CvPixelFormat.java	(revision 6857)
@@ -1,31 +0,0 @@
-package com.sensetime.faceapi.model;
-
-public enum CvPixelFormat {
-
-    GRAY8(0),
-    YUV420P(1),
-    NV12(2),
-    NV21(3),
-    BGRA8888(4),
-    BGR888(5),
-    RGBA8888(6);
-
-    final int nativeInt;
-
-    private static CvPixelFormat sImageFormats[] = {
-            GRAY8, YUV420P, NV12, NV21, BGRA8888, BGR888, RGBA8888
-    };
-
-    CvPixelFormat(int ni) {
-        this.nativeInt = ni;
-    }
-
-    public int getValue() {
-        return nativeInt;
-    }
-
-    public static CvPixelFormat nativeToConfig(int ni) {
-        return sImageFormats[ni];
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/FaceConfig.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/FaceConfig.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/FaceConfig.java	(revision 6857)
@@ -1,71 +0,0 @@
-package com.sensetime.faceapi.model;
-
-/**
- * 创建 FaceTrack 和 FaceDetect 必要的一些配置
- */
-public class FaceConfig {
-
-    /**
-     * 将输入图片 resize 到某个大小
-     */
-    public enum FaceImageResize {
-
-        DEFAULT_CONFIG(0x00000000),
-        RESIZE_320W(0x00000002),
-        RESIZE_640W(0x00000004),
-        RESIZE_1280W(0x00000008);
-
-        final int value;
-
-        FaceImageResize(int value) {
-            this.value = value;
-        }
-
-        public int getValue() {
-            return value;
-        }
-
-    }
-
-    /**
-     * 返回的人脸关键点数量
-     */
-    public enum FaceKeyPointCount {
-
-        POINT_COUNT_21(0x00000100),
-        POINT_COUNT_106(0x00000200);
-
-        final int value;
-
-        FaceKeyPointCount(int value) {
-            this.value = value;
-        }
-
-        public int getValue() {
-            return value;
-        }
-
-    }
-
-    /**
-     * Track 操作开启的线程数
-     */
-    public enum TrackThreadCount {
-
-        DEFAULT_CONFIG(0x00000000),
-        TWO_THREAD(0x00110000); // 开启双线程人脸跟踪，建议低配置环境开启此选项
-
-        final int value;
-
-        TrackThreadCount(int value) {
-            this.value = value;
-        }
-
-        public int getValue() {
-            return value;
-        }
-
-    }
-
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/FaceAttrInfo.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/FaceAttrInfo.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/FaceAttrInfo.java	(revision 6857)
@@ -1,30 +0,0 @@
-package com.sensetime.faceapi.model;
-
-/**
- * 属性检测返回的结果体
- */
-public class FaceAttrInfo {
-
-	public int age;
-	public int sex; // 性别 Male 0, Female 1
-	public float sexScore;
-	public int attractive;
-	public boolean hasEyeGlass;
-	public float eyeGlassScore;
-	public boolean hasSunGlass;
-	public float sunGlassScore;
-	public boolean isSmile;
-	public float smileScore;
-	public boolean hasMask;
-	public float maskScore;
-	public int race;// 种族 Yellow 0, Black 1,White 2
-	public boolean isEyeOpen;
-	public float eyeOpenScore;
-	public boolean isMouthOpen;
-	public float mouthOpenScore;
-	public boolean hasBeard;
-	public float beardScore;
-	public int emotion;
-	public float emotionScore;
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/ResultCode.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/ResultCode.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/ResultCode.java	(revision 6857)
@@ -1,198 +0,0 @@
-package com.sensetime.faceapi.model;
-
-public enum ResultCode {
-	
-	/**
-     * ok
-     */
-    OK(0),
-    
-    /**
-     * cause by invalid argument
-     */
-    E_INVALIDARG(-1),
-    
-    /**
-     * handle Error,may be cause by sdk out of date or model file incorrect
-     */
-    E_HANDLE(-2),
-    
-    /**
-     * cause by out of memory
-     */
-    E_OUTOFMEMORY(-3),
-    
-    /**
-     * cause by run in fail inside
-     */
-    E_FAIL(-4),
-    
-    /**
-     * cause define not found
-     */
-    E_DELNOTFOUND(-5),
-    
-    /**
-     * cause by invalid pixel format
-     */
-    
-    E_INVALID_PIXEL_FORMAT(-6),
-    
-    /**
-     * cause by file no found
-     */
-    E_FILE_NOT_FOUND(-7),
-    
-    /**
-     * cause by model format error
-     */
-    E_INVALID_FILE_FORMAT(-8),
-    
-    /**
-     * cause by model out of date
-     */
-    E_FILE_EXPIRE (-9),
-    
-    /**
-     * cause by invalid license
-     */
-    E_INVALID_AUTH (-13),
-    
-    /**
-     * cause by invalid appID or package name
-     */
-    E_INVALID_APPID(-14),
-    
-    /**
-     * cause by SDK out of data
-     */
-    E_AUTH_EXPIRE(-15),
-    
-    /**
-     * cause by UUID mismatch
-     */
-    E_UUID_MISMATCH(-16),
-    
-    /**
-     * cause by online auth connect fail
-     */
-    E_ONLINE_AUTH_CONNECT_FAIL (-17),
-    
-    /**
-     * cause by check online timeout
-     */
-    E_ONLINE_AUTH_TIMEOUT (-18),
-    
-    /**
-     * cause by check online fail
-     */
-    E_ONLINE_AUTH_INVALID (-19),
-    
-    /**
-     * cause by license not activiable
-     */
-    E_LICENSE_IS_NOT_ACTIVABLE (-20),
-    
-    /**
-     * cause by license active failed
-     */
-    E_ACTIVE_FAIL (-21),
-    
-    /**
-     * cause by invalid active code
-     */
-    E_ACTIVE_CODE_INVALID (-22),
-    
-    /**
-     * cause by unsupport function called
-     */
-    E_UNSUPPORTED (-1000);
-    
-    
-    private final int resultCode;
-
-    ResultCode(int resultCode) {
-        this.resultCode = resultCode;
-    }
-
-	public int getValue() {
-        return resultCode;
-    }
-    
-    public static String getDescription(int code){
-    	switch (code) {
-		case 0:
-			return DESCRIPTION_OK;
-		case -1:
-			return DESCRIPTION_E_INVALIDARG;
-		case -2:
-			return DESCRIPTION_E_HANDLE;
-		case -3:
-			return DESCRIPTION_E_OUTOFMEMORY;
-		case -4:
-			return DESCRIPTION_E_FAIL;
-		case -5:
-			return DESCRIPTION_E_DELNOTFOUND;
-		case -6:
-			return DESCRIPTION_E_INVALID_PIXEL_FORMAT;
-		case -7:
-			return DESCRIPTION_E_FILE_NOT_FOUND;
-		case -8:
-			return DESCRIPTION_E_INVALID_FILE_FORMAT;
-		case -9:
-			return DESCRIPTION_E_FILE_EXPIRE;
-		case -13:
-			return DESCRIPTION_E_INVALID_AUTH;
-		case -14:
-			return DESCRIPTION_E_INVALID_APPID;
-		case -15:
-			return DESCRIPTION_E_AUTH_EXPIRE;
-		case -16:
-			return DESCRIPTION_E_UUID_MISMATCH;
-		case -17:
-			return DESCRIPTION_E_ONLINE_AUTH_CONNECT_FAIL;
-		case -18:
-			return DESCRIPTION_E_ONLINE_AUTH_TIMEOUT;
-		case -19:
-			return DESCRIPTION_E_ONLINE_AUTH_INVALID;
-		case -20:
-			return DESCRIPTION_E_LICENSE_IS_NOT_ACTIVABLE;
-		case -21:
-			return DESCRIPTION_E_ACTIVE_FAIL;
-		case -22:
-			return DESCRIPTION_E_ACTIVE_CODE_INVALID;
-		case -1000:
-			return DESCRIPTION_E_UNSUPPORTED;
-		default:
-			break;
-		}
-    	return null;
-    }
-    
-    private static final String DESCRIPTION_OK = "OK"; 
-    private static final String DESCRIPTION_E_INVALIDARG = "invalid argument"; 
-    private static final String DESCRIPTION_E_HANDLE = "handle Error,may be cause by sdk out of date or model file incorrect"; 
-    private static final String DESCRIPTION_E_OUTOFMEMORY = "out of memory"; 
-    private static final String DESCRIPTION_E_FAIL = "run in fail inside"; 
-    
-    private static final String DESCRIPTION_E_DELNOTFOUND = "define not found"; 
-    private static final String DESCRIPTION_E_INVALID_PIXEL_FORMAT = "invalid pixel format"; 
-    private static final String DESCRIPTION_E_FILE_NOT_FOUND = "file no found"; 
-    private static final String DESCRIPTION_E_INVALID_FILE_FORMAT = "model format error"; 
-    private static final String DESCRIPTION_E_FILE_EXPIRE = "model out of date"; 
-    
-    private static final String DESCRIPTION_E_INVALID_AUTH = "invalid license"; 
-    private static final String DESCRIPTION_E_INVALID_APPID = "E_INVALID_APPID"; 
-    private static final String DESCRIPTION_E_AUTH_EXPIRE = "E_AUTH_EXPIRE"; 
-    private static final String DESCRIPTION_E_UUID_MISMATCH = "E_UUID_MISMATCH"; 
-    private static final String DESCRIPTION_E_ONLINE_AUTH_CONNECT_FAIL = "online auth connect fail"; 
-    
-    private static final String DESCRIPTION_E_ONLINE_AUTH_TIMEOUT = "check online timeout";
-    private static final String DESCRIPTION_E_ONLINE_AUTH_INVALID = "check online fail"; 
-    
-    private static final String DESCRIPTION_E_LICENSE_IS_NOT_ACTIVABLE = "invalid active code"; 
-    private static final String DESCRIPTION_E_ACTIVE_FAIL = "license active failed"; 
-    private static final String DESCRIPTION_E_ACTIVE_CODE_INVALID = "invalid active code"; 
-    private static final String DESCRIPTION_E_UNSUPPORTED = "unsupport function called"; 
-    
-}
\ No newline at end of file
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/FaceInfo.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/FaceInfo.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/FaceInfo.java	(revision 6857)
@@ -1,43 +0,0 @@
-package com.sensetime.faceapi.model;
-
-import android.graphics.PointF;
-import android.graphics.Rect;
-
-/**
- * 人脸检测返回的结果体
- */
-public class FaceInfo {
-	
-	public Rect faceRect;
-	public PointF[] facePoints;
-	public int id;
-	public float score;
-	public float yaw;
-	public float pitch;
-	public float roll;
-	public float eyeDist;
-
-	public FaceInfo clone() {
-		FaceInfo faceInfo = new FaceInfo();
-		faceInfo.faceRect = new Rect();
-		faceInfo.facePoints = new PointF[facePoints.length];
-		faceInfo.faceRect.set(faceRect);
-		for (int i = 0; i < faceInfo.facePoints.length; i++) {
-			faceInfo.facePoints[i] = new PointF();
-			faceInfo.facePoints[i].set(facePoints[i]);
-		}
-		faceInfo.id = id;
-		faceInfo.score = score;
-		faceInfo.yaw = yaw;
-		faceInfo.pitch = pitch;
-		faceInfo.roll = roll;
-		faceInfo.eyeDist = eyeDist;
-		return faceInfo;
-	}
-	
-	@Override
-	public String toString() {
-		return "FaceInfo(" + faceRect + ", " + score + ")";
-	}
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/FaceOrientation.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/FaceOrientation.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/model/FaceOrientation.java	(revision 6857)
@@ -1,30 +0,0 @@
-package com.sensetime.faceapi.model;
-
-public enum FaceOrientation {
-
-    UP(1), // 人脸方向朝上，箭头表示人头位置，直线表示身体，即  ↑
-    LEFT(2), // 人脸方向朝左，箭头表示人头位置，直线表示身体，即  ←
-    DOWN(4), // 人脸方向朝下，箭头表示人头位置，直线表示身体，即  ↓
-    RIGHT(8), // 人脸方向朝右，箭头表示人头位置，直线表示身体，即  →
-    UNKNOWN(15); // 未知
-
-    final int nativeInt;
-
-    FaceOrientation(int ni) {
-        this.nativeInt = ni;
-    }
-
-    private static FaceOrientation sFaceOrientations[] = {
-            null, UP, LEFT, null, DOWN, null, null, null, RIGHT,
-            null, null, null, null, null, null, UNKNOWN
-    };
-
-    public int getValue() {
-        return nativeInt;
-    }
-
-    public static FaceOrientation nativeToOrientation(int ni) {
-        return sFaceOrientations[ni];
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/BrightnessUtil.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/BrightnessUtil.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/BrightnessUtil.java	(revision 6857)
@@ -1,36 +0,0 @@
-package com.sensetime.faceapi.utils;
-
-import android.graphics.Rect;
-import android.util.Log;
-
-import com.sensetime.faceapi.FaceLibrary;
-import com.sensetime.faceapi.model.CvPixelFormat;
-import com.sensetime.faceapi.model.FaceInfo;
-
-public class BrightnessUtil {
-	private static final String TAG = "AverageBrightnessUtil";
-	public static float averageBrightness(byte[] imageData,CvPixelFormat format,int width,int height,FaceInfo faceInfo){
-		if(faceInfo == null){
-			Log.w(TAG, "averageBrightness faceInfo is NULL !!!");
-			return 0;
-		}
-		return averageBrightness(imageData,format,width, height, faceInfo.faceRect);
-	}
-
-	public static float averageBrightness(byte[] imageData,CvPixelFormat format,int width,int height,Rect rect){
-		if(rect == null){
-			Log.w(TAG, "averageBrightness rect is NULL !!!");
-			return 0;
-		}
-		return averageBrightness(imageData,format, width, height,rect.left,rect.top,rect.width(),rect.height());
-	}
-
-	public static float averageBrightness(byte[] imageData,CvPixelFormat format,int width,int height,int x,int y,int areaW,int areaH){
-		if(x > width  || y > height || areaW <= 0 || areaH <= 0){
-			Log.w(TAG, "averageBrightness area is not in image frame imageFrame : " + width + "x" + height + " area[x,y,w,h] : "+ x + ","+ y+","+areaW+","+areaH );
-			return 0;
-		}
-		return FaceLibrary.averageBrightness(imageData, format, width, height, x, y, areaW, areaH);
-	}
-	
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/FaceDrawUtil.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/FaceDrawUtil.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/FaceDrawUtil.java	(revision 6857)
@@ -1,79 +0,0 @@
-package com.sensetime.faceapi.utils;
-
-import com.sensetime.faceapi.model.FaceInfo;
-
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.graphics.PointF;
-import android.graphics.Rect;
-import android.util.Log;
-
-/**
- * 绘制人脸时常用的一些方法
- */
-public class FaceDrawUtil {
-
-    public static final boolean DEBUG = true;
-    public static final String TAG = "FaceDrawUtil";
-
-    /**
-     * Use this method to draw faces rect and points
-     *
-     * @param canvas    The canvas where draw
-     * @param faceInfos The face info array contain rect and points
-     * @param paint     The paint used to draw
-     */
-    public static void drawFaces(Canvas canvas, FaceInfo[] faceInfos, Paint paint) {
-        if (canvas == null || faceInfos == null) {
-            Log.w(TAG, "drawFaces canvas or faces is null !");
-            return;
-        }
-        for (FaceInfo faceInfo : faceInfos) {
-            drawFace(canvas, faceInfo, paint);
-        }
-    }
-
-    /**
-     * Use this method to draw one face rect and points
-     *
-     * @param canvas   The canvas where draw
-     * @param faceInfo The one face info contain rect and points
-     * @param paint    The paint used to draw
-     */
-    public static void drawFace(Canvas canvas, FaceInfo faceInfo, Paint paint) {
-        if (canvas == null || faceInfo == null) {
-            Log.w(TAG, "drawFace canvas or faces is null !");
-            return;
-        }
-        drawFaceRect(canvas, faceInfo.faceRect, paint);
-        drawPoints(canvas, faceInfo.facePoints, paint);
-    }
-
-    /**
-     * Use this method to draw face rect
-     *
-     * @param canvas The canvas where draw
-     * @param rect   The face rect
-     * @param paint  The paint used to draw
-     */
-    public static void drawFaceRect(Canvas canvas, Rect rect, Paint paint) {
-        if (canvas == null) return;
-        canvas.drawRect(rect, paint);
-    }
-
-    /**
-     * Use this method to draw face key points
-     *
-     * @param canvas The canvas where draw
-     * @param points The face points
-     * @param paint  The paint used to draw
-     */
-    public static void drawPoints(Canvas canvas, PointF[] points, Paint paint) {
-        if (canvas == null) return;
-        for (PointF point : points) {
-            PointF p = point;
-            canvas.drawPoint(p.x, p.y, paint);
-        }
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/FaceRotationUtil.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/FaceRotationUtil.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/FaceRotationUtil.java	(revision 6857)
@@ -1,165 +0,0 @@
-package com.sensetime.faceapi.utils;
-
-import com.sensetime.faceapi.model.FaceInfo;
-
-import android.graphics.PointF;
-import android.graphics.Rect;
-
-/**
- * 旋转FaceInfo的工具类, 包括旋转Face本身以及Face矩形框等
- **/
-public class FaceRotationUtil {
-
-    /**
-     * rotate faces
-     *
-     * @param faceInfos     used to rotate
-     * @param width         The width of image
-     * @param height        The height of image
-     * @param isFrontCamera The isFrontCamera whether the image come from front camera
-     * @param degrees       The degrees of camera display
-     * @see #rotateFaceInfo(FaceInfo, int, int, boolean, int)
-     */
-    public static void rotateFaceInfos(FaceInfo[] faceInfos, int width, int height, boolean isFrontCamera, int
-            degrees) {
-        if (faceInfos == null || faceInfos.length == 0) {
-            return;
-        }
-        for (FaceInfo face : faceInfos) {
-            rotateFaceInfo(face, width, height, isFrontCamera, degrees);
-        }
-    }
-
-    /**
-     * rotate one face
-     *
-     * @param faceInfo      used to rotate
-     * @param width         The width of image
-     * @param height        The height of image
-     * @param isFrontCamera The isFrontCamera whether the image come from front camera
-     * @param degrees       The degrees of camera display
-     */
-    public static void rotateFaceInfo(FaceInfo faceInfo, int width, int height, boolean isFrontCamera, int degrees) {
-        if (faceInfo == null) {
-            return;
-        }
-        rotateFaceRect(faceInfo.faceRect, width, height, isFrontCamera, degrees);
-        PointF[] points = faceInfo.facePoints;
-        for (int i = 0; i < points.length; i++) {
-            rotatePoints(points[i], width, height, isFrontCamera, degrees);
-        }
-    }
-
-    /**
-     * rotate face rect
-     *
-     * @param rect          used to rotate
-     * @param width         The width of image
-     * @param height        The height of image
-     * @param isFrontCamera The isFrontCamera whether the image come from front camera
-     * @param degrees       The degrees of camera display
-     */
-    public static Rect rotateFaceRect(Rect rect, int width, int height, boolean isFrontCamera, int degrees) {
-        int tmp;
-        switch (degrees) {
-            case 0: // landscape
-                // 前置摄像头时左右翻转
-                if (isFrontCamera) {
-                    rect.left = width - rect.left;
-                    rect.right = width - rect.right;
-                }
-                break;
-            case 90: // portrait
-                // 顺时针旋转90°
-                tmp = rect.left;
-                rect.left = height - rect.bottom;
-                rect.bottom = rect.right;
-                rect.right = height - rect.top;
-                rect.top = tmp;
-                // 前置摄像头时上下翻转
-                if (isFrontCamera) {
-                    tmp = rect.top;
-                    rect.top = width - rect.bottom;
-                    rect.bottom = width - tmp;
-                }
-                break;
-            case 180:
-                // 上下翻转
-                rect.top = height - rect.top;
-                rect.bottom = height - rect.bottom;
-                // 后置摄像头时再左右翻转
-                if (!isFrontCamera) {
-                    rect.left = width - rect.left;
-                    rect.right = width - rect.right;
-                }
-                break;
-            case 270:
-                // 顺时针旋转90°
-                tmp = rect.left;
-                rect.left = height - rect.bottom;
-                rect.bottom = rect.right;
-                rect.right = height - rect.top;
-                rect.top = tmp;
-                // 左右翻转
-                tmp = rect.left;
-                rect.left = height - rect.right;
-                rect.right = height - tmp;
-                // 后置摄像头时再上下翻转
-                if (!isFrontCamera) {
-                    tmp = rect.top;
-                    rect.top = width - rect.bottom;
-                    rect.bottom = width - tmp;
-                }
-                break;
-            default:
-                break;
-        }
-        return rect;
-    }
-
-    /**
-     * rotate face key points
-     *
-     * @param point         used to rotate
-     * @param width         The width of image
-     * @param height        The height of image
-     * @param isFrontCamera The isFrontCamera whether the image come from front camera
-     * @param degrees       The degrees of camera display
-     */
-    public static PointF rotatePoints(PointF point, int width, int height, boolean isFrontCamera, int degrees) {
-        float tmp;
-        switch (degrees) {
-            case 0: // landscape
-                if (isFrontCamera) {
-                    point.x = width - point.x;
-                }
-                break;
-            case 90: // portrait
-                tmp = point.x;
-                point.x = height - point.y;
-                point.y = tmp;
-                if (isFrontCamera) {
-                    point.y = width - point.y;
-                }
-                break;
-            case 180:
-                point.y = height - point.y;
-                if (!isFrontCamera) {
-                    point.x = width - point.x;
-                }
-                break;
-            case 270:
-                tmp = point.y;
-                point.y = point.x;
-                point.x = tmp;
-                if (!isFrontCamera) {
-                    point.y = width - point.y;
-                }
-                break;
-            default:
-                break;
-        }
-        return point;
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/ColorConvertUtil.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/ColorConvertUtil.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/ColorConvertUtil.java	(revision 6857)
@@ -1,90 +0,0 @@
-package com.sensetime.faceapi.utils;
-
-import java.nio.ByteBuffer;
-
-import android.graphics.Bitmap;
-import android.graphics.Bitmap.Config;
-import android.util.Log;
-
-import com.sensetime.faceapi.FaceLibrary;
-
-public class ColorConvertUtil {
-
-    public static final String TAG = "ColorConvertUtil";
-
-    /**
-     * 根据 bitmap 获取 bgr 格式的数据
-     */
-    public static void getBGRFromBitmap(Bitmap bitmap, byte[] bgr) {
-        if (bitmap == null || bitmap.isRecycled() || bgr == null) {
-            Log.e(TAG, "bitmap or bgr is null !!!");
-            return;
-        }
-        if (bitmap.getConfig() != Config.ARGB_8888) {
-            bitmap = bitmap.copy(Config.ARGB_8888, false);
-        }
-        FaceLibrary.getBGRFromBitmap(bitmap, bgr);
-    }
-
-    /**
-     * 从nv21的数据中裁剪出一块指定区域大小的Bitmap图片出来
-     *
-     * @param nv21        数据源
-     * @param imageWidth  原始图片宽度
-     * @param imageHeight 原始图片高度
-     * @param startX      裁剪区域 x 轴的起始位置
-     * @param startY      裁剪区域 y 轴的起始位置
-     * @param cropWidth   裁剪宽度
-     * @param cropHeight  裁剪高度
-     * @return 裁剪后的 bitmap 图片
-     */
-    public static Bitmap cropNv21ToBitmap(byte[] nv21, int imageWidth, int imageHeight, int startX, int startY, int
-            cropWidth, int cropHeight) {
-        if (nv21 == null || startX < 0 || startY < 0 || cropWidth < 0 || cropHeight < 0 || imageWidth < (startX +
-                cropWidth) || imageHeight < (startY + cropHeight)) {
-            Log.e(TAG, "cropNv21ToBitmap failed: illegal para !");
-            return null;
-        }
-        byte[] argb = new byte[cropWidth * cropHeight * 4];
-        ColorConvertUtil.cropNv21DataToARGB(nv21, imageWidth, imageHeight, startX, startY, cropWidth,
-                cropHeight, argb);
-        Bitmap bitmap = byteArrayToBitmap(argb, cropWidth, cropHeight);
-        return bitmap;
-    }
-
-    /**
-     * 从nv21的数据中裁剪出一块指定区域大小的 argb 数据
-     *
-     * @param nv21   数据源
-     * @param width  原始图片宽度
-     * @param height 原始图片高度
-     * @param x      裁剪区域 x 轴的起始位置
-     * @param y      裁剪区域 y 轴的起始位置
-     * @param w      裁剪宽度
-     * @param h      裁剪高度
-     * @param argb   输出的 argb 数据
-     */
-    public static void cropNv21DataToARGB(byte[] nv21, int width, int height, int x, int y, int w, int h, byte[] argb) {
-        if (nv21 == null || argb == null) {
-            Log.e(TAG, "cropNv21DataToARGB failed: nv21 or argb is null ");
-            return;
-        }
-        FaceLibrary.cropNv21Data(nv21, width, height, x, y, w, h, argb);
-    }
-
-    /**
-     * 将 argb 的 byte[] 数据转换成 bitmap
-     *
-     * @param argb   输入的 argb 数据
-     * @param width  图片宽度
-     * @param height 图片高度
-     * @return 得到的 bitmap
-     */
-    public static Bitmap byteArrayToBitmap(byte[] argb, int width, int height) {
-        ByteBuffer buffer = ByteBuffer.wrap(argb);
-        Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
-        bitmap.copyPixelsFromBuffer(buffer);
-        return bitmap;
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/AccelerometerManager.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/AccelerometerManager.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceapi/utils/AccelerometerManager.java	(revision 6857)
@@ -1,200 +0,0 @@
-package com.sensetime.faceapi.utils;
-
-import android.content.Context;
-import android.hardware.Sensor;
-import android.hardware.SensorEvent;
-import android.hardware.SensorEventListener;
-import android.hardware.SensorManager;
-import android.util.Log;
-
-import com.sensetime.faceapi.model.FaceOrientation;
-
-public class AccelerometerManager {
-
-	public static final String TAG = "AccelerometerManager";
-	private static AccelerometerManager instance;
-	private SensorManager mSensorManager;
-	private AccelerometerSensorListener mAccListener;
-	private boolean mHasStarted = false;
-
-	private AccelerometerManager() {
-	}
-
-	public static AccelerometerManager getInstance() {
-		if (instance == null) {
-			instance = new AccelerometerManager();
-		}
-		return instance;
-	}
-
-	/**
-	 * 启动加速度传感器
-	 */
-	public static void start(Context context) {
-		AccelerometerManager.getInstance().registerListener(context);
-	}
-
-	/**
-	 * 停止加速度传感器
-	 */
-	public static void stop() {
-		AccelerometerManager.getInstance().unregisterListener();
-	}
-
-	/**
-	 * 根据前后摄像头，依靠重力感应器获取方向后得到 FaceOrientation {@link FaceOrientation}
-     */
-	public static FaceOrientation getFaceOrientation(boolean isFrontCamera) {
-		int dir = getDir(isFrontCamera);
-		return getFaceOrientation(dir);
-	}
-
-	/**
-	 * 根据重力感应器得到的方向映射得到相应的 FaceOrientation {@link FaceOrientation}
-     */
-	public static FaceOrientation getFaceOrientation(int dir) {
-		switch (dir) {
-			case 0:
-				return FaceOrientation.UP;
-			case 1:
-				return FaceOrientation.LEFT;
-			case 2:
-				return FaceOrientation.DOWN;
-			case 3:
-				return FaceOrientation.RIGHT;
-			default:
-				return FaceOrientation.UNKNOWN;
-		}
-	}
-
-	/**
-	 * 根据重力感应器方向获取到对应的角度(0,90,180,270)
-	 */
-	public static int getDegree(boolean isFrontCamera){
-		return getDir(isFrontCamera) * 90;
-	}
-
-	/**
-	 * 根据重力感应器方向获取到对应的角度(0,90,180,270)
-	 */
-	public static int getDegree() {
-		return getDir() * 90;
-	}
-
-	/**
-	 * 根据重力感应器方向获取到对应的方向(0,1,2,3)
-	 * @param isFrontCamera 是否为前置摄像头，由于前置摄像头画面是镜像的，所以得到的方向也要做相应的翻转
-	 */
-	public static int getDir(boolean isFrontCamera) {
-		int dir = AccelerometerManager.getInstance().getDirection(isFrontCamera);
-		return dir;
-	}
-
-	/**
-	 * 根据重力感应器方向获取到对应的方向(0,1,2,3)
-	 */
-	public static int getDir() {
-		return getDir(false);
-	}
-
-	// ------------------------------------------------------------------------------
-
-	/**
-	 * Use this method to get the direction of mobile phone
-	 * @param isFrontCamera : Input the current camera which is using is front or not
-	 * @return the mobile phone direction value
-	 */
-	private int getDirection(boolean isFrontCamera) {
-		if (mAccListener != null) {
-			int dir = mAccListener.dir;
-			// 当且仅当为前置摄像头且画面是上下方向(portrait、portrait-inverse)的颠倒
-			if (isFrontCamera && ((dir & 1) == 1)) {
-				dir = (dir ^ 2);
-			}
-			return dir;
-		}
-		return -1; // default value is -1
-	}
-	
-	/**
-	 * Use this method to start listening of the sensor
-	 */
-	private void registerListener(Context context) {
-		if (mHasStarted) {
-			return;
-		}
-		mHasStarted = true;
-		mSensorManager = (SensorManager) context.getApplicationContext().getSystemService(Context.SENSOR_SERVICE);
-		Sensor accelerometerSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); // 获取加速度传感器
-		if (accelerometerSensor != null) { // 加速度传感器存在时才执行
-			mAccListener = new AccelerometerSensorListener();
-			mSensorManager.registerListener(mAccListener, accelerometerSensor, SensorManager.SENSOR_DELAY_NORMAL); // 注册事件监听
-		}
-	}
-
-	/**
-	 * Use this method to stop listening of the sensor
-	 */
-	private void unregisterListener() {
-		if (!mHasStarted || mSensorManager == null) {
-			return;
-		}
-		mHasStarted = false;
-		mSensorManager.unregisterListener(mAccListener);
-	}
-
-	private class AccelerometerSensorListener implements SensorEventListener {
-		
-		/**
-		 * landscape：
-		 *  ___________________
-		 * | +--------------+  |
-		 * | |              |  |
-		 * | |              |  |
-		 * | |              | O|
-		 * | |              |  |
-		 * | |______________|  |
-		 * ---------------------
-		 * portrait：
-		 *  ___________
-		 * |           |
-		 * |+---------+|
-		 * ||         ||
-		 * ||         ||
-		 * ||         ||
-		 * ||         ||
-		 * ||         ||
-		 * |+---------+|
-		 * |_____O_____|
-		 */
-		private int dir = -1;
-
-		public void onAccuracyChanged(Sensor sensor, int accuracy) {
-		}
-
-		public void onSensorChanged(SensorEvent event) {
-			if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
-				// All values are in SI units (m/s^2)
-				float x = event.values[0]; // Acceleration minus Gx on the x-axis
-				float y = event.values[1]; // Acceleration minus Gy on the y-axis
-				Log.d(TAG, "x: " + x + ", y: " + y);
-				if (Math.abs(x) > 0.5f || Math.abs(y) > 0.5f) {
-					if (Math.abs(x) > Math.abs(y)) {
-						if (x > 0) {
-							dir = 0; // landscape
-						} else {
-							dir = 2; // landscape-inverse
-						}
-					} else {
-						if (y > 0) {
-							dir = 1; // portrait
-						} else {
-							dir = 3; // portrait-inverse
-						}
-					}
-				}
-			}
-		}
-	}
-	
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/HackerProxy.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/HackerProxy.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/HackerProxy.java	(revision 6857)
@@ -1,54 +0,0 @@
-package com.sensetime.faceunlock.manager;
-
-import com.sensetime.faceapi.FaceHacker;
-import com.sensetime.faceapi.model.CvPixelFormat;
-import com.sensetime.faceapi.model.FaceInfo;
-import com.sensetime.faceapi.model.FaceOrientation;
-import com.sensetime.faceapi.utils.AccelerometerManager;
-import com.sensetime.faceunlock.bean.FaceFeature;
-import com.sensetime.faceunlock.config.AppConfig;
-import com.sensetime.faceunlock.util.FileUtil;
-import com.sensetime.faceunlock.util.LogUtil;
-
-public class HackerProxy {
-
-    private static final String TAG = "HackerProxy";
-
-    public static void init() {
-        FaceSDKManager.getInstance().initHacker();
-    }
-
-    public static boolean isPass(FaceFeature faceFeature, boolean isFrontCamera) {
-        if (!AppConfig.isOpenHacker) {
-            return true; // 如果没有打开活体开关，默认都是活体
-        }
-        float score = HackerProxy.hacker(faceFeature.nv21, faceFeature.width, faceFeature.height, faceFeature
-                .faceInfo, isFrontCamera);
-        boolean isPass = score < 0.98f;
-        LogUtil.d(TAG, "isPass: " + isPass);
-        long time = System.currentTimeMillis();
-        FileUtil.saveHackerData(faceFeature.nv21, faceFeature.width, faceFeature.height, score);
-        LogUtil.d(TAG, "saveHackerData time: " + (System.currentTimeMillis() - time) + "ms");
-        return isPass;
-    }
-
-    public static float hacker(byte[] nv21, int width, int height, FaceInfo faceInfo, boolean isFrontCamera) {
-        FaceHacker faceHacker = FaceSDKManager.getInstance().getFaceHacker();
-        if (faceHacker == null) {
-            LogUtil.w(TAG, "FaceHacker is null !");
-            return 0f;
-        }
-        FaceOrientation faceOrientation = AccelerometerManager.getFaceOrientation(isFrontCamera);
-        long time = System.currentTimeMillis();
-        float score = faceHacker.faceHackness(nv21, CvPixelFormat.NV21, width, height, width,
-                faceOrientation, faceInfo);
-        LogUtil.d(TAG, "hacker time: " + (System.currentTimeMillis() - time));
-        LogUtil.d(TAG, "score: " + score);
-        return score;
-    }
-
-    public static void release() {
-        FaceSDKManager.getInstance().releaseHacker();
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/TrackProxy.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/TrackProxy.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/TrackProxy.java	(revision 6857)
@@ -1,37 +0,0 @@
-package com.sensetime.faceunlock.manager;
-
-import com.sensetime.faceapi.FaceTrack;
-import com.sensetime.faceapi.model.CvPixelFormat;
-import com.sensetime.faceapi.model.FaceInfo;
-import com.sensetime.faceapi.model.FaceOrientation;
-import com.sensetime.faceapi.utils.AccelerometerManager;
-import com.sensetime.faceunlock.util.LogUtil;
-
-public class TrackProxy {
-
-    private static final String TAG = "TrackProxy";
-
-    public static void init() {
-        FaceSDKManager.getInstance().initTrack();
-    }
-
-    public static FaceInfo[] track(byte[] nv21, int width, int height, boolean isFrontCamera) {
-        FaceOrientation faceOrientation = AccelerometerManager.getFaceOrientation(isFrontCamera);
-        LogUtil.v(TAG, "track dir: " + faceOrientation.getValue());
-        FaceTrack tracker = FaceSDKManager.getInstance().getTrack();
-        if (tracker == null) {
-            LogUtil.w(TAG, "FaceTrack is null !");
-            return null;
-        }
-        long time = System.currentTimeMillis();
-        FaceInfo[] faces = tracker.track(nv21, CvPixelFormat.NV21, width, height, faceOrientation);
-        LogUtil.v(TAG, "track time: " + (System.currentTimeMillis() - time) + ", face count: " + ((faces == null) ? 0
-                : faces.length));
-        return faces;
-    }
-
-    public static void release() {
-        FaceSDKManager.getInstance().releaseTrack();
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/VerifyProxy.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/VerifyProxy.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/VerifyProxy.java	(revision 6857)
@@ -1,81 +0,0 @@
-package com.sensetime.faceunlock.manager;
-
-import android.content.Context;
-
-import com.sensetime.faceapi.FaceVerify;
-import com.sensetime.faceapi.model.CvPixelFormat;
-import com.sensetime.faceapi.model.FaceInfo;
-import com.sensetime.faceunlock.bean.FaceFeature;
-import com.sensetime.faceunlock.bean.User;
-import com.sensetime.faceunlock.config.AppConfig;
-import com.sensetime.faceunlock.util.LogUtil;
-
-import java.util.List;
-
-public class VerifyProxy {
-
-    private static final String TAG = "VerifyProxy";
-
-    public static void init(Context context) {
-        FaceSDKManager.getInstance().initVerify(context);
-    }
-
-    public static User isPass(FaceFeature faceFeature, Context context) {
-        if (faceFeature == null) {
-            return null;
-        }
-        List<User> users = UserManager.getAllUser(context);
-        if (users == null || users.size() <= 0) {
-            return null;
-        }
-        byte[] feature = VerifyProxy.getFeature(faceFeature.nv21, faceFeature.width, faceFeature.height, faceFeature
-                .faceInfo);
-        float maxSimilarValue = 0.0f;
-        int maxSimilarIndex = 0;
-        for (int i = 0; i < users.size(); i++) {
-            float similar = VerifyProxy.compare(feature, users.get(i).getFeature().getBytes());
-            if (similar > maxSimilarValue) {
-                maxSimilarValue = similar;
-                maxSimilarIndex = i;
-            }
-        }
-        LogUtil.d(TAG, "maxSimilarValue : " + maxSimilarValue);
-        boolean isPass = maxSimilarValue > AppConfig.threshold;
-        if (isPass) {
-            return users.get(maxSimilarIndex);
-        }
-        return null;
-    }
-
-    public static byte[] getFeature(byte[] nv21, int width, int height, FaceInfo faceInfo) {
-        FaceVerify verifier = FaceSDKManager.getInstance().getVerify();
-        if (verifier == null) {
-            LogUtil.w(TAG, "FaceVerify is null !");
-            return null;
-        }
-        long time = System.currentTimeMillis();
-        byte[] feature = verifier.getFeature(nv21, CvPixelFormat.NV21, width, height, width, faceInfo); // 获取特征值
-        LogUtil.d(TAG, "getFeature time : " + (System.currentTimeMillis() - time));
-        return feature;
-    }
-
-    public static float compare(byte[] feature1, byte[] feature2) {
-        FaceVerify verifier = FaceSDKManager.getInstance().getVerify();
-        if (verifier == null) {
-            LogUtil.w(TAG, "FaceVerify is null !");
-            return 0f;
-        }
-        if (feature1 == null || feature2 == null) {
-            LogUtil.w(TAG, "feature1 or feature2 is null !");
-            return 0f;
-        }
-        float score = verifier.compareFeature(feature1, feature2);
-        return score;
-    }
-
-    public static void release() {
-        FaceSDKManager.getInstance().releaseVerify();
-    }
-
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/UserManager.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/UserManager.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/UserManager.java	(revision 6857)
@@ -1,54 +0,0 @@
-package com.sensetime.faceunlock.manager;
-
-import android.content.Context;
-
-import com.sensetime.faceunlock.bean.User;
-import com.sensetime.faceunlock.db.SQLHelper;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class UserManager {
-
-    private static final List<User> users = new ArrayList<>(); // 数据库中所有的人员信息
-    private static final List<User> displayUsers = new ArrayList<>(); // 人员管理时仅需要显示的人员信息
-
-    public static List<User> getAllUser(Context context) {
-        if (users.size() <= 0) {
-            users.addAll(SQLHelper.getInstance(context).queryAll());
-        }
-        return users;
-    }
-
-    public static List<User> getDisplayUsers(Context context) {
-        if (displayUsers.size() <= 0) {
-            displayUsers.addAll(SQLHelper.getInstance(context).queryDisplay());
-        }
-        return displayUsers;
-    }
-
-    public static void refresh(Context context) {
-        users.clear();
-        displayUsers.clear();
-        users.addAll(SQLHelper.getInstance(context).queryAll());
-        displayUsers.addAll(SQLHelper.getInstance(context).queryDisplay());
-    }
-
-    public static void addUsers(List<User> users, Context context) {
-        deleteAllUser(context);
-        SQLHelper.getInstance(context).add(users);
-        refresh(context);
-    }
-
-    public static void deleteUser(User user, Context context) {
-        SQLHelper.getInstance(context).delete(user.getUserId());
-        refresh(context);
-    }
-
-    public static void deleteAllUser(Context context) {
-        SQLHelper.getInstance(context).deleteAllData();
-        users.clear();
-        displayUsers.clear();
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/DetectProxy.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/DetectProxy.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/DetectProxy.java	(revision 6857)
@@ -1,34 +0,0 @@
-package com.sensetime.faceunlock.manager;
-
-import com.sensetime.faceapi.FaceDetect;
-import com.sensetime.faceapi.model.CvPixelFormat;
-import com.sensetime.faceapi.model.FaceInfo;
-import com.sensetime.faceapi.model.FaceOrientation;
-import com.sensetime.faceunlock.util.LogUtil;
-
-public class DetectProxy {
-
-    private static final String TAG = "DetectProxy";
-
-    public static void init() {
-        FaceSDKManager.getInstance().initDetect();
-    }
-
-    public static FaceInfo[] detect(byte[] nv21, int width, int height) {
-        FaceDetect detector = FaceSDKManager.getInstance().getDetect();
-        if (detector == null) {
-            LogUtil.w(TAG, "FaceDetect is null !");
-            return null;
-        }
-        long time = System.currentTimeMillis();
-        FaceInfo[] faces = detector.detect(nv21, CvPixelFormat.NV21, width, height, width, FaceOrientation.RIGHT);
-        LogUtil.d(TAG, "detect time: " + (System.currentTimeMillis() - time) + ", face count: " + ((faces == null) ? 0
-                : faces.length));
-        return faces;
-    }
-
-    public static void release() {
-        FaceSDKManager.getInstance().releaseDetect();
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/FaceSDKManager.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/FaceSDKManager.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/manager/FaceSDKManager.java	(revision 6857)
@@ -1,118 +0,0 @@
-package com.sensetime.faceunlock.manager;
-
-import android.content.Context;
-import com.sensetime.faceapi.FaceDetect;
-import com.sensetime.faceapi.FaceHacker;
-import com.sensetime.faceapi.FaceTrack;
-import com.sensetime.faceapi.FaceVerify;
-import com.sensetime.faceapi.model.FaceConfig;
-import com.sensetime.faceunlock.util.FileUtil;
-import com.sensetime.faceunlock.util.LogUtil;
-
-import java.io.File;
-
-public class FaceSDKManager {
-
-	private static final String TAG = "FaceSDKManager";
-	private static final FaceSDKManager INSTANCE = new FaceSDKManager();
-	private FaceSDKManager() {
-	}
-
-	private FaceTrack faceTrack;
-	private FaceDetect faceDetect;
-	private FaceHacker faceHacker;
-	private FaceVerify faceVerify;
-
-	public static FaceSDKManager getInstance() {
-		return INSTANCE;
-	}
-
-	public FaceTrack getTrack() {
-		return faceTrack;
-	}
-
-	public FaceDetect getDetect() {
-		return faceDetect;
-	}
-
-	public FaceHacker getFaceHacker() {
-		return faceHacker;
-	}
-
-	public FaceVerify getVerify() {
-		return faceVerify;
-	}
-
-	public void initTrack() {
-		if (faceTrack != null) {
-			return;
-		}
-		long time = System.currentTimeMillis();
-		faceTrack = new FaceTrack();
-		LogUtil.d(TAG, "initTrack time: " + (System.currentTimeMillis() - time));
-	}
-
-	public void initDetect() {
-		if (faceDetect != null) {
-			return;
-		}
-		long time = System.currentTimeMillis();
-		faceDetect = new FaceDetect(FaceConfig.FaceImageResize.RESIZE_320W, FaceConfig.FaceKeyPointCount.POINT_COUNT_21);
-		LogUtil.d(TAG, "initDetect time: " + (System.currentTimeMillis() - time));
-	}
-
-	public void initHacker() {
-		if (faceHacker != null) {
-			return;
-		}
-		long time = System.currentTimeMillis();
-//		String path = context.getFilesDir().getAbsolutePath().toString() + "/" + FileUtil.HACKER_MODEL;
-//		LogUtil.d(TAG, "hacker model path: " + path);
-		faceHacker = new FaceHacker(null);
-		LogUtil.d(TAG, "initHacker time: " + (System.currentTimeMillis() - time));
-	}
-
-	public void initVerify(Context context) {
-		if (faceVerify != null) {
-			return;
-		}
-		FileUtil.copyModelFile(context);
-		String modelPath = context.getFilesDir().getAbsolutePath() + File.separator + FileUtil.VERIFY_MODEL;
-		long time = System.currentTimeMillis();
-		faceVerify = new FaceVerify(modelPath);
-		LogUtil.d(TAG, "initVerify time: " + (System.currentTimeMillis() - time) + "ms");
-	}
-
-	public void releaseTrack() {
-		if (faceTrack != null) {
-			faceTrack.release();
-			faceTrack = null;
-			LogUtil.v(TAG, "releaseTrack");
-		}
-	}
-
-	public void releaseDetect() {
-		if (faceDetect != null) {
-			faceDetect.release();
-			faceDetect = null;
-			LogUtil.v(TAG, "releaseDetect");
-		}
-	}
-
-	public void releaseHacker() {
-		if (faceHacker != null) {
-			faceHacker.release();
-			faceHacker = null;
-			LogUtil.v(TAG, "releaseHacker");
-		}
-	}
-
-	public void releaseVerify() {
-		if (faceVerify != null) {
-			faceVerify.release();
-			faceVerify = null;
-			LogUtil.v(TAG, "releaseVerify");
-		}
-	}
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/handler/WeakHandler.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/handler/WeakHandler.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/handler/WeakHandler.java	(revision 6857)
@@ -1,30 +0,0 @@
-package com.sensetime.faceunlock.handler;
-
-import android.app.Activity;
-import android.os.Handler;
-import android.os.Message;
-
-import java.lang.ref.WeakReference;
-
-/**
- * 弱引用封装的Handler，避免内存泄漏的发生
- */
-public abstract class WeakHandler<T extends Activity> extends Handler {
-
-    protected final WeakReference<T> weakReference;
-
-    public WeakHandler(T act) {
-        weakReference = new WeakReference<>(act);
-    }
-
-    public abstract void handleMsg(T act, Message msg);
-
-    @Override
-    public void handleMessage(Message msg) {
-        T act = weakReference.get();
-        if (act != null) {
-            handleMsg(act, msg);
-        }
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/FileUtil.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/FileUtil.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/FileUtil.java	(revision 6857)
@@ -1,131 +0,0 @@
-package com.sensetime.faceunlock.util;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.UUID;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.os.Environment;
-
-import com.sensetime.faceapi.utils.ColorConvertUtil;
-
-public class FileUtil {
-
-	public static final String TAG = "FileUtil";
-	public static final String VERIFY_MODEL = "verify.model";
-//	public static final String HACKER_MODEL = "M_Liveness_Antispoofing_General_6.0.2.model";
-
-	public static void copyModelFile(Context context) {
-		copyFileIfNeed(context, VERIFY_MODEL);
-//		copyFileIfNeed(context, HACKER_MODEL);
-	}
-
-	private static void copyFileIfNeed(Context context, String modelName) {
-		try {
-			File modelFile = new File(context.getFilesDir(), modelName);
-			InputStream is = context.getAssets().open(modelName);
-			if (modelFile.length() == is.available()) {
-				return;
-			}
-			OutputStream os = new FileOutputStream(modelFile);
-			byte[] buffer = new byte[1024 << 9]; // 512KB
-			int length = is.read(buffer);
-			while (length > 0) {
-				os.write(buffer, 0, length);
-				length = is.read(buffer);
-			}
-			os.flush();
-			os.close();
-			is.close();
-		} catch (IOException e) {
-			e.printStackTrace();
-		}finally{
-		}
-	}
-
-	public static String getAssertData(Context context, String path) {
-		try {
-			InputStream stream = context.getAssets().open(path);
-			int length = stream.available();
-			byte[] data = new byte[length];
-			stream.read(data);
-			stream.close();
-			return new String(data);
-		} catch (IOException e) {
-			e.printStackTrace();
-		}
-		return null;
-	}
-
-	public static String getUUIDName() {
-		String s = UUID.randomUUID().toString();
-		return s.substring(0, 8) + s.substring(9, 13) + s.substring(14, 18) + s.substring(19, 23) + s.substring(24);
-	}
-
-	public static boolean saveBitmap(Bitmap bitmap, String imagePath) {
-		File file = new File(imagePath);
-		File parentFile = file.getParentFile();
-		if (!parentFile.exists()) {
-			parentFile.mkdirs();
-		}
-		try {
-			FileOutputStream fos = new FileOutputStream(file);
-			bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos);
-			fos.flush();
-			fos.close();
-			return true;
-		} catch (FileNotFoundException e) {
-			e.printStackTrace();
-		} catch (IOException e) {
-			e.printStackTrace();
-		}
-		return false;
-	}
-
-	public static boolean saveBytes(byte[] bytes, String filePath) {
-		File file = new File(filePath);
-		File parentFile = file.getParentFile();
-		if (!parentFile.exists()) {
-			parentFile.mkdirs();
-		}
-		try {
-			FileOutputStream fos = new FileOutputStream(file);
-			fos.write(bytes);
-			fos.flush();
-			fos.close();
-			return true;
-		} catch (FileNotFoundException e) {
-			e.printStackTrace();
-		} catch (IOException e) {
-			e.printStackTrace();
-		}
-		return false;
-	}
-
-	public static final String DIR = Environment.getExternalStorageDirectory().getAbsolutePath() + "/sensetime/faceunlock/hacker/";
-	public static void saveHackerData(byte[] nv21, int width, int height, float score) {
-		String timestamp = getFormatTime(System.currentTimeMillis());
-		String nv21Name = DIR + timestamp + "/" + score + ".yuv";
-		saveBytes(nv21, nv21Name);
-		Bitmap bitmap = ColorConvertUtil.cropNv21ToBitmap(nv21, width, height, 0, 0, width, height);
-		String bitmapPath = DIR + timestamp + "/" + score + ".jpg";
-		saveBitmap(bitmap, bitmapPath);
-	}
-
-	/**
-	 * 将毫秒数转换成yyyy-MM-dd-HH-mm-ss的格式
-	 */
-	public static String getFormatTime(long milliseconds) {
-		SimpleDateFormat format = new SimpleDateFormat("yyyy.MM.dd-HH.mm.ss");
-		String times = format.format(new Date(milliseconds));
-		return times;
-	}
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/LogUtil.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/LogUtil.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/LogUtil.java	(revision 6857)
@@ -1,128 +0,0 @@
-package com.sensetime.faceunlock.util;
-
-/*import android.util.Log;
-
-public class LogUtil {
-
-    private static final boolean DEBUG = true;
-
-    public static void v(String tag, String msg) {
-        if (DEBUG) Log.v(tag, msg);
-    }
-
-    public static void d(String tag, String msg) {
-        if (DEBUG) Log.d(tag, msg);
-    }
-
-    public static void i(String tag, String msg) {
-        if (DEBUG) Log.i(tag, msg);
-    }
-
-    public static void w(String tag, String msg) {
-        if (DEBUG) Log.w(tag, msg);
-    }
-
-    public static void e(String tag, String msg) {
-        if (DEBUG) Log.e(tag, msg);
-    }
-
-}*/
-
-
-import android.content.Context;
-import android.util.Log;
-import android.os.Environment;
-
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-
-public class LogUtil {
-
-    private static final boolean DEBUG = true;
-    private static BufferedWriter bw;
-
-    public static void v(String tag, String msg) {
-        if (DEBUG) Log.v(tag, msg);
-    }
-
-    public static void d(String tag, String msg) {
-        if (DEBUG) Log.d(tag, msg);
-        if (bw != null) {
-            try {
-                bw.write(tag + "___" + msg);
-                bw.newLine();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    public static void i(String tag, String msg) {
-        if (DEBUG) Log.i(tag, msg);
-        if (bw != null) {
-            try {
-                bw.write(tag + "___" + msg);
-                bw.newLine();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    public static void w(String tag, String msg) {
-        if (DEBUG) Log.w(tag, msg);
-        if (bw != null) {
-            try {
-                bw.write(tag + "___" + msg);
-                bw.newLine();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    public static void e(String tag, String msg) {
-        if (DEBUG) Log.e(tag, msg);
-        if (bw != null) {
-            try {
-                bw.write(tag + "___" + msg);
-                bw.newLine();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    public static void init() {
-        String path = Environment.getExternalStorageDirectory().getPath();
-        String time = getTime();
-        try {
-            File file = new File(path, time);
-            bw = new BufferedWriter(new FileWriter(file));
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-
-    }
-
-    public static String getTime() {
-        long time = System.currentTimeMillis();//long now = android.os.SystemClock.uptimeMillis();
-        SimpleDateFormat format = new SimpleDateFormat("yyyy_MM_dd_HH_mm_ss");
-        Date d = new Date(time);
-        return format.format(d);
-    }
-
-    public static void destroy() {
-        if (bw != null) {
-            try {
-                bw.close();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/SPUtil.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/SPUtil.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/SPUtil.java	(revision 6857)
@@ -1,54 +0,0 @@
-package com.sensetime.faceunlock.util;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-
-public class SPUtil {
-
-	private static final String FILE_NAME = "config_data";
-	public static final String THRESHOLD_KEY = "threshold";
-	public static final String TRY_COUNT_KEY = "try_count";
-	public static final String IS_OPEN_LIVENESS = "is_open_liveness";
-
-	/**
-	 * 保存数据的方法，我们需要拿到保存数据的具体类型，然后根据类型调用不同的保存方法
-	 */
-	public static void put(Context context, String key, Object object) {
-		SharedPreferences sp = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
-		SharedPreferences.Editor editor = sp.edit();
-		if (object instanceof String) {
-			editor.putString(key, (String) object);
-		} else if (object instanceof Integer) {
-			editor.putInt(key, (Integer) object);
-		} else if (object instanceof Boolean) {
-			editor.putBoolean(key, (Boolean) object);
-		} else if (object instanceof Float) {
-			editor.putFloat(key, (Float) object);
-		} else if (object instanceof Long) {
-			editor.putLong(key, (Long) object);
-		} else {
-			editor.putString(key, object.toString());
-		}
-		editor.commit();
-	}
-
-	/**
-	 * 得到保存数据的方法，我们根据默认值得到保存的数据的具体类型，然后调用相对于的方法获取值
-	 */
-	public static Object get(Context context, String key, Object defaultObject) {
-		SharedPreferences sp = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
-		if (defaultObject instanceof String) {
-			return sp.getString(key, (String) defaultObject);
-		} else if (defaultObject instanceof Integer) {
-			return sp.getInt(key, (Integer) defaultObject);
-		} else if (defaultObject instanceof Boolean) {
-			return sp.getBoolean(key, (Boolean) defaultObject);
-		} else if (defaultObject instanceof Float) {
-			return sp.getFloat(key, (Float) defaultObject);
-		} else if (defaultObject instanceof Long) {
-			return sp.getLong(key, (Long) defaultObject);
-		}
-		return null;
-	}
-
-}
\ No newline at end of file
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/BrightnessHelper.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/BrightnessHelper.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/BrightnessHelper.java	(revision 6857)
@@ -1,48 +0,0 @@
-package com.sensetime.faceunlock.util;
-
-import android.provider.Settings;
-import android.util.Log;
-import android.content.Context;
-
-/**
- * Created by Administrator on 2017/7/11 14:31.
- * email: huan.fu@gometech.com.cn
- */
-
-public class BrightnessHelper {
-    //得到屏幕亮度调节模式
-    public static int getScreenMode(Context context) {
-        int screenMode = 0;
-        try {
-            screenMode = Settings.System.getInt(context.getContentResolver(),
-                    Settings.System.SCREEN_BRIGHTNESS_MODE);
-        } catch (Settings.SettingNotFoundException e) {
-            e.printStackTrace();
-        }
-        return screenMode;
-    }
-
-    //设置屏幕亮度调节模式
-    public static void setScreenMode(Context context,int mode) {
-        Settings.System.putInt(context.getContentResolver(),
-                Settings.System.SCREEN_BRIGHTNESS_MODE, mode);
-    }
-
-    //获取屏幕亮度
-    public static int getScreenBrightness(Context context) {
-        int screenBrightness = 0;
-        try {
-            screenBrightness = Settings.System.getInt(context.getContentResolver(),
-                    Settings.System.SCREEN_BRIGHTNESS);
-        } catch (Settings.SettingNotFoundException e) {
-            e.printStackTrace();
-        }
-        return screenBrightness;
-    }
-
-    //设置屏幕亮度
-    public static void setScreenBrightness(Context context,int value) {
-        Settings.System.putInt(context.getContentResolver(),
-                Settings.System.SCREEN_BRIGHTNESS, value);
-    }
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/DirectUtil.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/DirectUtil.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/DirectUtil.java	(revision 6857)
@@ -1,46 +0,0 @@
-package com.sensetime.faceunlock.util;
-
-import com.sensetime.faceapi.model.FaceInfo;
-
-public class DirectUtil {
-
-    /**
-     * 5方向的人脸
-     */
-    public static int getFiveDirect(FaceInfo face) {
-        if (isCenter(face)) {
-            return 0;
-        } else if (isTop(face)) {
-            return 1;
-        } else if (isRight(face)) {
-            return 4;
-        } else if (isBottom(face)) {
-            return 2;
-        } else if (isLeft(face)) {
-            return 3;
-        } else {
-            return -1;
-        }
-    }
-
-    private static boolean isTop(FaceInfo face) {
-        return face.pitch < -10 && Math.abs(face.yaw) < 10;
-    }
-
-    private static boolean isCenter(FaceInfo face) {
-        return Math.abs(face.pitch) < 5 && Math.abs(face.yaw) < 10;
-    }
-
-    private static boolean isBottom(FaceInfo face) {
-        return face.pitch > 10 && Math.abs(face.yaw) < 10;
-    }
-
-    private static boolean isLeft(FaceInfo face) {
-        return face.yaw < -15 && Math.abs(face.pitch) < 10;
-    }
-
-    private static boolean isRight(FaceInfo face) {
-        return face.yaw > 15 && Math.abs(face.pitch) < 10;
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/BitmapUtil.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/BitmapUtil.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/BitmapUtil.java	(revision 6857)
@@ -1,55 +0,0 @@
-package com.sensetime.faceunlock.util;
-
-import android.graphics.Bitmap;
-import android.graphics.Matrix;
-import android.graphics.Rect;
-
-import com.sensetime.faceapi.utils.ColorConvertUtil;
-
-public class BitmapUtil {
-
-    public static Bitmap cropBitmap(byte[] nv21, Rect rect, int previewWidth, int previewHeight) {
-        Rect scaleRect = BitmapUtil.getScaleRect(rect, 2, 2, previewWidth, previewHeight);
-        int cropWidth = scaleRect.width();
-        int cropHeight = scaleRect.height();
-        int startX = scaleRect.left % 2 == 0 ? scaleRect.left : scaleRect.left + 1;
-        int startY = scaleRect.top % 2 == 0 ? scaleRect.top : scaleRect.top + 1;
-        if (cropWidth % 2 != 0) {
-            cropWidth -= 1;
-        }
-        if (cropHeight % 2 != 0) {
-            cropHeight -= 1;
-        }
-        Bitmap cropBitmap = ColorConvertUtil.cropNv21ToBitmap(nv21, previewWidth, previewHeight, startX, startY,
-                cropWidth, cropHeight);
-        return cropBitmap;
-    }
-
-    public static Rect getScaleRect(Rect rect, float scaleX, float scaleY, int maxW, int maxH) {
-        Rect resultRect = new Rect();
-        int left = (int) (rect.left - rect.width() * (scaleX - 1) / 2);
-        int right = (int) (rect.right + rect.width() * (scaleX - 1) / 2);
-        int bottom = (int) (rect.bottom + rect.height() * (scaleY - 1) / 2);
-        int top = (int) (rect.top - rect.height() * (scaleY - 1) / 2);
-        resultRect.left = left > 0 ? left : 0;
-        resultRect.right = right > maxW ? maxW : right;
-        resultRect.bottom = bottom > maxH ? maxH : bottom;
-        resultRect.top = top > 0 ? top : 0;
-        return resultRect;
-    }
-
-    public static Bitmap rotateBitmap(Bitmap sourceBitmap, int degree, boolean frontCamera) {
-        if (degree == 0 && frontCamera == false) {
-            return sourceBitmap;
-        }
-        Matrix matrix = new Matrix();
-        matrix.postRotate(degree);
-        if (frontCamera) {
-            matrix.postScale(-1, 1);
-        }
-        Bitmap rotaBitmap = Bitmap.createBitmap(sourceBitmap, 0, 0, sourceBitmap.getWidth(), sourceBitmap.getHeight()
-                , matrix, false);
-        return rotaBitmap;
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/FaceUtil.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/FaceUtil.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/util/FaceUtil.java	(revision 6857)
@@ -1,63 +0,0 @@
-package com.sensetime.faceunlock.util;
-
-import android.graphics.Rect;
-import android.util.Log;
-
-import com.sensetime.faceapi.model.CvPixelFormat;
-import com.sensetime.faceapi.model.FaceInfo;
-import com.sensetime.faceapi.utils.BrightnessUtil;
-
-public class FaceUtil {
-
-    private static final String TAG = "FaceUtil";
-    private static final float MIN_BRIGHT = 0.14f;
-
-    /**
-     * 得到最大人脸
-     */
-    public static FaceInfo getMaxFace(FaceInfo[] faces) {
-        if (faces == null || faces.length <= 0) {
-            return null;
-        }
-        FaceInfo faceInfo = null;
-        for (int i = 0; i < faces.length; i++) {
-            if (faceInfo == null || faces[i].faceRect.width() > faceInfo.faceRect.width()) {
-                faceInfo = faces[i];
-            }
-        }
-        return faceInfo;
-    }
-
-    /**
-     * 亮度过滤
-     */
-    public static FaceInfo brightnessFilter(byte[] nv21, int width, int height, FaceInfo faceInfo) {
-        float bright = BrightnessUtil.averageBrightness(nv21, CvPixelFormat.NV21, width, height, faceInfo);
-        LogUtil.d(TAG, "filterFaces bright : " + bright);
-        if (bright < MIN_BRIGHT) {
-            LogUtil.w(TAG, "this face brightness is illegal !");
-            return null;
-        }
-        return faceInfo;
-    }
-
-    public static boolean isFrontFace(FaceInfo faceInfo) {
-        return Math.abs(faceInfo.pitch) < 15 && Math.abs(faceInfo.yaw) < 25;
-    }
-
-    /**
-     * 判断人脸是否在预览框内
-     *
-     * @param faceInfo 人脸信息
-     * @param width    预览宽度
-     * @param height   预览高度
-     * @return
-     */
-    public static boolean containFace(FaceInfo faceInfo, int width, int height) {
-        FaceInfo clone = faceInfo.clone();
-        int tolerantWidth = clone.faceRect.width() / 8;
-        Rect containerRect = new Rect(-tolerantWidth, -tolerantWidth, width + tolerantWidth, height + tolerantWidth);
-        return containerRect.contains(clone.faceRect);
-    }
-
-}
\ No newline at end of file
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/widget/FaceRegisterView.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/widget/FaceRegisterView.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/widget/FaceRegisterView.java	(revision 6857)
@@ -1,82 +0,0 @@
-package com.sensetime.faceunlock.widget;
-
-import android.content.Context;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.graphics.RectF;
-import android.util.AttributeSet;
-import android.view.View;
-
-public class FaceRegisterView extends View {
-	
-	public static final int FACE_DIR_COUNT = 5; // 5方向人脸
-
-	private Paint mPaint = new Paint(); // 绘制用的画笔
-	private RectF mRect = new RectF(); // 控件在屏幕中的位置，用来确定和绘制扇形
-	private boolean[] direct = new boolean[FACE_DIR_COUNT]; // 存储某个方向是否已经检测
-	private int mSmallCircleRadius; // 中间圆的半径
-	private int mStrokeWidth = 4; // 画笔的宽度
-
-	public FaceRegisterView(Context context) {
-		super(context);
-		init();
-	}
-
-	public FaceRegisterView(Context context, AttributeSet attrs) {
-		super(context, attrs);
-		init();
-	}
-
-	private void init() {
-		mPaint.setAntiAlias(true);
-		mPaint.setStyle(Paint.Style.STROKE);
-		mPaint.setStrokeWidth(mStrokeWidth);
-	}
-
-	@Override
-	protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-		super.onLayout(changed, left, top, right, bottom);
-		mRect.set(mStrokeWidth, mStrokeWidth, getWidth() - mStrokeWidth, getHeight() - mStrokeWidth);
-		mSmallCircleRadius = getWidth() >> 4;
-	}
-
-	public void reset() {
-		for (int i = 0; i < direct.length; i++) {
-			direct[i] = false;
-		}
-		postInvalidate(); // 更新UI
-	}
-	
-	/**
-	 * 设置某个方向去做特征分析，返回成功状态
-	 */
-	public boolean setDirectTrue(int index) {
-		if (index < 0 || index >= direct.length || direct[index]) {
-			return false; // 如果index越界或者direct[index]已经做过了特征分析，则返回false
-		}
-		direct[index] = true; // 设置direct[index]的状态为已经做过特征分析
-		postInvalidate(); // 更新UI
-		return true;
-	}
-	
-	@Override
-	protected void onDraw(Canvas canvas) {
-		super.onDraw(canvas);
-		mPaint.setColor(Color.RED);
-		canvas.drawCircle(mRect.centerX(), mRect.centerY(), mRect.width() / 2, mPaint);
-		canvas.drawCircle(mRect.centerX(), mRect.centerY(), mSmallCircleRadius, mPaint);
-		for (int i = 0; i < direct.length; i++) {
-			if (direct[i]) {
-				mPaint.setColor(Color.CYAN);
-				if (i == 0) {
-					canvas.drawCircle(mRect.centerX(), mRect.centerY(), mSmallCircleRadius, mPaint);
-				} else {
-					canvas.drawArc(mRect, 90 * i - 45, 90, false, mPaint);
-					// canvas.drawArc(mRect, 45 * i - 22.5f, 45, false, mPaint); // 9方向
-				}
-			}
-		}
-	}
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/widget/FaceUnlockCyleView.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/widget/FaceUnlockCyleView.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/widget/FaceUnlockCyleView.java	(revision 6857)
@@ -1,180 +0,0 @@
-package com.sensetime.faceunlock.widget;
-
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.graphics.RectF;
-import android.graphics.Typeface;
-import android.util.AttributeSet;
-import com.android.keyguard.R;
-import android.util.Log;
-import android.view.View;
-
-public class FaceUnlockCyleView extends View {
-
-	private Paint paint;
-
-	private int roundColor;
-
-	private int roundProgressColor;
-
-	private float roundProgressInerCycle;
-
-	private int textColor;
-
-	private float textSize;
-
-	private float roundWidth;
-
-	private int max;
-
-	private int progress;
-
-	private boolean textIsDisplayable;
-
-	private int style;
-
-	public static final int STROKE = 0;
-	public static final int FILL = 1;
-
-	public FaceUnlockCyleView(Context context) {
-		this(context, null);
-	}
-
-	public FaceUnlockCyleView(Context context, AttributeSet attrs) {
-		this(context, attrs, 0);
-	}
-
-	public FaceUnlockCyleView(Context context, AttributeSet attrs, int defStyle) {
-		super(context, attrs, defStyle);
-
-		paint = new Paint();
-		TypedArray mTypedArray = context.obtainStyledAttributes(attrs, R.styleable.RoundProgressBar);
-		roundColor = mTypedArray.getColor(R.styleable.RoundProgressBar_roundColor, Color.RED);
-		roundProgressColor = mTypedArray.getColor(R.styleable.RoundProgressBar_roundProgressColor, Color.GREEN);
-		roundProgressInerCycle = mTypedArray.getDimension(R.styleable.RoundProgressBar_roundProgressInterCycle, 20);
-		textColor = mTypedArray.getColor(R.styleable.RoundProgressBar_textColor, Color.GREEN);
-		textSize = mTypedArray.getDimension(R.styleable.RoundProgressBar_textSize, 15);
-		roundWidth = mTypedArray.getDimension(R.styleable.RoundProgressBar_roundWidth, 5);
-		max = mTypedArray.getInteger(R.styleable.RoundProgressBar_max, 100);
-		textIsDisplayable = mTypedArray.getBoolean(R.styleable.RoundProgressBar_textIsDisplayable, true);
-		style = mTypedArray.getInt(R.styleable.RoundProgressBar_style, 0);
-		mTypedArray.recycle();
-	}
-
-	@Override
-	protected void onDraw(Canvas canvas) {
-		super.onDraw(canvas);
-
-		int centre = getWidth() / 2;
-		int radius = (int) (centre - roundWidth / 2);
-		paint.setColor(roundColor);
-		paint.setStyle(Paint.Style.STROKE);
-		paint.setStrokeWidth(roundWidth);
-		paint.setAntiAlias(true);
-		canvas.drawCircle(centre, centre, radius, paint);
-
-		paint.setStrokeWidth(0);
-		paint.setColor(textColor);
-		paint.setTextSize(textSize);
-		paint.setTypeface(Typeface.DEFAULT_BOLD);
-		int percent = (int) (((float) progress / (float) max) * 100);
-		float textWidth = paint.measureText(percent + "%");
-
-		if (textIsDisplayable && percent != 0 && style == STROKE) {
-			canvas.drawText(percent + "%", centre - textWidth / 2, centre + textSize+760 / 2, paint);
-		}
-
-		paint.setStrokeWidth(roundWidth);
-		paint.setColor(roundProgressColor);
-		
-		RectF oval = new RectF(centre - radius, centre - radius, centre + radius, centre + radius);
-
-		switch (style) {
-		case STROKE: {
-			paint.setStyle(Paint.Style.STROKE);
-			canvas.drawArc(oval, -90, 360 * progress / max, false, paint);
-			break;
-		}
-		case FILL: {
-			paint.setStyle(Paint.Style.FILL_AND_STROKE);
-			if (progress != 0)
-//				canvas.drawArc(oval, 0, 360 * progress / max, true, paint);
-			break;
-		}
-		}
-
-	}
-
-	public synchronized int getMax() {
-		return max;
-	}
-
-	public synchronized void setMax(int max) {
-		if (max < 0) {
-			throw new IllegalArgumentException("max not less than 0");
-		}
-		this.max = max;
-	}
-
-	public synchronized int getProgress() {
-		return progress;
-	}
-
-	public synchronized void setProgress(int progress) {
-		if (progress < 0) {
-			throw new IllegalArgumentException("progress not less than 0");
-		}
-		if (progress > max) {
-			progress = max;
-		}
-		if (progress <= max) {
-			this.progress = progress;
-			postInvalidate();
-		}
-
-	}
-
-	public int getCricleColor() {
-		return roundColor;
-	}
-
-	public void setCricleColor(int cricleColor) {
-		this.roundColor = cricleColor;
-	}
-
-	public int getCricleProgressColor() {
-		return roundProgressColor;
-	}
-
-	public void setCricleProgressColor(int cricleProgressColor) {
-		this.roundProgressColor = cricleProgressColor;
-	}
-
-	public int getTextColor() {
-		return textColor;
-	}
-
-	public void setTextColor(int textColor) {
-		this.textColor = textColor;
-	}
-
-	public float getTextSize() {
-		return textSize;
-	}
-
-	public void setTextSize(float textSize) {
-		this.textSize = textSize;
-	}
-
-	public float getRoundWidth() {
-		return roundWidth;
-	}
-
-	public void setRoundWidth(float roundWidth) {
-		this.roundWidth = roundWidth;
-	}
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/widget/CameraView.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/widget/CameraView.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/widget/CameraView.java	(revision 6857)
@@ -1,578 +0,0 @@
-package com.sensetime.faceunlock.widget;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.ImageFormat;
-import android.graphics.Matrix;
-import android.graphics.Rect;
-import android.hardware.Camera;
-import android.hardware.Camera.Parameters;
-import android.hardware.Camera.PreviewCallback;
-import android.hardware.Camera.Size;
-import android.util.AttributeSet;
-import android.util.DisplayMetrics;
-import android.util.Log;
-import android.view.MotionEvent;
-import android.view.Surface;
-import android.view.SurfaceHolder;
-import android.view.SurfaceView;
-import android.view.View;
-import android.view.WindowManager;
-import android.widget.Toast;
-
-import com.android.keyguard.R;
-
-import java.util.ArrayList;
-import java.util.List;
-import android.content.Intent;
-
-/**
- * 相机View
- */
-public class CameraView extends SurfaceView implements Camera.AutoFocusCallback {
-
-    private final static String TAG = "CameraView";
-    private final static boolean DEBUG = true;
-    private final static int SCALE_TYPE_4_3 = 1; // 自定义属性中4:3比例的枚举对应的值为1
-    private final static int SCALE_TYPE_16_9 = 2; // 自定义属性中16:9比例的枚举对应的值为2
-    private final static String CAMERA_STOP_FACE_SERVICE = "camera_stop_face_service"; //add by yukai,2017/7/29 
-
-    private Camera mCamera; // 相机对象
-    private Matrix matrix = new Matrix(); // 记录屏幕拉伸的矩阵，用于绘制人脸框使用
-    private PreviewCallback mPreviewCallback; // 相机预览的数据回调
-    private Size mPreviewSize; // 当前预览分辨率大小
-
-    private float mPreviewScale; // 预览显示的比例(4:3/16:9)
-    private float previewScaleX;
-    private float previewScaleY;
-    private int mResolution; // 分辨率大小，以预览高度为标准(320, 480, 720, 1080...)
-    private int mCameraFacing; // 摄像头方向
-    private boolean mIsOpened;
-
-    public int mPreviewWidth; // 预览宽度
-    public int mPreviewHeight; // 预览高度
-    public int mDegrees; // 预览显示的角度
-    public byte[] mBuffer; // 预览缓冲数据，使用可以让底层减少重复创建byte[]，起到重用的作用
-
-    public CameraView(Context context) {
-        super(context);
-        init(context, null);
-    }
-
-    public CameraView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init(context, attrs);
-    }
-
-    private void init(Context context, AttributeSet attrs) {
-        // 设置透明状态栏和透明导航栏，需要 API >= 19
-//        ((Activity) context).getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
-//        ((Activity) context).getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
-        // 设置屏幕常亮
-        setKeepScreenOn(true);
-        // 自定义属性
-        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CameraView);
-        mCameraFacing = a.getInt(R.styleable.CameraView_cameraFacing, Camera.CameraInfo.CAMERA_FACING_FRONT);
-        mResolution = a.getInt(R.styleable.CameraView_resolution, 480);
-        int scaleType = a.getInt(R.styleable.CameraView_scale, 0);
-        mPreviewScale = getPreviewScale(scaleType);
-        a.recycle();
-        // 设置SurfaceHolder的回调
-        getHolder().addCallback(callback);
-    }
-
-    private SurfaceHolder.Callback callback = new SurfaceHolder.Callback() {
-        @Override
-        public void surfaceCreated(SurfaceHolder holder) {
-            if (DEBUG) {
-                Log.v(TAG, "SurfaceHolder Created");
-            }
-            try {
-                openCamera(mCameraFacing); // 1.打开相机
-                initParameters(); // 2.设置相机参数
-                mCamera.setPreviewDisplay(getHolder()); // 3.设置预览显示的SurFace
-            } catch (Exception e) {
-                e.printStackTrace();
-		Toast.makeText(getContext(), "打开人脸识别失败, 请检查相机或者权限是否被占用", Toast.LENGTH_SHORT).show();
-		Intent intent = new Intent();
-		intent.setAction(CAMERA_STOP_FACE_SERVICE);
-		getContext().sendBroadcast(intent);
-            }
-        }
-        @Override
-        public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
-            if (DEBUG) {
-                Log.v(TAG, "SurfaceHolder Changed. width : " + width + ", height : " + height);
-            }
-            updateCamera(); // 4.更新相机属性，每次更换分辨率需要更新的操作，包括设置预览大小和方向，开始预览
-            if (width > height) {
-                previewScaleX = width / (float) mPreviewWidth;
-                previewScaleY = height / (float) mPreviewHeight;
-            } else {
-                previewScaleX = width / (float) mPreviewHeight;
-                previewScaleY = height / (float) mPreviewWidth;
-            }
-            matrix.setScale(previewScaleX, previewScaleY);
-        }
-
-        @Override
-        public void surfaceDestroyed(SurfaceHolder holder) {
-            if (DEBUG) {
-                Log.v(TAG, "SurfaceHolder Destroyed");
-            }
-			holder.removeCallback(this);
-            releaseCamera(); // 5.释放相机资源
-        }
-    };
-
-    private void openCamera(int mCameraFacing) throws RuntimeException {
-        releaseCamera();
-        Camera.CameraInfo info = new Camera.CameraInfo();
-        for (int i = 0; i < Camera.getNumberOfCameras(); i++) {
-            Camera.getCameraInfo(i, info);
-            if (info.facing == mCameraFacing) {
-                mCamera = Camera.open(i); // 打开对应的摄像头，获取到camera实例
-                mIsOpened = true;
-                return;
-            }
-        }
-    }
-
-    private void initParameters() {
-        if (mCamera == null) {
-            return;
-        }
-        try {
-            Parameters parameters = mCamera.getParameters();
-            // 如果摄像头不支持这些参数都会出错的，所以设置的时候一定要判断是否支持
-            List<String> supportedFlashModes = parameters.getSupportedFlashModes();
-            if (supportedFlashModes != null && supportedFlashModes.contains(Parameters.FLASH_MODE_OFF)) {
-                parameters.setFlashMode(Parameters.FLASH_MODE_OFF); // 设置闪光模式
-            }
-            List<String> supportedFocusModes = parameters.getSupportedFocusModes();
-            if (supportedFocusModes != null && supportedFocusModes.contains(Parameters.FOCUS_MODE_AUTO)) {
-                parameters.setFocusMode(Parameters.FOCUS_MODE_AUTO); // 设置聚焦模式
-            }
-            parameters.setPreviewFormat(ImageFormat.NV21); // 设置预览图片格式
-            parameters.setPictureFormat(ImageFormat.JPEG); // 设置拍照图片格式
-            parameters.setExposureCompensation(0);
-            mCamera.setParameters(parameters); // 将设置好的parameters添加到相机里
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-
-    /**
-     * 每次启动摄像头、切换分辨率都需要进行的操作，所以抽离出来作为一个单独的方法
-     */
-    private void updateCamera() {
-        if (mCamera == null) {
-            return;
-        }
-        mCamera.stopPreview(); // 1.先停止预览
-        setCameraDisplayOrientation(getContext(), mCamera); // 2.设置相机的显示方向
-        initPreviewSize(); // 3.初始化相机预览尺寸
-        initPreviewBuffer(); // 4.初始化相机预览的缓存
-        mCamera.startPreview(); // 5.开始预览
-    }
-
-    /**
-     * 初始化预览尺寸大小并设置，根据拉伸比例、分辨率来计算
-     */
-    private void initPreviewSize() {
-        if (mCamera == null) {
-            return;
-        }
-        Parameters parameters = mCamera.getParameters();
-        mPreviewSize = getFitPreviewSize(parameters); // 获取适合的预览大小
-        mPreviewWidth = mPreviewSize.width;
-        mPreviewHeight = mPreviewSize.height;
-        parameters.setPreviewSize(mPreviewWidth, mPreviewHeight); // 设置预览图片大小
-        if (DEBUG) {
-            Log.d(TAG, "initPreviewSize() mPreviewWidth: " + mPreviewWidth + ", mPreviewHeight: " + mPreviewHeight);
-        }
-        mCamera.setParameters(parameters);
-    }
-
-    /**
-     * 具体计算最佳分辨率大小的方法
-     */
-    private Size getFitPreviewSize(Parameters parameters) {
-        List<Size> previewSizes = parameters.getSupportedPreviewSizes(); // 获取支持的预览尺寸大小
-        int minDelta = Integer.MAX_VALUE; // 最小的差值，初始值应该设置大点保证之后的计算中会被重置
-        int index = 0; // 最小的差值对应的索引坐标
-        for (int i = 0; i < previewSizes.size(); i++) {
-            Size previewSize = previewSizes.get(i);
-            if (DEBUG) {
-                Log.d(TAG, "SupportedPreviewSize, width: " + previewSize.width + ", height: " + previewSize.height);
-            }
-            // 找到一个与设置的分辨率差值最小的相机支持的分辨率大小
-            if (previewSize.width * mPreviewScale == previewSize.height) {
-                int delta = Math.abs(mResolution - previewSize.height);
-                if (delta == 0) {
-                    return previewSize;
-                }
-                if (minDelta > delta) {
-                    minDelta = delta;
-                    index = i;
-                }
-            }
-        }
-        return previewSizes.get(index); // 默认返回与设置的分辨率最接近的预览尺寸
-    }
-
-    private void initPreviewBuffer() {
-        if (mCamera == null) {
-            return;
-        }
-        mBuffer = new byte[mPreviewWidth * mPreviewHeight * 3 / 2]; // 初始化预览缓冲数据的大小
-        if (DEBUG) {
-            Log.d(TAG, "initPreviewBuffer() mBuffer.length: " + mBuffer.length);
-        }
-        mCamera.addCallbackBuffer(mBuffer); // 将此预览缓冲数据添加到相机预览缓冲数据队列里
-        mCamera.setPreviewCallbackWithBuffer(mPreviewCallback); // 设置预览的回调
-		
-    }
-
-    /**
-     * 设置相机显示的方向，必须设置，否则显示的图像方向会错误
-     */
-    private void setCameraDisplayOrientation(Context context, Camera camera) {
-        int rotation = ((WindowManager) (context.getApplicationContext().getSystemService(Context.WINDOW_SERVICE)))
-                .getDefaultDisplay().getRotation();
-        switch (rotation) {
-            case Surface.ROTATION_0: // portrait
-                mDegrees = 90;
-                break;
-            case Surface.ROTATION_90: // landscape
-                mDegrees = 0;
-                break;
-            case Surface.ROTATION_180: // portrait-reverse
-                mDegrees = 270;
-                break;
-            case Surface.ROTATION_270: // landscape-reverse
-                mDegrees = 180;
-                break;
-            default:
-                mDegrees = 90; // 大部分使用场景都是portrait，默认使用portrait的显示方向
-                break;
-        }
-        camera.setDisplayOrientation(mDegrees);
-    }
-
-    protected void setExposure(int value) {
-        Parameters parameters = mCamera.getParameters();
-        if (value == parameters.getExposureCompensation()) {
-            return;
-        }
-        Log.d(TAG, "exposure value : " + value);
-        parameters.setExposureCompensation(value);
-        mCamera.setParameters(parameters);
-    }
-
-    /**
-     * 释放相机资源
-     */
-    public void releaseCamera() {
-        if (null != mCamera) {
-            if (DEBUG) {
-                Log.v(TAG, "releaseCamera()");
-            }
-            mCamera.setPreviewCallbackWithBuffer(null);
-            mCamera.stopPreview();
-            mCamera.release();
-            mCamera = null;
-            mIsOpened = false;
-			if(mBuffer != null){
-				mBuffer = null;
-			}
-        }
-    }
-
-    /**
-     * 根据自定义属性的模式（4:3模式,16:9模式,auto模式）来获取相机的显示比例
-     */
-    private float getPreviewScale(int type) {
-        if (type == SCALE_TYPE_4_3) { // 4:3模式
-            return 0.75f;
-        }
-        if (type == SCALE_TYPE_16_9) { // 16:9模式
-            return 0.5625f;
-        }
-        return getScreenScale(); // auto模式
-    }
-
-    /**
-     * 获取设备屏幕的拉伸比例，目前安卓的设备屏幕比例只有4：3和16：9两种
-     */
-    private float getScreenScale() {
-        WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
-        DisplayMetrics displayMetrics = new DisplayMetrics();
-        wm.getDefaultDisplay().getMetrics(displayMetrics);
-        float width = displayMetrics.widthPixels;
-        float height = displayMetrics.heightPixels;
-        float scale;
-        if (width > height) {
-            scale = height / width;
-        } else {
-            scale = width / height;
-        }
-        if (DEBUG) {
-            Log.d(TAG, "displayMetrics.widthPixels : " + width);
-            Log.d(TAG, "displayMetrics.heightPixels : " + height);
-            Log.d(TAG, "scale : " + scale);
-        }
-        return Math.abs(scale - 0.75f) > Math.abs(scale - 0.5625f) ? 0.5625f : 0.75f; // 0.75(4:3) 或者 0.5625(16:9)
-    }
-
-    /**
-     * 以点击的坐标点（基于CameraView控件大小的坐标系）为中心进行聚焦
-     */
-    private void focusOnPoint(int x, int y) {
-        if (DEBUG) {
-            Log.d(TAG, "touch point (" + x + ", " + y + ")");
-        }
-        if (mCamera == null) {
-            return;
-        }
-        Parameters parameters = mCamera.getParameters();
-        // 1.先要判断是否支持设置聚焦区域
-        if (parameters.getMaxNumFocusAreas() > 0) {
-            int width = getWidth();
-            int height = getHeight();
-            // 2.以触摸点为中心点，view窄边的1/4为聚焦区域的默认边长
-            int length = Math.min(width, height) >> 3; // 1/8的长度
-            int left = x - length;
-            int top = y - length;
-            int right = x + length;
-            int bottom = y + length;
-            // 3.映射，因为相机聚焦的区域是一个(-1000,-1000)到(1000,1000)的坐标区域
-            left = left * 2000 / width - 1000;
-            top = top * 2000 / height - 1000;
-            right = right * 2000 / width - 1000;
-            bottom = bottom * 2000 / height - 1000;
-            // 4.判断上述矩形区域是否超过边界，若超过则设置为临界值
-            left = left < -1000 ? -1000 : left;
-            top = top < -1000 ? -1000 : top;
-            right = right > 1000 ? 1000 : right;
-            bottom = bottom > 1000 ? 1000 : bottom;
-            if (DEBUG) {
-                Log.d(TAG, "focus area (" + left + ", " + top + ", " + right + ", " + bottom + ")");
-            }
-            ArrayList<Camera.Area> areas = new ArrayList<Camera.Area>();
-            areas.add(new Camera.Area(new Rect(left, top, right, bottom), 600));
-            parameters.setFocusAreas(areas);
-        }
-        try {
-            mCamera.cancelAutoFocus(); // 先要取消掉进程中所有的聚焦功能
-            mCamera.setParameters(parameters);
-            mCamera.autoFocus(this); // 调用聚焦
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-
-    public void setPreviewCallback(PreviewCallback previewCallback) {
-        mPreviewCallback = previewCallback;
-    }
-
-    /**
-     * 每次预览的回调中，需要调用这个方法才可以起到重用mBuffer
-     */
-    public void addCallbackBuffer() {
-        if (mCamera != null) {
-            mCamera.addCallbackBuffer(mBuffer);
-        }
-    }
-
-    /**
-     * 切换前后摄像头
-     */
-    public void switchCamera() {
-        mCameraFacing ^= 1; // 先改变摄像头朝向
-        mIsOpened = false;
-        restartCamera();
-    }
-
-    public void restartCamera() {
-        if (mIsOpened) {
-            return;
-        }
-        Log.w(TAG, "restartCamera");
-        try {
-            openCamera(mCameraFacing); // 重新打开对应的摄像头
-            initParameters(); // 重新初始化参数
-            mCamera.setPreviewDisplay(getHolder());
-            updateCamera();
-        } catch (Exception e) {
-            e.printStackTrace();
-	    Toast.makeText(getContext(), "打开人脸识别失败, 请检查相机或者权限是否被占用", Toast.LENGTH_SHORT).show();
-	    Intent intent = new Intent();
-	    intent.setAction(CAMERA_STOP_FACE_SERVICE);
-	    getContext().sendBroadcast(intent);
-        }
-    }
-    /**
-     * 切换分辨率
-     */
-    public void resetResolution(Size size) {
-        float scale = size.height * 1.0f / size.width;
-        if (mPreviewScale == scale && mResolution == size.height) {
-            return; // 比例分辨率均为改变，直接返回
-        }
-        mResolution = size.height; // 重置分辨率大小
-        if (mPreviewScale == scale) {
-            // 比例未改变，只需要重新更新预览分辨率即可
-            updateCamera();
-            resetMatrix();
-        } else {
-            // 比例改变，因为View的大小将要变化了，需要重新布局
-            mPreviewScale = scale;
-            requestLayout();
-        }
-    }
-    /**
-     * 比例未改变时，surfaceView的大小并没有改变，只是相机的预览分辨率改变了，不会调用到surfaceChanged()方法，所以就需要手动重置matrix
-     */
-    private void resetMatrix() {
-        int width = getWidth();
-        int height = getHeight();
-        if (DEBUG) {
-            Log.d(TAG, "resetMatrix() width: " + width + ", height: " + height);
-        }
-        if (width > height) {
-            previewScaleX = width / (float) mPreviewWidth;
-            previewScaleY = height / (float) mPreviewHeight;
-        } else {
-            previewScaleX = width / (float) mPreviewHeight;
-            previewScaleY = height / (float) mPreviewWidth;
-        }
-        matrix.setScale(previewScaleX, previewScaleY);
-    }
-
-    public Camera getCamera() {
-        return mCamera;
-    }
-
-    public List<Size> getSupportPreviewSize() {
-        if (mCamera == null) {
-            return null;
-        }
-        return mCamera.getParameters().getSupportedPreviewSizes();
-    }
-
-    public Matrix getMatrix() {
-        return matrix;
-    }
-
-    public Size getPreviewSize() {
-        return mPreviewSize;
-    }
-
-    public boolean isFrontCamera() {
-        return mCameraFacing == Camera.CameraInfo.CAMERA_FACING_FRONT;
-    }
-
-    public void startPreview() {
-        if (mCamera != null) {
-            if (DEBUG) {
-                Log.d(TAG, "startPreview()");
-            }
-            mCamera.setPreviewCallbackWithBuffer(mPreviewCallback);
-            mCamera.startPreview();
-        }
-    }
-
-    public void stopPreview() {
-        if (mCamera != null) {
-            if (DEBUG) {
-                Log.d(TAG, "stopPreview()");
-            }
-            mCamera.stopPreview();
-        }
-    }
-
-    public float getPreviewScaleX() {
-        return previewScaleX;
-    }
-
-    public float getPreviewScaleY() {
-        return previewScaleY;
-    }
-
-    /**
-     * 设置长按可切换前后摄像头
-     */
-    public void setLongClickSwitchCamera() {
-        setOnLongClickListener(new OnLongClickListener() {
-            @Override
-            public boolean onLongClick(View v) {
-                switchCamera();
-                return true;
-            }
-        });
-    }
-
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-		//super.onMeasure(widthMeasureSpec, heightMeasureSpec);
-        int originalWidth = MeasureSpec.getSize(widthMeasureSpec);
-        int originalHeight = MeasureSpec.getSize(heightMeasureSpec);
-        float scale; // 宽高比，用 较小数/较大数
-        int finalWidth, finalHeight; // 根据预览的比例去重新计算和设置View的宽高
-        if (originalWidth < originalHeight) {
-            scale = originalWidth * 1.0f / originalHeight;
-            if (scale == mPreviewScale) { // 比例一样则不改变
-                finalWidth = originalWidth;
-                finalHeight = originalHeight;
-            } else {
-                if (mPreviewScale == 0.75f) { // 预览比例4:3,压缩高度
-                    finalWidth = originalWidth;
-                    finalHeight = finalWidth * 4 / 3;
-                } else { // 预览比例16:9,压缩宽度
-                    finalWidth = originalWidth;
-                    finalHeight = finalWidth * 16 / 9;
-                }
-            }
-        } else {
-            scale = originalHeight * 1.0f / originalWidth;
-            if (scale == mPreviewScale) { // 比例一样则不改变
-                finalWidth = originalWidth;
-                finalHeight = originalHeight;
-            } else {
-                if (mPreviewScale == 0.75f) { // 预览比例4:3,压缩宽度
-                    finalHeight = originalHeight;
-                    finalWidth = finalHeight * 4 / 3;
-                } else { // 预览比例16:9,压缩高度
-                    finalWidth = originalWidth;
-                    finalHeight = finalWidth * 9 / 16;
-                }
-            }
-        }
-        if (DEBUG) {
-            Log.d(TAG, "originalWidth :" + originalWidth + ", originalHeight :" + originalHeight);
-            Log.d(TAG, "finalWidth: " + finalWidth + ", finalHeight: " + finalHeight);
-        }
-        setMeasuredDimension(finalWidth, finalHeight);
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent event) {
-        switch (event.getAction()) {
-            case MotionEvent.ACTION_DOWN:
-                focusOnPoint((int) event.getX(), (int) event.getY()); // 点击聚焦
-                break;
-            default:
-                break;
-        }
-        return super.onTouchEvent(event);
-    }
-
-    @Override
-    public void onAutoFocus(boolean success, Camera camera) {
-        if (DEBUG) {
-            Log.d(TAG, "onAutoFocus : " + success);
-        }
-    }
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/widget/MaskView.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/widget/MaskView.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/widget/MaskView.java	(revision 6857)
@@ -1,115 +0,0 @@
-package com.sensetime.faceunlock.widget;
-
-import android.content.Context;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.graphics.PorterDuff;
-import android.graphics.PorterDuffXfermode;
-import android.graphics.Rect;
-import android.os.Build;
-import android.util.AttributeSet;
-import android.view.View;
-import android.util.Log;
-
-/**
- * 相机页面的蒙板View
- */
-public class MaskView extends View {
-
-    private static final String TAG = "MaskView";
-
-    private int left;
-    private int top;
-    private int right;
-    private int bottom;
-    private int progress; // 进度
-
-    private Paint mClearPaint;
-    private Paint mCirclePaint;
-    private Rect mMaskRect;
-    private boolean isFirstScale = true;
-
-    public MaskView(Context context) {
-        super(context);
-        init();
-    }
-
-    public MaskView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init();
-    }
-
-    private void init() {
-        mClearPaint = new Paint();
-        mClearPaint.setAntiAlias(true);
-        mClearPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));
-        mCirclePaint = new Paint();
-		mCirclePaint.setAntiAlias(true);
-        mClearPaint.setAntiAlias(true);
-        mCirclePaint.setStyle(Paint.Style.STROKE);
-        mCirclePaint.setStrokeWidth(10);
-        mMaskRect = new Rect();
-    }
-
-    public void setProgress(int progress) {
-        this.progress = progress;
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-            invalidate();
-        }
-    }
-
-    public Rect getMaskRect(float scaleX, float scaleY) {
-        if (isFirstScale) {
-            int left = (int) ((this.left - 40) / scaleX);
-            int top = (int) ((this.top + 60) / scaleY);
-            int right = (int) ((this.right + 40) / scaleX);
-            int bottom = (int) ((this.bottom + 140) / scaleY);
-            int length = left / 2;
-            mMaskRect.set(left - length, top - length, right + length, bottom + length);
-            isFirstScale = false;
-            com.sensetime.faceunlock.util.LogUtil.d(TAG, "scaleX : " + scaleX);
-            com.sensetime.faceunlock.util.LogUtil.d(TAG, "scaleY : " + scaleY);
-            com.sensetime.faceunlock.util.LogUtil.d(TAG, "left : " + left);
-            com.sensetime.faceunlock.util.LogUtil.d(TAG, "top : " + top);
-            com.sensetime.faceunlock.util.LogUtil.d(TAG, "right : " + right);
-            com.sensetime.faceunlock.util.LogUtil.d(TAG, "bottom : " + bottom);
-        }
-        return mMaskRect;
-    }
-
-    @Override
-    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-        super.onLayout(changed, left, top, right, bottom);
-        if (changed)
-            initMaskArea();
-    }
-
-    private void initMaskArea() {
-        int width = getWidth();
-        int length = width / 6;
-        left = length;
-        top = length; // 上下蒙板区域固定
-        right = length * 5;
-        bottom = length * 5;
-    }
-
-    @Override
-    protected void onDraw(Canvas canvas) {
-        super.onDraw(canvas);
-            float cx = (left + right) >> 1;
-            float cy = (top + bottom + 200) >> 1;
-            float radius = (right - left) >> 1;
-            float radius1 = 280;
-			float temp = radius1 - radius;
-            canvas.drawCircle(cx, cy, radius1, mClearPaint);
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-            mCirclePaint.setColor(0xffaaaaaa);
-            canvas.drawCircle(cx, cy, radius1, mCirclePaint);
-            mCirclePaint.setColor(0xff2EA8FC);
-            float sweepAngle = progress * 360 / 100.0f;
-            com.sensetime.faceunlock.util.LogUtil.d(TAG, "sweepAngle: " + sweepAngle);
-            canvas.drawArc(left - temp , top - temp +100 , right + temp , bottom + temp +100, -90, sweepAngle, false, mCirclePaint);
-        }
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/bean/User.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/bean/User.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/bean/User.java	(revision 6857)
@@ -1,70 +0,0 @@
-package com.sensetime.faceunlock.bean;
-
-public class User {
-
-	private String userId; // 不同人的 userId 不同，同一人的 userId 相同
-	private String name;
-	private String feature; // 特征值
-	private String imagePath;
-	private int isDisplay; // 是否显示（用户管理时只显示正方向的人脸）
-
-	public User() {
-	}
-
-	public User(String userId, String name, String feature, String imagePath, int isDisplay) {
-		this.userId = userId;
-		this.name = name;
-		this.feature = feature;
-		this.imagePath = imagePath;
-		this.isDisplay = isDisplay;
-	}
-
-	public String getUserId() {
-		return userId;
-	}
-
-	public void setUserId(String userId) {
-		this.userId = userId;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public void setName(String name) {
-		this.name = name;
-	}
-
-	public String getFeature() {
-		return feature;
-	}
-
-	public void setFeature(String feature) {
-		this.feature = feature;
-	}
-
-	public String getImagePath() {
-		return imagePath;
-	}
-
-	public void setImagePath(String imagePath) {
-		this.imagePath = imagePath;
-	}
-
-	public int getIsDisplay() {
-		return isDisplay;
-	}
-
-	public void setIsDisplay(int isDisplay) {
-		this.isDisplay = isDisplay;
-	}
-
-	@Override
-	public String toString() {
-		return "User{" +
-				"name='" + name + '\'' +
-				", imagePath='" + imagePath + '\'' +
-				'}';
-	}
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/bean/FaceFeature.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/bean/FaceFeature.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/bean/FaceFeature.java	(revision 6857)
@@ -1,19 +0,0 @@
-package com.sensetime.faceunlock.bean;
-
-import com.sensetime.faceapi.model.FaceInfo;
-
-public class FaceFeature {
-
-    public FaceInfo faceInfo; // 人脸
-    public byte[] nv21; // 当前帧的 nv21 数据
-    public int width; // 图片宽度
-    public int height; // 图片高度
-
-    public FaceFeature(FaceInfo faceInfo, byte[] nv21, int width, int height) {
-        this.faceInfo = faceInfo;
-        this.nv21 = nv21;
-        this.width = width;
-        this.height = height;
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/config/AppConfig.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/config/AppConfig.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/config/AppConfig.java	(revision 6857)
@@ -1,24 +0,0 @@
-package com.sensetime.faceunlock.config;
-
-import android.content.Context;
-import com.sensetime.faceunlock.util.LogUtil;
-import com.sensetime.faceunlock.util.SPUtil;
-
-public class AppConfig {
-
-    private static final String TAG = "AppConfig";
-    public static float threshold = 0.65f; // 人脸比对阈值
-    public static int attemptCount = 2; // 重试次数
-    public static boolean isOpenHacker = false; // 活体检测开关
-
-    /*static {
-        Context context = SystemUIApplication.getInstance();
-        threshold = (Float) SPUtil.get(context, SPUtil.THRESHOLD_KEY, 0.65f);
-        attemptCount = (Integer) SPUtil.get(context, SPUtil.TRY_COUNT_KEY, 2);
-        isOpenHacker = (Boolean) SPUtil.get(context, SPUtil.IS_OPEN_LIVENESS, false);
-        LogUtil.d(TAG, "threshold: " + threshold);
-        LogUtil.d(TAG, "attemptCount: " + attemptCount);
-        LogUtil.d(TAG, "isOpenHacker: " + isOpenHacker);
-    }*/
-
-}
Index: frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/db/SQLHelper.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/db/SQLHelper.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/sensetime/faceunlock/db/SQLHelper.java	(revision 6857)
@@ -1,146 +0,0 @@
-package com.sensetime.faceunlock.db;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import android.content.ContentValues;
-import android.content.Context;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteDatabase.CursorFactory;
-import android.database.sqlite.SQLiteOpenHelper;
-import com.sensetime.faceunlock.bean.User;
-import com.sensetime.faceunlock.util.LogUtil;
-
-public class SQLHelper extends SQLiteOpenHelper {
-
-    public static final String TAG = "SQLHelper";
-
-    private static final String DATABASE_NAME = "user.db";
-    private static final String TABLE_NAME = "user";
-    private static final int VERSION = 1;
-
-    private static final String ID = "id";
-    private static final String USER_ID = "user_id"; // 一个人的唯一识别号
-    private static final String NAME = "name"; // 姓名
-    private static final String FEATURE = "feature"; // 特征值
-    private static final String IMAGE_PATH = "image_path"; // 图片路径
-    private static final String IS_DISPLAY = "is_display"; // 显示时一个人只会显示一张图片即可，用0表示不显示，1表示显示
-
-    private static SQLHelper instance;
-
-    public static SQLHelper getInstance(Context context) {
-        if (instance == null) {
-            instance = new SQLHelper(context.getApplicationContext(), DATABASE_NAME, null, VERSION);
-        }
-        return instance;
-    }
-
-    public SQLHelper(Context context, String name, CursorFactory factory, int version) {
-        super(context, name, factory, version);
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-        String sql = "CREATE TABLE " + TABLE_NAME + "(" + ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + USER_ID +
-                " TEXT," + NAME + " TEXT," + IMAGE_PATH + " TEXT," + FEATURE + " TEXT," + IS_DISPLAY + " INTEGER)";
-        db.execSQL(sql);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-    }
-
-    // 增
-    public void add(User user) {
-        SQLiteDatabase db = instance.getWritableDatabase();
-        ContentValues values = new ContentValues();
-        values.put(USER_ID, user.getUserId());
-        values.put(NAME, user.getName());
-        values.put(IMAGE_PATH, user.getImagePath());
-        values.put(FEATURE, user.getFeature());
-        values.put(IS_DISPLAY, user.getIsDisplay());
-        db.insert(TABLE_NAME, null, values);
-        db.close();
-        LogUtil.v(TAG, "db add " + user.toString());
-    }
-
-    // 增
-    public void add(List<User> users) {
-        SQLiteDatabase db = instance.getWritableDatabase();
-        ContentValues values = new ContentValues();
-        for (User user : users) {
-            values.clear();
-            values.put(USER_ID, user.getUserId());
-            values.put(NAME, user.getName());
-            values.put(IMAGE_PATH, user.getImagePath());
-            values.put(FEATURE, user.getFeature());
-            values.put(IS_DISPLAY, user.getIsDisplay());
-            db.insert(TABLE_NAME, null, values);
-            LogUtil.v(TAG, "db add " + user.toString());
-        }
-        db.close();
-    }
-
-    // 查所有
-    public List<User> queryAll() {
-        ArrayList<User> list = new ArrayList<User>();
-        SQLiteDatabase db = instance.getWritableDatabase();
-        Cursor cursor = db.query(TABLE_NAME, null, null, null, null, null, null);
-        while (cursor.moveToNext()) {
-            User user = new User();
-            user.setUserId(cursor.getString(cursor.getColumnIndex(USER_ID)));
-            user.setName(cursor.getString(cursor.getColumnIndex(NAME)));
-            user.setImagePath(cursor.getString(cursor.getColumnIndex(IMAGE_PATH)));
-            user.setFeature(cursor.getString(cursor.getColumnIndex(FEATURE)));
-            user.setIsDisplay(cursor.getInt(cursor.getColumnIndex(IS_DISPLAY)));
-            list.add(user);
-            LogUtil.v(TAG, "list add " + user.toString());
-        }
-        db.close();
-        LogUtil.v(TAG, "list size: " + list.size());
-        return list;
-    }
-    
-    // 查所有
-    public List<User> queryDisplay() {
-    	ArrayList<User> list = new ArrayList<User>();
-    	SQLiteDatabase db = instance.getWritableDatabase();
-        String sql = "select * from " + TABLE_NAME + " where " + IS_DISPLAY + "=" + 1;
-        Cursor cursor = db.rawQuery(sql, null);
-    	while (cursor.moveToNext()) {
-    		User user = new User();
-    		user.setUserId(cursor.getString(cursor.getColumnIndex(USER_ID)));
-    		user.setName(cursor.getString(cursor.getColumnIndex(NAME)));
-    		user.setImagePath(cursor.getString(cursor.getColumnIndex(IMAGE_PATH)));
-    		user.setFeature(cursor.getString(cursor.getColumnIndex(FEATURE)));
-    		user.setIsDisplay(cursor.getInt(cursor.getColumnIndex(IS_DISPLAY)));
-    		list.add(user);
-            LogUtil.v(TAG, "list add " + user.toString());
-    	}
-    	db.close();
-        LogUtil.v(TAG, "list size: " + list.size());
-    	return list;
-    }
-
-    // 删
-    public void delete(String userId) {
-        SQLiteDatabase db = instance.getWritableDatabase();
-        int deleteCount = db.delete(TABLE_NAME, USER_ID + "='" + userId + "'", null);
-        if (deleteCount == 1) {
-            LogUtil.v(TAG, "db delete: " + userId);
-        }
-        db.close();
-    }
-
-    /**
-     * 删除所有
-     */
-    public void deleteAllData() {
-        SQLiteDatabase db = instance.getWritableDatabase();
-        int deleteCount = db.delete(TABLE_NAME, null, null);
-        LogUtil.v(TAG, "db delete count: " + deleteCount);
-        db.close();
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/face/scanner/FaceService.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/face/scanner/FaceService.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/face/scanner/FaceService.java	(revision 6857)
@@ -1,631 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-
-package com.face.scanner;
-
-import android.R.integer;
-import android.app.AlertDialog;
-import android.app.Service;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.os.Binder;
-import android.os.Bundle;
-import android.os.Debug;
-import android.os.HandlerThread;
-import android.os.IBinder;
-import android.os.Message;
-import android.os.Looper;
-import android.os.Process;
-import android.os.Environment;
-import android.os.Handler;
-import android.os.RemoteException;
-import android.os.Vibrator;
-import android.view.Gravity;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.WindowManager;
-import android.view.SurfaceHolder;
-import android.view.Window;
-import android.view.WindowManagerGlobal;
-import android.view.IWindowManager;
-import android.view.IApplicationToken;
-import android.graphics.PixelFormat;
-import android.graphics.Color;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Rect;
-
-import java.io.File;
-import android.content.res.Configuration;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.ComponentName;
-import android.content.SharedPreferences;
-import android.content.SharedPreferences.Editor;
-import android.content.ServiceConnection;
-import android.preference.PreferenceManager;
-import android.hardware.Camera;
-import android.media.MediaPlayer;
-import android.util.DisplayMetrics;
-import android.util.Log;
-import android.widget.FrameLayout;
-import android.widget.LinearLayout;
-import android.widget.TextView;
-import android.widget.Toast;
-import android.provider.Settings;
-import java.util.List;
-import java.util.ArrayList;
-
-import com.face.scanner.view.CameraSurfaceView;
-
-
-import com.face.scanner.view.RoundProgressBar;
-
-import com.android.internal.policy.IFaceService;
-import com.android.internal.policy.IFaceStateCallback;
-import com.android.internal.policy.IKeyguardService;
-import com.sensetime.faceapi.FaceLibrary;
-import com.sensetime.faceapi.model.CvPixelFormat;
-import com.sensetime.faceapi.model.FaceInfo;
-import com.sensetime.faceapi.utils.AccelerometerManager;
-import com.sensetime.faceunlock.bean.FaceFeature;
-import com.sensetime.faceunlock.bean.User;
-import com.sensetime.faceunlock.config.AppConfig;
-import com.sensetime.faceunlock.manager.DetectProxy;
-import com.sensetime.faceunlock.manager.HackerProxy;
-import com.sensetime.faceunlock.manager.VerifyProxy;
-import com.sensetime.faceunlock.util.BrightnessHelper;
-import com.sensetime.faceunlock.util.LogUtil;
-import com.sensetime.faceunlock.widget.CameraView;
-
-import android.widget.RelativeLayout;
-
-import com.android.keyguard.R;
-import com.android.internal.policy.IFaceOverTimeCallback;
-
-import com.android.keyguard.KeyguardUpdateMonitor;
-import android.content.SharedPreferences;
-
-public class FaceService extends Service {
-    static final String TAG = "FaceService";
-    private WindowManager mWindowManager;
-    private WindowManager.LayoutParams mLayoutParams;
-    private LayoutInflater mLayoutInflater;
-    private View mFaceView;
-    private boolean mViewAttatched = false;
-    private IFaceStateCallback mStateCallback;
-	private IFaceOverTimeCallback mOverTimeCallback;
-    private Handler mHandler;
-    // Its Add
-    private String mShowUI = null;
-    boolean mAsyncTaskRunning = false;
-    boolean mFaceState = true;
-    private CameraView cameraView;
-    private byte[] nv21; // nv21的数据
-    private volatile boolean isTracking; // 是否正在进行track操作
-    private boolean isVerifying; // 是否正在进行verify操作
-    private volatile boolean isNv21DataReady; // 判断nv21的数据是否拷贝完成
-    private Thread trackThread; // 进行Track的线程
-    private volatile boolean isKilled; // 控制Track线程是否停止
-    private HandlerThread verifyThread; // 进行Verify的线程
-    private Handler verifyHandler; // 进行Verify的线程的Handler对象
-    private User user; // verify通过，即存储检测到的User
-    private boolean isNotHacker; // 是否为活体
-    private int attemptCount; // 重试次数
-    public static final int START_FACE_VERIFY = 101;
-    public static final int STOP_FACE_VERIFY = 102;
-    private static final int MODE_INIT = 0;
-    private static final int MODE_SWITCH_TO_PRIVACY = 1;
-    private static final int MODE_UNLOCK_PRIVACY = 2;
-    private int mPrivacyMode = MODE_INIT;
-    public static final String KEYGUARD_PACKAGE = "com.android.systemui";
-    public static final String KEYGUARD_CLASS = "com.android.systemui.keyguard.KeyguardService";
-    private IKeyguardService mKeyguardService;
-    private ArrayList<IFaceStateCallback> mCallbacks;
-    private ArrayList<IFaceOverTimeCallback> mFaceOverTimeCallbacks;
-	
-    boolean mIsNotGetFaceInfo = false;
-    final Handler handler = new Handler();
-    Runnable runnable = new Runnable() {    
-        @Override    
-        public void run() {
-            LogUtil.d(TAG,"...............Runnable mIsNotGetFaceInfo="+mIsNotGetFaceInfo);
-            if(mIsNotGetFaceInfo){
-                if (mBrightnessChanged) {
-                    BrightnessHelper.setScreenBrightness(FaceService.this, mLastScreenBrightness);
-                    BrightnessHelper.setScreenMode(FaceService.this, mLastScreenMode);
-                    mBrightnessChanged = false;
-                }
-                //Toast.makeText(FaceService.this.getApplicationContext(), R.string.face_face_get, Toast.LENGTH_SHORT).show();
-				if(/*mOverTimeCallback != null*/mFaceOverTimeCallbacks != null && mFaceOverTimeCallbacks.size() > 0){
-					try{
-						//mOverTimeCallback.faceOverTime();
-                        for (IFaceOverTimeCallback iFaceOverTimeCallback : mFaceOverTimeCallbacks) {
-                            iFaceOverTimeCallback.faceOverTime();
-                        }
-					}catch (RemoteException e) {
-						e.printStackTrace();
-					}
-				}
-			}
-			stopSelf();
-        }    
-    };   
-
-    private int mLastScreenMode;
-    private int mLastScreenBrightness;
-    private boolean mBrightnessChanged = false;
-    private static final float BRIGHT_MIN = 0.12f;
-
-    private static final String PREF_NAME = "user_pref";
-    private static final String KEY_AUTH_SUCCESS_BEFORE = "auth_success_before";
-    private KeyguardUpdateMonitor mKeyguardUpdateMonitor;
-    private SharedPreferences mPref;
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        Log.d(TAG, "FaceService:onCreate()");
-        /*Settings.System.putInt(getContentResolver(),
-                Settings.System.FACE_VERIFY_SERVICE_RUN, 1);zxp*/
-        sendFaceBrodcast(START_FACE_VERIFY);
-        mWindowManager = (WindowManager) getApplicationContext()
-                .getSystemService(Context.WINDOW_SERVICE);
-        /*mShowUI = Settings.System.getStringForUser(getContentResolver(),
-                Settings.System.FACE_SCAN_SHOW_UI, 0);zxp*/
-        mShowUI = (mShowUI == null) ? "0":mShowUI;
-        mFaceState = true;
-
-        mLayoutInflater = LayoutInflater.from(this);
-        mHandler = new Handler();
-        mCallbacks = new ArrayList<IFaceStateCallback>();
-        mFaceOverTimeCallbacks = new ArrayList<IFaceOverTimeCallback>();
-        DetectProxy.init();
-        VerifyProxy.init(this);
-        if (AppConfig.isOpenHacker)
-            HackerProxy.init();
-
-        createView();
-        initUI();
-        handler.postDelayed(runnable, 2500);
-        mKeyguardUpdateMonitor = KeyguardUpdateMonitor.getInstance(getApplicationContext());
-        mPref = getApplicationContext().getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
-    }
-
-    @Override
-    public void onStart(Intent intent, int startId) {
-        // TODO Auto-generated method stub
-        Log.d(TAG, "FaceService:onStart()");
-        super.onStart(intent, startId);
-    }
-
-    private void bindKeyguardService(){
-        Intent bindKeyguardIntent = new Intent();
-        bindKeyguardIntent.setClassName(KEYGUARD_PACKAGE, KEYGUARD_CLASS);
-        if (bindService(bindKeyguardIntent, mKeyguardConn,
-                Context.BIND_AUTO_CREATE)) {
-            Log.d(TAG, "---bindKeyguardService sucess---");
-        } else {
-            Log.d(TAG, "---bindKeyguardService failed---");
-        }
-    }
-
-    private ServiceConnection mKeyguardConn = new ServiceConnection() {
-        @Override
-        public void onServiceConnected(ComponentName name, IBinder service) {
-            Log.v(TAG, "*** Keyguard connected (yay!)");
-            mKeyguardService = IKeyguardService.Stub.asInterface(service);
-			//unlock();//ADD ZXP
-			
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName name) {
-            Log.v(TAG, "*** Keyguard disconnected (boo!)");
-            mKeyguardService = null;
-        }
-    };
-
-    private void createView() {
-        mFaceView = mLayoutInflater.inflate(R.layout.face_service_view, null);
-        mLayoutParams = new WindowManager.LayoutParams();
-        mLayoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
-        mLayoutParams.height = WindowManager.LayoutParams.WRAP_CONTENT;
-        mLayoutParams.gravity = Gravity.TOP;
-        mLayoutParams.type = WindowManager.LayoutParams.TYPE_PHONE;
-        mLayoutParams.format = PixelFormat.RGBA_8888;
-        mLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
-    }
-
-    private void initUI() {
-        cameraView = (CameraView) mFaceView.findViewById(R.id.camera_view);
-        cameraView.setVisibility(View.INVISIBLE);// added by iuv luyang
-        cameraView.setPreviewCallback(new Camera.PreviewCallback() {
-
-            @Override
-            public void onPreviewFrame(byte[] data, Camera camera) {
-                Log.d(TAG, "onPreviewFrame");
-                // add by wuyongchao for bug 106825 begin
-                if(data == null){
-                    data = new byte[777600];
-                }
-               // add by wuyongchao for bug 106825 end
-                if (nv21 == null || data.length != nv21.length) {
-                    nv21 = new byte[data.length];
-                }
-                if (!isTracking && !isVerifying) {
-                    synchronized (nv21) {
-                        System.arraycopy(data, 0, nv21, 0, data.length);
-                        isNv21DataReady = true;
-                        data = null;
-                    }
-                }
-                cameraView.addCallbackBuffer();
-            }
-        });
-
-        if (mShowUI.equals("0")) {
-
-        }
-
-    }
-
-    private void startIdenTask() {
-        Log.d(TAG, "startIdenTask");
-        AccelerometerManager.start(this);
-        isKilled = false;
-        cameraView.restartCamera();
-        trackThread = new Thread() {
-            @Override
-            public void run() {
-                while (!isKilled && !Thread.interrupted()) {
-                    if (isNv21DataReady) {
-                        isTracking = true;
-                        synchronized (nv21) {
-                            FaceInfo[] faces = DetectProxy.detect(nv21,
-                                    cameraView.mPreviewWidth,
-                                    cameraView.mPreviewHeight);
-                            FaceInfo faceInfo = filterFaces(faces);
-                            if(faceInfo == null){
-                                mIsNotGetFaceInfo = true;
-                            }else{
-                                mIsNotGetFaceInfo = false;
-                            }
-                            LogUtil.i(TAG,"...mIsNotGetFaceInfo="+mIsNotGetFaceInfo);
-                            maxBrightnessIfNeed(nv21, faceInfo);
-                            if (!isKilled) {
-                                analysis(faceInfo);
-                            }
-                        }
-                        isTracking = false;
-                        isNv21DataReady = false;
-                        nv21 = null;
-                    }
-                }
-            }
-        };
-        trackThread.start();
-        initGetFeatureThread(); // 初始化GetFeature的线程
-    }
-
-    private void maxBrightnessIfNeed(byte[] nv21, FaceInfo faceInfo) {
-        if (nv21 == null || nv21.length == 0 || faceInfo == null) {
-            return;
-        }
-        //mLastScreenMode = BrightnessHelper.getScreenMode(this);
-        //mLastScreenBrightness = BrightnessHelper.getScreenBrightness(this);
-        Rect rect = faceInfo.faceRect;
-        float brightness = FaceLibrary.averageBrightness(nv21, CvPixelFormat.NV21, cameraView.mPreviewWidth, cameraView.mPreviewHeight, rect.left, rect.top, rect.width(), rect.height());
-        if (brightness < BRIGHT_MIN && !mBrightnessChanged) {
-            mLastScreenMode = BrightnessHelper.getScreenMode(this);
-            mLastScreenBrightness = BrightnessHelper.getScreenBrightness(this);
-            mBrightnessChanged = true;
-            BrightnessHelper.setScreenMode(this, 0);
-            BrightnessHelper.setScreenBrightness(this, 255);
-        }
-    }
-
-    private FaceInfo filterFaces(FaceInfo[] faces) {
-        if (faces == null || faces.length <= 0) {
-            return null;
-        }
-        FaceInfo faceInfo = null;
-        for (int i = 0; i < faces.length; i++) {
-            if (faceInfo == null
-                    || faces[i].faceRect.width() > faceInfo.faceRect.width()) {
-                faceInfo = faces[i];
-            }
-        }
-        return faceInfo;
-    }
-
-    private void analysis(FaceInfo faceInfo) {
-        if (faceInfo == null || isVerifying) {
-            return;
-        }
-        isVerifying = true;
-        Message msg = Message.obtain(verifyHandler);
-        msg.obj = new FaceFeature(faceInfo, nv21, cameraView.mPreviewWidth,
-                cameraView.mPreviewHeight);
-        verifyHandler.sendMessage(msg);
-    }
-
-    private void initGetFeatureThread() {
-        verifyThread = new HandlerThread("VerifyThread");
-        verifyThread.start();
-        verifyHandler = new Handler(verifyThread.getLooper()) {
-            @Override
-            public void handleMessage(Message msg) {
-                FaceFeature faceFeature = (FaceFeature) msg.obj;
-                handleFeature(faceFeature);
-            }
-        };
-    }
-
-    private void handleFeature(FaceFeature faceFeature) {
-		Log.d("zxp","faceFeature = "+faceFeature);
-        if (faceFeature == null) {
-            return;
-        }
-
-        // 做一次 verify 和 hacker，如果某次已经检测出来结果并且通过了，则不再重复检测
-        if (user == null) {
-            user = VerifyProxy.isPass(faceFeature, this);
-        }
-        if (!isNotHacker) {
-            isNotHacker = HackerProxy.isPass(faceFeature,
-                    cameraView.isFrontCamera());
-        }
-
-        attemptCount++;
-        LogUtil.d(TAG, "attemptCount: " + attemptCount);
-        // 达到重试次数上限时，发送结果，否则继续进行检测
-        if ((user != null && isNotHacker)
-                || attemptCount >= AppConfig.attemptCount) {
-            cameraView.setPreviewCallback(null);
-            if (!isKilled) {
-                cameraView.stopPreview();
-            }
-			Log.d("zxp","user = "+user+"isNotHacker = "+isNotHacker);
-            analyseResult(user, isNotHacker);
-        } else {
-            isVerifying = false;
-			Vibrator vib = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
-            vib.vibrate(100);
-        }
-    }
-
-    private void analyseResult(User user, boolean isNotHacker) {
-        if (mBrightnessChanged) {
-            BrightnessHelper.setScreenBrightness(this, mLastScreenBrightness);
-            BrightnessHelper.setScreenMode(this, mLastScreenMode);
-            mBrightnessChanged = false;
-        }
-        if (user != null && isNotHacker) {
-            try {
-				unlock();
-                //mStateCallback.onIdentifyResult(true);
-                if (mCallbacks != null && mCallbacks.size() > 0) {
-                    for (IFaceStateCallback iFaceStateCallback : mCallbacks) {
-                        iFaceStateCallback.onIdentifyResult(true);
-                    }
-                }
-            } catch (RemoteException e) {
-                e.printStackTrace();
-            }
-        } else {
-            try {
-                //mStateCallback.onIdentifyResult(false);
-                if (mCallbacks != null && mCallbacks.size() > 0) {
-                    for (IFaceStateCallback iFaceStateCallback : mCallbacks) {
-                        iFaceStateCallback.onIdentifyResult(false);
-                    }
-                }
-            } catch (RemoteException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    private void unlock() {
-        try {
-            if (mKeyguardService != null) {
-                boolean isAuthSuccessBefore = mPref.getBoolean(KEY_AUTH_SUCCESS_BEFORE, false);
-                boolean faceAuthLockscreenOngoing =
-                    mKeyguardUpdateMonitor.isFaceAuthLockscreenOngoing();
-
-                if (isAuthSuccessBefore && !faceAuthLockscreenOngoing) {
-                    mKeyguardService.keyguardDone(false,true);
-                    Log.d(TAG, "---unlock sucess------");
-                } else {
-                    mKeyguardService.dismiss(false);
-                    mKeyguardUpdateMonitor.setFaceAuthLockscreenOngoing(true);
-
-                    Editor editor = mPref.edit();
-                    editor.putBoolean(KEY_AUTH_SUCCESS_BEFORE, true);
-                    editor.commit();
-
-                    Log.d(TAG, "---unlock password is needed------");
-                }
-            }
-        } catch (Exception e) {
-            Log.d(TAG, "---unlock failed---");
-        }
-    }
-
-    private void stopThread() {
-        isKilled = true;
-        if (trackThread != null) {
-            try {
-                trackThread.interrupt();
-                trackThread.join();
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }
-        }
-        if (verifyThread != null) {
-            verifyThread.quitSafely();
-            verifyThread = null;
-        }
-    }
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        sendFaceBrodcast(START_FACE_VERIFY);
-        mAsyncTaskRunning = false;
-        if (!mViewAttatched && mFaceView != null && mFaceState && mShowUI.equals("1")) {
-            Log.d(TAG, "$$$$ onBind:addView $$$$ ");
-            mWindowManager.addView(mFaceView, mLayoutParams);
-            mViewAttatched = true;
-        }
-        mPrivacyMode = intent.getIntExtra("privacyState", MODE_INIT);
-        /*if (mPrivacyMode == MODE_UNLOCK_PRIVACY) {
-            bindKeyguardService();
-        }zxp*/
-		bindKeyguardService();
-		Log.d(TAG, "zxp");
-        return mBinder;
-    }
-
-    @Override
-    public boolean onUnbind(Intent intent) {
-        if (mViewAttatched) {
-            Log.d(TAG, "$$$$ onUnbind:removeView $$$$ ");
-            mWindowManager.removeView(mFaceView);
-            mViewAttatched = false;
-            cameraView.setPreviewCallback(null);
-        }
-        if (mPrivacyMode == MODE_UNLOCK_PRIVACY) {
-            unbindService(mKeyguardConn);
-        }
-		if(handler != null){
-			handler.removeCallbacks(runnable);
-		}
-        stopIdentify();
-        sendFaceBrodcast(STOP_FACE_VERIFY);
-        return false;
-    }
-
-    @Override
-    public void onDestroy() {
-        Log.d(TAG, "$$$$ onDestroy $$$$ ");
-        stopIdentify();
-        cameraView.releaseCamera();
-        if (mViewAttatched) {
-            mWindowManager.removeView(mFaceView);
-            mViewAttatched = false;
-        }
-        if (mCallbacks != null) {
-            mCallbacks.clear();
-            mCallbacks = null;
-        }
-
-        if (mFaceOverTimeCallbacks != null) {
-            mFaceOverTimeCallbacks.clear();
-            mFaceOverTimeCallbacks = null;
-        }
-        mHandler.removeCallbacks(mKillSelfRunnable);
-        //DetectProxy.release();
-        //VerifyProxy.release();
-        /*Settings.System.putInt(getContentResolver(),
-                Settings.System.FACE_VERIFY_SERVICE_RUN, 0);zxp*/
-        if (AppConfig.isOpenHacker)
-            HackerProxy.release();
-    }
-
-    private void sendFaceBrodcast(int flag){
-        Intent mIntent = new Intent();
-        if (flag == START_FACE_VERIFY) {
-            mIntent.setAction("action_start_face_verity");
-        } else if (flag == STOP_FACE_VERIFY){
-            mIntent.setAction("action_stop_face_verity");
-        }
-        this.getApplicationContext().sendBroadcast(mIntent);
-
-    }
-
-    private Runnable mRetryIdentifyRunnable = new Runnable() {
-        @Override
-        public void run() {
-            Log.d(TAG, "try to start identify runnable");
-            startIdenTask();
-        }
-    };
-
-    private Runnable mKillSelfRunnable = new Runnable() {
-        @Override
-        public void run() {
-            stopSelf();
-        }
-    };
-
-    public void startIdentify() {
-        Log.d(TAG, "$$$$ startIdentify $$$$,mAsyncTaskRunning= "
-                + mAsyncTaskRunning);
-        if (!mAsyncTaskRunning) {
-            mAsyncTaskRunning = true;
-            mHandler.post(mRetryIdentifyRunnable);
-        }
-
-        mHandler.removeCallbacks(mKillSelfRunnable);
-        mHandler.postDelayed(mKillSelfRunnable, 1000*5);
-    }
-
-    public void stopIdentify() {
-        Log.d(TAG, "$$$$ stopIdentify $$$$ ");
-        stopThread();
-        if (mAsyncTaskRunning) {
-            mHandler.removeCallbacks(mRetryIdentifyRunnable);
-            mAsyncTaskRunning = false;
-        }
-        if (mBrightnessChanged) {
-            BrightnessHelper.setScreenBrightness(this, mLastScreenBrightness);
-            BrightnessHelper.setScreenMode(this, mLastScreenMode);
-            mBrightnessChanged = false;
-        }
-        AccelerometerManager.stop();
-    }
-
-    private final IFaceService.Stub mBinder = new IFaceService.Stub() {
-
-        @Override
-        // Binder interface
-        public void setStateCallback(IFaceStateCallback callback) {
-            //mStateCallback = callback;
-            mCallbacks.add(callback);
-        }
-		
-		@Override
-        // Binder interface
-        public void faceOverTimeCallback(IFaceOverTimeCallback callback) {
-            //mOverTimeCallback = callback;
-            mFaceOverTimeCallbacks.add(callback);
-        }
-
-        @Override
-        // Binder interface
-        public void startFaceIdentify() {
-            startIdentify();
-        }
-
-       @Override
-        // Binder interface
-        public void stopFaceIdentify() {
-            stopIdentify();
-        }
-
-    };
-}
Index: frameworks/base/packages/Keyguard/src/com/face/scanner/BootCompleteReceiver.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/face/scanner/BootCompleteReceiver.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/face/scanner/BootCompleteReceiver.java	(revision 6857)
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.face.scanner;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.util.Log;
-import android.os.RemoteException;
-import android.app.ActivityManagerNative;
-import android.provider.Settings;
-import android.os.UserManager;
-import android.content.pm.UserInfo;
-import com.android.keyguard.R;
-import java.util.List;
-
-/**
- * A proxy for Recents events which happens strictly for non-owner users.
- */
-public class BootCompleteReceiver extends BroadcastReceiver {
-    private static final String TAG = "BootCompleteReceiver";
-
-	@Override  
-	public void onReceive(final Context context, final Intent intent) {  
-		Log.d(TAG, "onReceive");  
-		String action = intent.getAction();  
-	   
-		if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {	
-			Log.d(TAG, "boot completed");
-			/*String state = Settings.System.getStringForUser(context.getContentResolver(),Settings.System.PRIVACY_SPACE_ENABLED, 0);zxp*/
-			String state ="0";
-            if (state == null) {
-                state = "0";
-            }
-			if(state.equals("1")) { 	
-				initPrivacySpace(context);
-			}
-		}
-	}  
-
-    private void initPrivacySpace(final Context context) {
-        /*String state = Settings.System.getStringForUser(context.getContentResolver(),Settings.System.PRIVACY_SPACE_STATE, 0);zxp*/
-		String state ="0";
-        try{
-            if(state.equals("0")) {		
-                UserManager um= (UserManager) context.getSystemService(Context.USER_SERVICE);		
-                UserInfo user = um.createUser(context.getString(R.string.privacy_data),UserInfo.FLAG_ADMIN);
-                /*Settings.System.putStringForUser(context.getContentResolver(),Settings.System.PRIVACY_USER_ID,""+user.id, 0);zxp*/
-                ActivityManagerNative.getDefault().startUserInBackground(user.id);
-                //user = um.createUser("clone",UserInfo.FLAG_ADMIN);
-                //Settings.System.putStringForUser(getContentResolver(),Settings.System.CLONE_USER_ID,""+user.id, 0);
-                //ActivityManagerNative.getDefault().startUserInBackground(user.id);
-                /*Settings.System.putStringForUser(context.getContentResolver(),Settings.System.PRIVACY_SPACE_STATE,"1", 0);zxp*/
-            } else {
-                String userID="0";
-    			/*userID = Settings.System.getStringForUser(context.getContentResolver(),Settings.System.PRIVACY_USER_ID, 0);zxp*/
-    			int id = Integer.parseInt(userID);
-    		    ActivityManagerNative.getDefault().startUserInBackground(id);
-    			//userID = Settings.System.getStringForUser(getContentResolver(),Settings.System.CLONE_USER_ID, 0);
-    			//int id = Integer.parseInt(userID);	
-    		    //ActivityManagerNative.getDefault().startUserInBackground(id);
-            } 
-        }catch(Exception re) {
-            Log.e(TAG, "Couldn't switch user " + re);
-        }
-
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/face/scanner/FaceViewCloseNotifiy.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/face/scanner/FaceViewCloseNotifiy.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/face/scanner/FaceViewCloseNotifiy.java	(revision 6857)
@@ -1,51 +0,0 @@
-package com.face.scanner;
-
-
-import android.app.Notification;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
-import com.android.keyguard.R;
-import android.graphics.BitmapFactory;
-
-public class FaceViewCloseNotifiy {
-	private static final int NOTIFICATION_FLAG = 1;  
-	Context mContext = null;;
-	NotificationManager mNotificationManager = null;
-	PendingIntent pendingIntent  = null;
-	Intent mIntent = null;
-	long[] vibs={800,800,800,800};
-	Uri uri = null;
-	public FaceViewCloseNotifiy(Context context) {
-		super();
-		// TODO Auto-generated constructor stub
-		this.mContext=context;
-		mNotificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
-		mIntent = new Intent();
-		mIntent.setClassName("com.android.settings", "com.android.settings.face.FaceSettingMainActivity");
-		mIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 
-		pendingIntent = PendingIntent.getActivity(context, 0,  
-				mIntent, 0);
-		uri=Uri.parse("/system/media/audio/notifications/pixiedust.ogg");
-	}
-    public void showNotify() 
-    {
-    	Notification notify = new Notification.Builder(mContext)
- //       .setTicker("Ticker")
-       // .setSmallIcon(R.drawable.face_notify)
-		/*  .setLargeIcon(BitmapFactory.decodeResource(
-                        mContext.getResources(), R.drawable.face_big_notify))*/
- //       .setVibrate(vibs)
-          .setContentTitle(mContext.getString(R.string.face_notify_view_title))
-          .setContentText(mContext.getString(R.string.face_notify_view_text))
-          .setContentIntent(pendingIntent)
-          .setAutoCancel(true)
-//        .setDefaults(NotificationCompat.DEFAULT_LIGHTS)
-          .setNumber(1)
-          .setSound(uri)
-          .build();
-    	mNotificationManager.notify(NOTIFICATION_FLAG, notify); 
-    }
-}
Index: frameworks/base/packages/Keyguard/src/com/face/scanner/PrivacySpaceActivity.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/face/scanner/PrivacySpaceActivity.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/face/scanner/PrivacySpaceActivity.java	(revision 6857)
@@ -1,503 +0,0 @@
-package com.face.scanner;
-
-import android.R.integer;
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.hardware.Camera;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Message;
-import android.os.Vibrator;
-import android.provider.Settings;
-import android.util.Log;
-import android.view.Window;
-import android.view.WindowManager;
-import android.widget.Toast;
-
-import com.android.keyguard.R;
-import com.android.keyguard.KeyguardUtils;
-import com.sensetime.faceapi.model.FaceInfo;
-import com.sensetime.faceapi.utils.AccelerometerManager;
-import com.sensetime.faceunlock.bean.FaceFeature;
-import com.sensetime.faceunlock.bean.User;
-import com.sensetime.faceunlock.config.AppConfig;
-import com.sensetime.faceunlock.manager.DetectProxy;
-import com.sensetime.faceunlock.manager.HackerProxy;
-import com.sensetime.faceunlock.manager.TrackProxy;
-import com.sensetime.faceunlock.manager.UserManager;
-import com.sensetime.faceunlock.manager.VerifyProxy;
-import com.sensetime.faceunlock.util.LogUtil;
-import com.sensetime.faceunlock.widget.CameraView;
-
-import android.view.View;
-import android.provider.Settings;
-//Begin: Add by junwei.shen for bug-98638 at 2017.7.2
-import android.os.Looper;
-import android.widget.TextView;
-//End: Add by junwei.shen at 2017.7.2
-import java.util.Timer;
-import java.util.TimerTask;
-
-import com.sensetime.faceapi.FaceLibrary;
-import com.sensetime.faceapi.model.CvPixelFormat;
-import com.sensetime.faceunlock.util.BrightnessHelper;
-
-import android.graphics.Rect;
-
-public class PrivacySpaceActivity extends Activity {
-    private static final String TAG = "PrivacySpaceActivity";
-    private static final int FACE_NEW_REQUEST = 300;
-    private static final int FACE_REPLACE_REQUEST = 301;
-    private static final int FACE_REMOVE_REQUEST = 302;
-
-    public static final int MODE_INIT = 0;
-    public static final int MODE_UNLOCK_NORMAL = 1;
-    public static final int MODE_UNLOCK_PRIVACY = 2;
-    public static final int MODE_UNLOCK_CLONE = 3;
-    public static final int MODE_SWITCH_TO_PRIVACY = 4;
-    public static final int MODE_SWITCH_TO_CLONE = 5;
-    public static final int MODE_VERIFY = 6;
-    public static final int MODE_VERIFY_SHOW_UI = 7;
-    //Begin: Add by junwei.shen for bug-98638 at 2017.7.2
-    public static final int CANCEL_TOAST = 8;
-    public static final int MODE_VERITY_UNLOCK = 9;
-    public static final int MODE_PRIVACY_PROTECTION = 10;
-    public static final int START_FACE_VERIFY = 101;
-    public static final int STOP_FACE_VERIFY = 102;
-
-    public static final int PRIVACY_OK = 100;
-
-    private Toast toast = null;
-    //End: Add by junwei.shen for bug-98638 at 2017.7.2
-    private CameraView cameraView; // 相机控件
-    private AlertDialog dialog;
-
-    private Thread trackThread; // 进行Track的线程
-    private HandlerThread verifyThread; // 进行Verify的线程
-    private Handler verifyHandler; // 进行Verify的线程的Handler对象
-    private User user; // verify通过，即存储检测到的User
-
-    private volatile boolean isNv21DataReady; // 判断nv21的数据是否拷贝完成
-    private volatile boolean isTracking; // 是否正在进行track操作
-    private boolean isKilled; // 控制Track线程是否停止
-    private boolean isVerifying; // 是否正在进行verify操作
-    private byte[] nv21; // nv21的数据
-    private int attemptCount; // 重试次数
-    private boolean isNotHacker; // 是否为活体
-    private long totalTime; // 总耗时
-    private long verifyTime;
-    private long hackerTime;
-
-    boolean mUnlockFinished = false;
-    private int mPrivacyMode;
-    private boolean mFromNotification;
-    private boolean mFromKeyguard;
-
-    private int mLastScreenMode;
-    private int mLastScreenBrightness;
-    private boolean mBrightnessChanged = false;
-    private static final float BRIGHT_MIN = 0.12f;
-
-    //wym add for 99963. 2017/07/06
-
-    //Timer timer = new Timer();
-    boolean mIsNotGetFaceInfo = false;
-
-    /*TimerTask task = new TimerTask() {
-        @Override
-        public void run() {
-
-            runOnUiThread(new Runnable() {
-                @Override
-                public void run() {
-                    LogUtil.d(TAG, "...............timerTask mIsNotGetFaceInfo=" + mIsNotGetFaceInfo);
-                    if (mIsNotGetFaceInfo) {
-                        KeyguardUtils.showNormalDialog(PrivacySpaceActivity.this, "人脸认证");
-                    }
-                }
-            });
-        }
-    };*/
-
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        sendFaceBrodcast(START_FACE_VERIFY);
-        /*String state = Settings.System.getStringForUser(this.getApplicationContext().getContentResolver(), Settings.System.FACE_STATE_ENABLED, 0);zxp*/
-        String state = "0";
-		if (state == null) {
-            state = "0";
-        }
-        if (state.equals("0")) {
-            getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
-        }
-        requestWindowFeature(Window.FEATURE_NO_TITLE);
-        mPrivacyMode = getIntent().getIntExtra("privacyState", MODE_INIT);
-        mFromNotification = getIntent().getBooleanExtra("fromNotification", false);
-        mFromKeyguard = getIntent().getBooleanExtra("START_FROM_KEYGUARD", false);
-        if (mFromKeyguard || (mPrivacyMode == MODE_UNLOCK_PRIVACY)) {
-            getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
-            WindowManager.LayoutParams lp = getWindow().getAttributes();
-            int keyguardFlag = WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED
-                    | WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES
-                    | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON
-                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD;
-            lp.flags |= keyguardFlag;
-            getWindow().setAttributes(lp);
-        }
-        resizeWindow();
-        Log.d("changjun", "mPrivacyMode:" + mPrivacyMode + ",mFromNotification:" + mFromNotification);
-        setContentView(R.layout.activity_verify);
-        initView();
-        mLastScreenMode = BrightnessHelper.getScreenMode(this);
-        mLastScreenBrightness = BrightnessHelper.getScreenBrightness(this);
-        DetectProxy.init();
-        VerifyProxy.init(this);
-        if (AppConfig.isOpenHacker) {
-            HackerProxy.init();
-        }
-        final IntentFilter filter = new IntentFilter();
-        filter.addAction(Intent.ACTION_SCREEN_OFF);
-        filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
-        registerReceiver(mReceiver, filter);
-        LogUtil.d(TAG,"!!!!!!!!!timer.schedule!!!!!!");
-        //timer.schedule(task, 2000);
-    }
-
-    private void resizeWindow() {
-        WindowManager.LayoutParams lp = getWindow().getAttributes();
-        lp.width = 1;
-        lp.height = 1;
-        lp.alpha = 0.0f;
-        lp.dimAmount = 0.0f;
-        getWindow().setAttributes(lp);
-    }
-
-    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(final Context context, final Intent intent) {
-            Log.d(TAG, "onReceive");
-            String action = intent.getAction();
-
-            if (Intent.ACTION_SCREEN_OFF.equals(action)) {
-                Log.d(TAG, "screen off");
-                PrivacySpaceActivity.this.finish();
-            } else if (Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action)) {
-                String reason = intent.getStringExtra("reason");
-                if ("homekey".equals(reason)) {
-                    PrivacySpaceActivity.this.finish();
-                }
-            }
-        }
-    };
-
-    private void initView() {
-        cameraView = (CameraView) findViewById(R.id.camera_view);
-        cameraView.setVisibility(View.INVISIBLE);// added by iuv luyang
-        cameraView.setPreviewCallback(new Camera.PreviewCallback() {
-
-            @Override
-            public void onPreviewFrame(byte[] data, Camera camera) {
-                if (totalTime == 0) {
-                    totalTime = System.currentTimeMillis();
-                }
-                if (nv21 == null || data.length != nv21.length) {
-                    nv21 = new byte[data.length];
-                }
-                if (!isTracking && !isVerifying) {
-                    synchronized (nv21) {
-                        System.arraycopy(data, 0, nv21, 0, data.length);
-                        isNv21DataReady = true;
-                    }
-                }
-                cameraView.addCallbackBuffer();
-            }
-        });
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        sendFaceBrodcast(START_FACE_VERIFY);
-        AccelerometerManager.start(this);
-        isKilled = false;
-        cameraView.restartCamera();
-        trackThread = new Thread() {
-            @Override
-            public void run() {
-                while (!isKilled && !Thread.interrupted()) {
-                    if (isNv21DataReady) {
-                        isTracking = true;
-                        synchronized (nv21) {
-                            FaceInfo[] faces = DetectProxy.detect(nv21, cameraView.mPreviewWidth,
-                                    cameraView.mPreviewHeight);
-                            FaceInfo faceInfo = filterFaces(faces);
-                            maxBrightnessIfNeed(nv21, faceInfo);
-                            if (faceInfo == null) {
-                                mIsNotGetFaceInfo = true;
-                            } else {
-                                mIsNotGetFaceInfo = false;
-                                //timer.cancel();
-                            }
-                            LogUtil.i(TAG, "...mIsNotGetFaceInfo=" + mIsNotGetFaceInfo);
-                            analysis(faceInfo);
-                        }
-                        isTracking = false;
-                        isNv21DataReady = false;
-                    }
-                }
-            }
-        };
-        trackThread.start();
-        initGetFeatureThread(); // 初始化GetFeature的线程
-    }
-
-    private void maxBrightnessIfNeed(byte[] nv21, FaceInfo faceInfo) {
-        if (nv21 == null || nv21.length == 0 || faceInfo == null) {
-            return;
-        }
-        Rect rect = faceInfo.faceRect;
-        float brightness = FaceLibrary.averageBrightness(nv21, CvPixelFormat.NV21, cameraView.mPreviewWidth, cameraView.mPreviewHeight, rect.left, rect.top, rect.width(), rect.height());
-        if (brightness < BRIGHT_MIN) {
-            mBrightnessChanged = true;
-            BrightnessHelper.setScreenMode(this, 0);
-            BrightnessHelper.setScreenBrightness(this, 255);
-        }
-    }
-
-
-    private FaceInfo filterFaces(FaceInfo[] faces) {
-        if (faces == null || faces.length <= 0) {
-            return null;
-        }
-        FaceInfo faceInfo = null;
-        for (int i = 0; i < faces.length; i++) {
-            if (faceInfo == null || faces[i].faceRect.width() > faceInfo.faceRect.width()) {
-                faceInfo = faces[i];
-            }
-        }
-        return faceInfo;
-    }
-
-    private void analysis(FaceInfo faceInfo) {
-        if (faceInfo == null || isVerifying) {
-            return;
-        }
-        isVerifying = true;
-        Message msg = Message.obtain(verifyHandler);
-        msg.obj = new FaceFeature(faceInfo, nv21, cameraView.mPreviewWidth, cameraView.mPreviewHeight);
-        verifyHandler.sendMessage(msg);
-    }
-
-    private void initGetFeatureThread() {
-        verifyThread = new HandlerThread("VerifyThread");
-        verifyThread.start();
-        verifyHandler = new Handler(verifyThread.getLooper()) {
-            @Override
-            public void handleMessage(Message msg) {
-                FaceFeature faceFeature = (FaceFeature) msg.obj;
-                handleFeature(faceFeature);
-            }
-        };
-    }
-
-    private void handleFeature(FaceFeature faceFeature) {
-        if (faceFeature == null) {
-            return;
-        }
-
-        // 做一次 verify 和 hacker，如果某次已经检测出来结果并且通过了，则不再重复检测
-        if (user == null) {
-            verifyTime = System.currentTimeMillis();
-            user = VerifyProxy.isPass(faceFeature, this);
-            verifyTime = System.currentTimeMillis() - verifyTime;
-        }
-        if (!isNotHacker) {
-            hackerTime = System.currentTimeMillis();
-            isNotHacker = HackerProxy.isPass(faceFeature, cameraView.isFrontCamera());
-            hackerTime = System.currentTimeMillis() - hackerTime;
-        }
-
-        attemptCount++;
-        LogUtil.d(TAG, "attemptCount: " + attemptCount);
-        // 达到重试次数上限时，发送结果，否则继续进行检测
-        if ((user != null && isNotHacker) || attemptCount >= AppConfig.attemptCount) {
-            cameraView.setPreviewCallback(null);
-            cameraView.stopPreview();
-            analyseResult(user, isNotHacker);
-        } else {
-            isVerifying = false;
-        }
-    }
-
-    //Begin:Add by junwei.shen for bug-98638 at 2017.7.2
-    Handler hd = new Handler(Looper.getMainLooper()) {
-
-        @Override
-        public void handleMessage(Message msg) {
-            super.handleMessage(msg);
-            if (msg.what == CANCEL_TOAST) {
-                toast.cancel();
-//                toast = null;
-                finish();
-            }
-        }
-
-    };
-    //End: Add by junwei.shen for bug-98638 at 2017.7.2
-
-    private void analyseResult(User user, boolean isNotHacker) {
-        Intent intent = new Intent();
-        intent.setAction("SAVE_RECORDER");
-        sendBroadcast(intent);
-        if (user != null && isNotHacker) {
-            String debugMsg = "total time: " + (System.currentTimeMillis() - totalTime) + "ms\nverify time: " +
-                    verifyTime + "ms\nhacker time: " + hackerTime + "ms\nattempts count: " + attemptCount;
-            Vibrator vib = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
-            vib.vibrate(100);
-            beginUnlock();
-            finish();
-            return;
-        } else {
-            //Begin: Changed by junwei.shen for bug-98638 at 2017.7.2
-//          Toast.makeText(PrivacySpaceActivity.this, R.string.face_not_recognized, Toast.LENGTH_LONG).show();
-            toast = Toast.makeText(PrivacySpaceActivity.this, R.string.face_not_recognized, Toast.LENGTH_LONG);
-            toast.show();
-            hd.sendEmptyMessageDelayed(CANCEL_TOAST, 1000);
-            //End: Changed by junwei.shen for bug-98638 at 2017.7.2
-            setResult(RESULT_CANCELED);
-            //Changed by junwei.shen for bug-98638 at 2017.7.2
-//          finish();
-
-        }
-    }
-
-    public void saveFaceState(boolean enabled) {
-       /* Settings.System.putStringForUser(getContentResolver(), Settings.System.FACE_STATE_ENABLED, enabled ? "1" : "0", 0);zxp*/
-    }
-
-    private void switchToPrivacySpace() {
-        String userID = "0";
-        /*userID = Settings.System.getStringForUser(getContentResolver(), Settings.System.PRIVACY_USER_ID, 0);zxp*/
-        int id = Integer.parseInt(userID);
-        try {
-            if (mPrivacyMode == MODE_UNLOCK_PRIVACY) {
-                sendFaceBrodcast(RESULT_OK);
-            }
-            Intent i = new Intent("PRIVACY_SPACE_SWITCH");
-            i.putExtra("userid", id);
-            sendBroadcast(i);
-        } catch (Exception re) {
-            Log.e(TAG, "Couldn't switch user " + re);
-        }
-    }
-
-    private void beginUnlock() {
-        //unlock();
-        switch (mPrivacyMode) {
-            case MODE_INIT:
-                break;
-            case MODE_SWITCH_TO_CLONE:
-            case MODE_SWITCH_TO_PRIVACY:
-                switchToPrivacySpace();
-                break;
-            case MODE_UNLOCK_NORMAL:
-                break;
-            case MODE_UNLOCK_CLONE:
-            case MODE_UNLOCK_PRIVACY:
-                switchToPrivacySpace();
-                break;
-            case MODE_VERIFY:
-            case MODE_VERIFY_SHOW_UI:
-                setResult(RESULT_OK);
-                break;
-            case MODE_VERITY_UNLOCK:
-                sendFaceBrodcast(RESULT_OK);
-            case MODE_PRIVACY_PROTECTION:
-                sendFaceBrodcast(PRIVACY_OK);
-                break;
-            default:
-                break;
-        }
-
-    }
-
-    private void sendFaceBrodcast(int flag) {
-        Intent mIntent = new Intent();
-        if (flag == RESULT_OK) {
-            mIntent.setAction("action_face_OK");
-        } else if (flag == RESULT_CANCELED) {
-            mIntent.setAction("action_face_fail");
-        } else if (flag == PRIVACY_OK) {
-            mIntent.setAction("action_privacy_ok");
-        } else if (flag == START_FACE_VERIFY) {
-            mIntent.setAction("action_start_face_verity");
-        } else if (flag == STOP_FACE_VERIFY) {
-            mIntent.setAction("action_stop_face_verity");
-        }
-        this.getApplicationContext().sendBroadcast(mIntent);
-
-    }
-
-    private void dismissDialog() {
-        if (dialog != null && dialog.isShowing()) {
-            dialog.dismiss();
-            dialog = null;
-            isVerifying = false;
-        }
-    }
-
-    @Override
-    protected void onPause() {
-        sendFaceBrodcast(STOP_FACE_VERIFY);
-        dismissDialog();
-        AccelerometerManager.stop();
-        cameraView.releaseCamera();
-        stopThread();
-        super.onPause();
-    }
-
-    private void stopThread() {
-        isKilled = true;
-        if (trackThread != null) {
-            try {
-                trackThread.interrupt();
-                trackThread.join();
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }
-        }
-        if (verifyThread != null) {
-            verifyThread.quitSafely();
-            verifyThread = null;
-        }
-    }
-
-    /*added by iuv luyang*/
-    @Override
-    public void onBackPressed() {
-        Toast.makeText(this.getApplicationContext(), R.string.face_cancel_identify, Toast.LENGTH_SHORT).show();
-        super.onBackPressed();
-    }
-    /*end by iuv luyang*/
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        sendFaceBrodcast(STOP_FACE_VERIFY);
-        unregisterReceiver(mReceiver);
-        if (mBrightnessChanged) {
-            BrightnessHelper.setScreenBrightness(this, mLastScreenBrightness);
-            BrightnessHelper.setScreenMode(this, mLastScreenMode);
-        }
-        if (AppConfig.isOpenHacker)
-            HackerProxy.release();
-    }
-}
Index: frameworks/base/packages/Keyguard/src/com/face/scanner/KeyguardStateCallback.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/face/scanner/KeyguardStateCallback.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/face/scanner/KeyguardStateCallback.java	(revision 6857)
@@ -1,82 +0,0 @@
-package com.face.scanner;
-
-
-import com.android.internal.policy.IKeyguardService;
-import com.android.internal.policy.IKeyguardStateCallback;
-import android.util.Log;
-import android.os.RemoteException;
-
-
-public class KeyguardStateCallback extends IKeyguardStateCallback.Stub {
-    private static final String TAG = "KeyguardStateCallback";
-    private static KeyguardStateCallback sCallback = null;
-	
-    PrivacySpaceActivity mActivity = null;
-    boolean mKeyguardShowing = false;
-    boolean mUnlockFinished = false;
-    boolean mSimSecure = false;
-    boolean mInputRestricted = false;
-    boolean mRegistered = false;
-    boolean mHasLockscreenWallpaper = false;
-	boolean mTrusted = false;
-	
-    KeyguardStateCallback() {
-        super();
-    }
-	
-    public static KeyguardStateCallback getInistance() {
-        if(sCallback == null) {
-            sCallback = new KeyguardStateCallback();
-        }
-        return sCallback;
-    }	
-	
-    public void onShowingStateChanged(boolean showing) {
-        boolean oldShow = mKeyguardShowing;
-        mKeyguardShowing = showing;
-        Log.d(TAG," onShowingStateChanged:oldShow="+oldShow+",mKeyguardShowing="+mKeyguardShowing);
-        if(oldShow && !mKeyguardShowing && mActivity != null && !mActivity.mUnlockFinished) {
-            Log.d(TAG," Unlocked, finish PrivacySpaceActivity");
-            mActivity.mUnlockFinished = true;
-            mActivity.finish();
-            mActivity = null;
-        }
-    }
-	
-    public void onSimSecureStateChanged(boolean simSecure) {
-        mSimSecure = simSecure;
-    }
-	
-    public void onInputRestrictedStateChanged(boolean inputRestricted) {
-        mInputRestricted = inputRestricted;
-    }
-	
-    public void onAntiTheftStateChanged(boolean antiTheftEnabled) {
-        ;
-    }
-	
-    public void registerToKeyguard(IKeyguardService Service) {
-        if(!mRegistered) {
-            try {
-                Service.addStateMonitorCallback(this);
-                mRegistered = true;
-            } catch (RemoteException e) {
-                Log.e(TAG, "Remote Exception when addStateMonitorCallback", e);
-            }
-        }
-    }
-	
-    public void setActivity(PrivacySpaceActivity a) {
-        mActivity = a;
-    }
-	   @Override // Binder interface
-    public void onHasLockscreenWallpaperChanged(boolean hasLockscreenWallpaper) {
-        mHasLockscreenWallpaper = hasLockscreenWallpaper;
-    }
-
-    @Override // Binder interface
-    public void onTrustedChanged(boolean trusted) {
-        mTrusted = trusted;
-    }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/face/scanner/view/InfraredLedManager.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/face/scanner/view/InfraredLedManager.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/face/scanner/view/InfraredLedManager.java	(revision 6857)
@@ -1,192 +0,0 @@
-/*
- * Copyright (C) 2010 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// TODO : change to your package name
-
-package com.face.scanner.view;
-
-import android.os.IBinder;
-import android.util.Log;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-final class InfraredLedManager {
-
-    private static final String TAG = InfraredLedManager.class.getSimpleName();
-
-    private static final Object iInfraredLedService;
-    private static final Method setOn;
-    private static final Method setOff;
-    private static final Method setBrightness;
-
-    static {
-        iInfraredLedService = getHardwareService();
-        setOn = getSetOnMethod(iInfraredLedService);
-        setOff = getSetOffMethod(iInfraredLedService);
-        setBrightness = getSetBrightnessMethod(iInfraredLedService);
-        if (iInfraredLedService == null) {
-            Log.v(TAG,
-                    "This device does not supports control of a infrared_led");
-        } else {
-            Log.v(TAG,
-                    "This device support control of a infrared_led, Service is:"
-                            + iInfraredLedService.toString());
-        }
-    }
-
-    private InfraredLedManager() {
-    }
-
-    /** API setOn */
-    static public void setInfraredLedOn() {
-        insideSetOn();
-    }
-
-    /** API setOff */
-    static public void setInfraredLedOff() {
-        insideSetOff();
-    }
-
-    /** API setBrightness */
-    static public void setInfraredLedBrightness(int value) {
-        insideSetBrightness(value);
-    }
-
-    private static Object getHardwareService() {
-        Class<?> serviceManagerClass = maybeForName("android.os.ServiceManager");
-        if (serviceManagerClass == null) {
-            Log.d(TAG, "serviceManagerClass == null");
-            return null;
-        }
-
-        Method getServiceMethod = maybeGetMethod(serviceManagerClass,
-                "getService", String.class);
-        if (getServiceMethod == null) {
-            Log.d(TAG, "getServiceMethod == null");
-            return null;
-        }
-
-        Object hardwareService = invoke(getServiceMethod, null, "infrared_led");
-        if (hardwareService == null) {
-            Log.d(TAG, "infraredLedService == null");
-            return null;
-        }
-
-        Class<?> iHardwareServiceStubClass = maybeForName("android.app.IInfraredLedService$Stub");
-        if (iHardwareServiceStubClass == null) {
-            Log.d("TAG", "iInfraredLedServiceStubClass == null");
-            return null;
-        }
-
-        Method asInterfaceMethod = maybeGetMethod(iHardwareServiceStubClass,
-                "asInterface", IBinder.class);
-        if (asInterfaceMethod == null) {
-            Log.d(TAG, "asInterfaceMethod == null");
-            return null;
-        }
-        return invoke(asInterfaceMethod, null, hardwareService);
-    }
-
-    private static Method getSetOnMethod(Object iHardwareService) {
-        if (iHardwareService == null) {
-            return null;
-        }
-        Class<?> proxyClass = iHardwareService.getClass();
-        return maybeGetMethod(proxyClass, "setOn");
-    }
-
-    private static Method getSetOffMethod(Object iHardwareService) {
-        if (iHardwareService == null) {
-            return null;
-        }
-        Class<?> proxyClass = iHardwareService.getClass();
-        return maybeGetMethod(proxyClass, "setOff");
-    }
-
-    private static Method getSetBrightnessMethod(Object iHardwareService) {
-        if (iHardwareService == null) {
-            return null;
-        }
-        Class<?> proxyClass = iHardwareService.getClass();
-        return maybeGetMethod(proxyClass, "setBrightness", int.class);
-    }
-
-    private static Class<?> maybeForName(String name) {
-        try {
-            return Class.forName(name);
-        } catch (ClassNotFoundException cnfe) {
-            // OK
-            return null;
-        } catch (RuntimeException re) {
-            Log.w(TAG, "Unexpected error while finding class " + name, re);
-            return null;
-        }
-    }
-
-    private static Method maybeGetMethod(Class<?> clazz, String name,
-            Class<?>... argClasses) {
-        try {
-            return clazz.getMethod(name, argClasses);
-        } catch (NoSuchMethodException nsme) {
-            // OK
-            return null;
-        } catch (RuntimeException re) {
-            Log.w(TAG, "Unexpected error while finding method " + name, re);
-            return null;
-        }
-    }
-
-    private static Object invoke(Method method, Object instance, Object... args) {
-        try {
-            return method.invoke(instance, args);
-        } catch (IllegalAccessException e) {
-            Log.w(TAG, "Unexpected error while invoking " + method, e);
-            return null;
-        } catch (InvocationTargetException e) {
-            Log.w(TAG, "Unexpected error while invoking " + method,
-                    e.getCause());
-            return null;
-        } catch (RuntimeException re) {
-            Log.w(TAG, "Unexpected error while invoking " + method, re);
-            return null;
-        }
-    }
-
-    private static void insideSetOn() {
-        if (iInfraredLedService == null) {
-            Log.v(TAG, "set infrared_led On , but iInfraredLedService is null");
-        } else {
-            invoke(setOn, iInfraredLedService);
-        }
-    }
-
-    private static void insideSetOff() {
-        if (iInfraredLedService == null) {
-            Log.v(TAG, "set infrared_led Off , but iInfraredLedService is null");
-        } else {
-            invoke(setOff, iInfraredLedService);
-        }
-    }
-
-    private static void insideSetBrightness(int value) {
-        if (iInfraredLedService == null) {
-            Log.v(TAG, "set infrared_led Brightness , but iInfraredLedService is null");
-        } else {
-            invoke(setBrightness, iInfraredLedService, value);
-        }
-    }
-}
Index: frameworks/base/packages/Keyguard/src/com/face/scanner/view/CameraSurfaceView.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/face/scanner/view/CameraSurfaceView.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/face/scanner/view/CameraSurfaceView.java	(revision 6857)
@@ -1,261 +0,0 @@
-
-package com.face.scanner.view;
-
-import java.io.IOException;
-import java.util.List;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.ImageFormat;
-import android.graphics.SurfaceTexture;
-import android.hardware.Camera;
-import android.hardware.Camera.CameraInfo;
-import android.hardware.Camera.Parameters;
-import android.hardware.Camera.Size;
-import android.util.Log;
-import android.view.Surface;
-import android.view.SurfaceHolder;
-import android.view.SurfaceView;
-import android.view.WindowManager; 
-
-import com.face.scanner.PrivacySpaceActivity;
-import com.face.scanner.FaceActivity;
-import com.face.scanner.FaceService;
-import com.android.keyguard.R;
-
-public class CameraSurfaceView extends SurfaceView implements
-        SurfaceHolder.Callback {
-    private SurfaceHolder mHolder; // SurfaceView的控制器
-    private Camera mCamera; // Camera对象
-    private int cameraID;
-    private Context context;
-    private int cameraRotateAngle = 0;
-
-    private int previewImH = 0;
-    private int previewImW = 0;
-    // 虹膜图像采集模式必须为预览模式
-    private Camera.PreviewCallback previewCallback = null;
-    private SurfaceTexture mst;
-
-    public boolean mSurfaceDestroyed = true;
-
-    public interface IEvent {
-        void onSurfaceViewReady(CameraSurfaceView surfaceView);
-    }
-
-    private IEvent event;
-
-    public CameraSurfaceView(Context context, int cameraID,
-            Camera.PreviewCallback previewCallback, IEvent event) {
-        super(context);
-
-        this.cameraID = cameraID;
-        this.context = context;
-        this.event = event;
-        this.previewCallback = previewCallback;
-
-        mHolder = getHolder();
-        mHolder.addCallback(this);
-        mst = new SurfaceTexture(0);
-    }
-
- 	public void OpenFlashLED()
- 	{
- 		if(mCamera == null) openCamera(true);
- 		if(mCamera == null) return;
- 		Camera.Parameters params = mCamera.getParameters();
-		params.setFlashMode(Parameters.FLASH_MODE_ON);
-		params.setFlashMode(Parameters.FLASH_MODE_TORCH);
-		mCamera.setParameters(params);
- 	}
- 	public void setCameraBrightness(int value){
- 		if(mCamera == null){
- 			return;
- 		}
- 		Camera.Parameters params = mCamera.getParameters();
- 		int maxExposureCompensation = params.getMaxExposureCompensation();
- 		int minExposureCompensation = params.getMinExposureCompensation();
- 		
- 		if(value<minExposureCompensation){
- 			value = minExposureCompensation;
- 		}else if(value>maxExposureCompensation){
- 			value = maxExposureCompensation;
- 		}
- 		
- 		params.setExposureCompensation(value);
- 		mCamera.setParameters(params);
- 	}
- 	public int getCameraBrightness(){
- 		Camera.Parameters params = mCamera.getParameters();
- 		int exposureCompensation = params.getExposureCompensation();
- 		return exposureCompensation;
- 	}
-
- 	public void CloseFlashLED()
- 	{
- 		if(mCamera != null){
- 			Parameters parameters = mCamera.getParameters();
- 			parameters.setFlashMode(Parameters.FLASH_MODE_OFF);
- 			mCamera.setParameters(parameters);
- 		}
- 	}
-    // openCamera and set camera parameters
-    public void openCamera(boolean forceReopen) {
-        if (forceReopen && mCamera != null) {
-            mCamera.stopPreview();
-            mCamera.setPreviewCallback(null);
-            mCamera.release();
-            mCamera = null;
-        }
-        try {
-            if (mCamera == null) {
-                mCamera = Camera.openLegacy(cameraID,Camera.CAMERA_HAL_API_VERSION_1_0);
-            }
-    
-            //updateCameraParameters();
-    
-            mCamera.setPreviewDisplay(mHolder);
-            // 绝对布局需要的=========================================
-            mCamera.setPreviewCallback(previewCallback);
-            // mCamera.autoFocus(cb);
-            mCamera.setPreviewTexture(mst);
-            // 绝对布局需要的=========================================
-    
-            if (forceReopen) {
-                mCamera.startPreview();
-            }
-
-        } catch (RuntimeException re) {
-            re.printStackTrace();
-            if(context instanceof PrivacySpaceActivity) {
-                //((PrivacySpaceActivity)context).showExitToast(R.string.close_camera);
-            } else if(context instanceof FaceActivity) {
-                //((FaceActivity)context).showExitToast(R.string.close_camera);
-            } else if(context instanceof FaceService) {
-                //((FaceService)context).showExitToast(R.string.close_camera);
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-        }			
-    }
-
-    public void surfaceCreated(SurfaceHolder holder) {
-        mSurfaceDestroyed = false;
-        mHolder = holder;
-        openCamera(true);
-    }
-
-    // 如果surface变化，则重新打开camera preview，相当于重新初始化
-    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
-        try {
-            if(mCamera == null) return;
-            mHolder = holder;
-            mCamera.startPreview();
-            if (event != null) {
-                event.onSurfaceViewReady(this);
-            }
-            event = null;
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-
-    // surface界面销毁后，自动退出preview，收回camra资源
-    public void surfaceDestroyed(SurfaceHolder holder) {
-        stopCamera();
-        mSurfaceDestroyed = true;
-    }
-
-    private void setCameraDisplayOrientation(Context context, int cameraId,
-            Camera camera) {
-        CameraInfo info = new CameraInfo();
-        Camera.getCameraInfo(cameraId, info);
-        int rotation = ((WindowManager) (context.getApplicationContext().getSystemService(Context.WINDOW_SERVICE)))
-                .getDefaultDisplay().getRotation();
-
-        int degrees = 0;
-        switch (rotation) {
-            case Surface.ROTATION_0:
-                degrees = 0;
-                break;
-            case Surface.ROTATION_90:
-                degrees = 90;
-                break;
-            case Surface.ROTATION_180:
-                degrees = 180;
-                break;
-            case Surface.ROTATION_270:
-                degrees = 270;
-                break;
-        }
-        degrees = 270;
-        int result;
-        if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
-            result = (info.orientation + degrees) % 360;
-            result = (360 - result) % 360;
-        } else {
-            result = (info.orientation - degrees + 360) % 360;
-        }
-        cameraRotateAngle = result;
-
-        // if(EnumDeviceType.isJiaWeiA780())
-        {
-            cameraRotateAngle = 0;
-        }
-
-        Log.d("CameraSurface", "preview angel:" + result);
-        camera.setDisplayOrientation(result);
-    }
-
-    public int getCameraRotateAngle() {
-        return cameraRotateAngle;
-    }
-
-    public int getPreviewImH() {
-        return previewImH;
-    }
-
-    public int getPreviewImW() {
-        return previewImW;
-    }
-
-    public int getDeviceType() {
-        return 1;
-    }
-
-    public void stopCamera() {
-        if (mCamera != null) {
-            mCamera.stopPreview();
-            mCamera.setPreviewCallback(null);
-            mCamera.release();
-            mCamera = null;
-            mHolder = null;
-        }
-    }
-    
-    private double mRequestedAspect = 1920 / (double)1080;
-    @Override
-	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-
-		if (mRequestedAspect > 0) {
-			int initialWidth = MeasureSpec.getSize(widthMeasureSpec);
-			int initialHeight = MeasureSpec.getSize(heightMeasureSpec);
-
-			final double viewAspectRatio = (double)initialWidth / initialHeight;
-			final double aspectDiff = mRequestedAspect / viewAspectRatio - 1;
-
-			if (Math.abs(aspectDiff) > 0.01) {
-				if (aspectDiff > 0) {
-					initialHeight = (int) (initialWidth / mRequestedAspect);
-				} else {
-					initialWidth = (int) (initialHeight * mRequestedAspect);
-				}
-				widthMeasureSpec = MeasureSpec.makeMeasureSpec(initialWidth, MeasureSpec.EXACTLY);
-				heightMeasureSpec = MeasureSpec.makeMeasureSpec(initialHeight, MeasureSpec.EXACTLY);
-			}
-		}
-		super.onMeasure(widthMeasureSpec, heightMeasureSpec);
-	}
-    
-    
-}
Index: frameworks/base/packages/Keyguard/src/com/face/scanner/view/DrawFaceEyesView.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/face/scanner/view/DrawFaceEyesView.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/face/scanner/view/DrawFaceEyesView.java	(revision 6857)
@@ -1,753 +0,0 @@
-package com.face.scanner.view;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.Camera;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Matrix;
-import android.graphics.Paint;
-import android.util.AttributeSet;
-import android.view.View;
-import com.android.keyguard.R;
-import android.graphics.Path;
-import android.graphics.PathMeasure;
-
-public class DrawFaceEyesView extends View{
-	private Paint mainPaint; 
-	private Paint alphPaint;
-	private Camera camera=new Camera();
-    
-    private Bitmap hongmoMaskImage=BitmapFactory.decodeResource(getResources(), R.drawable.hongmo_mask_two);
-	private Matrix hongmoMaskImageMatrix=new Matrix();
-    
-//    private Bitmap hongmoMeshImage=BitmapFactory.decodeResource(getResources(), R.drawable.hongmo_mesh_image);
-	private Matrix hongmoMeshImageMatrix=new Matrix();
-//
-//	private Bitmap hongmoMeshMaskImage=BitmapFactory.decodeResource(getResources(), R.drawable.hongmo_mesh_mask_image);
-//	private Matrix hongmoMeshMaskImageMatrix=new Matrix();
-//	private float upDownValue=0.0f;
-//	private boolean downJudge=false;
-	
-	private int borderLeftLine1StartY=60;
-	private int borderLeftLine1EndY=60;
-	private final int BORDERLEFTLINE1ENDY=85;
-	private int borderLeftLine1StartX=16;
-	
-	private int borderLeftLine2StartY=110;
-	private int borderLeftLine2EndY=110;
-	private final int BORDERLEFTLINE2ENDY=185;
-	private int borderLeftLine2StartX=9;
-	
-	private int borderLeftLine3StartY=220;
-	private int borderLeftLine3EndY=220;
-	private final int BORDERLEFTLINE3ENDY=340;
-	private int borderLeftLine3StartX=21;
-	
-	private int borderLeftLine4StartY=220;
-	private int borderLeftLine4EndY=220;
-	private final int BORDERLEFTLINE4ENDY=110;
-	private int borderLeftLine4StartX=3;
-	
-	private int borderLeftLine5StartY=109;
-	private int borderLeftLine5EndY=109;
-	private final int BORDERLEFTLINE5ENDY=99;
-	private int borderLeftLine5StartX=3;
-	private int borderLeftLine5EndX=3;
-	
-	private int borderLeftLine6StartY=98;
-	private int borderLeftLine6EndY=98;
-	private final int BORDERLEFTLINE6ENDY=0;
-	private int borderLeftLine6StartX=14;
-	
-	private int borderLeftLine7StartY=520;
-	private int borderLeftLine7EndY=520;
-	private final int BORDERLEFTLINE7ENDY=150;
-	private int borderLeftLine7StartX=16;
-	
-	private int borderLeftLine8StartY=149;
-	private int borderLeftLine8EndY=149;
-	private final int BORDERLEFTLINE8ENDY=140;
-	private int borderLeftLine8StartX=16;
-	private int borderLeftLine8EndX=16;
-	
-	private int borderLeftLine9StartY=320;
-	private int borderLeftLine9EndY=320;
-	private final int BORDERLEFTLINE9ENDY=355;
-	private int borderLeftLine9StartX=29;
-	
-	private int borderLeftLine10StartY=356;
-	private int borderLeftLine10EndY=356;
-	private final int BORDERLEFTLINE10ENDY=365;
-	private int borderLeftLine10StartX=29;
-	private int borderLeftLine10EndX=29;
-	
-	private int borderLeftLine11StartY=365;
-	private int borderLeftLine11EndY=365;
-	private final int BORDERLEFTLINE11ENDY=511;
-	private int borderLeftLine11StartX=20;
-	
-	private int borderLeftLine12StartY=230;
-	private int borderLeftLine12EndY=230;
-	private final int BORDERLEFTLINE12ENDY=410;
-	private int borderLeftLine12StartX=9;
-	
-	private int borderBottomLine1StartX=16;
-	private int borderBottomLine1EndX=16;
-	private final int BORDERBOTTOMLINE1ENDX=1080;
-	private int borderBottomLine1StartY=510;
-	
-	private int borderLeftLinePoint1StartY=192;
-	private int borderLeftLinePoint1EndY=192;
-	private final int BORDERLEFTLINEPOINT1ENDY=196;
-	private int borderLeftLinePoint1StartX=9;
-	
-	private int borderLeftLinePoint2StartY=202;
-	private int borderLeftLinePoint2EndY=202;
-	private final int BORDERLEFTLINEPOINT2ENDY=206;
-	private int borderLeftLinePoint2StartX=9;
-	
-	private int borderLeftLinePoint3StartY=212;
-	private int borderLeftLinePoint3EndY=212;
-	private final int BORDERLEFTLINEPOINT3ENDY=216;
-	private int borderLeftLinePoint3StartX=9;
-	
-	private int borderLeftLinePoint4StartY=397;
-	private int borderLeftLinePoint4EndY=397;
-	private final int BORDERLEFTLINEPOINT4ENDY=401;
-	private int borderLeftLinePoint4StartX=20;
-	
-	private int borderLeftLinePoint5StartY=407;
-	private int borderLeftLinePoint5EndY=407;
-	private final int BORDERLEFTLINEPOINT5ENDY=411;
-	private int borderLeftLinePoint5StartX=20;
-	
-	private int borderLeftLinePoint6StartY=417;
-	private int borderLeftLinePoint6EndY=417;
-	private final int BORDERLEFTLINEPOINT6ENDY=421;
-	private int borderLeftLinePoint6StartX=20;
-	
-	private int borderLeftLinePoint7StartY=489;
-	private int borderLeftLinePoint7EndY=489;
-	private final int BORDERLEFTLINEPOINT7ENDY=493;
-	private int borderLeftLinePoint7StartX=20;
-	
-	private int borderLeftLinePoint8StartY=499;
-	private int borderLeftLinePoint8EndY=499;
-	private final int BORDERLEFTLINEPOINT8ENDY=503;
-	private int borderLeftLinePoint8StartX=20;
-	
-	private int borderLeftLinePoint9StartY=509;
-	private int borderLeftLinePoint9EndY=509;
-	private final int BORDERLEFTLINEPOINT9ENDY=513;
-	private int borderLeftLinePoint9StartX=20;
-	
-	private Bitmap bitmapCircle1=BitmapFactory.decodeResource(getResources(), R.drawable.circle_one);
-	private Matrix circle1RotateMartrix1=new Matrix(); 
-	private int circle1DegreeValue1=0;
-	private Matrix circle1RotateMartrix2=new Matrix();
-	private int circle1DegreeValue2=0;
-	private Matrix circle1RotateMartrix3=new Matrix();
-	private int circle1DegreeValue3=0;
-	private Matrix circle1RotateMartrix4=new Matrix();
-	private int circle1DegreeValue4=0;
-	private Matrix circle1RotateMartrix5=new Matrix();
-	private int circle1DegreeValue5=0;
-	private Matrix circle1RotateMartrix6=new Matrix();
-	private int circle1DegreeValue6=0;
-	private Matrix circle1RotateMartrix7=new Matrix();
-	private int circle1DegreeValue7=0;
-	private Matrix circle1RotateMartrix8=new Matrix();
-	private int circle1DegreeValue8=0;
-	private Matrix circle1RotateMartrix9=new Matrix();
-	private int circle1DegreeValue9=0;
-	private Matrix circle1RotateMartrix10=new Matrix();
-	private int circle1DegreeValue10=0;
-	private Matrix circle1RotateMartrix11=new Matrix();
-	private int circle1DegreeValue11=0;
-	private Matrix circle1RotateMartrix12=new Matrix();
-	private int circle1DegreeValue12=0;
-	
-	private Bitmap bitmapCircle2=BitmapFactory.decodeResource(getResources(), R.drawable.circle_two);
-	private Matrix circle2ScaleMatrix1=new Matrix();
-	private float circle2ScaleValue1=0.0f;
-	
-	private Bitmap bitmapCircle3=BitmapFactory.decodeResource(getResources(), R.drawable.circle_three);
-	private Matrix circle3ScaleMatrix1=new Matrix();
-	private float circle3ScaleValue1=0.0f;
-	
-	private Bitmap bitmapCircle4=BitmapFactory.decodeResource(getResources(), R.drawable.circle_four);
-	private Matrix circle4ScaleMatrix1=new Matrix();
-	private float circle4ScaleValue1=0.0f;
-	
-	private Bitmap bitmapCircle5=BitmapFactory.decodeResource(getResources(), R.drawable.circle_five);
-	private Matrix circle5ScaleMatrix1=new Matrix();
-	private float circle5ScaleValue1=0.0f;
-	
-	private Bitmap bitmapCircle6=BitmapFactory.decodeResource(getResources(), R.drawable.circle_six);
-	private Matrix circle6ScaleMatrix1=new Matrix();
-	private float circle6ScaleValue1=0.0f;
-	
-	private Bitmap bitmapCircle7=BitmapFactory.decodeResource(getResources(), R.drawable.circle_seven);
-	private Matrix circle7ScaleMatrix1=new Matrix();
-	private float circle7ScaleValue1=0.0f;
-	
-	private Bitmap bitmapCircle8=BitmapFactory.decodeResource(getResources(), R.drawable.circle_eight);
-	private Matrix circle8ScaleMatrix1=new Matrix();
-	private float circle8ScaleValue1=0.0f;
-	
-	private Bitmap bitmapCircle9=BitmapFactory.decodeResource(getResources(), R.drawable.circle_nine);
-	private Matrix circle9ScaleMatrix1=new Matrix();
-	private int circle9DelayCount=0;
-	private float circle9ScaleValue1=1.1f;
-	private float circle9DegreeValue1=0.0f;
-	private int circle9AlphValue1=0;
-	private boolean scaleBigJudge=true;
-	
-	private float hongmo1Scale=0.0f;
-	private int hongmo1ZDegree=72;
-	private int hongmo2ZDegree=144;
-	private int hongmo3ZDegree=216;
-	private int hongmo4ZDegree=288;
-	private int hongmo5ZDegree=360;
-	private boolean hongmo1RightRotate=true;
-	
-	private Bitmap hongmoImage1=BitmapFactory.decodeResource(getResources(), R.drawable.circle_focus);
-	private Matrix hongmoImage1RotateMartrix1=new Matrix(); 
-	private int hongmoImage1DegreeValue1=0;
-	private Matrix hongmoImage1RotateMartrix2=new Matrix();
-	private int hongmoImage1DegreeValue2=0;
-	private Matrix hongmoImage1RotateMartrix3=new Matrix();
-	private int hongmoImage1DegreeValue3=0;
-	private Matrix hongmoImage1RotateMartrix4=new Matrix();
-	private int hongmoImage1DegreeValue4=0;
-	private Matrix hongmoImage1RotateMartrix5=new Matrix();
-	private int hongmoImage1DegreeValue5=0;
-	
-	public DrawFaceEyesView(Context context) {
-		this(context,null);
-	}	
-	
-	public DrawFaceEyesView(Context context, AttributeSet attrs) {
-		super(context, attrs);
-		// TODO Auto-generated constructor stub
-		mainPaint = new Paint();
-		alphPaint = new Paint();
-	}
-
-	@Override
-	protected void onDraw(Canvas canvas) {
-		// TODO Auto-generated method stub
-		super.onDraw(canvas);
-		//canvas.drawColor(Color.BLACK);
-    	
-    	
-    	/////////////////////////////////////////////////////////////
-//        if(downJudge&&upDownValue<0.0f){
-//			upDownValue+=30;
-//			hongmoMeshMaskImageMatrix.setTranslate(0f, upDownValue);
-//			if(upDownValue>-60.0f){
-//				downJudge=false;
-//			}
-//		}
-//
-//		if(!downJudge&&upDownValue>-960.0f){
-//			upDownValue-=30;
-//			hongmoMeshMaskImageMatrix.setTranslate(0f, upDownValue);
-//			if(upDownValue<-900.0f){
-//				downJudge=true;
-//			}
-//		}
-        
-        
-        
-    	if(borderLeftLine1EndY<BORDERLEFTLINE1ENDY){
-    		borderLeftLine1EndY++;
-    	}
-    	
-    	if(borderLeftLine2EndY<BORDERLEFTLINE2ENDY){
-    		borderLeftLine2EndY+=3;
-    	}else if(borderLeftLinePoint1EndY<BORDERLEFTLINEPOINT1ENDY){
-    		borderLeftLinePoint1EndY+=1;
-    	}else if(borderLeftLinePoint2EndY<BORDERLEFTLINEPOINT2ENDY){
-    		borderLeftLinePoint2EndY+=1;
-    	}else if(borderLeftLinePoint3EndY<BORDERLEFTLINEPOINT3ENDY){
-    		borderLeftLinePoint3EndY+=1;
-    	}
-    	
-    	if(borderLeftLine3EndY<BORDERLEFTLINE3ENDY){
-    		borderLeftLine3EndY+=5;
-    	}else if(borderLeftLinePoint4EndY<BORDERLEFTLINEPOINT4ENDY){
-    		borderLeftLinePoint4EndY+=1;
-    	}else if(borderLeftLinePoint5EndY<BORDERLEFTLINEPOINT5ENDY){
-    		borderLeftLinePoint5EndY+=1;
-    	}else if(borderLeftLinePoint6EndY<BORDERLEFTLINEPOINT6ENDY){
-    		borderLeftLinePoint6EndY+=1;
-    	}else if(borderLeftLinePoint7EndY<BORDERLEFTLINEPOINT7ENDY){
-    		borderLeftLinePoint7EndY+=1;
-    	}else if(borderLeftLinePoint8EndY<BORDERLEFTLINEPOINT8ENDY){
-    		borderLeftLinePoint8EndY+=1;
-    	}else if(borderLeftLinePoint9EndY<BORDERLEFTLINEPOINT9ENDY){
-    		borderLeftLinePoint9EndY+=1;
-    	}
-    	
-    	if(borderLeftLine4EndY>BORDERLEFTLINE4ENDY){
-    		borderLeftLine4EndY-=3;
-    	}else if(borderLeftLine5EndY>BORDERLEFTLINE5ENDY){
-    		borderLeftLine5EndY-=3;
-    		borderLeftLine5EndX+=3;
-    	}else if(borderLeftLine6EndY>BORDERLEFTLINE6ENDY){
-    		borderLeftLine6EndY-=3;
-    	}
-    	
-    	if(borderLeftLine7EndY>BORDERLEFTLINE7ENDY){
-    		borderLeftLine7EndY-=3;
-    	}else if(borderLeftLine8EndY>BORDERLEFTLINE8ENDY){
-    		borderLeftLine8EndY-=3;
-    		borderLeftLine8EndX+=3;
-    	}
-    	
-    	if(borderBottomLine1EndX<BORDERBOTTOMLINE1ENDX){
-    		borderBottomLine1EndX+=60;
-    	}
-    	
-    	if(borderLeftLine9EndY<BORDERLEFTLINE9ENDY){
-    		borderLeftLine9EndY+=3;
-    	}else if(borderLeftLine10EndY<BORDERLEFTLINE10ENDY){
-    		borderLeftLine10EndY+=3;
-    		borderLeftLine10EndX-=3;
-    	}else if(borderLeftLine11EndY<BORDERLEFTLINE11ENDY){
-    		borderLeftLine11EndY+=3;
-    	}
-    	
-    	if(borderLeftLine12EndY<BORDERLEFTLINE12ENDY){
-    		borderLeftLine12EndY+=3;
-    	}
-        
-    	if(circle1DegreeValue1<=18){
-    		circle1DegreeValue1+=3;
-    		circle1RotateMartrix1.setRotate(circle1DegreeValue1, 270, 270);
-    	}else{
-    		circle1DegreeValue1=-378;
-    	}
-    	
-    	if(circle1DegreeValue2<=48){
-    		circle1DegreeValue2+=3;
-    		circle1RotateMartrix2.setRotate(circle1DegreeValue2, 270, 270);
-    	}else{
-    		circle1DegreeValue2=-408;
-    	}
-    	
-    	if(circle1DegreeValue3<=72){
-    		circle1DegreeValue3+=3;
-    		circle1RotateMartrix3.setRotate(circle1DegreeValue3, 270, 270);
-    	}else{
-    		circle1DegreeValue3=-432;
-    	}
-    	
-    	if(circle1DegreeValue4<=96){
-    		circle1DegreeValue4+=3;
-    		circle1RotateMartrix4.setRotate(circle1DegreeValue4, 270, 270);
-    	}else{
-    		circle1DegreeValue4=-456;
-    	}
-    	
-    	if(circle1DegreeValue5<=135){
-    		circle1DegreeValue5+=3;
-    		circle1RotateMartrix5.setRotate(circle1DegreeValue5, 270, 270);
-    	}else{
-    		circle1DegreeValue5=-495;
-    	}
-    	
-    	if(circle1DegreeValue6<=156){
-    		circle1DegreeValue6+=3;
-    		circle1RotateMartrix6.setRotate(circle1DegreeValue6, 270, 270);
-    	}else{
-    		circle1DegreeValue6=-516;
-    	}
-    	
-    	if(circle1DegreeValue7>=-18){
-    		circle1DegreeValue7-=3;
-    		circle1RotateMartrix7.setRotate(circle1DegreeValue7, 270, 270);
-    	}else{
-    		circle1DegreeValue7=378;
-    	}
-    	
-    	if(circle1DegreeValue8>=-48){
-    		circle1DegreeValue8-=3;
-    		circle1RotateMartrix8.setRotate(circle1DegreeValue8, 270, 270);
-    	}else{
-    		circle1DegreeValue8=408;
-    	}
-    	
-    	if(circle1DegreeValue9>=-72){
-    		circle1DegreeValue9-=3;
-    		circle1RotateMartrix9.setRotate(circle1DegreeValue9, 270, 270);
-    	}else{
-    		circle1DegreeValue9=432;
-    	}
-    	
-    	if(circle1DegreeValue10>=-96){
-    		circle1DegreeValue10-=3;
-    		circle1RotateMartrix10.setRotate(circle1DegreeValue10, 270, 270);
-    	}else{
-    		circle1DegreeValue10=456;
-    	}
-    	
-    	if(circle1DegreeValue11>=-135){
-    		circle1DegreeValue11-=3;
-    		circle1RotateMartrix11.setRotate(circle1DegreeValue11, 270, 270);
-    	}else{
-    		circle1DegreeValue11=495;
-    	}
-    	
-    	if(circle1DegreeValue12>=-156){
-    		circle1DegreeValue12-=3;
-    		circle1RotateMartrix12.setRotate(circle1DegreeValue12, 270, 270);
-    	}else{
-    		circle1DegreeValue12=516;
-    	}
-    	
-    	if(circle2ScaleValue1<=1){
-    		circle2ScaleValue1+=0.05;
-    		circle2ScaleMatrix1.setScale(circle2ScaleValue1, circle2ScaleValue1, 270f, 270f);
-    	}
-    	
-    	if(circle3ScaleValue1<=1){
-    		circle3ScaleValue1+=0.02;
-    		circle3ScaleMatrix1.setScale(circle3ScaleValue1, circle3ScaleValue1, 270f, 270f);
-    	}
-    	
-    	if(circle4ScaleValue1<=1){
-    		circle4ScaleValue1+=0.03;
-    		circle4ScaleMatrix1.setScale(circle4ScaleValue1, circle4ScaleValue1, 270f, 270f);
-    	}
-    	
-    	if(circle5ScaleValue1<=1){
-    		circle5ScaleValue1+=0.04;
-    		circle5ScaleMatrix1.setScale(circle5ScaleValue1, circle5ScaleValue1, 270f, 270f);
-    	}
-    	
-    	if(circle6ScaleValue1<=1){
-    		circle6ScaleValue1+=0.05;
-    		circle6ScaleMatrix1.setScale(circle6ScaleValue1, circle6ScaleValue1, 270f, 270f);
-    	}
-    	
-    	if(circle7ScaleValue1<=1){
-    		circle7ScaleValue1+=0.06;
-    		circle7ScaleMatrix1.setScale(circle7ScaleValue1, circle7ScaleValue1, 270f, 270f);
-    	}
-    	
-    	if(circle8ScaleValue1<=1){
-    		circle8ScaleValue1+=0.07;
-    		circle8ScaleMatrix1.setScale(circle8ScaleValue1, circle8ScaleValue1, 270f, 270f);
-    	}
-    	
-    	if(circle9DelayCount<50){
-    		circle9DelayCount+=1;
-    	}else if(circle9ScaleValue1>=1&&circle9DelayCount<60){
-    		circle9ScaleValue1-=0.02;
-    		circle9AlphValue1=255;
-    		circle9ScaleMatrix1.setScale(circle9ScaleValue1, circle9ScaleValue1, 270f, 270f);
-    	}else if(circle9DegreeValue1<10&&circle9DelayCount<60){
-    		circle9DegreeValue1+=1;
-    		circle9AlphValue1-=25;
-    		circle9ScaleMatrix1.setScale(circle9ScaleValue1, circle9ScaleValue1, 270f, 270f);
-    		circle9ScaleMatrix1.setRotate(circle9DegreeValue1, 270f, 270f);
-    	}else if(circle9DelayCount<70){
-    		circle9DelayCount+=1;
-    	}else if(circle9DelayCount<80){
-    		circle9DelayCount+=1;
-    		circle9DegreeValue1-=1;
-    		circle9AlphValue1+=25;
-    		circle9ScaleMatrix1.setRotate(circle9DegreeValue1, 270f, 270f);
-    	}else if(circle9DelayCount<120){
-    		circle9DelayCount+=1;
-    		if(scaleBigJudge&&circle9ScaleValue1<1.2){
-    			circle9ScaleValue1+=0.005;
-    			if(circle9ScaleValue1>=1.1){
-    				scaleBigJudge=false;
-    			}
-    		}else{
-    			circle9ScaleValue1-=0.005;
-    		}
-    		circle9ScaleMatrix1.setScale(circle9ScaleValue1, circle9ScaleValue1, 270f, 270f);
-    	}
-    	
-    	if(hongmo1Scale<=1){
-    		hongmo1Scale+=0.05;
-    	}else if(hongmo1ZDegree<=45&&hongmo1RightRotate){
-    		hongmo1ZDegree+=2;
-    		hongmo2ZDegree+=2;
-    		hongmo3ZDegree+=2;
-    		hongmo4ZDegree+=2;
-    		hongmo5ZDegree+=2;
-    	}else{
-    		hongmo1RightRotate=false;
-    	}
-    	if(hongmo1ZDegree>=-45&&!hongmo1RightRotate){
-    		hongmo1ZDegree-=2;
-    		hongmo2ZDegree-=2;
-    		hongmo3ZDegree-=2;
-    		hongmo4ZDegree-=2;
-    		hongmo5ZDegree-=2;
-    	}else{
-    		hongmo1RightRotate=true;
-    	}
-    	
-    	if(hongmoImage1DegreeValue1<=72){
-    		hongmoImage1DegreeValue1+=9;
-    		hongmoImage1RotateMartrix1.setRotate(hongmoImage1DegreeValue1, 37.5f, 37.5f);
-    	}
-    	
-    	if(hongmoImage1DegreeValue2<=144){
-    		hongmoImage1DegreeValue2+=9;
-    		hongmoImage1RotateMartrix2.setRotate(hongmoImage1DegreeValue2, 37.5f, 37.5f);
-    	}
-    	
-    	if(hongmoImage1DegreeValue3<=216){
-    		hongmoImage1DegreeValue3+=9;
-    		hongmoImage1RotateMartrix3.setRotate(hongmoImage1DegreeValue3, 37.5f, 37.5f);
-    	}
-    	
-    	if(hongmoImage1DegreeValue4<=288){
-    		hongmoImage1DegreeValue4+=9;
-    		hongmoImage1RotateMartrix4.setRotate(hongmoImage1DegreeValue4, 37.5f, 37.5f);
-    	}
-    	
-    	if(hongmoImage1DegreeValue5<=360){
-    		hongmoImage1DegreeValue5+=9;
-    		hongmoImage1RotateMartrix5.setRotate(hongmoImage1DegreeValue5, 37.5f, 37.5f);
-    	}
-    	
-    	//A
-    	/////////////////////////////////////////////////////////////
-//        canvas.drawBitmap(hongmoMeshImage, hongmoMeshImageMatrix, null);
-//        canvas.drawBitmap(hongmoMeshMaskImage, hongmoMeshMaskImageMatrix, null);
-        canvas.drawBitmap(hongmoMaskImage, hongmoMeshImageMatrix, null);
-        
-        mainPaint.setColor(Color.RED);
-        mainPaint.setStrokeWidth(5);
-        /*canvas.drawLine(borderLeftLine1StartX, borderLeftLine1StartY, borderLeftLine1StartX, borderLeftLine1EndY, mainPaint);
-        
-        mainPaint.setStrokeWidth(3);
-        canvas.drawLine(borderLeftLine2StartX, borderLeftLine2StartY, borderLeftLine2StartX, borderLeftLine2EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint1StartX, borderLeftLinePoint1StartY, borderLeftLinePoint1StartX, borderLeftLinePoint1EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint2StartX, borderLeftLinePoint2StartY, borderLeftLinePoint2StartX, borderLeftLinePoint2EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint3StartX, borderLeftLinePoint3StartY, borderLeftLinePoint3StartX, borderLeftLinePoint3EndY, mainPaint);
-
-        
-        mainPaint.setStrokeWidth(3);
-        canvas.drawLine(borderLeftLine3StartX, borderLeftLine3StartY, borderLeftLine3StartX, borderLeftLine3EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint4StartX, borderLeftLinePoint4StartY, borderLeftLinePoint4StartX, borderLeftLinePoint4EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint5StartX, borderLeftLinePoint5StartY, borderLeftLinePoint5StartX, borderLeftLinePoint5EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint6StartX, borderLeftLinePoint6StartY, borderLeftLinePoint6StartX, borderLeftLinePoint6EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint7StartX, borderLeftLinePoint7StartY, borderLeftLinePoint7StartX, borderLeftLinePoint7EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint8StartX, borderLeftLinePoint8StartY, borderLeftLinePoint8StartX, borderLeftLinePoint8EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint9StartX, borderLeftLinePoint9StartY, borderLeftLinePoint9StartX, borderLeftLinePoint9EndY, mainPaint);
-
-        
-        mainPaint.setStrokeWidth(1);
-        canvas.drawLine(borderLeftLine4StartX, borderLeftLine4StartY, borderLeftLine4StartX, borderLeftLine4EndY, mainPaint);
-        canvas.drawLine(borderLeftLine5StartX, borderLeftLine5StartY, borderLeftLine5EndX, borderLeftLine5EndY, mainPaint);
-        canvas.drawLine(borderLeftLine6StartX, borderLeftLine6StartY, borderLeftLine6StartX, borderLeftLine6EndY, mainPaint);
-        
-        mainPaint.setStrokeWidth(1);
-        canvas.drawLine(borderLeftLine7StartX, borderLeftLine7StartY, borderLeftLine7StartX, borderLeftLine7EndY, mainPaint);
-        canvas.drawLine(borderLeftLine8StartX, borderLeftLine8StartY, borderLeftLine8EndX, borderLeftLine8EndY, mainPaint);
-        canvas.drawLine(borderBottomLine1StartX, borderBottomLine1StartY, borderBottomLine1EndX, borderBottomLine1StartY, mainPaint);
-        
-        mainPaint.setStrokeWidth(1);
-        canvas.drawLine(borderLeftLine9StartX, borderLeftLine9StartY, borderLeftLine9StartX, borderLeftLine9EndY, mainPaint);
-        canvas.drawLine(borderLeftLine10StartX, borderLeftLine10StartY, borderLeftLine10EndX, borderLeftLine10EndY, mainPaint);
-        canvas.drawLine(borderLeftLine11StartX, borderLeftLine11StartY, borderLeftLine11StartX, borderLeftLine11EndY, mainPaint);
-        
-        mainPaint.setStrokeWidth(1);
-        canvas.drawLine(borderLeftLine12StartX, borderLeftLine12StartY, borderLeftLine12StartX, borderLeftLine12EndY, mainPaint);*/
-        
-        
-        //canvas.translate(140, 140);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix1, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix2, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix3, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix4, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix5, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix6, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix7, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix8, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix9, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix10, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix11, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix12, null);
-        
-        canvas.drawBitmap(bitmapCircle2, circle2ScaleMatrix1, null);
-        
-        canvas.drawBitmap(bitmapCircle3, circle3ScaleMatrix1, null);
-        
-        canvas.drawBitmap(bitmapCircle4, circle4ScaleMatrix1, null);
-        
-        canvas.drawBitmap(bitmapCircle5, circle5ScaleMatrix1, null);
-        
-        canvas.drawBitmap(bitmapCircle6, circle6ScaleMatrix1, null);
-        
-        canvas.drawBitmap(bitmapCircle7, circle7ScaleMatrix1, null);
-        
-        canvas.drawBitmap(bitmapCircle8, circle8ScaleMatrix1, null);
-        
-        alphPaint.setAlpha(circle9AlphValue1);
-        canvas.drawBitmap(bitmapCircle9, circle9ScaleMatrix1, alphPaint);
-        
-        
-        
-        //B
-    	/////////////////////////////////////////////////////////////
-        canvas.translate(540, 0);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix1, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix2, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix3, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix4, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix5, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix6, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix7, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix8, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix9, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix10, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix11, null);
-        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix12, null);
-        
-        canvas.drawBitmap(bitmapCircle2, circle2ScaleMatrix1, null);
-        
-        canvas.drawBitmap(bitmapCircle3, circle3ScaleMatrix1, null);
-        
-        canvas.drawBitmap(bitmapCircle4, circle4ScaleMatrix1, null);
-        
-        canvas.drawBitmap(bitmapCircle5, circle5ScaleMatrix1, null);
-        
-        canvas.drawBitmap(bitmapCircle6, circle6ScaleMatrix1, null);
-        
-        canvas.drawBitmap(bitmapCircle7, circle7ScaleMatrix1, null);
-        
-        canvas.drawBitmap(bitmapCircle8, circle8ScaleMatrix1, null);
-        
-        alphPaint.setAlpha(circle9AlphValue1);
-        canvas.drawBitmap(bitmapCircle9, circle9ScaleMatrix1, alphPaint);
-        
-        
-        
-        //C
-    	/////////////////////////////////////////////////////////////
-        canvas.translate(510, 0);
-        
-        mainPaint.setColor(Color.RED);
-        mainPaint.setStrokeWidth(5);
-        /*canvas.drawLine(borderLeftLine1StartX, borderLeftLine1StartY, borderLeftLine1StartX, borderLeftLine1EndY, mainPaint);
-        
-        mainPaint.setStrokeWidth(3);
-        canvas.drawLine(borderLeftLine2StartX, borderLeftLine2StartY, borderLeftLine2StartX, borderLeftLine2EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint1StartX, borderLeftLinePoint1StartY, borderLeftLinePoint1StartX, borderLeftLinePoint1EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint2StartX, borderLeftLinePoint2StartY, borderLeftLinePoint2StartX, borderLeftLinePoint2EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint3StartX, borderLeftLinePoint3StartY, borderLeftLinePoint3StartX, borderLeftLinePoint3EndY, mainPaint);
-
-        
-        mainPaint.setStrokeWidth(3);
-        canvas.drawLine(borderLeftLine3StartX, borderLeftLine3StartY, borderLeftLine3StartX, borderLeftLine3EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint4StartX, borderLeftLinePoint4StartY, borderLeftLinePoint4StartX, borderLeftLinePoint4EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint5StartX, borderLeftLinePoint5StartY, borderLeftLinePoint5StartX, borderLeftLinePoint5EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint6StartX, borderLeftLinePoint6StartY, borderLeftLinePoint6StartX, borderLeftLinePoint6EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint7StartX, borderLeftLinePoint7StartY, borderLeftLinePoint7StartX, borderLeftLinePoint7EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint8StartX, borderLeftLinePoint8StartY, borderLeftLinePoint8StartX, borderLeftLinePoint8EndY, mainPaint);
-        canvas.drawLine(borderLeftLinePoint9StartX, borderLeftLinePoint9StartY, borderLeftLinePoint9StartX, borderLeftLinePoint9EndY, mainPaint);
-
-        
-        mainPaint.setStrokeWidth(1);
-        canvas.drawLine(borderLeftLine4StartX, borderLeftLine4StartY, borderLeftLine4StartX, borderLeftLine4EndY, mainPaint);
-        canvas.drawLine(borderLeftLine5StartX, borderLeftLine5StartY, borderLeftLine5EndX, borderLeftLine5EndY, mainPaint);
-        canvas.drawLine(borderLeftLine6StartX, borderLeftLine6StartY, borderLeftLine6StartX, borderLeftLine6EndY, mainPaint);
-        
-        mainPaint.setStrokeWidth(1);
-        canvas.drawLine(borderLeftLine7StartX, borderLeftLine7StartY, borderLeftLine7StartX, borderLeftLine7EndY, mainPaint);
-        canvas.drawLine(borderLeftLine8StartX, borderLeftLine8StartY, borderLeftLine8EndX, borderLeftLine8EndY, mainPaint);
-        //canvas.drawLine(borderBottomLine1StartX, borderBottomLine1StartY, borderBottomLine1EndX, borderBottomLine1StartY, mainPaint);
-        
-        mainPaint.setStrokeWidth(1);
-        canvas.drawLine(borderLeftLine9StartX, borderLeftLine9StartY, borderLeftLine9StartX, borderLeftLine9EndY, mainPaint);
-        canvas.drawLine(borderLeftLine10StartX, borderLeftLine10StartY, borderLeftLine10EndX, borderLeftLine10EndY, mainPaint);
-        canvas.drawLine(borderLeftLine11StartX, borderLeftLine11StartY, borderLeftLine11StartX, borderLeftLine11EndY, mainPaint);
-        
-        mainPaint.setStrokeWidth(1);
-        canvas.drawLine(borderLeftLine12StartX, borderLeftLine12StartY, borderLeftLine12StartX, borderLeftLine12EndY, mainPaint);*/
-        
-        canvas.translate(-814, 233);
-        if(hongmoImage1DegreeValue5>=369){
-        	camera.save();
-    		camera.rotateZ(hongmo1ZDegree);
-    		//camera.rotateX(hongmo1XDegree);
-    		camera.getMatrix(hongmoImage1RotateMartrix1);
-    		camera.restore();
-    		camera.save();
-    		camera.rotateZ(hongmo2ZDegree);
-    		camera.getMatrix(hongmoImage1RotateMartrix2);
-    		camera.restore();
-    		camera.save();
-    		camera.rotateZ(hongmo3ZDegree);
-    		camera.getMatrix(hongmoImage1RotateMartrix3);
-    		camera.restore();
-    		camera.save();
-    		camera.rotateZ(hongmo4ZDegree);
-    		camera.getMatrix(hongmoImage1RotateMartrix4);
-    		camera.restore();
-    		camera.save();
-    		camera.rotateZ(hongmo5ZDegree);
-    		camera.getMatrix(hongmoImage1RotateMartrix5);
-    		camera.restore();
-    		
-    		hongmoImage1RotateMartrix1.preTranslate(-37.5f, -37.5f); 
-    		hongmoImage1RotateMartrix1.postTranslate(37.5f, 37.5f);
-    		
-    		hongmoImage1RotateMartrix2.preTranslate(-37.5f, -37.5f); 
-    		hongmoImage1RotateMartrix2.postTranslate(37.5f, 37.5f);
-    		
-    		hongmoImage1RotateMartrix3.preTranslate(-37.5f, -37.5f); 
-    		hongmoImage1RotateMartrix3.postTranslate(37.5f, 37.5f);
-    		
-    		hongmoImage1RotateMartrix4.preTranslate(-37.5f, -37.5f); 
-    		hongmoImage1RotateMartrix4.postTranslate(37.5f, 37.5f);
-    		
-    		hongmoImage1RotateMartrix5.preTranslate(-37.5f, -37.5f); 
-    		hongmoImage1RotateMartrix5.postTranslate(37.5f, 37.5f);
-        }
-        
-        
-        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix1, null);
-        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix2, null);
-        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix3, null);
-        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix4, null);
-        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix5, null);
-        
-        canvas.translate(540, 0);
-        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix1, null);
-        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix2, null);
-        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix3, null);
-        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix4, null);
-        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix5, null);
-        
-        
-        invalidate();
-	}
-	
-    public void recycleBitmap() {
-        if(!hongmoMaskImage.isRecycled())hongmoMaskImage.recycle();
-        if(!bitmapCircle1.isRecycled())bitmapCircle1.recycle();
-        if(!bitmapCircle2.isRecycled())bitmapCircle2.recycle();
-        if(!bitmapCircle3.isRecycled())bitmapCircle3.recycle();
-        if(!bitmapCircle4.isRecycled())bitmapCircle4.recycle();
-        if(!bitmapCircle5.isRecycled())bitmapCircle5.recycle();
-        if(!bitmapCircle6.isRecycled())bitmapCircle6.recycle();
-        if(!bitmapCircle7.isRecycled())bitmapCircle7.recycle();
-        if(!bitmapCircle8.isRecycled())bitmapCircle8.recycle();
-        if(!bitmapCircle9.isRecycled())bitmapCircle9.recycle();
-        if(!hongmoImage1.isRecycled())hongmoImage1.recycle();
-   }
-
-}
Index: frameworks/base/packages/Keyguard/src/com/face/scanner/view/RoundProgressBar.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/face/scanner/view/RoundProgressBar.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/face/scanner/view/RoundProgressBar.java	(revision 6857)
@@ -1,275 +0,0 @@
-package com.face.scanner.view;
-
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.graphics.RectF;
-import android.graphics.Typeface;
-import android.graphics.drawable.BitmapDrawable;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.widget.ImageView;
-
-import com.android.keyguard.R;
-
-
-/**
- * 线程安全的View，可直接在线程中更新进度
- *
- */
-public class RoundProgressBar extends ImageView {
-
-	/**
-	 * 画笔对象的引用
-	 */
-	private Paint paint;
-
-	/**
-	 * 圆环的颜色
-	 */
-	private int roundColor;
-
-	/**
-	 * 圆环进度的颜色
-	 */
-	private int roundProgressColor;
-
-	/**
-	 * 中间进度百分比的字符串的颜色
-	 */
-	private int textColor;
-
-	/**
-	 * 中间进度百分比的字符串的字体
-	 */
-	private float textSize;
-
-	/**
-	 * 圆环的宽度
-	 */
-	private float roundWidth;
-
-	/**
-	 * 最大进度
-	 */
-	private int max;
-
-	/**
-	 * 当前进度
-	 */
-	private int left_progress, right_progress;
-	
-	private Bitmap mBackgroundBitmap;
-	private int mBGWidth;
-	private int mBGHeight;
-	
-
-	private float x1,x2,y,radius;
-	
-	private boolean textIsDisplayable;
-
-	public RoundProgressBar(Context context) {
-		this(context, null);
-	}
-
-	public RoundProgressBar(Context context, AttributeSet attrs) {
-		this(context, attrs, 0);
-	}
-
-	public RoundProgressBar(Context context, AttributeSet attrs, int defStyle) {
-		super(context, attrs, defStyle);
-
-		paint = new Paint();
-
-
-		TypedArray mTypedArray = context.obtainStyledAttributes(attrs,
-				R.styleable.RoundProgressBar);
-
-		//获取自定义属性和默认
-
-		//roundProgressColor = mTypedArray.getColor(R.styleable.RoundProgressBar_roundProgressColor, Color.GREEN);
-		roundProgressColor = mTypedArray.getColor(R.styleable.RoundProgressBar_roundProgressColor, context.getResources().getColor(android.R.color.white));
-		//textColor = mTypedArray.getColor(R.styleable.RoundProgressBar_textColor, Color.GREEN);
-		textColor = mTypedArray.getColor(R.styleable.RoundProgressBar_textColor,  context.getResources().getColor(android.R.color.white));
-		textSize = mTypedArray.getDimension(R.styleable.RoundProgressBar_textSize, 15);
-		roundWidth = mTypedArray.getDimension(R.styleable.RoundProgressBar_roundWidth, 5);
-		max = mTypedArray.getInteger(R.styleable.RoundProgressBar_max, 100);
-		textIsDisplayable = mTypedArray.getBoolean(R.styleable.RoundProgressBar_textIsDisplayable, true);
-//		style = mTypedArray.getInt(R.styleable.RoundProgressBar_style, 0);
-		roundColor = mTypedArray.getColor(R.styleable.RoundProgressBar_roundColor, Color.RED);
-		mTypedArray.recycle();
-		
-//		mBackgroundBitmap = ((BitmapDrawable)getResources().getDrawable(R.drawable.b_3_2_ok_00)).getBitmap();
-		
-//		setDrawingCacheEnabled(false);
-		setImageResource(R.drawable.b_3_2_ok_00);
-	}
-
-
-	@Override
-	protected void onDraw(Canvas canvas) {
-		super.onDraw(canvas);
-		
-		if(mBGWidth == 0 || mBGHeight == 0){
-			mBGWidth = getMeasuredWidth();
-			mBGHeight = getMeasuredHeight();
-			x1 = (float) (mBGWidth * 90 / 360);
-			x2 = (float) (mBGWidth * 270 / 360);
-			y = (float) (mBGHeight * 91 / 203);
-			radius = (float) (mBGWidth * 52 / 360);
-			Log.i("hz", "mBGWidth:" + mBGWidth + ",mBGHeight:" + mBGHeight);
-		}
-		
-		Log.i("hz", "getWidth:" + getMeasuredWidth() + ",getHeight:" + getMeasuredHeight());
-		/**
-		 * 画最外层的大圆环
-		 */
-		paint.setColor(roundColor); //设置圆环的颜色
-		paint.setStyle(Paint.Style.STROKE); //设置空心
-		paint.setStrokeWidth(roundWidth); //设置圆环的宽度
-		paint.setAntiAlias(true);  //消除锯齿
-		canvas.drawCircle(x1, y, radius, paint); //画出圆环
-		
-		canvas.drawCircle(x2, y, radius, paint); //画出圆环
-		
-		/**
-		 * 画进度百分比
-		 */
-		paint.setStrokeWidth(0);
-		paint.setColor(textColor);
-		paint.setTextSize(textSize);
-		paint.setTypeface(Typeface.DEFAULT_BOLD); //设置字体
-
-
-		/**
-		 * 画圆弧 ，画圆环的进度
-		 */
-		paint.setStrokeWidth(roundWidth); //设置圆环的宽度
-		paint.setColor(Color.argb(255, 72, 236, 239));  //设置进度的颜色
-		RectF left_oval = new RectF(x1 - radius, y - radius, x1
-				+ radius, y + radius);  //用于定义的圆弧的形状和大小的界限
-		RectF right_oval = new RectF(x2 - radius, y - radius, x2
-				+ radius, y + radius);  //用于定义的圆弧的形状和大小的界限
-
-		paint.setStyle(Paint.Style.STROKE);
-		canvas.drawArc(left_oval, -90, 360 * left_progress / max, false, paint);  //根据进度画圆弧
-		canvas.drawArc(right_oval, -90, 360 * right_progress / max, false, paint);  //根据进度画圆弧
-		
-	}
-
-
-	public synchronized int getMax() {
-		return max;
-	}
-
-	/**
-	 * 设置进度的最大值
-	 * @param max
-	 */
-	public synchronized void setMax(int max) {
-		if(max < 0){
-			throw new IllegalArgumentException("max not less than 0");
-		}
-		this.max = max;
-	}
-
-	/**
-	 * 获取进度.需要同步
-	 * @return
-	 */
-	public synchronized int getLeftProgress() {
-		return left_progress;
-	}
-	public synchronized int getRightProgress() {
-		return right_progress;
-	}
-
-	/**
-	 * 设置进度，此为线程安全控件，由于考虑多线的问题，需要同步
-	 * 刷新界面调用postInvalidate()能在非UI线程刷新
-	 * @param progress
-	 */
-	public synchronized void setLeftProgress(int leftProgress) {
-		if(leftProgress < 0){
-			throw new IllegalArgumentException("progress not less than 0");
-		}
-		if(leftProgress > max){
-			leftProgress = max;
-		}
-		if(leftProgress <= max){
-			this.left_progress = leftProgress;
-			postInvalidate();
-		}
-	}
-	
-	public synchronized void setRightProgress(int rightProgress) {
-		if(rightProgress < 0){
-			throw new IllegalArgumentException("progress not less than 0");
-		}
-		if(rightProgress > max){
-			rightProgress = max;
-		}
-		if(rightProgress <= max){
-			this.right_progress = rightProgress;
-			postInvalidate();
-		}
-	}
-	
-	public synchronized void setLeftAndRightProgress(int leftProgress,int rightProgress) {
-		if(leftProgress <0 || rightProgress < 0){
-			throw new IllegalArgumentException("progress not less than 0");
-		}
-		if(leftProgress > max || rightProgress > max){
-			rightProgress = max;
-		}
-		this.left_progress = leftProgress;
-		this.right_progress = rightProgress;
-		postInvalidate();
-	}
-
-
-	public int getCricleColor() {
-		return roundColor;
-	}
-
-	public void setCricleColor(int cricleColor) {
-		this.roundColor = cricleColor;
-	}
-
-	public int getCricleProgressColor() {
-		return roundProgressColor;
-	}
-
-	public void setCricleProgressColor(int cricleProgressColor) {
-		this.roundProgressColor = cricleProgressColor;
-	}
-
-	public int getTextColor() {
-		return textColor;
-	}
-
-	public void setTextColor(int textColor) {
-		this.textColor = textColor;
-	}
-
-	public float getTextSize() {
-		return textSize;
-	}
-
-	public void setTextSize(float textSize) {
-		this.textSize = textSize;
-	}
-
-	public float getRoundWidth() {
-		return roundWidth;
-	}
-
-	public void setRoundWidth(float roundWidth) {
-		this.roundWidth = roundWidth;
-	}
-
-
-}
Index: frameworks/base/packages/Keyguard/src/com/face/scanner/FaceActivity.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/face/scanner/FaceActivity.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/face/scanner/FaceActivity.java	(revision 6857)
@@ -1,636 +0,0 @@
-package com.face.scanner;
-
-import java.util.ArrayList;
-
-import android.app.Activity;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.graphics.Bitmap;
-import android.graphics.Rect;
-import android.hardware.Camera;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Message;
-import android.os.SystemClock;
-import android.provider.Settings;
-import android.util.Log;
-import android.view.View;
-import android.view.Window;
-import android.view.WindowManager;
-import android.widget.CheckBox;
-import android.widget.LinearLayout;
-import android.widget.Toast;
-import com.sensetime.faceunlock.widget.FaceUnlockCyleView;
-import com.android.keyguard.R;
-import com.android.keyguard.KeyguardUtils;
-import android.widget.TextView;
-import com.sensetime.faceapi.model.FaceInfo;
-import com.sensetime.faceapi.utils.AccelerometerManager;
-import com.sensetime.faceunlock.bean.FaceFeature;
-import com.sensetime.faceunlock.bean.User;
-import com.sensetime.faceunlock.config.AppConfig;
-import com.sensetime.faceunlock.handler.WeakHandler;
-import com.sensetime.faceunlock.manager.HackerProxy;
-import com.sensetime.faceunlock.manager.UserManager;
-import com.sensetime.faceunlock.manager.VerifyProxy;
-import com.sensetime.faceunlock.util.BitmapUtil;
-import com.sensetime.faceunlock.util.DirectUtil;
-import com.sensetime.faceunlock.util.FileUtil;
-import com.sensetime.faceunlock.util.FaceUtil;
-import com.sensetime.faceunlock.util.LogUtil;
-import com.sensetime.faceunlock.widget.CameraView;
-import com.sensetime.faceunlock.widget.FaceRegisterView;
-import com.sensetime.faceunlock.widget.MaskView;
-import com.sensetime.faceunlock.manager.DetectProxy;
-import com.sensetime.faceapi.utils.FaceRotationUtil;
-//wym for bug 99963
-import java.util.Timer;
-import java.util.TimerTask;
-//Begin: add by junwei.shen, create password AlertDialog for Face, at 2017.7.12
-import android.app.AlertDialog;
-import android.app.admin.DevicePolicyManager;
-import android.content.DialogInterface;
-import android.content.ComponentName;
-import android.provider.Settings.SettingNotFoundException;
-//End: add by junwei.shen, create password AlertDialog for Face, at 2017.7.12
-import android.telephony.TelephonyManager;
-import android.app.Service;
-
-
-
-public class FaceActivity extends Activity {
-    private static final String TAG = "FaceActivity";
-    private CameraView mCameraView; // 
-    private CheckBox[] checkBoxes = new CheckBox[5];
-
-    private Thread mTrackThread; // 
-    private HandlerThread mGetFeatureThread; // 
-    private Handler mGetFeatureHandler; //
-    private ArrayList<User> users = new ArrayList<>(); // 
-    private String uuid = FileUtil.getUUIDName(); //
-
-    private volatile boolean mIsNv21DataReady; //
-    private volatile boolean mIsTracking; //
-    private boolean isVerifying; //
-    private boolean mIsKilled; // 
-    private byte[] mNv21; // 
-    private int mCount; // 
-    private int mLastFaceId = -1;
-    private WeakHandler<FaceActivity> uiHandler;
-
-    private static final int Face_NEW_REQUEST = 300;
-    private static final int Face_REPLACE_REQUEST = 301;
-    private static final int Face_REMOVE_REQUEST = 302;   
-    private static final int Face_DEMO_REMOVE_REQUEST = 303;
-    //Add by junwei.shen, for deal Face entry timeout, at 2017.7.4
-    private static final int Face_ENTRY_TIMEOUT = 304;
-    private static final int FROM_SETTING = 400;
-    
-    public static final int MSG_SHOW_HINT1_TV = 0x001;
-    public static final int MSG_SHOW_HINT2_TV = 0x002;
-    public static final int MSG_HIDE_HINT_TV = 0x003;
-    public static final int MSG_UPDATE_PROGRESS = 0x004;
-    public static final int MSG_NOT_SAME_FACE = 0x005;
-    public static final int MSG_DARK_LIGHT = 0x006;
-    public static final int MSG_SHOW_HINT4_TV = 0x007;
-    public static final int MSG_LONGTIME_NO_FACE = 0x008;
-
-    public static final int MAX_NOT_SAME_COUNT = 10;
-    private int mNotSameFaceCount;
-
-    public String HINT_TEXT_1;
-    public String HINT_TEXT_2;
-    public String HINT_TEXT_3;
-    public String HINT_TEXT_4;
-    
-    private int mRequestType;
-    private int mFromSource;
-    private boolean isFMode;
-    private User user; // 
-    private boolean isNotHacker; 
-    private int attemptCount; 
-    private boolean mIsBroadcastRegister = false;
-
-    private TextView description_info,info_text;
-    private int progress = 0;
-    private boolean isShowErrorInfo = false;
-    private FaceUnlockCyleView CycleView;
-    private MaskView mMaskView;
-    //Begin: add by junwei.shen, create password AlertDialog for Face, at 2017.7.12
-    private String KEY_HAS_PASSWORD = "has_password";
-    private int hasPassword = -1;
-    private Context mContext;
-    private ComponentName mComponentName;
-    private String sharedPackageName = "com.android.settings";
-    private String sharedClassName = "com.android.settings.ChooseLockGeneric";
-    public static final String MINIMUM_QUALITY_KEY = "minimum_quality";
-    public static final String HIDE_DISABLED_PREFS = "hide_disabled_prefs";
-    public static final String EXTRA_KEY_HAS_CHALLENGE = "has_challenge";
-    public static final String EXTRA_KEY_CHALLENGE = "challenge";
-    public static final String EXTRA_KEY_FOR_FINGERPRINT = "for_fingerprint";
-    private static final int CHOOSE_LOCK_GENERIC_REQUEST = 227;
-    //End: add by junwei.shen, create password AlertDialog for Face, at 2017.7.12
-
-    //wym add for 99963. 2017/07/06
-    Timer timer = new Timer();
-    boolean mIsNotGetFaceInfo = true;
-    
-    TimerTask task = new TimerTask() {    
-      @Override  
-         public void run() {    
-         
-            runOnUiThread(new Runnable() {
-                @Override  
-                public void run() { 
-                    LogUtil.d(TAG,"...............timerTask mIsNotGetFaceInfo="+mIsNotGetFaceInfo);
-                    if(mIsNotGetFaceInfo){    
-                        //KeyguardUtils.showNormalDialog(FaceActivity.this,"人脸录入");
-                        Toast.makeText(FaceActivity.this.getApplicationContext(), R.string.face_face_get, Toast.LENGTH_SHORT).show();
-                        FaceActivity.this.finish();
-                    }
-                }  
-            });  
-        }  
-    };
-    
-    BroadcastReceiver mBatInfoReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(final Context context, final Intent intent) {
-            Log.d(TAG, "onReceive");
-            String action = intent.getAction();
-			
-			TelephonyManager tManager = (TelephonyManager) context.getSystemService(Service.TELEPHONY_SERVICE);
-            if (Intent.ACTION_SCREEN_OFF.equals(action) || tManager.getCallState() == TelephonyManager.CALL_STATE_RINGING) {
-                Log.d(TAG, "screen off");
-                FaceActivity.this.finish();
-            }
-        }
-    };
-
-    private void initUiHandler() {
-        uiHandler = new WeakHandler<FaceActivity>(this) {
-            @Override
-            public void handleMsg(FaceActivity act, Message msg) {
-                switch (msg.what) {
-                    case MSG_SHOW_HINT1_TV:
-                        info_text.setVisibility(View.VISIBLE);
-                        info_text.setText(HINT_TEXT_1);
-                        break;
-                    case MSG_SHOW_HINT2_TV:
-                        info_text.setVisibility(View.VISIBLE);
-                        info_text.setText(HINT_TEXT_2);
-                        break;
-                    case MSG_SHOW_HINT4_TV:
-                        info_text.setVisibility(View.VISIBLE);
-                        info_text.setText(HINT_TEXT_4);
-                        break;
-					case MSG_LONGTIME_NO_FACE:
-					    
-					    task = new TimerTask() {    
-                             @Override  
-                            public void run() {    
-         
-                            runOnUiThread(new Runnable() {
-                            @Override  
-                            public void run() { 
-                            LogUtil.d(TAG,"...............timerTask mIsNotGetFaceInfo="+mIsNotGetFaceInfo);
-                            if(mIsNotGetFaceInfo){    
-                                Toast.makeText(FaceActivity.this.getApplicationContext(), R.string.face_face_get, Toast.LENGTH_SHORT).show();
-                                FaceActivity.this.finish();
-                                }
-                                }  
-                                });
-                            }  
-                        };
-						timer = new Timer();
-						timer.schedule(task, 20000);
-					    break;
-                    case MSG_DARK_LIGHT:
-                        info_text.setVisibility(View.VISIBLE);
-                        info_text.setText(HINT_TEXT_3);
-                        break;
-                    case MSG_HIDE_HINT_TV:
-                        info_text.setVisibility(View.GONE);
-                        break;
-                    case MSG_UPDATE_PROGRESS:
-                        int progress = users.size() * 20;
-                        mMaskView.setProgress(progress);
-                        if (users.size() >= 5) {
-                            mCameraView.setPreviewCallback(null);
-                            mCameraView.stopPreview();
-                            register("jun");
-                        }
-                        break;
-                    case MSG_NOT_SAME_FACE:
-                        if (mMaskView != null) {
-                            mMaskView.setProgress(0);
-                            users.clear();
-                            mNotSameFaceCount = 0;
-                            UserManager.deleteAllUser(FaceActivity.this);
-                        }
-                        break;
-                }
-            }
-        };
-    }
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
-        requestWindowFeature(Window.FEATURE_NO_TITLE);
-        HINT_TEXT_1 = getString(R.string.ic_default_move_face_center);
-        HINT_TEXT_2 = getString(R.string.ic_default_stay_font);
-        HINT_TEXT_3 = getString(R.string.ic_default_dark_light);
-        HINT_TEXT_4 = getString(R.string.ic_default_no_face_data_info);
-        //isFMode = getIntent().getBooleanExtra("isFMode", false);
-        mRequestType = getIntent().getIntExtra("requestType", 0);
-        mFromSource = getIntent().getIntExtra("source", 0);
-       // Log.d(TAG, "mRequestType:"+mRequestType+", isFMode:"+isFMode);
-        /*if(isFMode)
-        {
-            mRequestType = Face_NEW_REQUEST;
-            getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
-        }zxp*/
-        
-        if(mRequestType < Face_NEW_REQUEST || mRequestType > Face_DEMO_REMOVE_REQUEST)
-        {
-            Log.d(TAG, "onCreate:request error");
-            finish();
-        }
-        if (mRequestType == Face_REMOVE_REQUEST) {
-            UserManager.deleteAllUser(this);
-            saveFaceState(false);
-            setResult(RESULT_OK);
-            finish();
-            return;
-        }
-        setContentView(R.layout.activity_register);
-        initView();
-        DetectProxy.init();
-        VerifyProxy.init(this);
-        initUiHandler();
-        if (AppConfig.isOpenHacker) {
-            HackerProxy.init();
-        }
-        final IntentFilter filter = new IntentFilter();  
-        filter.addAction(Intent.ACTION_SCREEN_OFF);
-		filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
-        registerReceiver(mBatInfoReceiver, filter);
-        mIsBroadcastRegister = true;
-        LogUtil.d(TAG,"!!!!!!!!!timer.schedule!!!!!!");
-        timer.schedule(task, 20000);
-        //Add by junwei.shen, create password AlertDialog for Face, at 2017.7.12
-        mContext = FaceActivity.this;
-
-    }
-
-    private void initView() {
-        mCameraView = (CameraView) findViewById(R.id.camera_view);
-        if (mRequestType == Face_REMOVE_REQUEST) {
-            LinearLayout linearLayout = (LinearLayout) findViewById(R.id.register);
-            linearLayout.setVisibility(View.GONE);
-        } else {
-            checkBoxes[0] = (CheckBox) findViewById(R.id.register_front);
-            checkBoxes[1] = (CheckBox) findViewById(R.id.register_up);
-            checkBoxes[2] = (CheckBox) findViewById(R.id.register_down);
-            checkBoxes[3] = (CheckBox) findViewById(R.id.register_left);
-            checkBoxes[4] = (CheckBox) findViewById(R.id.register_right);
-            description_info = (TextView) findViewById(R.id.face_unlock_scan_bottom_info);
-            info_text = (TextView) findViewById(R.id.face_unlock_info_text);
-            mMaskView = (MaskView) findViewById(R.id.mask_view);
-            description_info.setText(R.string.ic_default_sacn_face_description_info);
-            CycleView =  (FaceUnlockCyleView) findViewById(R.id.face_unlock_cycle_view);
-        }
-
-        mCameraView.setPreviewCallback(new Camera.PreviewCallback() {
-
-            @Override
-            public void onPreviewFrame(byte[] data, Camera camera) {
-                if (mNv21 == null || data.length != mNv21.length) {
-                    mNv21 = new byte[data.length];
-                }
-                if (!mIsTracking && !isVerifying) {
-                    synchronized (mNv21) {
-                        System.arraycopy(data, 0, mNv21, 0, data.length);
-                        mIsNv21DataReady = true;
-                    }
-                }
-                mCameraView.addCallbackBuffer();
-            }
-        });
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-
-        try {
-            hasPassword = Settings.System.getInt(getContentResolver(), KEY_HAS_PASSWORD);
-
-        } catch (SettingNotFoundException e) {
-            e.printStackTrace();
-        }
-        try {
-            mComponentName = new ComponentName(sharedPackageName, sharedClassName);
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-        AlertDialog createNewPwdDialog = null;
-        if (hasPassword == 0) {
-            createNewPwdDialog = new AlertDialog.Builder(mContext)
-                    .setTitle(R.string.add_fingerprint_message_secturity)
-                    .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
-                        @Override
-                        public void onClick(DialogInterface dialog, int which) {
-                            dialog.dismiss();
-                            Intent intent = new Intent();
-                            intent.setComponent(mComponentName);
-                            intent.putExtra(MINIMUM_QUALITY_KEY,
-                                    DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
-                            intent.putExtra(HIDE_DISABLED_PREFS, true);
-                            intent.putExtra(EXTRA_KEY_HAS_CHALLENGE, true);
-                            intent.putExtra(EXTRA_KEY_CHALLENGE, 0);
-                            intent.putExtra(EXTRA_KEY_FOR_FINGERPRINT, false);
-                            startActivityForResult(intent, CHOOSE_LOCK_GENERIC_REQUEST);
-                        }
-                    })
-                    .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
-                        @Override
-                        public void onClick(DialogInterface dialog, int which) {
-                            dialog.dismiss();
-                        }
-                    })
-                    .setCancelable(false)
-                    .create();
-            createNewPwdDialog.show();
-        } else if (createNewPwdDialog != null) {
-//            createNewPwdDialog.hide();
-//            createNewPwdDialog.dismiss();
-        }
-        //End: add by junwei.shen, create password AlertDialog for Face, at 2017.7.12
-        AccelerometerManager.start(this);
-        mIsKilled = false;
-        mCameraView.restartCamera();
-        mTrackThread = new Thread() {
-            @Override
-            public void run() {
-                //Add by junwei.shen, for deal Face entry timeout, at 2017.7.4
-                //time1 = System.currentTimeMillis();
-                SystemClock.sleep(200);
-                while (!mIsKilled && !Thread.interrupted()) {
-                    if (mIsNv21DataReady) {
-                        mIsTracking = true;
-                        synchronized (mNv21) {
-                            FaceInfo[] faces = DetectProxy.detect(mNv21, mCameraView.mPreviewWidth, mCameraView.mPreviewHeight);
-                            //FaceInfo face = filterFaces(faces);
-                            FaceInfo face = filterFaces(mNv21,faces, mCameraView.mPreviewWidth, mCameraView.mPreviewHeight);
-                            if(face == null){
-								if(!mIsNotGetFaceInfo){                                  
-									uiHandler.sendEmptyMessage(MSG_LONGTIME_NO_FACE);
-								}
-								mIsNotGetFaceInfo = true;
-                            }else{
-                                mIsNotGetFaceInfo = false;
-								if(timer != null)
-                                    timer.cancel();
-								if(task != null)
-									task.cancel();
-                            }
-                            LogUtil.i(TAG,"...mIsNotGetFaceInfo="+mIsNotGetFaceInfo);
-                            if (mRequestType != Face_REMOVE_REQUEST) {
-                                face = isSamePerson(face);
-                            }
-                            //analysis(face);
-                            analysis(mNv21, mCameraView.mPreviewWidth, mCameraView.mPreviewHeight,face);
-                        }
-                        mIsTracking = false;
-                        mIsNv21DataReady = false;
-                    }
-                }
-            }
-        };
-        mTrackThread.start();
-    }
-
-    private FaceInfo filterFaces(byte[] nv21, FaceInfo[] faces, int width, int height) {
-        if (faces == null || faces.length <= 0) {
-            LogUtil.v(TAG, "filter face is null");
-            // 更新提示文本的显示
-            if (info_text.getVisibility() != View.VISIBLE || !info_text.getText().toString().equals(HINT_TEXT_4)) {
-                uiHandler.sendEmptyMessage(MSG_SHOW_HINT4_TV);
-            }
-            return null;
-        }
-        // 筛选最大人脸
-        FaceInfo faceInfo = FaceUtil.getMaxFace(faces);
-        // 边界过滤
-        Rect maskRect = mMaskView.getMaskRect(mCameraView.getPreviewScaleX(), mCameraView.getPreviewScaleY());
-        FaceInfo clone = faceInfo.clone();
-        FaceRotationUtil.rotateFaceInfo(clone, mCameraView.mPreviewWidth, mCameraView.mPreviewHeight,
-                mCameraView.isFrontCamera(), mCameraView.mDegrees);
-        //该代码是判断人脸是否在圆框内
-        if (!maskRect.contains(clone.faceRect)) {
-            LogUtil.w(TAG, "filterFaces face out of frame !!!");
-            // 更新提示文本的显示
-            if (info_text.getVisibility() != View.VISIBLE || !info_text.getText().toString().equals(HINT_TEXT_1)) {
-                uiHandler.sendEmptyMessage(MSG_SHOW_HINT1_TV);
-            }
-            return null;
-        }
-        // 角度过滤
-        if (!FaceUtil.isFrontFace(faceInfo)) {
-            LogUtil.w(TAG, "is not front face !");
-            // 更新提示文本的显示
-            if (info_text.getVisibility() != View.VISIBLE || !info_text.getText().toString().equals(HINT_TEXT_2)) {
-                uiHandler.sendEmptyMessage(MSG_SHOW_HINT2_TV);
-            }
-            return null;
-        }
-        // 亮度过滤
-        faceInfo = FaceUtil.brightnessFilter(nv21, width, height, faceInfo);
-        if (faceInfo == null) {
-            if (info_text.getVisibility() != View.VISIBLE || !info_text.getText().toString().equals(HINT_TEXT_3)) {
-                uiHandler.sendEmptyMessage(MSG_DARK_LIGHT);
-            }
-            return null;
-        }
-        // 隐藏提示文本
-        if (faceInfo != null || info_text.getVisibility() != View.GONE) {
-            uiHandler.sendEmptyMessage(MSG_HIDE_HINT_TV);
-        }
-        return faceInfo;
-    }
-
-    private void analysis(byte[] nv21, int width, int height, FaceInfo faceInfo) {
-        if (faceInfo == null) {
-            LogUtil.w(TAG, "analysis face is null");
-            return;
-        }
-        // 特征提取
-        byte[] feature = VerifyProxy.getFeature(nv21, width, height, faceInfo);
-        // 检查特征值是否都相似
-        if (!checkFeature(feature)) {
-            LogUtil.w(TAG, "this face is not sample person !");
-            mNotSameFaceCount++;
-            if (mNotSameFaceCount == MAX_NOT_SAME_COUNT) {
-                LogUtil.w(TAG, "this face is not sample person ! = " + mNotSameFaceCount);
-                uiHandler.sendEmptyMessage(MSG_NOT_SAME_FACE);
-            }
-            return;
-        }
-        // 保存用户图片
-        String imagePath = saveUserImage(nv21, width, height, faceInfo, mCameraView.isFrontCamera());
-        User user = new User(uuid, null, new String(feature), imagePath, users.size());
-        users.add(user);
-        // 发送消息更新 UI
-        uiHandler.sendEmptyMessage(MSG_UPDATE_PROGRESS);
-    }
-
-    private String saveUserImage(byte[] nv21, int width, int height, FaceInfo faceInfo, boolean isFrontCamera) {
-        long time = System.currentTimeMillis();
-        Bitmap avatarBitmap = getAvatarBitmap(nv21, width, height, faceInfo.faceRect, isFrontCamera);
-        LogUtil.d(TAG, "getAvatarBitmap time : " + (System.currentTimeMillis() - time));
-        String imagePath = getFilesDir().getAbsolutePath() + "/" + users.size() + ".jpg";
-        time = System.currentTimeMillis();
-        FileUtil.saveBitmap(avatarBitmap, imagePath);
-        LogUtil.d(TAG, "saveBitmap time : " + (System.currentTimeMillis() - time));
-        return imagePath;
-    }
-
-    private Bitmap getAvatarBitmap(byte[] nv21, int width, int height, Rect rect, boolean isFrontCamera) {
-        Bitmap cropBitmap = BitmapUtil.cropBitmap(nv21, rect, width, height);
-        Bitmap rotateBitmap = BitmapUtil.rotateBitmap(cropBitmap, 270, isFrontCamera);
-        return rotateBitmap;
-    }
-
-    /**
-     * 判断是否为同一个人
-     */
-    private boolean checkFeature(byte[] feature) {
-        if (users == null || users.size() <= 0) {
-            return true;
-        }
-        for (int i = 0; i < users.size(); i++) {
-            float score = VerifyProxy.compare(feature, users.get(i).getFeature().getBytes());
-            if (score > 0.65f) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private FaceInfo isSamePerson(FaceInfo face) {
-        if (face != null && mLastFaceId == face.id) {
-            return face;
-        } else {
-            runOnUiThread(new Runnable() {
-
-                @Override
-                public void run() {
-                    reset();
-                }
-            });
-            if (face != null) {
-                mLastFaceId = face.id;
-                return face;
-            }
-            return null;
-        }
-    }
-
-    private void reset() {
-        for (int i = 0; i < checkBoxes.length; i++) {
-            checkBoxes[i].setChecked(false);
-        }
-    }
-
-    private void register(String name) {
-        for (User user : users) {
-            user.setName(name);
-        }
-        long time = System.currentTimeMillis();
-        UserManager.addUsers(users, this);
-        LogUtil.d(TAG, "users size: " + users.size());
-        LogUtil.d(TAG, "db add users time : " + (System.currentTimeMillis() - time));
-        saveFaceState(true);
-        setResult(RESULT_OK);
-        finish();
-    }
-    
-    public void saveFaceState(boolean enabled){
-        Settings.System.putStringForUser(getContentResolver(),Settings.System.FACE_STATE_ENABLED,enabled?"1":"0", 0);  /* ZXP*/    
-    }
-
-    @Override
-    protected void onPause() {
-        AccelerometerManager.stop();
-        mCameraView.releaseCamera();
-        stopThread();
-        super.onPause();
-        if (mRequestType == Face_NEW_REQUEST && mFromSource == FROM_SETTING) {
-            finish();
-        }
-    }
-
-    private void stopThread() {
-        mIsKilled = true;
-        if (mTrackThread != null) {
-            try {
-                mTrackThread.interrupt();
-                mTrackThread.join();
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }
-        }
-        if (mGetFeatureHandler != null) {
-            mGetFeatureThread.quitSafely();
-            mGetFeatureHandler = null;
-        }
-    }
-
-    /*added by iuv luyang*/
-    @Override
-    public void onBackPressed() {
-        //Begin: add by junwei.shen, create backPressed AlertDialog for Face, at 2017.7.12
-//        Toast.makeText(this.getApplicationContext(), R.string.Face_cancel_op, Toast.LENGTH_SHORT).show();
-//        super.onBackPressed();
-        new AlertDialog.Builder(mContext)
-                .setTitle(R.string.cancel_face_entering)
-                .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialogInterface, int i) {
-                        dialogInterface.dismiss();
-                        finish();
-                    }
-                })
-                .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialogInterface, int i) {
-                        dialogInterface.dismiss();
-                    }
-                })
-                .create()
-                .show();
-        //End: add by junwei.shen, create backPressed AlertDialog for Face, at 2017.7.12
-    }
-    /*end by iuv luyang*/
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        if (AppConfig.isOpenHacker)
-            HackerProxy.release();
-        if (mIsBroadcastRegister) {
-            unregisterReceiver(mBatInfoReceiver);
-            mIsBroadcastRegister = false;
-        }
-		if(timer != null)
-			timer.cancel();
-		if(task != null)
-			task.cancel();
-    }
-}
Index: frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java
===================================================================
--- frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java	(revision 6856)
+++ frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java	(revision 6857)
@@ -371,16 +371,6 @@
         return sCurrentUser;
     }
 
-    private boolean mFaceAuthLockscreenOngoing;
-
-    public void setFaceAuthLockscreenOngoing(boolean ongoing) {
-        mFaceAuthLockscreenOngoing = ongoing;
-    }
-
-    public boolean isFaceAuthLockscreenOngoing() {
-        return mFaceAuthLockscreenOngoing;
-    }
-
     @Override
     public void onTrustChanged(boolean enabled, int userId, int flags) {
         mUserHasTrust.put(userId, enabled);
Index: frameworks/base/packages/Keyguard/libs/UnlockSdk1.2.105.10733.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: frameworks/base/packages/Keyguard/libs/UnlockSdk1.2.105.10733.jar
===================================================================
--- frameworks/base/packages/Keyguard/libs/UnlockSdk1.2.105.10733.jar	(revision 0)
+++ frameworks/base/packages/Keyguard/libs/UnlockSdk1.2.105.10733.jar	(revision 6857)

Property changes on: frameworks/base/packages/Keyguard/libs/UnlockSdk1.2.105.10733.jar
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: frameworks/base/packages/Keyguard/res/values/strings.xml
===================================================================
--- frameworks/base/packages/Keyguard/res/values/strings.xml	(revision 6856)
+++ frameworks/base/packages/Keyguard/res/values/strings.xml	(revision 6857)
@@ -434,4 +434,78 @@
     <string name="back_to_keyguard">Back</string>
     <string name="delete_pin">Delete</string>
     <string name="privacy_data">Privacy Data</string>
+	
+    <string name="app_name">Face Unlock Demo</string>
+    <string name="exit_prompt_wording">Click again to exit</string>
+
+    <string name="btn_ok">OK</string>
+    <string name="btn_cancel">Cancel</string>
+    <string name="btn_camera">Enter your face</string>
+    <string name="btn_unlock">Unlock with face</string>
+    <string name="btn_again">Try Again</string>
+    <string name="btn_back">Back</string>
+
+    <string name="msg_noface">Sorry, the system has no face, please enter your face first.</string>
+    <string name="msg_nodetect">Sorry, the system cannot recognize your face.</string>
+    <string name="msg_nocamera">
+        Sorry, the system cannot acquire the camera permissions, please open the permissions first.
+    </string>
+    <string name="msg_success">Unlock Success!</string>
+
+    <string name="txt_welcome">Mobile Face Verification\nDemo</string>
+    <string name="txt_camera">Move your face into the area and take a picture</string>
+    <string name="txt_camera_success">Face Registered</string>
+    <string name="txt_unlock">Please face the screen to unlock</string>
+    <string name="txt_name">Please enter your name</string>
+    <string name="unlock_count">Unlock count: %1$d</string>
+    <string name="txt_camera_success_left">Face angle: left</string>
+    <string name="txt_camera_success_right">Face angle: right</string>
+    <string name="txt_camera_success_top">Face angle: rise head</string>
+    <string name="txt_camera_success_down">Face angle: head down</string>
+    <string name="unlock_failed_compare">Compare failed</string>
+    <string name="unlock_failed_liveness">No human face found</string>
+    <string name="unlock_failed_warning">Detecting</string>
+    <string name="unlock_failed_argument">Invalid argument</string>
+    <string name="unlock_failed_face_blur">face is too blur</string>
+    <string name="unlock_failed_face_multi">multi faces</string>
+    <string name="unlock_failed_face_not_complete">face not complete</string>
+    <string name="unlock_failed_handle">invalid handle</string>
+    <string name="unlock_failed">Internal error</string>
+    <string name="unlock_failed_quality">Face incomplete</string>
+    <string name="unlock_failed_face_not_found">Detecting</string>
+    <string name="attr_light_dark">faint light</string>
+    <string name="attr_light_high">over exposed</string>
+    <string name="attr_light_shadow">uneven lighting</string>
+    <string name="unlock_failed_face_small">Face too small</string>
+    <string name="unlock_failed_face_large">Face too large</string>
+    <string name="unlock_failed_offset_left">Face inclined left</string>
+    <string name="unlock_failed_offset_right">Face inclined right</string>
+    <string name="unlock_failed_offset_top">Face inclined top</string>
+    <string name="unlock_failed_offset_bottom">Face inclined down</string>
+    <string name="unlock_camera_steady">Please keep steady</string>
+    <string name="fail_report">Unlock Failed\nLiveness Attack ：%1$d times\nLow Facial Confidence：%2$d times</string>
+    <string name="title_activity_settings">Settings</string>
+    <string name="feature_count_limit">Feature count limited</string>
+
+
+    <string name="first_frame_threshold">First frame threshold</string>
+    <string name="compare_threshold">Compare threshold</string>
+    <string name="liveness_threshold">Liveness threshold</string>
+
+
+    <string name="attr_blur">Face is too blur</string>
+    <string name="attr_eye_occlusion">eyes is blocked</string>
+    <string name="attr_eye_close">eye is closed</string>
+    <string name="attr_mouth_occlusion">mouth is blocked</string>
+    <string name="model_version">Liveness version</string>
+    <string name="detect_version">Detect version</string>
+    <string name="preview">Preview</string>
+    <string name="strick_mode">Strict Mode</string>
+    <string name="lock_screen">Screen locked, click to unlock.</string>
+    <string name="start_detect">Start detect</string>
+    <string name="unlock_succeed">Unlock succeed %1$d ms"</string>
+    <string name="failed_to_unlock">Unlock failed</string>
+    <string name="feature_miss">feature file not found,please save feature first</string>
+    <string name="feature_version_error">feature version has been updated,please save feature once more</string>
+    <string name="bad_light">Bad light</string>
 </resources>
Index: frameworks/base/packages/SystemUI/Android.mk
===================================================================
--- frameworks/base/packages/SystemUI/Android.mk	(revision 6856)
+++ frameworks/base/packages/SystemUI/Android.mk	(revision 6857)
@@ -31,6 +31,8 @@
     framework-protos \
     SystemUI-proto-tags
 
+#LOCAL_STATIC_JAVA_LIBRARIES += unlock
+#LOCAL_STATIC_JAVA_AAR_LIBRARIES := unlocksdk
 ifeq ($(strip $(MTK_FULLSCREEN_SWITCH_SUPPORT)),yes)
 LOCAL_STATIC_JAVA_LIBRARIES += FullscreenSwitchService
 endif
@@ -38,7 +40,7 @@
 # LOCAL_JNI_SHARED_LIBRARIES := libyv12util
 
 ifeq (yes,$(strip $(TCL_LSCREEN_SUPPORT)))
-	LOCAL_STATIC_JAVA_AAR_LIBRARIES := play_services_base
+	LOCAL_STATIC_JAVA_AAR_LIBRARIES += play_services_base
 	LOCAL_STATIC_JAVA_AAR_LIBRARIES += play_services_basement
 endif
 
@@ -51,10 +53,15 @@
 LOCAL_PRIVILEGED_MODULE := true
 
 LOCAL_PROGUARD_FLAG_FILES := proguard.flags
-LOCAL_PREBUILT_JNI_LIBS := libs/arm64-v8a/libIrisking.so \
-    libs/arm64-v8a/libjni_cvface_api.so \
-    libs/arm64-v8a/libcvface_api.so
 
+
+LOCAL_PREBUILT_JNI_LIBS := libs/arm64-v8a/libFaceDetectCA.so \
+    libs/arm64-v8a/libmegface.so \
+	libs/arm64-v8a/libmeglive.so \
+	libs/arm64-v8a/libMegviiUnlock.so \
+	libs/arm64-v8a/libMegviiUnlock-jni-1.2.so \
+	libs/arm64-v8a/libunlockmegcv.so 
+	
 LOCAL_RESOURCE_DIR := \
     frameworks/base/packages/Keyguard/res \
     frameworks/base/packages/Keyguard/res_ext \
@@ -67,7 +74,7 @@
     frameworks/support/v17/leanback/res
 
 LOCAL_AAPT_FLAGS := --auto-add-overlay \
-    --extra-packages com.android.keyguard:android.support.v7.recyclerview:android.support.v7.preference:android.support.v14.preference:android.support.v7.appcompat \
+    --extra-packages com.android.keyguard:android.support.v7.recyclerview:android.support.v7.preference:android.support.v14.preference:android.support.v7.appcompat:com.megvii.facepp.sdk \
     --extra-packages android.support.v17.leanback
 
 ifneq ($(SYSTEM_UI_INCREMENTAL_BUILDS),)
@@ -80,10 +87,13 @@
 include $(BUILD_PACKAGE)
 
 include $(CLEAR_VARS) 
+#LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := unlocksdk:libs/UnlockSdk1.2.105.10733.aar
+#LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES += unlock:libs/UnlockSdk1.2.105.10733.jar
 ifeq (yes,$(strip $(TCL_LSCREEN_SUPPORT)))
-	LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := play_services_base:libs/play-services-base-10.2.0.aar
+	LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES += play_services_base:libs/play-services-base-10.2.0.aar
 	LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES += play_services_basement:libs/play-services-basement-10.2.0.aar
 endif
+
 include $(BUILD_MULTI_PREBUILT) 
 
 ifeq ($(EXCLUDE_SYSTEMUI_TESTS),)
Index: frameworks/base/packages/SystemUI/src/com/face/scanner/PrivacySpaceActivity.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/face/scanner/PrivacySpaceActivity.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/face/scanner/PrivacySpaceActivity.java	(revision 6857)
@@ -0,0 +1,503 @@
+package com.face.scanner;
+
+import android.R.integer;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.hardware.Camera;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Message;
+import android.os.Vibrator;
+import android.provider.Settings;
+import android.util.Log;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.Toast;
+
+import com.android.keyguard.R;
+import com.android.keyguard.KeyguardUtils;
+import com.sensetime.faceapi.model.FaceInfo;
+import com.sensetime.faceapi.utils.AccelerometerManager;
+import com.sensetime.faceunlock.bean.FaceFeature;
+import com.sensetime.faceunlock.bean.User;
+import com.sensetime.faceunlock.config.AppConfig;
+import com.sensetime.faceunlock.manager.DetectProxy;
+import com.sensetime.faceunlock.manager.HackerProxy;
+import com.sensetime.faceunlock.manager.TrackProxy;
+import com.sensetime.faceunlock.manager.UserManager;
+import com.sensetime.faceunlock.manager.VerifyProxy;
+import com.sensetime.faceunlock.util.LogUtil;
+import com.sensetime.faceunlock.widget.CameraView;
+
+import android.view.View;
+import android.provider.Settings;
+//Begin: Add by junwei.shen for bug-98638 at 2017.7.2
+import android.os.Looper;
+import android.widget.TextView;
+//End: Add by junwei.shen at 2017.7.2
+import java.util.Timer;
+import java.util.TimerTask;
+
+import com.sensetime.faceapi.FaceLibrary;
+import com.sensetime.faceapi.model.CvPixelFormat;
+import com.sensetime.faceunlock.util.BrightnessHelper;
+
+import android.graphics.Rect;
+
+public class PrivacySpaceActivity extends Activity {
+    private static final String TAG = "PrivacySpaceActivity";
+    private static final int FACE_NEW_REQUEST = 300;
+    private static final int FACE_REPLACE_REQUEST = 301;
+    private static final int FACE_REMOVE_REQUEST = 302;
+
+    public static final int MODE_INIT = 0;
+    public static final int MODE_UNLOCK_NORMAL = 1;
+    public static final int MODE_UNLOCK_PRIVACY = 2;
+    public static final int MODE_UNLOCK_CLONE = 3;
+    public static final int MODE_SWITCH_TO_PRIVACY = 4;
+    public static final int MODE_SWITCH_TO_CLONE = 5;
+    public static final int MODE_VERIFY = 6;
+    public static final int MODE_VERIFY_SHOW_UI = 7;
+    //Begin: Add by junwei.shen for bug-98638 at 2017.7.2
+    public static final int CANCEL_TOAST = 8;
+    public static final int MODE_VERITY_UNLOCK = 9;
+    public static final int MODE_PRIVACY_PROTECTION = 10;
+    public static final int START_FACE_VERIFY = 101;
+    public static final int STOP_FACE_VERIFY = 102;
+
+    public static final int PRIVACY_OK = 100;
+
+    private Toast toast = null;
+    //End: Add by junwei.shen for bug-98638 at 2017.7.2
+    private CameraView cameraView; // 相机控件
+    private AlertDialog dialog;
+
+    private Thread trackThread; // 进行Track的线程
+    private HandlerThread verifyThread; // 进行Verify的线程
+    private Handler verifyHandler; // 进行Verify的线程的Handler对象
+    private User user; // verify通过，即存储检测到的User
+
+    private volatile boolean isNv21DataReady; // 判断nv21的数据是否拷贝完成
+    private volatile boolean isTracking; // 是否正在进行track操作
+    private boolean isKilled; // 控制Track线程是否停止
+    private boolean isVerifying; // 是否正在进行verify操作
+    private byte[] nv21; // nv21的数据
+    private int attemptCount; // 重试次数
+    private boolean isNotHacker; // 是否为活体
+    private long totalTime; // 总耗时
+    private long verifyTime;
+    private long hackerTime;
+
+    boolean mUnlockFinished = false;
+    private int mPrivacyMode;
+    private boolean mFromNotification;
+    private boolean mFromKeyguard;
+
+    private int mLastScreenMode;
+    private int mLastScreenBrightness;
+    private boolean mBrightnessChanged = false;
+    private static final float BRIGHT_MIN = 0.12f;
+
+    //wym add for 99963. 2017/07/06
+
+    //Timer timer = new Timer();
+    boolean mIsNotGetFaceInfo = false;
+
+    /*TimerTask task = new TimerTask() {
+        @Override
+        public void run() {
+
+            runOnUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    LogUtil.d(TAG, "...............timerTask mIsNotGetFaceInfo=" + mIsNotGetFaceInfo);
+                    if (mIsNotGetFaceInfo) {
+                        KeyguardUtils.showNormalDialog(PrivacySpaceActivity.this, "人脸认证");
+                    }
+                }
+            });
+        }
+    };*/
+
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        sendFaceBrodcast(START_FACE_VERIFY);
+        /*String state = Settings.System.getStringForUser(this.getApplicationContext().getContentResolver(), Settings.System.FACE_STATE_ENABLED, 0);zxp*/
+        String state = "0";
+		if (state == null) {
+            state = "0";
+        }
+        if (state.equals("0")) {
+            getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
+        }
+        requestWindowFeature(Window.FEATURE_NO_TITLE);
+        mPrivacyMode = getIntent().getIntExtra("privacyState", MODE_INIT);
+        mFromNotification = getIntent().getBooleanExtra("fromNotification", false);
+        mFromKeyguard = getIntent().getBooleanExtra("START_FROM_KEYGUARD", false);
+        if (mFromKeyguard || (mPrivacyMode == MODE_UNLOCK_PRIVACY)) {
+            getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
+            WindowManager.LayoutParams lp = getWindow().getAttributes();
+            int keyguardFlag = WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED
+                    | WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES
+                    | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON
+                    | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD;
+            lp.flags |= keyguardFlag;
+            getWindow().setAttributes(lp);
+        }
+        resizeWindow();
+        Log.d("changjun", "mPrivacyMode:" + mPrivacyMode + ",mFromNotification:" + mFromNotification);
+        setContentView(R.layout.activity_verify);
+        initView();
+        mLastScreenMode = BrightnessHelper.getScreenMode(this);
+        mLastScreenBrightness = BrightnessHelper.getScreenBrightness(this);
+        DetectProxy.init();
+        VerifyProxy.init(this);
+        if (AppConfig.isOpenHacker) {
+            HackerProxy.init();
+        }
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
+        registerReceiver(mReceiver, filter);
+        LogUtil.d(TAG,"!!!!!!!!!timer.schedule!!!!!!");
+        //timer.schedule(task, 2000);
+    }
+
+    private void resizeWindow() {
+        WindowManager.LayoutParams lp = getWindow().getAttributes();
+        lp.width = 1;
+        lp.height = 1;
+        lp.alpha = 0.0f;
+        lp.dimAmount = 0.0f;
+        getWindow().setAttributes(lp);
+    }
+
+    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(final Context context, final Intent intent) {
+            Log.d(TAG, "onReceive");
+            String action = intent.getAction();
+
+            if (Intent.ACTION_SCREEN_OFF.equals(action)) {
+                Log.d(TAG, "screen off");
+                PrivacySpaceActivity.this.finish();
+            } else if (Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action)) {
+                String reason = intent.getStringExtra("reason");
+                if ("homekey".equals(reason)) {
+                    PrivacySpaceActivity.this.finish();
+                }
+            }
+        }
+    };
+
+    private void initView() {
+        cameraView = (CameraView) findViewById(R.id.camera_view);
+        cameraView.setVisibility(View.INVISIBLE);// added by iuv luyang
+        cameraView.setPreviewCallback(new Camera.PreviewCallback() {
+
+            @Override
+            public void onPreviewFrame(byte[] data, Camera camera) {
+                if (totalTime == 0) {
+                    totalTime = System.currentTimeMillis();
+                }
+                if (nv21 == null || data.length != nv21.length) {
+                    nv21 = new byte[data.length];
+                }
+                if (!isTracking && !isVerifying) {
+                    synchronized (nv21) {
+                        System.arraycopy(data, 0, nv21, 0, data.length);
+                        isNv21DataReady = true;
+                    }
+                }
+                cameraView.addCallbackBuffer();
+            }
+        });
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        sendFaceBrodcast(START_FACE_VERIFY);
+        AccelerometerManager.start(this);
+        isKilled = false;
+        cameraView.restartCamera();
+        trackThread = new Thread() {
+            @Override
+            public void run() {
+                while (!isKilled && !Thread.interrupted()) {
+                    if (isNv21DataReady) {
+                        isTracking = true;
+                        synchronized (nv21) {
+                            FaceInfo[] faces = DetectProxy.detect(nv21, cameraView.mPreviewWidth,
+                                    cameraView.mPreviewHeight);
+                            FaceInfo faceInfo = filterFaces(faces);
+                            maxBrightnessIfNeed(nv21, faceInfo);
+                            if (faceInfo == null) {
+                                mIsNotGetFaceInfo = true;
+                            } else {
+                                mIsNotGetFaceInfo = false;
+                                //timer.cancel();
+                            }
+                            LogUtil.i(TAG, "...mIsNotGetFaceInfo=" + mIsNotGetFaceInfo);
+                            analysis(faceInfo);
+                        }
+                        isTracking = false;
+                        isNv21DataReady = false;
+                    }
+                }
+            }
+        };
+        trackThread.start();
+        initGetFeatureThread(); // 初始化GetFeature的线程
+    }
+
+    private void maxBrightnessIfNeed(byte[] nv21, FaceInfo faceInfo) {
+        if (nv21 == null || nv21.length == 0 || faceInfo == null) {
+            return;
+        }
+        Rect rect = faceInfo.faceRect;
+        float brightness = FaceLibrary.averageBrightness(nv21, CvPixelFormat.NV21, cameraView.mPreviewWidth, cameraView.mPreviewHeight, rect.left, rect.top, rect.width(), rect.height());
+        if (brightness < BRIGHT_MIN) {
+            mBrightnessChanged = true;
+            BrightnessHelper.setScreenMode(this, 0);
+            BrightnessHelper.setScreenBrightness(this, 255);
+        }
+    }
+
+
+    private FaceInfo filterFaces(FaceInfo[] faces) {
+        if (faces == null || faces.length <= 0) {
+            return null;
+        }
+        FaceInfo faceInfo = null;
+        for (int i = 0; i < faces.length; i++) {
+            if (faceInfo == null || faces[i].faceRect.width() > faceInfo.faceRect.width()) {
+                faceInfo = faces[i];
+            }
+        }
+        return faceInfo;
+    }
+
+    private void analysis(FaceInfo faceInfo) {
+        if (faceInfo == null || isVerifying) {
+            return;
+        }
+        isVerifying = true;
+        Message msg = Message.obtain(verifyHandler);
+        msg.obj = new FaceFeature(faceInfo, nv21, cameraView.mPreviewWidth, cameraView.mPreviewHeight);
+        verifyHandler.sendMessage(msg);
+    }
+
+    private void initGetFeatureThread() {
+        verifyThread = new HandlerThread("VerifyThread");
+        verifyThread.start();
+        verifyHandler = new Handler(verifyThread.getLooper()) {
+            @Override
+            public void handleMessage(Message msg) {
+                FaceFeature faceFeature = (FaceFeature) msg.obj;
+                handleFeature(faceFeature);
+            }
+        };
+    }
+
+    private void handleFeature(FaceFeature faceFeature) {
+        if (faceFeature == null) {
+            return;
+        }
+
+        // 做一次 verify 和 hacker，如果某次已经检测出来结果并且通过了，则不再重复检测
+        if (user == null) {
+            verifyTime = System.currentTimeMillis();
+            user = VerifyProxy.isPass(faceFeature, this);
+            verifyTime = System.currentTimeMillis() - verifyTime;
+        }
+        if (!isNotHacker) {
+            hackerTime = System.currentTimeMillis();
+            isNotHacker = HackerProxy.isPass(faceFeature, cameraView.isFrontCamera());
+            hackerTime = System.currentTimeMillis() - hackerTime;
+        }
+
+        attemptCount++;
+        LogUtil.d(TAG, "attemptCount: " + attemptCount);
+        // 达到重试次数上限时，发送结果，否则继续进行检测
+        if ((user != null && isNotHacker) || attemptCount >= AppConfig.attemptCount) {
+            cameraView.setPreviewCallback(null);
+            cameraView.stopPreview();
+            analyseResult(user, isNotHacker);
+        } else {
+            isVerifying = false;
+        }
+    }
+
+    //Begin:Add by junwei.shen for bug-98638 at 2017.7.2
+    Handler hd = new Handler(Looper.getMainLooper()) {
+
+        @Override
+        public void handleMessage(Message msg) {
+            super.handleMessage(msg);
+            if (msg.what == CANCEL_TOAST) {
+                toast.cancel();
+//                toast = null;
+                finish();
+            }
+        }
+
+    };
+    //End: Add by junwei.shen for bug-98638 at 2017.7.2
+
+    private void analyseResult(User user, boolean isNotHacker) {
+        Intent intent = new Intent();
+        intent.setAction("SAVE_RECORDER");
+        sendBroadcast(intent);
+        if (user != null && isNotHacker) {
+            String debugMsg = "total time: " + (System.currentTimeMillis() - totalTime) + "ms\nverify time: " +
+                    verifyTime + "ms\nhacker time: " + hackerTime + "ms\nattempts count: " + attemptCount;
+            Vibrator vib = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
+            vib.vibrate(100);
+            beginUnlock();
+            finish();
+            return;
+        } else {
+            //Begin: Changed by junwei.shen for bug-98638 at 2017.7.2
+//          Toast.makeText(PrivacySpaceActivity.this, R.string.face_not_recognized, Toast.LENGTH_LONG).show();
+            toast = Toast.makeText(PrivacySpaceActivity.this, R.string.face_not_recognized, Toast.LENGTH_LONG);
+            toast.show();
+            hd.sendEmptyMessageDelayed(CANCEL_TOAST, 1000);
+            //End: Changed by junwei.shen for bug-98638 at 2017.7.2
+            setResult(RESULT_CANCELED);
+            //Changed by junwei.shen for bug-98638 at 2017.7.2
+//          finish();
+
+        }
+    }
+
+    public void saveFaceState(boolean enabled) {
+       /* Settings.System.putStringForUser(getContentResolver(), Settings.System.FACE_STATE_ENABLED, enabled ? "1" : "0", 0);zxp*/
+    }
+
+    private void switchToPrivacySpace() {
+        String userID = "0";
+        /*userID = Settings.System.getStringForUser(getContentResolver(), Settings.System.PRIVACY_USER_ID, 0);zxp*/
+        int id = Integer.parseInt(userID);
+        try {
+            if (mPrivacyMode == MODE_UNLOCK_PRIVACY) {
+                sendFaceBrodcast(RESULT_OK);
+            }
+            Intent i = new Intent("PRIVACY_SPACE_SWITCH");
+            i.putExtra("userid", id);
+            sendBroadcast(i);
+        } catch (Exception re) {
+            Log.e(TAG, "Couldn't switch user " + re);
+        }
+    }
+
+    private void beginUnlock() {
+        //unlock();
+        switch (mPrivacyMode) {
+            case MODE_INIT:
+                break;
+            case MODE_SWITCH_TO_CLONE:
+            case MODE_SWITCH_TO_PRIVACY:
+                switchToPrivacySpace();
+                break;
+            case MODE_UNLOCK_NORMAL:
+                break;
+            case MODE_UNLOCK_CLONE:
+            case MODE_UNLOCK_PRIVACY:
+                switchToPrivacySpace();
+                break;
+            case MODE_VERIFY:
+            case MODE_VERIFY_SHOW_UI:
+                setResult(RESULT_OK);
+                break;
+            case MODE_VERITY_UNLOCK:
+                sendFaceBrodcast(RESULT_OK);
+            case MODE_PRIVACY_PROTECTION:
+                sendFaceBrodcast(PRIVACY_OK);
+                break;
+            default:
+                break;
+        }
+
+    }
+
+    private void sendFaceBrodcast(int flag) {
+        Intent mIntent = new Intent();
+        if (flag == RESULT_OK) {
+            mIntent.setAction("action_face_OK");
+        } else if (flag == RESULT_CANCELED) {
+            mIntent.setAction("action_face_fail");
+        } else if (flag == PRIVACY_OK) {
+            mIntent.setAction("action_privacy_ok");
+        } else if (flag == START_FACE_VERIFY) {
+            mIntent.setAction("action_start_face_verity");
+        } else if (flag == STOP_FACE_VERIFY) {
+            mIntent.setAction("action_stop_face_verity");
+        }
+        this.getApplicationContext().sendBroadcast(mIntent);
+
+    }
+
+    private void dismissDialog() {
+        if (dialog != null && dialog.isShowing()) {
+            dialog.dismiss();
+            dialog = null;
+            isVerifying = false;
+        }
+    }
+
+    @Override
+    protected void onPause() {
+        sendFaceBrodcast(STOP_FACE_VERIFY);
+        dismissDialog();
+        AccelerometerManager.stop();
+        cameraView.releaseCamera();
+        stopThread();
+        super.onPause();
+    }
+
+    private void stopThread() {
+        isKilled = true;
+        if (trackThread != null) {
+            try {
+                trackThread.interrupt();
+                trackThread.join();
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        }
+        if (verifyThread != null) {
+            verifyThread.quitSafely();
+            verifyThread = null;
+        }
+    }
+
+    /*added by iuv luyang*/
+    @Override
+    public void onBackPressed() {
+        Toast.makeText(this.getApplicationContext(), R.string.face_cancel_identify, Toast.LENGTH_SHORT).show();
+        super.onBackPressed();
+    }
+    /*end by iuv luyang*/
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        sendFaceBrodcast(STOP_FACE_VERIFY);
+        unregisterReceiver(mReceiver);
+        if (mBrightnessChanged) {
+            BrightnessHelper.setScreenBrightness(this, mLastScreenBrightness);
+            BrightnessHelper.setScreenMode(this, mLastScreenMode);
+        }
+        if (AppConfig.isOpenHacker)
+            HackerProxy.release();
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/face/scanner/PrivacySpaceActivity.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/face/scanner/LiteManager.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/face/scanner/LiteManager.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/face/scanner/LiteManager.java	(revision 6857)
@@ -0,0 +1,261 @@
+package com.face.scanner;
+
+import android.content.Context;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.util.Log;
+
+import com.megvii.facepp.sdk.Lite;
+import com.sensetime.faceunlock.util.ConUtil;
+import com.android.systemui.R;
+
+import java.io.File;
+
+public class LiteManager implements LiteService {
+
+    private static final String TAG = "LiteManager";
+    private Handler mHandler;
+    private Context mContext;
+    private SaveCallBack mSaveCallBack;
+    private UnLockCallBack mUnLockCallBack;
+    private volatile Status mStatus = Status.idle;
+    private volatile StatusObserver mStatusObserver;
+    private static LiteManager sInstance;
+
+
+    public synchronized static LiteManager getInstance(Context context) {
+        if (sInstance == null) {
+            sInstance = new LiteManager(context);
+        }
+        return sInstance;
+    }
+
+    private LiteManager(Context context) {
+        mContext = context.getApplicationContext();
+    }
+	
+	public final void runOnWorjerThread(Runnable action) {
+        if (Thread.currentThread() != mHandler.getLooper().getThread()) {
+            mHandler.post(action);
+        } else {
+            action.run();
+        }
+    }
+
+    @Override
+    public Handler initAll() {
+        if (mHandler == null) {
+            HandlerThread handlerThread = new HandlerThread("LiteService"
+                    , Thread.MAX_PRIORITY);
+            handlerThread.start();
+            mHandler = new Handler(handlerThread.getLooper());
+        }
+        runOnWorjerThread(new Runnable() {
+            @Override
+            public void run() {
+                if (getStatus() != Status.idle) {
+                    return;
+                }
+                setStatus(Status.initializing);
+                doInit();
+                setStatus(Status.initialized);
+            }
+        });
+		return mHandler;
+    }
+
+    @Override
+    public void setStatusObserver(StatusObserver statusObserver) {
+        mStatusObserver = statusObserver;
+    }
+
+    private void doInit() {
+		// 初始化Lite参数
+		String livePath1 = "";
+        String livePath2 = "";
+        File dir = mContext.getExternalFilesDir("megvii");
+        if (!dir.exists()) {
+            Log.i("zxp","dir.exists()");
+			return;
+        }
+		livePath1 = dir + "/model/liveness1.dlc";
+		if ( !new File(livePath1).exists() ){
+			Log.d("zxp", "FaceService:onCreate start 1...");
+			livePath1 = ConUtil.saveRaw(mContext, R.raw.panorama_mgba,
+                    "model", "liveness1.dlc");
+			Log.d("zxp", "FaceService:onCreate start 2...");
+		}
+					
+        Lite.getInstance().initHandle(dir.getAbsolutePath());
+		
+        Lite.getInstance().setConfig(-8, 8, -13, 13, true);
+		
+		Log.d("zxp", "FaceService:onCreate start 3...");
+        byte[] faceppContent = ConUtil.getFileContent(mContext, R.raw
+                .megviifacepp_modela);
+				
+		Log.d("zxp", "FaceService:onCreate start 4...");
+		
+		Log.i("zxp", "init all start ");
+        final long result = Lite.getInstance().initAll(livePath1, livePath2, faceppContent);
+		Log.i("zxp", "init all end ");
+    }
+
+    @Override
+    public void pepareSave(final SaveCallBack saveCallBack) {
+        runOnWorjerThread(new Runnable() {
+            @Override
+            public void run() {
+                mSaveCallBack = saveCallBack;
+                if (getStatus() != Status.initialized) {
+                    sendCompareCallBack(false, ERROR_NOT_INIT);
+                } else {
+                    Lite.getInstance().prepare();
+                }
+            }
+        });
+    }
+
+    @Override
+    public void save(final byte[] imageData, final int width, final int height, final int angle, final boolean useLive, final byte[] savedFeature, final byte[] img, final int[] outFeatureId) {
+        runOnWorjerThread(new Runnable() {
+            @Override
+            public void run() {
+                if (getStatus() != Status.initialized) {
+                    return;
+                }
+                int ret = Lite.getInstance().saveFeature(imageData, width, height
+                        , angle, useLive, savedFeature
+                        , img, outFeatureId);
+                if (ret == Lite.MG_UNLOCK_OK) {
+                    sendSaveResetCallBack(true, ERROR_NO_ERROR);
+                }
+            }
+        });
+    }
+
+    private void sendSaveResetCallBack(final boolean success, final int errorCode) {
+        if (mSaveCallBack != null) {
+            final SaveCallBack callBack = mSaveCallBack;
+            runOnWorjerThread(new Runnable() {
+                @Override
+                public void run() {
+                    if (callBack != null) {
+                        callBack.onSaveFinish(success, errorCode);
+                    }
+                }
+            });
+            mSaveCallBack = null;
+        }
+    }
+
+    @Override
+    public void resetSave() {
+        runOnWorjerThread(new Runnable() {
+            @Override
+            public void run() {
+                if (getStatus() == Status.initialized) {
+                    Lite.getInstance().reset();
+                }
+                sendSaveResetCallBack(false, ERROR_OTHERS);
+            }
+        });
+    }
+
+    @Override
+    public void pepareCompare(final UnLockCallBack unlockCallBack) {
+        runOnWorjerThread(new Runnable() {
+            @Override
+            public void run() {
+                mUnLockCallBack = unlockCallBack;
+                if (getStatus() != Status.initialized) {
+                    sendCompareCallBack(false, ERROR_NOT_INIT);
+                } else {
+                    Lite.getInstance().prepare();
+                }
+            }
+        });
+    }
+
+    @Override
+    public void compare(final byte[] imageData, final int width
+            , final int height, final int angle, final boolean useLive, final boolean strictMode, final int[] report) {
+		
+        runOnWorjerThread(new Runnable() {
+            @Override
+            public void run() {
+                if (getStatus() != Status.initialized) {
+                    return;
+                }
+                int ret = Lite.getInstance().compare(imageData, width, height
+                        , angle, useLive, strictMode
+                        , report);
+                if (ret == Lite.MG_UNLOCK_OK) {
+                    sendCompareCallBack(true, ERROR_NO_ERROR);
+                }
+            }
+        });
+    }
+
+    private void sendCompareCallBack(final boolean success, final int errorCode) {
+        final UnLockCallBack callBack = mUnLockCallBack;
+        if (callBack != null) {
+            runOnWorjerThread(new Runnable() {
+                @Override
+                public void run() {
+                    if (callBack != null) {
+                        callBack.onUnlockFinish(success, errorCode);
+                    }
+                }
+            });
+            mSaveCallBack = null;
+        }
+    }
+
+    @Override
+    public void resetCompare() {
+        runOnWorjerThread(new Runnable() {
+            @Override
+            public void run() {
+                if (getStatus() == Status.initialized) {
+                    Lite.getInstance().reset();
+                }
+                sendCompareCallBack(false, ERROR_OTHERS);
+            }
+        });
+    }
+
+    @Override
+    public void release() {
+        runOnWorjerThread(new Runnable() {
+            @Override
+            public void run() {
+                if (getStatus() == Status.idle) {
+                    return;
+                }
+                Lite.getInstance().release();
+                setStatus(Status.idle);
+            }
+        });
+    }
+
+    public synchronized Status getStatus() {
+        return mStatus;
+    }
+
+    public synchronized void setStatus(Status status) {
+        if (mStatus != status) {
+            mStatus = status;
+            final StatusObserver observer = mStatusObserver;
+            runOnWorjerThread(new Runnable() {
+                @Override
+                public void run() {
+                    if (observer != null) {
+                        observer.onStatusChanged(mStatus);
+                    }
+                }
+            });
+        }
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/face/scanner/LiteManager.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/face/scanner/KeyguardStateCallback.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/face/scanner/KeyguardStateCallback.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/face/scanner/KeyguardStateCallback.java	(revision 6857)
@@ -0,0 +1,82 @@
+package com.face.scanner;
+
+
+import com.android.internal.policy.IKeyguardService;
+import com.android.internal.policy.IKeyguardStateCallback;
+import android.util.Log;
+import android.os.RemoteException;
+
+
+public class KeyguardStateCallback extends IKeyguardStateCallback.Stub {
+    private static final String TAG = "KeyguardStateCallback";
+    private static KeyguardStateCallback sCallback = null;
+	
+    PrivacySpaceActivity mActivity = null;
+    boolean mKeyguardShowing = false;
+    boolean mUnlockFinished = false;
+    boolean mSimSecure = false;
+    boolean mInputRestricted = false;
+    boolean mRegistered = false;
+    boolean mHasLockscreenWallpaper = false;
+	boolean mTrusted = false;
+	
+    KeyguardStateCallback() {
+        super();
+    }
+	
+    public static KeyguardStateCallback getInistance() {
+        if(sCallback == null) {
+            sCallback = new KeyguardStateCallback();
+        }
+        return sCallback;
+    }	
+	
+    public void onShowingStateChanged(boolean showing) {
+        boolean oldShow = mKeyguardShowing;
+        mKeyguardShowing = showing;
+        Log.d(TAG," onShowingStateChanged:oldShow="+oldShow+",mKeyguardShowing="+mKeyguardShowing);
+        if(oldShow && !mKeyguardShowing && mActivity != null && !mActivity.mUnlockFinished) {
+            Log.d(TAG," Unlocked, finish PrivacySpaceActivity");
+            mActivity.mUnlockFinished = true;
+            mActivity.finish();
+            mActivity = null;
+        }
+    }
+	
+    public void onSimSecureStateChanged(boolean simSecure) {
+        mSimSecure = simSecure;
+    }
+	
+    public void onInputRestrictedStateChanged(boolean inputRestricted) {
+        mInputRestricted = inputRestricted;
+    }
+	
+    public void onAntiTheftStateChanged(boolean antiTheftEnabled) {
+        ;
+    }
+	
+    public void registerToKeyguard(IKeyguardService Service) {
+        if(!mRegistered) {
+            try {
+                Service.addStateMonitorCallback(this);
+                mRegistered = true;
+            } catch (RemoteException e) {
+                Log.e(TAG, "Remote Exception when addStateMonitorCallback", e);
+            }
+        }
+    }
+	
+    public void setActivity(PrivacySpaceActivity a) {
+        mActivity = a;
+    }
+	   @Override // Binder interface
+    public void onHasLockscreenWallpaperChanged(boolean hasLockscreenWallpaper) {
+        mHasLockscreenWallpaper = hasLockscreenWallpaper;
+    }
+
+    @Override // Binder interface
+    public void onTrustedChanged(boolean trusted) {
+        mTrusted = trusted;
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/face/scanner/KeyguardStateCallback.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/face/scanner/view/InfraredLedManager.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/face/scanner/view/InfraredLedManager.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/face/scanner/view/InfraredLedManager.java	(revision 6857)
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// TODO : change to your package name
+
+package com.face.scanner.view;
+
+import android.os.IBinder;
+import android.util.Log;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+final class InfraredLedManager {
+
+    private static final String TAG = InfraredLedManager.class.getSimpleName();
+
+    private static final Object iInfraredLedService;
+    private static final Method setOn;
+    private static final Method setOff;
+    private static final Method setBrightness;
+
+    static {
+        iInfraredLedService = getHardwareService();
+        setOn = getSetOnMethod(iInfraredLedService);
+        setOff = getSetOffMethod(iInfraredLedService);
+        setBrightness = getSetBrightnessMethod(iInfraredLedService);
+        if (iInfraredLedService == null) {
+            Log.v(TAG,
+                    "This device does not supports control of a infrared_led");
+        } else {
+            Log.v(TAG,
+                    "This device support control of a infrared_led, Service is:"
+                            + iInfraredLedService.toString());
+        }
+    }
+
+    private InfraredLedManager() {
+    }
+
+    /** API setOn */
+    static public void setInfraredLedOn() {
+        insideSetOn();
+    }
+
+    /** API setOff */
+    static public void setInfraredLedOff() {
+        insideSetOff();
+    }
+
+    /** API setBrightness */
+    static public void setInfraredLedBrightness(int value) {
+        insideSetBrightness(value);
+    }
+
+    private static Object getHardwareService() {
+        Class<?> serviceManagerClass = maybeForName("android.os.ServiceManager");
+        if (serviceManagerClass == null) {
+            Log.d(TAG, "serviceManagerClass == null");
+            return null;
+        }
+
+        Method getServiceMethod = maybeGetMethod(serviceManagerClass,
+                "getService", String.class);
+        if (getServiceMethod == null) {
+            Log.d(TAG, "getServiceMethod == null");
+            return null;
+        }
+
+        Object hardwareService = invoke(getServiceMethod, null, "infrared_led");
+        if (hardwareService == null) {
+            Log.d(TAG, "infraredLedService == null");
+            return null;
+        }
+
+        Class<?> iHardwareServiceStubClass = maybeForName("android.app.IInfraredLedService$Stub");
+        if (iHardwareServiceStubClass == null) {
+            Log.d("TAG", "iInfraredLedServiceStubClass == null");
+            return null;
+        }
+
+        Method asInterfaceMethod = maybeGetMethod(iHardwareServiceStubClass,
+                "asInterface", IBinder.class);
+        if (asInterfaceMethod == null) {
+            Log.d(TAG, "asInterfaceMethod == null");
+            return null;
+        }
+        return invoke(asInterfaceMethod, null, hardwareService);
+    }
+
+    private static Method getSetOnMethod(Object iHardwareService) {
+        if (iHardwareService == null) {
+            return null;
+        }
+        Class<?> proxyClass = iHardwareService.getClass();
+        return maybeGetMethod(proxyClass, "setOn");
+    }
+
+    private static Method getSetOffMethod(Object iHardwareService) {
+        if (iHardwareService == null) {
+            return null;
+        }
+        Class<?> proxyClass = iHardwareService.getClass();
+        return maybeGetMethod(proxyClass, "setOff");
+    }
+
+    private static Method getSetBrightnessMethod(Object iHardwareService) {
+        if (iHardwareService == null) {
+            return null;
+        }
+        Class<?> proxyClass = iHardwareService.getClass();
+        return maybeGetMethod(proxyClass, "setBrightness", int.class);
+    }
+
+    private static Class<?> maybeForName(String name) {
+        try {
+            return Class.forName(name);
+        } catch (ClassNotFoundException cnfe) {
+            // OK
+            return null;
+        } catch (RuntimeException re) {
+            Log.w(TAG, "Unexpected error while finding class " + name, re);
+            return null;
+        }
+    }
+
+    private static Method maybeGetMethod(Class<?> clazz, String name,
+            Class<?>... argClasses) {
+        try {
+            return clazz.getMethod(name, argClasses);
+        } catch (NoSuchMethodException nsme) {
+            // OK
+            return null;
+        } catch (RuntimeException re) {
+            Log.w(TAG, "Unexpected error while finding method " + name, re);
+            return null;
+        }
+    }
+
+    private static Object invoke(Method method, Object instance, Object... args) {
+        try {
+            return method.invoke(instance, args);
+        } catch (IllegalAccessException e) {
+            Log.w(TAG, "Unexpected error while invoking " + method, e);
+            return null;
+        } catch (InvocationTargetException e) {
+            Log.w(TAG, "Unexpected error while invoking " + method,
+                    e.getCause());
+            return null;
+        } catch (RuntimeException re) {
+            Log.w(TAG, "Unexpected error while invoking " + method, re);
+            return null;
+        }
+    }
+
+    private static void insideSetOn() {
+        if (iInfraredLedService == null) {
+            Log.v(TAG, "set infrared_led On , but iInfraredLedService is null");
+        } else {
+            invoke(setOn, iInfraredLedService);
+        }
+    }
+
+    private static void insideSetOff() {
+        if (iInfraredLedService == null) {
+            Log.v(TAG, "set infrared_led Off , but iInfraredLedService is null");
+        } else {
+            invoke(setOff, iInfraredLedService);
+        }
+    }
+
+    private static void insideSetBrightness(int value) {
+        if (iInfraredLedService == null) {
+            Log.v(TAG, "set infrared_led Brightness , but iInfraredLedService is null");
+        } else {
+            invoke(setBrightness, iInfraredLedService, value);
+        }
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/face/scanner/view/InfraredLedManager.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/face/scanner/view/CameraSurfaceView.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/face/scanner/view/CameraSurfaceView.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/face/scanner/view/CameraSurfaceView.java	(revision 6857)
@@ -0,0 +1,261 @@
+
+package com.face.scanner.view;
+
+import java.io.IOException;
+import java.util.List;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.ImageFormat;
+import android.graphics.SurfaceTexture;
+import android.hardware.Camera;
+import android.hardware.Camera.CameraInfo;
+import android.hardware.Camera.Parameters;
+import android.hardware.Camera.Size;
+import android.util.Log;
+import android.view.Surface;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.WindowManager; 
+
+import com.face.scanner.PrivacySpaceActivity;
+import com.face.scanner.FaceActivity;
+import com.face.scanner.FaceService;
+import com.android.keyguard.R;
+
+public class CameraSurfaceView extends SurfaceView implements
+        SurfaceHolder.Callback {
+    private SurfaceHolder mHolder; // SurfaceView的控制器
+    private Camera mCamera; // Camera对象
+    private int cameraID;
+    private Context context;
+    private int cameraRotateAngle = 0;
+
+    private int previewImH = 0;
+    private int previewImW = 0;
+    // 虹膜图像采集模式必须为预览模式
+    private Camera.PreviewCallback previewCallback = null;
+    private SurfaceTexture mst;
+
+    public boolean mSurfaceDestroyed = true;
+
+    public interface IEvent {
+        void onSurfaceViewReady(CameraSurfaceView surfaceView);
+    }
+
+    private IEvent event;
+
+    public CameraSurfaceView(Context context, int cameraID,
+            Camera.PreviewCallback previewCallback, IEvent event) {
+        super(context);
+
+        this.cameraID = cameraID;
+        this.context = context;
+        this.event = event;
+        this.previewCallback = previewCallback;
+
+        mHolder = getHolder();
+        mHolder.addCallback(this);
+        mst = new SurfaceTexture(0);
+    }
+
+ 	public void OpenFlashLED()
+ 	{
+ 		if(mCamera == null) openCamera(true);
+ 		if(mCamera == null) return;
+ 		Camera.Parameters params = mCamera.getParameters();
+		params.setFlashMode(Parameters.FLASH_MODE_ON);
+		params.setFlashMode(Parameters.FLASH_MODE_TORCH);
+		mCamera.setParameters(params);
+ 	}
+ 	public void setCameraBrightness(int value){
+ 		if(mCamera == null){
+ 			return;
+ 		}
+ 		Camera.Parameters params = mCamera.getParameters();
+ 		int maxExposureCompensation = params.getMaxExposureCompensation();
+ 		int minExposureCompensation = params.getMinExposureCompensation();
+ 		
+ 		if(value<minExposureCompensation){
+ 			value = minExposureCompensation;
+ 		}else if(value>maxExposureCompensation){
+ 			value = maxExposureCompensation;
+ 		}
+ 		
+ 		params.setExposureCompensation(value);
+ 		mCamera.setParameters(params);
+ 	}
+ 	public int getCameraBrightness(){
+ 		Camera.Parameters params = mCamera.getParameters();
+ 		int exposureCompensation = params.getExposureCompensation();
+ 		return exposureCompensation;
+ 	}
+
+ 	public void CloseFlashLED()
+ 	{
+ 		if(mCamera != null){
+ 			Parameters parameters = mCamera.getParameters();
+ 			parameters.setFlashMode(Parameters.FLASH_MODE_OFF);
+ 			mCamera.setParameters(parameters);
+ 		}
+ 	}
+    // openCamera and set camera parameters
+    public void openCamera(boolean forceReopen) {
+        if (forceReopen && mCamera != null) {
+            mCamera.stopPreview();
+            mCamera.setPreviewCallback(null);
+            mCamera.release();
+            mCamera = null;
+        }
+        try {
+            if (mCamera == null) {
+                mCamera = Camera.openLegacy(cameraID,Camera.CAMERA_HAL_API_VERSION_1_0);
+            }
+    
+            //updateCameraParameters();
+    
+            mCamera.setPreviewDisplay(mHolder);
+            // 绝对布局需要的=========================================
+            mCamera.setPreviewCallback(previewCallback);
+            // mCamera.autoFocus(cb);
+            mCamera.setPreviewTexture(mst);
+            // 绝对布局需要的=========================================
+    
+            if (forceReopen) {
+                mCamera.startPreview();
+            }
+
+        } catch (RuntimeException re) {
+            re.printStackTrace();
+            if(context instanceof PrivacySpaceActivity) {
+                //((PrivacySpaceActivity)context).showExitToast(R.string.close_camera);
+            } else if(context instanceof FaceActivity) {
+                //((FaceActivity)context).showExitToast(R.string.close_camera);
+            } else if(context instanceof FaceService) {
+                //((FaceService)context).showExitToast(R.string.close_camera);
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }			
+    }
+
+    public void surfaceCreated(SurfaceHolder holder) {
+        mSurfaceDestroyed = false;
+        mHolder = holder;
+        openCamera(true);
+    }
+
+    // 如果surface变化，则重新打开camera preview，相当于重新初始化
+    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
+        try {
+            if(mCamera == null) return;
+            mHolder = holder;
+            mCamera.startPreview();
+            if (event != null) {
+                event.onSurfaceViewReady(this);
+            }
+            event = null;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    // surface界面销毁后，自动退出preview，收回camra资源
+    public void surfaceDestroyed(SurfaceHolder holder) {
+        stopCamera();
+        mSurfaceDestroyed = true;
+    }
+
+    private void setCameraDisplayOrientation(Context context, int cameraId,
+            Camera camera) {
+        CameraInfo info = new CameraInfo();
+        Camera.getCameraInfo(cameraId, info);
+        int rotation = ((WindowManager) (context.getApplicationContext().getSystemService(Context.WINDOW_SERVICE)))
+                .getDefaultDisplay().getRotation();
+
+        int degrees = 0;
+        switch (rotation) {
+            case Surface.ROTATION_0:
+                degrees = 0;
+                break;
+            case Surface.ROTATION_90:
+                degrees = 90;
+                break;
+            case Surface.ROTATION_180:
+                degrees = 180;
+                break;
+            case Surface.ROTATION_270:
+                degrees = 270;
+                break;
+        }
+        degrees = 270;
+        int result;
+        if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
+            result = (info.orientation + degrees) % 360;
+            result = (360 - result) % 360;
+        } else {
+            result = (info.orientation - degrees + 360) % 360;
+        }
+        cameraRotateAngle = result;
+
+        // if(EnumDeviceType.isJiaWeiA780())
+        {
+            cameraRotateAngle = 0;
+        }
+
+        Log.d("CameraSurface", "preview angel:" + result);
+        camera.setDisplayOrientation(result);
+    }
+
+    public int getCameraRotateAngle() {
+        return cameraRotateAngle;
+    }
+
+    public int getPreviewImH() {
+        return previewImH;
+    }
+
+    public int getPreviewImW() {
+        return previewImW;
+    }
+
+    public int getDeviceType() {
+        return 1;
+    }
+
+    public void stopCamera() {
+        if (mCamera != null) {
+            mCamera.stopPreview();
+            mCamera.setPreviewCallback(null);
+            mCamera.release();
+            mCamera = null;
+            mHolder = null;
+        }
+    }
+    
+    private double mRequestedAspect = 1920 / (double)1080;
+    @Override
+	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+
+		if (mRequestedAspect > 0) {
+			int initialWidth = MeasureSpec.getSize(widthMeasureSpec);
+			int initialHeight = MeasureSpec.getSize(heightMeasureSpec);
+
+			final double viewAspectRatio = (double)initialWidth / initialHeight;
+			final double aspectDiff = mRequestedAspect / viewAspectRatio - 1;
+
+			if (Math.abs(aspectDiff) > 0.01) {
+				if (aspectDiff > 0) {
+					initialHeight = (int) (initialWidth / mRequestedAspect);
+				} else {
+					initialWidth = (int) (initialHeight * mRequestedAspect);
+				}
+				widthMeasureSpec = MeasureSpec.makeMeasureSpec(initialWidth, MeasureSpec.EXACTLY);
+				heightMeasureSpec = MeasureSpec.makeMeasureSpec(initialHeight, MeasureSpec.EXACTLY);
+			}
+		}
+		super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+	}
+    
+    
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/face/scanner/view/CameraSurfaceView.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/face/scanner/view/DrawFaceEyesView.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/face/scanner/view/DrawFaceEyesView.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/face/scanner/view/DrawFaceEyesView.java	(revision 6857)
@@ -0,0 +1,753 @@
+package com.face.scanner.view;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Camera;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import android.util.AttributeSet;
+import android.view.View;
+import com.android.keyguard.R;
+import android.graphics.Path;
+import android.graphics.PathMeasure;
+
+public class DrawFaceEyesView extends View{
+	private Paint mainPaint; 
+	private Paint alphPaint;
+	private Camera camera=new Camera();
+    
+    private Bitmap hongmoMaskImage=BitmapFactory.decodeResource(getResources(), R.drawable.hongmo_mask_two);
+	private Matrix hongmoMaskImageMatrix=new Matrix();
+    
+//    private Bitmap hongmoMeshImage=BitmapFactory.decodeResource(getResources(), R.drawable.hongmo_mesh_image);
+	private Matrix hongmoMeshImageMatrix=new Matrix();
+//
+//	private Bitmap hongmoMeshMaskImage=BitmapFactory.decodeResource(getResources(), R.drawable.hongmo_mesh_mask_image);
+//	private Matrix hongmoMeshMaskImageMatrix=new Matrix();
+//	private float upDownValue=0.0f;
+//	private boolean downJudge=false;
+	
+	private int borderLeftLine1StartY=60;
+	private int borderLeftLine1EndY=60;
+	private final int BORDERLEFTLINE1ENDY=85;
+	private int borderLeftLine1StartX=16;
+	
+	private int borderLeftLine2StartY=110;
+	private int borderLeftLine2EndY=110;
+	private final int BORDERLEFTLINE2ENDY=185;
+	private int borderLeftLine2StartX=9;
+	
+	private int borderLeftLine3StartY=220;
+	private int borderLeftLine3EndY=220;
+	private final int BORDERLEFTLINE3ENDY=340;
+	private int borderLeftLine3StartX=21;
+	
+	private int borderLeftLine4StartY=220;
+	private int borderLeftLine4EndY=220;
+	private final int BORDERLEFTLINE4ENDY=110;
+	private int borderLeftLine4StartX=3;
+	
+	private int borderLeftLine5StartY=109;
+	private int borderLeftLine5EndY=109;
+	private final int BORDERLEFTLINE5ENDY=99;
+	private int borderLeftLine5StartX=3;
+	private int borderLeftLine5EndX=3;
+	
+	private int borderLeftLine6StartY=98;
+	private int borderLeftLine6EndY=98;
+	private final int BORDERLEFTLINE6ENDY=0;
+	private int borderLeftLine6StartX=14;
+	
+	private int borderLeftLine7StartY=520;
+	private int borderLeftLine7EndY=520;
+	private final int BORDERLEFTLINE7ENDY=150;
+	private int borderLeftLine7StartX=16;
+	
+	private int borderLeftLine8StartY=149;
+	private int borderLeftLine8EndY=149;
+	private final int BORDERLEFTLINE8ENDY=140;
+	private int borderLeftLine8StartX=16;
+	private int borderLeftLine8EndX=16;
+	
+	private int borderLeftLine9StartY=320;
+	private int borderLeftLine9EndY=320;
+	private final int BORDERLEFTLINE9ENDY=355;
+	private int borderLeftLine9StartX=29;
+	
+	private int borderLeftLine10StartY=356;
+	private int borderLeftLine10EndY=356;
+	private final int BORDERLEFTLINE10ENDY=365;
+	private int borderLeftLine10StartX=29;
+	private int borderLeftLine10EndX=29;
+	
+	private int borderLeftLine11StartY=365;
+	private int borderLeftLine11EndY=365;
+	private final int BORDERLEFTLINE11ENDY=511;
+	private int borderLeftLine11StartX=20;
+	
+	private int borderLeftLine12StartY=230;
+	private int borderLeftLine12EndY=230;
+	private final int BORDERLEFTLINE12ENDY=410;
+	private int borderLeftLine12StartX=9;
+	
+	private int borderBottomLine1StartX=16;
+	private int borderBottomLine1EndX=16;
+	private final int BORDERBOTTOMLINE1ENDX=1080;
+	private int borderBottomLine1StartY=510;
+	
+	private int borderLeftLinePoint1StartY=192;
+	private int borderLeftLinePoint1EndY=192;
+	private final int BORDERLEFTLINEPOINT1ENDY=196;
+	private int borderLeftLinePoint1StartX=9;
+	
+	private int borderLeftLinePoint2StartY=202;
+	private int borderLeftLinePoint2EndY=202;
+	private final int BORDERLEFTLINEPOINT2ENDY=206;
+	private int borderLeftLinePoint2StartX=9;
+	
+	private int borderLeftLinePoint3StartY=212;
+	private int borderLeftLinePoint3EndY=212;
+	private final int BORDERLEFTLINEPOINT3ENDY=216;
+	private int borderLeftLinePoint3StartX=9;
+	
+	private int borderLeftLinePoint4StartY=397;
+	private int borderLeftLinePoint4EndY=397;
+	private final int BORDERLEFTLINEPOINT4ENDY=401;
+	private int borderLeftLinePoint4StartX=20;
+	
+	private int borderLeftLinePoint5StartY=407;
+	private int borderLeftLinePoint5EndY=407;
+	private final int BORDERLEFTLINEPOINT5ENDY=411;
+	private int borderLeftLinePoint5StartX=20;
+	
+	private int borderLeftLinePoint6StartY=417;
+	private int borderLeftLinePoint6EndY=417;
+	private final int BORDERLEFTLINEPOINT6ENDY=421;
+	private int borderLeftLinePoint6StartX=20;
+	
+	private int borderLeftLinePoint7StartY=489;
+	private int borderLeftLinePoint7EndY=489;
+	private final int BORDERLEFTLINEPOINT7ENDY=493;
+	private int borderLeftLinePoint7StartX=20;
+	
+	private int borderLeftLinePoint8StartY=499;
+	private int borderLeftLinePoint8EndY=499;
+	private final int BORDERLEFTLINEPOINT8ENDY=503;
+	private int borderLeftLinePoint8StartX=20;
+	
+	private int borderLeftLinePoint9StartY=509;
+	private int borderLeftLinePoint9EndY=509;
+	private final int BORDERLEFTLINEPOINT9ENDY=513;
+	private int borderLeftLinePoint9StartX=20;
+	
+	private Bitmap bitmapCircle1=BitmapFactory.decodeResource(getResources(), R.drawable.circle_one);
+	private Matrix circle1RotateMartrix1=new Matrix(); 
+	private int circle1DegreeValue1=0;
+	private Matrix circle1RotateMartrix2=new Matrix();
+	private int circle1DegreeValue2=0;
+	private Matrix circle1RotateMartrix3=new Matrix();
+	private int circle1DegreeValue3=0;
+	private Matrix circle1RotateMartrix4=new Matrix();
+	private int circle1DegreeValue4=0;
+	private Matrix circle1RotateMartrix5=new Matrix();
+	private int circle1DegreeValue5=0;
+	private Matrix circle1RotateMartrix6=new Matrix();
+	private int circle1DegreeValue6=0;
+	private Matrix circle1RotateMartrix7=new Matrix();
+	private int circle1DegreeValue7=0;
+	private Matrix circle1RotateMartrix8=new Matrix();
+	private int circle1DegreeValue8=0;
+	private Matrix circle1RotateMartrix9=new Matrix();
+	private int circle1DegreeValue9=0;
+	private Matrix circle1RotateMartrix10=new Matrix();
+	private int circle1DegreeValue10=0;
+	private Matrix circle1RotateMartrix11=new Matrix();
+	private int circle1DegreeValue11=0;
+	private Matrix circle1RotateMartrix12=new Matrix();
+	private int circle1DegreeValue12=0;
+	
+	private Bitmap bitmapCircle2=BitmapFactory.decodeResource(getResources(), R.drawable.circle_two);
+	private Matrix circle2ScaleMatrix1=new Matrix();
+	private float circle2ScaleValue1=0.0f;
+	
+	private Bitmap bitmapCircle3=BitmapFactory.decodeResource(getResources(), R.drawable.circle_three);
+	private Matrix circle3ScaleMatrix1=new Matrix();
+	private float circle3ScaleValue1=0.0f;
+	
+	private Bitmap bitmapCircle4=BitmapFactory.decodeResource(getResources(), R.drawable.circle_four);
+	private Matrix circle4ScaleMatrix1=new Matrix();
+	private float circle4ScaleValue1=0.0f;
+	
+	private Bitmap bitmapCircle5=BitmapFactory.decodeResource(getResources(), R.drawable.circle_five);
+	private Matrix circle5ScaleMatrix1=new Matrix();
+	private float circle5ScaleValue1=0.0f;
+	
+	private Bitmap bitmapCircle6=BitmapFactory.decodeResource(getResources(), R.drawable.circle_six);
+	private Matrix circle6ScaleMatrix1=new Matrix();
+	private float circle6ScaleValue1=0.0f;
+	
+	private Bitmap bitmapCircle7=BitmapFactory.decodeResource(getResources(), R.drawable.circle_seven);
+	private Matrix circle7ScaleMatrix1=new Matrix();
+	private float circle7ScaleValue1=0.0f;
+	
+	private Bitmap bitmapCircle8=BitmapFactory.decodeResource(getResources(), R.drawable.circle_eight);
+	private Matrix circle8ScaleMatrix1=new Matrix();
+	private float circle8ScaleValue1=0.0f;
+	
+	private Bitmap bitmapCircle9=BitmapFactory.decodeResource(getResources(), R.drawable.circle_nine);
+	private Matrix circle9ScaleMatrix1=new Matrix();
+	private int circle9DelayCount=0;
+	private float circle9ScaleValue1=1.1f;
+	private float circle9DegreeValue1=0.0f;
+	private int circle9AlphValue1=0;
+	private boolean scaleBigJudge=true;
+	
+	private float hongmo1Scale=0.0f;
+	private int hongmo1ZDegree=72;
+	private int hongmo2ZDegree=144;
+	private int hongmo3ZDegree=216;
+	private int hongmo4ZDegree=288;
+	private int hongmo5ZDegree=360;
+	private boolean hongmo1RightRotate=true;
+	
+	private Bitmap hongmoImage1=BitmapFactory.decodeResource(getResources(), R.drawable.circle_focus);
+	private Matrix hongmoImage1RotateMartrix1=new Matrix(); 
+	private int hongmoImage1DegreeValue1=0;
+	private Matrix hongmoImage1RotateMartrix2=new Matrix();
+	private int hongmoImage1DegreeValue2=0;
+	private Matrix hongmoImage1RotateMartrix3=new Matrix();
+	private int hongmoImage1DegreeValue3=0;
+	private Matrix hongmoImage1RotateMartrix4=new Matrix();
+	private int hongmoImage1DegreeValue4=0;
+	private Matrix hongmoImage1RotateMartrix5=new Matrix();
+	private int hongmoImage1DegreeValue5=0;
+	
+	public DrawFaceEyesView(Context context) {
+		this(context,null);
+	}	
+	
+	public DrawFaceEyesView(Context context, AttributeSet attrs) {
+		super(context, attrs);
+		// TODO Auto-generated constructor stub
+		mainPaint = new Paint();
+		alphPaint = new Paint();
+	}
+
+	@Override
+	protected void onDraw(Canvas canvas) {
+		// TODO Auto-generated method stub
+		super.onDraw(canvas);
+		//canvas.drawColor(Color.BLACK);
+    	
+    	
+    	/////////////////////////////////////////////////////////////
+//        if(downJudge&&upDownValue<0.0f){
+//			upDownValue+=30;
+//			hongmoMeshMaskImageMatrix.setTranslate(0f, upDownValue);
+//			if(upDownValue>-60.0f){
+//				downJudge=false;
+//			}
+//		}
+//
+//		if(!downJudge&&upDownValue>-960.0f){
+//			upDownValue-=30;
+//			hongmoMeshMaskImageMatrix.setTranslate(0f, upDownValue);
+//			if(upDownValue<-900.0f){
+//				downJudge=true;
+//			}
+//		}
+        
+        
+        
+    	if(borderLeftLine1EndY<BORDERLEFTLINE1ENDY){
+    		borderLeftLine1EndY++;
+    	}
+    	
+    	if(borderLeftLine2EndY<BORDERLEFTLINE2ENDY){
+    		borderLeftLine2EndY+=3;
+    	}else if(borderLeftLinePoint1EndY<BORDERLEFTLINEPOINT1ENDY){
+    		borderLeftLinePoint1EndY+=1;
+    	}else if(borderLeftLinePoint2EndY<BORDERLEFTLINEPOINT2ENDY){
+    		borderLeftLinePoint2EndY+=1;
+    	}else if(borderLeftLinePoint3EndY<BORDERLEFTLINEPOINT3ENDY){
+    		borderLeftLinePoint3EndY+=1;
+    	}
+    	
+    	if(borderLeftLine3EndY<BORDERLEFTLINE3ENDY){
+    		borderLeftLine3EndY+=5;
+    	}else if(borderLeftLinePoint4EndY<BORDERLEFTLINEPOINT4ENDY){
+    		borderLeftLinePoint4EndY+=1;
+    	}else if(borderLeftLinePoint5EndY<BORDERLEFTLINEPOINT5ENDY){
+    		borderLeftLinePoint5EndY+=1;
+    	}else if(borderLeftLinePoint6EndY<BORDERLEFTLINEPOINT6ENDY){
+    		borderLeftLinePoint6EndY+=1;
+    	}else if(borderLeftLinePoint7EndY<BORDERLEFTLINEPOINT7ENDY){
+    		borderLeftLinePoint7EndY+=1;
+    	}else if(borderLeftLinePoint8EndY<BORDERLEFTLINEPOINT8ENDY){
+    		borderLeftLinePoint8EndY+=1;
+    	}else if(borderLeftLinePoint9EndY<BORDERLEFTLINEPOINT9ENDY){
+    		borderLeftLinePoint9EndY+=1;
+    	}
+    	
+    	if(borderLeftLine4EndY>BORDERLEFTLINE4ENDY){
+    		borderLeftLine4EndY-=3;
+    	}else if(borderLeftLine5EndY>BORDERLEFTLINE5ENDY){
+    		borderLeftLine5EndY-=3;
+    		borderLeftLine5EndX+=3;
+    	}else if(borderLeftLine6EndY>BORDERLEFTLINE6ENDY){
+    		borderLeftLine6EndY-=3;
+    	}
+    	
+    	if(borderLeftLine7EndY>BORDERLEFTLINE7ENDY){
+    		borderLeftLine7EndY-=3;
+    	}else if(borderLeftLine8EndY>BORDERLEFTLINE8ENDY){
+    		borderLeftLine8EndY-=3;
+    		borderLeftLine8EndX+=3;
+    	}
+    	
+    	if(borderBottomLine1EndX<BORDERBOTTOMLINE1ENDX){
+    		borderBottomLine1EndX+=60;
+    	}
+    	
+    	if(borderLeftLine9EndY<BORDERLEFTLINE9ENDY){
+    		borderLeftLine9EndY+=3;
+    	}else if(borderLeftLine10EndY<BORDERLEFTLINE10ENDY){
+    		borderLeftLine10EndY+=3;
+    		borderLeftLine10EndX-=3;
+    	}else if(borderLeftLine11EndY<BORDERLEFTLINE11ENDY){
+    		borderLeftLine11EndY+=3;
+    	}
+    	
+    	if(borderLeftLine12EndY<BORDERLEFTLINE12ENDY){
+    		borderLeftLine12EndY+=3;
+    	}
+        
+    	if(circle1DegreeValue1<=18){
+    		circle1DegreeValue1+=3;
+    		circle1RotateMartrix1.setRotate(circle1DegreeValue1, 270, 270);
+    	}else{
+    		circle1DegreeValue1=-378;
+    	}
+    	
+    	if(circle1DegreeValue2<=48){
+    		circle1DegreeValue2+=3;
+    		circle1RotateMartrix2.setRotate(circle1DegreeValue2, 270, 270);
+    	}else{
+    		circle1DegreeValue2=-408;
+    	}
+    	
+    	if(circle1DegreeValue3<=72){
+    		circle1DegreeValue3+=3;
+    		circle1RotateMartrix3.setRotate(circle1DegreeValue3, 270, 270);
+    	}else{
+    		circle1DegreeValue3=-432;
+    	}
+    	
+    	if(circle1DegreeValue4<=96){
+    		circle1DegreeValue4+=3;
+    		circle1RotateMartrix4.setRotate(circle1DegreeValue4, 270, 270);
+    	}else{
+    		circle1DegreeValue4=-456;
+    	}
+    	
+    	if(circle1DegreeValue5<=135){
+    		circle1DegreeValue5+=3;
+    		circle1RotateMartrix5.setRotate(circle1DegreeValue5, 270, 270);
+    	}else{
+    		circle1DegreeValue5=-495;
+    	}
+    	
+    	if(circle1DegreeValue6<=156){
+    		circle1DegreeValue6+=3;
+    		circle1RotateMartrix6.setRotate(circle1DegreeValue6, 270, 270);
+    	}else{
+    		circle1DegreeValue6=-516;
+    	}
+    	
+    	if(circle1DegreeValue7>=-18){
+    		circle1DegreeValue7-=3;
+    		circle1RotateMartrix7.setRotate(circle1DegreeValue7, 270, 270);
+    	}else{
+    		circle1DegreeValue7=378;
+    	}
+    	
+    	if(circle1DegreeValue8>=-48){
+    		circle1DegreeValue8-=3;
+    		circle1RotateMartrix8.setRotate(circle1DegreeValue8, 270, 270);
+    	}else{
+    		circle1DegreeValue8=408;
+    	}
+    	
+    	if(circle1DegreeValue9>=-72){
+    		circle1DegreeValue9-=3;
+    		circle1RotateMartrix9.setRotate(circle1DegreeValue9, 270, 270);
+    	}else{
+    		circle1DegreeValue9=432;
+    	}
+    	
+    	if(circle1DegreeValue10>=-96){
+    		circle1DegreeValue10-=3;
+    		circle1RotateMartrix10.setRotate(circle1DegreeValue10, 270, 270);
+    	}else{
+    		circle1DegreeValue10=456;
+    	}
+    	
+    	if(circle1DegreeValue11>=-135){
+    		circle1DegreeValue11-=3;
+    		circle1RotateMartrix11.setRotate(circle1DegreeValue11, 270, 270);
+    	}else{
+    		circle1DegreeValue11=495;
+    	}
+    	
+    	if(circle1DegreeValue12>=-156){
+    		circle1DegreeValue12-=3;
+    		circle1RotateMartrix12.setRotate(circle1DegreeValue12, 270, 270);
+    	}else{
+    		circle1DegreeValue12=516;
+    	}
+    	
+    	if(circle2ScaleValue1<=1){
+    		circle2ScaleValue1+=0.05;
+    		circle2ScaleMatrix1.setScale(circle2ScaleValue1, circle2ScaleValue1, 270f, 270f);
+    	}
+    	
+    	if(circle3ScaleValue1<=1){
+    		circle3ScaleValue1+=0.02;
+    		circle3ScaleMatrix1.setScale(circle3ScaleValue1, circle3ScaleValue1, 270f, 270f);
+    	}
+    	
+    	if(circle4ScaleValue1<=1){
+    		circle4ScaleValue1+=0.03;
+    		circle4ScaleMatrix1.setScale(circle4ScaleValue1, circle4ScaleValue1, 270f, 270f);
+    	}
+    	
+    	if(circle5ScaleValue1<=1){
+    		circle5ScaleValue1+=0.04;
+    		circle5ScaleMatrix1.setScale(circle5ScaleValue1, circle5ScaleValue1, 270f, 270f);
+    	}
+    	
+    	if(circle6ScaleValue1<=1){
+    		circle6ScaleValue1+=0.05;
+    		circle6ScaleMatrix1.setScale(circle6ScaleValue1, circle6ScaleValue1, 270f, 270f);
+    	}
+    	
+    	if(circle7ScaleValue1<=1){
+    		circle7ScaleValue1+=0.06;
+    		circle7ScaleMatrix1.setScale(circle7ScaleValue1, circle7ScaleValue1, 270f, 270f);
+    	}
+    	
+    	if(circle8ScaleValue1<=1){
+    		circle8ScaleValue1+=0.07;
+    		circle8ScaleMatrix1.setScale(circle8ScaleValue1, circle8ScaleValue1, 270f, 270f);
+    	}
+    	
+    	if(circle9DelayCount<50){
+    		circle9DelayCount+=1;
+    	}else if(circle9ScaleValue1>=1&&circle9DelayCount<60){
+    		circle9ScaleValue1-=0.02;
+    		circle9AlphValue1=255;
+    		circle9ScaleMatrix1.setScale(circle9ScaleValue1, circle9ScaleValue1, 270f, 270f);
+    	}else if(circle9DegreeValue1<10&&circle9DelayCount<60){
+    		circle9DegreeValue1+=1;
+    		circle9AlphValue1-=25;
+    		circle9ScaleMatrix1.setScale(circle9ScaleValue1, circle9ScaleValue1, 270f, 270f);
+    		circle9ScaleMatrix1.setRotate(circle9DegreeValue1, 270f, 270f);
+    	}else if(circle9DelayCount<70){
+    		circle9DelayCount+=1;
+    	}else if(circle9DelayCount<80){
+    		circle9DelayCount+=1;
+    		circle9DegreeValue1-=1;
+    		circle9AlphValue1+=25;
+    		circle9ScaleMatrix1.setRotate(circle9DegreeValue1, 270f, 270f);
+    	}else if(circle9DelayCount<120){
+    		circle9DelayCount+=1;
+    		if(scaleBigJudge&&circle9ScaleValue1<1.2){
+    			circle9ScaleValue1+=0.005;
+    			if(circle9ScaleValue1>=1.1){
+    				scaleBigJudge=false;
+    			}
+    		}else{
+    			circle9ScaleValue1-=0.005;
+    		}
+    		circle9ScaleMatrix1.setScale(circle9ScaleValue1, circle9ScaleValue1, 270f, 270f);
+    	}
+    	
+    	if(hongmo1Scale<=1){
+    		hongmo1Scale+=0.05;
+    	}else if(hongmo1ZDegree<=45&&hongmo1RightRotate){
+    		hongmo1ZDegree+=2;
+    		hongmo2ZDegree+=2;
+    		hongmo3ZDegree+=2;
+    		hongmo4ZDegree+=2;
+    		hongmo5ZDegree+=2;
+    	}else{
+    		hongmo1RightRotate=false;
+    	}
+    	if(hongmo1ZDegree>=-45&&!hongmo1RightRotate){
+    		hongmo1ZDegree-=2;
+    		hongmo2ZDegree-=2;
+    		hongmo3ZDegree-=2;
+    		hongmo4ZDegree-=2;
+    		hongmo5ZDegree-=2;
+    	}else{
+    		hongmo1RightRotate=true;
+    	}
+    	
+    	if(hongmoImage1DegreeValue1<=72){
+    		hongmoImage1DegreeValue1+=9;
+    		hongmoImage1RotateMartrix1.setRotate(hongmoImage1DegreeValue1, 37.5f, 37.5f);
+    	}
+    	
+    	if(hongmoImage1DegreeValue2<=144){
+    		hongmoImage1DegreeValue2+=9;
+    		hongmoImage1RotateMartrix2.setRotate(hongmoImage1DegreeValue2, 37.5f, 37.5f);
+    	}
+    	
+    	if(hongmoImage1DegreeValue3<=216){
+    		hongmoImage1DegreeValue3+=9;
+    		hongmoImage1RotateMartrix3.setRotate(hongmoImage1DegreeValue3, 37.5f, 37.5f);
+    	}
+    	
+    	if(hongmoImage1DegreeValue4<=288){
+    		hongmoImage1DegreeValue4+=9;
+    		hongmoImage1RotateMartrix4.setRotate(hongmoImage1DegreeValue4, 37.5f, 37.5f);
+    	}
+    	
+    	if(hongmoImage1DegreeValue5<=360){
+    		hongmoImage1DegreeValue5+=9;
+    		hongmoImage1RotateMartrix5.setRotate(hongmoImage1DegreeValue5, 37.5f, 37.5f);
+    	}
+    	
+    	//A
+    	/////////////////////////////////////////////////////////////
+//        canvas.drawBitmap(hongmoMeshImage, hongmoMeshImageMatrix, null);
+//        canvas.drawBitmap(hongmoMeshMaskImage, hongmoMeshMaskImageMatrix, null);
+        canvas.drawBitmap(hongmoMaskImage, hongmoMeshImageMatrix, null);
+        
+        mainPaint.setColor(Color.RED);
+        mainPaint.setStrokeWidth(5);
+        /*canvas.drawLine(borderLeftLine1StartX, borderLeftLine1StartY, borderLeftLine1StartX, borderLeftLine1EndY, mainPaint);
+        
+        mainPaint.setStrokeWidth(3);
+        canvas.drawLine(borderLeftLine2StartX, borderLeftLine2StartY, borderLeftLine2StartX, borderLeftLine2EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint1StartX, borderLeftLinePoint1StartY, borderLeftLinePoint1StartX, borderLeftLinePoint1EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint2StartX, borderLeftLinePoint2StartY, borderLeftLinePoint2StartX, borderLeftLinePoint2EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint3StartX, borderLeftLinePoint3StartY, borderLeftLinePoint3StartX, borderLeftLinePoint3EndY, mainPaint);
+
+        
+        mainPaint.setStrokeWidth(3);
+        canvas.drawLine(borderLeftLine3StartX, borderLeftLine3StartY, borderLeftLine3StartX, borderLeftLine3EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint4StartX, borderLeftLinePoint4StartY, borderLeftLinePoint4StartX, borderLeftLinePoint4EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint5StartX, borderLeftLinePoint5StartY, borderLeftLinePoint5StartX, borderLeftLinePoint5EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint6StartX, borderLeftLinePoint6StartY, borderLeftLinePoint6StartX, borderLeftLinePoint6EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint7StartX, borderLeftLinePoint7StartY, borderLeftLinePoint7StartX, borderLeftLinePoint7EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint8StartX, borderLeftLinePoint8StartY, borderLeftLinePoint8StartX, borderLeftLinePoint8EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint9StartX, borderLeftLinePoint9StartY, borderLeftLinePoint9StartX, borderLeftLinePoint9EndY, mainPaint);
+
+        
+        mainPaint.setStrokeWidth(1);
+        canvas.drawLine(borderLeftLine4StartX, borderLeftLine4StartY, borderLeftLine4StartX, borderLeftLine4EndY, mainPaint);
+        canvas.drawLine(borderLeftLine5StartX, borderLeftLine5StartY, borderLeftLine5EndX, borderLeftLine5EndY, mainPaint);
+        canvas.drawLine(borderLeftLine6StartX, borderLeftLine6StartY, borderLeftLine6StartX, borderLeftLine6EndY, mainPaint);
+        
+        mainPaint.setStrokeWidth(1);
+        canvas.drawLine(borderLeftLine7StartX, borderLeftLine7StartY, borderLeftLine7StartX, borderLeftLine7EndY, mainPaint);
+        canvas.drawLine(borderLeftLine8StartX, borderLeftLine8StartY, borderLeftLine8EndX, borderLeftLine8EndY, mainPaint);
+        canvas.drawLine(borderBottomLine1StartX, borderBottomLine1StartY, borderBottomLine1EndX, borderBottomLine1StartY, mainPaint);
+        
+        mainPaint.setStrokeWidth(1);
+        canvas.drawLine(borderLeftLine9StartX, borderLeftLine9StartY, borderLeftLine9StartX, borderLeftLine9EndY, mainPaint);
+        canvas.drawLine(borderLeftLine10StartX, borderLeftLine10StartY, borderLeftLine10EndX, borderLeftLine10EndY, mainPaint);
+        canvas.drawLine(borderLeftLine11StartX, borderLeftLine11StartY, borderLeftLine11StartX, borderLeftLine11EndY, mainPaint);
+        
+        mainPaint.setStrokeWidth(1);
+        canvas.drawLine(borderLeftLine12StartX, borderLeftLine12StartY, borderLeftLine12StartX, borderLeftLine12EndY, mainPaint);*/
+        
+        
+        //canvas.translate(140, 140);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix1, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix2, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix3, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix4, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix5, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix6, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix7, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix8, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix9, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix10, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix11, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix12, null);
+        
+        canvas.drawBitmap(bitmapCircle2, circle2ScaleMatrix1, null);
+        
+        canvas.drawBitmap(bitmapCircle3, circle3ScaleMatrix1, null);
+        
+        canvas.drawBitmap(bitmapCircle4, circle4ScaleMatrix1, null);
+        
+        canvas.drawBitmap(bitmapCircle5, circle5ScaleMatrix1, null);
+        
+        canvas.drawBitmap(bitmapCircle6, circle6ScaleMatrix1, null);
+        
+        canvas.drawBitmap(bitmapCircle7, circle7ScaleMatrix1, null);
+        
+        canvas.drawBitmap(bitmapCircle8, circle8ScaleMatrix1, null);
+        
+        alphPaint.setAlpha(circle9AlphValue1);
+        canvas.drawBitmap(bitmapCircle9, circle9ScaleMatrix1, alphPaint);
+        
+        
+        
+        //B
+    	/////////////////////////////////////////////////////////////
+        canvas.translate(540, 0);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix1, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix2, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix3, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix4, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix5, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix6, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix7, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix8, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix9, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix10, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix11, null);
+        canvas.drawBitmap(bitmapCircle1, circle1RotateMartrix12, null);
+        
+        canvas.drawBitmap(bitmapCircle2, circle2ScaleMatrix1, null);
+        
+        canvas.drawBitmap(bitmapCircle3, circle3ScaleMatrix1, null);
+        
+        canvas.drawBitmap(bitmapCircle4, circle4ScaleMatrix1, null);
+        
+        canvas.drawBitmap(bitmapCircle5, circle5ScaleMatrix1, null);
+        
+        canvas.drawBitmap(bitmapCircle6, circle6ScaleMatrix1, null);
+        
+        canvas.drawBitmap(bitmapCircle7, circle7ScaleMatrix1, null);
+        
+        canvas.drawBitmap(bitmapCircle8, circle8ScaleMatrix1, null);
+        
+        alphPaint.setAlpha(circle9AlphValue1);
+        canvas.drawBitmap(bitmapCircle9, circle9ScaleMatrix1, alphPaint);
+        
+        
+        
+        //C
+    	/////////////////////////////////////////////////////////////
+        canvas.translate(510, 0);
+        
+        mainPaint.setColor(Color.RED);
+        mainPaint.setStrokeWidth(5);
+        /*canvas.drawLine(borderLeftLine1StartX, borderLeftLine1StartY, borderLeftLine1StartX, borderLeftLine1EndY, mainPaint);
+        
+        mainPaint.setStrokeWidth(3);
+        canvas.drawLine(borderLeftLine2StartX, borderLeftLine2StartY, borderLeftLine2StartX, borderLeftLine2EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint1StartX, borderLeftLinePoint1StartY, borderLeftLinePoint1StartX, borderLeftLinePoint1EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint2StartX, borderLeftLinePoint2StartY, borderLeftLinePoint2StartX, borderLeftLinePoint2EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint3StartX, borderLeftLinePoint3StartY, borderLeftLinePoint3StartX, borderLeftLinePoint3EndY, mainPaint);
+
+        
+        mainPaint.setStrokeWidth(3);
+        canvas.drawLine(borderLeftLine3StartX, borderLeftLine3StartY, borderLeftLine3StartX, borderLeftLine3EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint4StartX, borderLeftLinePoint4StartY, borderLeftLinePoint4StartX, borderLeftLinePoint4EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint5StartX, borderLeftLinePoint5StartY, borderLeftLinePoint5StartX, borderLeftLinePoint5EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint6StartX, borderLeftLinePoint6StartY, borderLeftLinePoint6StartX, borderLeftLinePoint6EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint7StartX, borderLeftLinePoint7StartY, borderLeftLinePoint7StartX, borderLeftLinePoint7EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint8StartX, borderLeftLinePoint8StartY, borderLeftLinePoint8StartX, borderLeftLinePoint8EndY, mainPaint);
+        canvas.drawLine(borderLeftLinePoint9StartX, borderLeftLinePoint9StartY, borderLeftLinePoint9StartX, borderLeftLinePoint9EndY, mainPaint);
+
+        
+        mainPaint.setStrokeWidth(1);
+        canvas.drawLine(borderLeftLine4StartX, borderLeftLine4StartY, borderLeftLine4StartX, borderLeftLine4EndY, mainPaint);
+        canvas.drawLine(borderLeftLine5StartX, borderLeftLine5StartY, borderLeftLine5EndX, borderLeftLine5EndY, mainPaint);
+        canvas.drawLine(borderLeftLine6StartX, borderLeftLine6StartY, borderLeftLine6StartX, borderLeftLine6EndY, mainPaint);
+        
+        mainPaint.setStrokeWidth(1);
+        canvas.drawLine(borderLeftLine7StartX, borderLeftLine7StartY, borderLeftLine7StartX, borderLeftLine7EndY, mainPaint);
+        canvas.drawLine(borderLeftLine8StartX, borderLeftLine8StartY, borderLeftLine8EndX, borderLeftLine8EndY, mainPaint);
+        //canvas.drawLine(borderBottomLine1StartX, borderBottomLine1StartY, borderBottomLine1EndX, borderBottomLine1StartY, mainPaint);
+        
+        mainPaint.setStrokeWidth(1);
+        canvas.drawLine(borderLeftLine9StartX, borderLeftLine9StartY, borderLeftLine9StartX, borderLeftLine9EndY, mainPaint);
+        canvas.drawLine(borderLeftLine10StartX, borderLeftLine10StartY, borderLeftLine10EndX, borderLeftLine10EndY, mainPaint);
+        canvas.drawLine(borderLeftLine11StartX, borderLeftLine11StartY, borderLeftLine11StartX, borderLeftLine11EndY, mainPaint);
+        
+        mainPaint.setStrokeWidth(1);
+        canvas.drawLine(borderLeftLine12StartX, borderLeftLine12StartY, borderLeftLine12StartX, borderLeftLine12EndY, mainPaint);*/
+        
+        canvas.translate(-814, 233);
+        if(hongmoImage1DegreeValue5>=369){
+        	camera.save();
+    		camera.rotateZ(hongmo1ZDegree);
+    		//camera.rotateX(hongmo1XDegree);
+    		camera.getMatrix(hongmoImage1RotateMartrix1);
+    		camera.restore();
+    		camera.save();
+    		camera.rotateZ(hongmo2ZDegree);
+    		camera.getMatrix(hongmoImage1RotateMartrix2);
+    		camera.restore();
+    		camera.save();
+    		camera.rotateZ(hongmo3ZDegree);
+    		camera.getMatrix(hongmoImage1RotateMartrix3);
+    		camera.restore();
+    		camera.save();
+    		camera.rotateZ(hongmo4ZDegree);
+    		camera.getMatrix(hongmoImage1RotateMartrix4);
+    		camera.restore();
+    		camera.save();
+    		camera.rotateZ(hongmo5ZDegree);
+    		camera.getMatrix(hongmoImage1RotateMartrix5);
+    		camera.restore();
+    		
+    		hongmoImage1RotateMartrix1.preTranslate(-37.5f, -37.5f); 
+    		hongmoImage1RotateMartrix1.postTranslate(37.5f, 37.5f);
+    		
+    		hongmoImage1RotateMartrix2.preTranslate(-37.5f, -37.5f); 
+    		hongmoImage1RotateMartrix2.postTranslate(37.5f, 37.5f);
+    		
+    		hongmoImage1RotateMartrix3.preTranslate(-37.5f, -37.5f); 
+    		hongmoImage1RotateMartrix3.postTranslate(37.5f, 37.5f);
+    		
+    		hongmoImage1RotateMartrix4.preTranslate(-37.5f, -37.5f); 
+    		hongmoImage1RotateMartrix4.postTranslate(37.5f, 37.5f);
+    		
+    		hongmoImage1RotateMartrix5.preTranslate(-37.5f, -37.5f); 
+    		hongmoImage1RotateMartrix5.postTranslate(37.5f, 37.5f);
+        }
+        
+        
+        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix1, null);
+        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix2, null);
+        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix3, null);
+        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix4, null);
+        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix5, null);
+        
+        canvas.translate(540, 0);
+        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix1, null);
+        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix2, null);
+        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix3, null);
+        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix4, null);
+        canvas.drawBitmap(hongmoImage1, hongmoImage1RotateMartrix5, null);
+        
+        
+        invalidate();
+	}
+	
+    public void recycleBitmap() {
+        if(!hongmoMaskImage.isRecycled())hongmoMaskImage.recycle();
+        if(!bitmapCircle1.isRecycled())bitmapCircle1.recycle();
+        if(!bitmapCircle2.isRecycled())bitmapCircle2.recycle();
+        if(!bitmapCircle3.isRecycled())bitmapCircle3.recycle();
+        if(!bitmapCircle4.isRecycled())bitmapCircle4.recycle();
+        if(!bitmapCircle5.isRecycled())bitmapCircle5.recycle();
+        if(!bitmapCircle6.isRecycled())bitmapCircle6.recycle();
+        if(!bitmapCircle7.isRecycled())bitmapCircle7.recycle();
+        if(!bitmapCircle8.isRecycled())bitmapCircle8.recycle();
+        if(!bitmapCircle9.isRecycled())bitmapCircle9.recycle();
+        if(!hongmoImage1.isRecycled())hongmoImage1.recycle();
+   }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/face/scanner/view/DrawFaceEyesView.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/face/scanner/view/RoundProgressBar.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/face/scanner/view/RoundProgressBar.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/face/scanner/view/RoundProgressBar.java	(revision 6857)
@@ -0,0 +1,275 @@
+package com.face.scanner.view;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.graphics.Typeface;
+import android.graphics.drawable.BitmapDrawable;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.widget.ImageView;
+
+import com.android.keyguard.R;
+
+
+/**
+ * 线程安全的View，可直接在线程中更新进度
+ *
+ */
+public class RoundProgressBar extends ImageView {
+
+	/**
+	 * 画笔对象的引用
+	 */
+	private Paint paint;
+
+	/**
+	 * 圆环的颜色
+	 */
+	private int roundColor;
+
+	/**
+	 * 圆环进度的颜色
+	 */
+	private int roundProgressColor;
+
+	/**
+	 * 中间进度百分比的字符串的颜色
+	 */
+	private int textColor;
+
+	/**
+	 * 中间进度百分比的字符串的字体
+	 */
+	private float textSize;
+
+	/**
+	 * 圆环的宽度
+	 */
+	private float roundWidth;
+
+	/**
+	 * 最大进度
+	 */
+	private int max;
+
+	/**
+	 * 当前进度
+	 */
+	private int left_progress, right_progress;
+	
+	private Bitmap mBackgroundBitmap;
+	private int mBGWidth;
+	private int mBGHeight;
+	
+
+	private float x1,x2,y,radius;
+	
+	private boolean textIsDisplayable;
+
+	public RoundProgressBar(Context context) {
+		this(context, null);
+	}
+
+	public RoundProgressBar(Context context, AttributeSet attrs) {
+		this(context, attrs, 0);
+	}
+
+	public RoundProgressBar(Context context, AttributeSet attrs, int defStyle) {
+		super(context, attrs, defStyle);
+
+		paint = new Paint();
+
+
+		TypedArray mTypedArray = context.obtainStyledAttributes(attrs,
+				R.styleable.RoundProgressBar);
+
+		//获取自定义属性和默认
+
+		//roundProgressColor = mTypedArray.getColor(R.styleable.RoundProgressBar_roundProgressColor, Color.GREEN);
+		roundProgressColor = mTypedArray.getColor(R.styleable.RoundProgressBar_roundProgressColor, context.getResources().getColor(android.R.color.white));
+		//textColor = mTypedArray.getColor(R.styleable.RoundProgressBar_textColor, Color.GREEN);
+		textColor = mTypedArray.getColor(R.styleable.RoundProgressBar_textColor,  context.getResources().getColor(android.R.color.white));
+		textSize = mTypedArray.getDimension(R.styleable.RoundProgressBar_textSize, 15);
+		roundWidth = mTypedArray.getDimension(R.styleable.RoundProgressBar_roundWidth, 5);
+		max = mTypedArray.getInteger(R.styleable.RoundProgressBar_max, 100);
+		textIsDisplayable = mTypedArray.getBoolean(R.styleable.RoundProgressBar_textIsDisplayable, true);
+//		style = mTypedArray.getInt(R.styleable.RoundProgressBar_style, 0);
+		roundColor = mTypedArray.getColor(R.styleable.RoundProgressBar_roundColor, Color.RED);
+		mTypedArray.recycle();
+		
+//		mBackgroundBitmap = ((BitmapDrawable)getResources().getDrawable(R.drawable.b_3_2_ok_00)).getBitmap();
+		
+//		setDrawingCacheEnabled(false);
+		setImageResource(R.drawable.b_3_2_ok_00);
+	}
+
+
+	@Override
+	protected void onDraw(Canvas canvas) {
+		super.onDraw(canvas);
+		
+		if(mBGWidth == 0 || mBGHeight == 0){
+			mBGWidth = getMeasuredWidth();
+			mBGHeight = getMeasuredHeight();
+			x1 = (float) (mBGWidth * 90 / 360);
+			x2 = (float) (mBGWidth * 270 / 360);
+			y = (float) (mBGHeight * 91 / 203);
+			radius = (float) (mBGWidth * 52 / 360);
+			Log.i("hz", "mBGWidth:" + mBGWidth + ",mBGHeight:" + mBGHeight);
+		}
+		
+		Log.i("hz", "getWidth:" + getMeasuredWidth() + ",getHeight:" + getMeasuredHeight());
+		/**
+		 * 画最外层的大圆环
+		 */
+		paint.setColor(roundColor); //设置圆环的颜色
+		paint.setStyle(Paint.Style.STROKE); //设置空心
+		paint.setStrokeWidth(roundWidth); //设置圆环的宽度
+		paint.setAntiAlias(true);  //消除锯齿
+		canvas.drawCircle(x1, y, radius, paint); //画出圆环
+		
+		canvas.drawCircle(x2, y, radius, paint); //画出圆环
+		
+		/**
+		 * 画进度百分比
+		 */
+		paint.setStrokeWidth(0);
+		paint.setColor(textColor);
+		paint.setTextSize(textSize);
+		paint.setTypeface(Typeface.DEFAULT_BOLD); //设置字体
+
+
+		/**
+		 * 画圆弧 ，画圆环的进度
+		 */
+		paint.setStrokeWidth(roundWidth); //设置圆环的宽度
+		paint.setColor(Color.argb(255, 72, 236, 239));  //设置进度的颜色
+		RectF left_oval = new RectF(x1 - radius, y - radius, x1
+				+ radius, y + radius);  //用于定义的圆弧的形状和大小的界限
+		RectF right_oval = new RectF(x2 - radius, y - radius, x2
+				+ radius, y + radius);  //用于定义的圆弧的形状和大小的界限
+
+		paint.setStyle(Paint.Style.STROKE);
+		canvas.drawArc(left_oval, -90, 360 * left_progress / max, false, paint);  //根据进度画圆弧
+		canvas.drawArc(right_oval, -90, 360 * right_progress / max, false, paint);  //根据进度画圆弧
+		
+	}
+
+
+	public synchronized int getMax() {
+		return max;
+	}
+
+	/**
+	 * 设置进度的最大值
+	 * @param max
+	 */
+	public synchronized void setMax(int max) {
+		if(max < 0){
+			throw new IllegalArgumentException("max not less than 0");
+		}
+		this.max = max;
+	}
+
+	/**
+	 * 获取进度.需要同步
+	 * @return
+	 */
+	public synchronized int getLeftProgress() {
+		return left_progress;
+	}
+	public synchronized int getRightProgress() {
+		return right_progress;
+	}
+
+	/**
+	 * 设置进度，此为线程安全控件，由于考虑多线的问题，需要同步
+	 * 刷新界面调用postInvalidate()能在非UI线程刷新
+	 * @param progress
+	 */
+	public synchronized void setLeftProgress(int leftProgress) {
+		if(leftProgress < 0){
+			throw new IllegalArgumentException("progress not less than 0");
+		}
+		if(leftProgress > max){
+			leftProgress = max;
+		}
+		if(leftProgress <= max){
+			this.left_progress = leftProgress;
+			postInvalidate();
+		}
+	}
+	
+	public synchronized void setRightProgress(int rightProgress) {
+		if(rightProgress < 0){
+			throw new IllegalArgumentException("progress not less than 0");
+		}
+		if(rightProgress > max){
+			rightProgress = max;
+		}
+		if(rightProgress <= max){
+			this.right_progress = rightProgress;
+			postInvalidate();
+		}
+	}
+	
+	public synchronized void setLeftAndRightProgress(int leftProgress,int rightProgress) {
+		if(leftProgress <0 || rightProgress < 0){
+			throw new IllegalArgumentException("progress not less than 0");
+		}
+		if(leftProgress > max || rightProgress > max){
+			rightProgress = max;
+		}
+		this.left_progress = leftProgress;
+		this.right_progress = rightProgress;
+		postInvalidate();
+	}
+
+
+	public int getCricleColor() {
+		return roundColor;
+	}
+
+	public void setCricleColor(int cricleColor) {
+		this.roundColor = cricleColor;
+	}
+
+	public int getCricleProgressColor() {
+		return roundProgressColor;
+	}
+
+	public void setCricleProgressColor(int cricleProgressColor) {
+		this.roundProgressColor = cricleProgressColor;
+	}
+
+	public int getTextColor() {
+		return textColor;
+	}
+
+	public void setTextColor(int textColor) {
+		this.textColor = textColor;
+	}
+
+	public float getTextSize() {
+		return textSize;
+	}
+
+	public void setTextSize(float textSize) {
+		this.textSize = textSize;
+	}
+
+	public float getRoundWidth() {
+		return roundWidth;
+	}
+
+	public void setRoundWidth(float roundWidth) {
+		this.roundWidth = roundWidth;
+	}
+
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/face/scanner/view/RoundProgressBar.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/face/scanner/FaceActivity.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/face/scanner/FaceActivity.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/face/scanner/FaceActivity.java	(revision 6857)
@@ -0,0 +1,668 @@
+package com.face.scanner;
+
+import java.util.ArrayList;
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.graphics.Bitmap;
+import android.graphics.Rect;
+import android.hardware.Camera;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Message;
+import android.os.SystemClock;
+import android.provider.Settings;
+import android.util.Log;
+import android.view.View;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.CheckBox;
+import android.widget.LinearLayout;
+import android.widget.Toast;
+import com.sensetime.faceunlock.widget.FaceUnlockCyleView;
+import com.android.keyguard.R;
+import com.android.keyguard.KeyguardUtils;
+import android.widget.TextView;
+import com.sensetime.faceapi.model.FaceInfo;
+import com.sensetime.faceapi.utils.AccelerometerManager;
+import com.sensetime.faceunlock.bean.FaceFeature;
+import com.sensetime.faceunlock.bean.User;
+import com.sensetime.faceunlock.config.AppConfig;
+import com.sensetime.faceunlock.manager.UserManager;
+import com.sensetime.faceunlock.util.BitmapUtil;
+import com.sensetime.faceunlock.util.DirectUtil;
+import com.sensetime.faceunlock.util.FileUtil;
+import com.sensetime.faceunlock.util.FaceUtil;
+import com.sensetime.faceunlock.util.LogUtil;
+import com.sensetime.faceunlock.widget.CameraView;
+import com.sensetime.faceunlock.widget.FaceRegisterView;
+import com.sensetime.faceunlock.widget.MaskView;
+import com.sensetime.faceapi.utils.FaceRotationUtil;
+import com.sensetime.faceunlock.util.ConUtil;
+import com.sensetime.faceunlock.util.SharedUtil;
+import com.sensetime.faceunlock.util.DialogUtil;
+import com.sensetime.faceunlock.util.PdUtils;
+
+//Begin: add by junwei.shen, create password AlertDialog for Face, at 2017.7.12
+import android.app.AlertDialog;
+import android.app.admin.DevicePolicyManager;
+import android.content.DialogInterface;
+import android.content.ComponentName;
+import android.provider.Settings.SettingNotFoundException;
+//End: add by junwei.shen, create password AlertDialog for Face, at 2017.7.12
+import android.telephony.TelephonyManager;
+import android.app.Service;
+import com.megvii.facepp.sdk.Lite;//com.megvii.facepp.sdk
+import com.sensetime.faceapi.utils.ICamera;
+import android.hardware.Camera.CameraInfo;
+import java.util.List;
+import java.util.ArrayList;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.ImageFormat;
+import android.graphics.Matrix;
+import android.graphics.Rect;
+import android.graphics.YuvImage;
+import java.io.ByteArrayOutputStream;
+import java.util.HashMap;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+
+
+//import org.greenrobot.eventbus.EventBus;
+
+
+
+public class FaceActivity extends Activity {
+    private static final String TAG = "FaceActivity";
+    private CameraView mCameraView; //
+    private Thread mTrackThread; //
+    private HandlerThread mGetFeatureThread; //
+    private ArrayList<User> users = new ArrayList<>(); //
+    private String uuid = FileUtil.getUUIDName(); //
+
+    private volatile boolean mIsNv21DataReady; //
+    private volatile boolean mIsTracking; //
+    private boolean isVerifying; //
+    private boolean mIsKilled; //
+    private byte[] mNv21; //
+    private int mCount; //
+    private int mLastFaceId = -1;
+
+    private static final int Face_NEW_REQUEST = 300;
+    private static final int Face_REPLACE_REQUEST = 301;
+    private static final int Face_REMOVE_REQUEST = 302;
+    private static final int Face_DEMO_REMOVE_REQUEST = 303;
+    //Add by junwei.shen, for deal Face entry timeout, at 2017.7.4
+    private static final int Face_ENTRY_TIMEOUT = 304;
+    private static final int FROM_SETTING = 400;
+
+    public static final int MSG_SHOW_HINT1_TV = 0x001;
+    public static final int MSG_SHOW_HINT2_TV = 0x002;
+    public static final int MSG_HIDE_HINT_TV = 0x003;
+    public static final int MSG_UPDATE_PROGRESS = 0x004;
+    public static final int MSG_NOT_SAME_FACE = 0x005;
+    public static final int MSG_DARK_LIGHT = 0x006;
+    public static final int MSG_SHOW_HINT4_TV = 0x007;
+    public static final int MSG_LONGTIME_NO_FACE = 0x008;
+
+    public static final int MAX_NOT_SAME_COUNT = 10;
+    private int mNotSameFaceCount;
+
+    public String HINT_TEXT_1;
+    public String HINT_TEXT_2;
+    public String HINT_TEXT_3;
+    public String HINT_TEXT_4;
+
+    private int mRequestType;
+    private int mFromSource;
+    private boolean isFMode;
+    private User user; //
+    private boolean isNotHacker;
+    private int attemptCount;
+    private boolean mIsBroadcastRegister = false;
+
+    private TextView description_info;
+    private int progress = 0;
+    private boolean isShowErrorInfo = false;
+    private FaceUnlockCyleView CycleView;
+    private MaskView mMaskView;
+    //Begin: add by junwei.shen, create password AlertDialog for Face, at 2017.7.12
+    private String KEY_HAS_PASSWORD = "has_password";
+    private int hasPassword = -1;
+    private Context mContext;
+    private ComponentName mComponentName;
+    private String sharedPackageName = "com.android.settings";
+    private String sharedClassName = "com.android.settings.ChooseLockGeneric";
+    public static final String MINIMUM_QUALITY_KEY = "minimum_quality";
+    public static final String HIDE_DISABLED_PREFS = "hide_disabled_prefs";
+    public static final String EXTRA_KEY_HAS_CHALLENGE = "has_challenge";
+    public static final String EXTRA_KEY_CHALLENGE = "challenge";
+    public static final String EXTRA_KEY_FOR_FINGERPRINT = "for_fingerprint";
+    private static final int CHOOSE_LOCK_GENERIC_REQUEST = 227;
+    //End: add by junwei.shen, create password AlertDialog for Face, at 2017.7.12
+
+    protected Lite lite;
+    protected DialogUtil dialogUtil;
+    protected SharedUtil sharedUtil;
+
+
+    boolean mIsNotGetFaceInfo = true;
+    protected HandlerThread handlerThread = new HandlerThread("detect");
+     protected Handler handler;
+    private boolean isDetect;
+
+    final static int FEATURE_SIZE  = 10000;
+    byte[] savedFeature = new byte[FEATURE_SIZE];
+//  byte[] image = new byte[32968];//非2pd版本的输出数据
+    byte[] image = new byte[40000];//2pd版本的输出数据
+    BroadcastReceiver mBatInfoReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(final Context context, final Intent intent) {
+            Log.d(TAG, "onReceive");
+            String action = intent.getAction();
+
+            TelephonyManager tManager = (TelephonyManager) context.getSystemService(Service.TELEPHONY_SERVICE);
+            if (Intent.ACTION_SCREEN_OFF.equals(action) || tManager.getCallState() == TelephonyManager.CALL_STATE_RINGING) {
+                Log.d(TAG, "screen off");
+                FaceActivity.this.finish();
+            }
+        }
+    };
+    
+    
+
+
+    protected class CachedNV21 {
+        byte[] data;
+        int w;
+        int h;
+        String path;
+        String name;
+    }
+
+
+    protected List<CachedNV21> caches = new ArrayList<>();
+
+    protected synchronized void addSavedNV21(byte[] data, int w, int h, String path, String name) {
+        CachedNV21 cache = new CachedNV21();
+        cache.data = data;
+        cache.w = w;
+        cache.h = h;
+        cache.path = path;
+        cache.name = name;
+        caches.add(cache);
+    }
+    protected synchronized void commitSave() {
+        for (CachedNV21 cache : caches) {
+            ConUtil.saveNV21(this, cache.data, cache.w, cache.h, cache.path, cache.name);
+        }
+        caches.clear();
+    }
+
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        Log.d(TAG, "onCreate start");
+        
+        super.onCreate(savedInstanceState);
+        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
+        requestWindowFeature(Window.FEATURE_NO_TITLE);
+        HINT_TEXT_1 = getString(R.string.ic_default_move_face_center);
+        HINT_TEXT_2 = getString(R.string.ic_default_stay_font);
+        HINT_TEXT_3 = getString(R.string.ic_default_dark_light);
+        HINT_TEXT_4 = getString(R.string.ic_default_no_face_data_info);
+        mRequestType = getIntent().getIntExtra("requestType", 0);
+        mFromSource = getIntent().getIntExtra("source", 0);
+
+        if(mRequestType < Face_NEW_REQUEST || mRequestType > Face_DEMO_REMOVE_REQUEST)
+        {
+            Log.d(TAG, "onCreate:request error");
+            finish();
+        }
+        if (mRequestType == Face_REMOVE_REQUEST) {
+            saveFaceState(false);
+            setResult(RESULT_OK);
+            finish();
+            return;
+        }
+        handlerThread.start();
+        handler = new Handler(handlerThread.getLooper());
+        lite = Lite.getInstance();
+        setContentView(R.layout.activity_register);
+        init();
+        initView();
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
+        registerReceiver(mBatInfoReceiver, filter);
+        mIsBroadcastRegister = true;
+        mContext = FaceActivity.this;
+
+
+        dialogUtil = new DialogUtil(this);
+        sharedUtil = new SharedUtil(this);
+    }
+
+    private void initView() {
+        //lite = Lite.getInstance();
+        mCameraView = (CameraView) findViewById(R.id.camera_view);
+        if (mRequestType == Face_REMOVE_REQUEST) {
+            LinearLayout linearLayout = (LinearLayout) findViewById(R.id.register);
+            linearLayout.setVisibility(View.GONE);
+        } else {
+            description_info = (TextView) findViewById(R.id.face_unlock_scan_bottom_info);
+            mMaskView = (MaskView) findViewById(R.id.mask_view);
+            description_info.setText(R.string.ic_default_sacn_face_description_info);
+            CycleView =  (FaceUnlockCyleView) findViewById(R.id.face_unlock_cycle_view);
+        }
+
+        mCameraView.setPreviewCallback(new Camera.PreviewCallback() {
+
+            @Override
+            public void onPreviewFrame(byte[] data, Camera camera) {
+                if (mNv21 == null || data.length != mNv21.length) {
+                    mNv21 = new byte[data.length];
+                }
+
+                if (!mIsTracking && !isVerifying) {
+                    synchronized (mNv21) {
+                        System.arraycopy(data, 0, mNv21, 0, data.length);
+                        mIsNv21DataReady = true;
+                    }
+                }
+                mCameraView.addCallbackBuffer();
+
+                 if (!isDetect) {
+                    isDetect = true;
+                    handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            SystemClock.sleep(500);
+                            byte[] data = PdUtils.getPdData(camera);
+                            if (data == null) {
+                                Log.i(TAG,"mNv21 =="+mNv21);
+                                handleData(mNv21, mCameraView.mPreviewWidth, mCameraView.mPreviewHeight);
+                            } else {
+                                handleData(data, -1, -1);
+                            }
+                        }
+                });
+            }
+
+            }
+        });
+    }
+
+        private void init() {
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                Log.i(TAG, "init start");
+
+                String livePath1 = "";
+                String livePath2 = "";
+
+                livePath1 = ConUtil.saveRaw(FaceActivity.this, R.raw.panorama_mgba,
+                            "model", "liveness1.dlc");
+
+                File dir = FaceActivity.this.getExternalFilesDir("megvii");
+                if (!dir.exists()) {
+                    dir.mkdirs();
+                }
+                Lite.getInstance().initHandle(dir.getAbsolutePath());
+
+                lite.setConfig(-8, 8, -13, 13, true);
+
+                byte[] faceppContent = ConUtil.getFileContent(getBaseContext(), R.raw
+                        .megviifacepp_modela);
+                final long result = Lite.getInstance().initAll(livePath1, livePath2, faceppContent);
+
+                Lite.getInstance().prepare();
+                int ret = Lite.getInstance().restoreFeature();
+                Lite.getInstance().reset();
+                Log.d(TAG, "run: restoreFeature " + ret);
+            }
+        });
+    }
+
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        Log.d(TAG,"lite="+lite);
+        handler.post(new Runnable(){
+           public void run(){
+               lite.prepare();
+               lite.setDetectArea(4, 6, 480, 640);
+           }
+        });
+        try {
+            hasPassword = Settings.System.getInt(getContentResolver(), KEY_HAS_PASSWORD);
+
+        } catch (SettingNotFoundException e) {
+            e.printStackTrace();
+        }
+        try {
+            mComponentName = new ComponentName(sharedPackageName, sharedClassName);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        AlertDialog createNewPwdDialog = null;
+        if (hasPassword == 0) {
+            createNewPwdDialog = new AlertDialog.Builder(mContext)
+                    .setTitle(R.string.add_fingerprint_message_secturity)
+                    .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            dialog.dismiss();
+                            Intent intent = new Intent();
+                            intent.setComponent(mComponentName);
+                            intent.putExtra(MINIMUM_QUALITY_KEY,
+                                    DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
+                            intent.putExtra(HIDE_DISABLED_PREFS, true);
+                            intent.putExtra(EXTRA_KEY_HAS_CHALLENGE, true);
+                            intent.putExtra(EXTRA_KEY_CHALLENGE, 0);
+                            intent.putExtra(EXTRA_KEY_FOR_FINGERPRINT, false);
+                            startActivityForResult(intent, CHOOSE_LOCK_GENERIC_REQUEST);
+                        }
+                    })
+                    .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            dialog.dismiss();
+                        }
+                    })
+                    .setCancelable(false)
+                    .create();
+            createNewPwdDialog.show();
+        } else if (createNewPwdDialog != null) {
+
+        }
+
+        AccelerometerManager.start(this);
+        mIsKilled = false;
+        mCameraView.restartCamera();
+        mTrackThread = new Thread() {
+            @Override
+            public void run() {
+            }
+        };
+        mTrackThread.start();
+    }
+    public void saveFaceState(boolean enabled){
+        Settings.System.putStringForUser(getContentResolver(),Settings.System.FACE_STATE_ENABLED,enabled?"1":"0", 0);  /* ZXP*/
+    }
+
+    @Override
+    protected void onPause() {
+        AccelerometerManager.stop();
+        mCameraView.releaseCamera();
+        stopThread();
+        super.onPause();
+        if (mRequestType == Face_NEW_REQUEST && mFromSource == FROM_SETTING) {
+            finish();
+        }
+    }
+
+    private void stopThread() {
+        mIsKilled = true;
+        if (mTrackThread != null) {
+            try {
+                mTrackThread.interrupt();
+                mTrackThread.join();
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    /*added by iuv luyang*/
+    @Override
+    public void onBackPressed() {
+        new AlertDialog.Builder(mContext)
+                .setTitle(R.string.cancel_face_entering)
+                .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialogInterface, int i) {
+                        dialogInterface.dismiss();
+                        finish();
+                    }
+                })
+                .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialogInterface, int i) {
+                        dialogInterface.dismiss();
+                    }
+                })
+                .create()
+                .show();
+        //End: add by junwei.shen, create backPressed AlertDialog for Face, at 2017.7.12
+    }
+    /*end by iuv luyang*/
+
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        if (mIsBroadcastRegister) {
+            unregisterReceiver(mBatInfoReceiver);
+            mIsBroadcastRegister = false;
+        }
+    }
+
+    public Bitmap getBitMap(byte[] data, Rect roi, int angle, boolean isBackCamera) {
+        YuvImage yuvImage = new YuvImage(data, ImageFormat.NV21, 480, 640, null);
+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+        yuvImage.compressToJpeg(new Rect(0, 0, 480, 640), 80,
+                byteArrayOutputStream);
+        byte[] jpegData = byteArrayOutputStream.toByteArray();
+        // 获取照相后的bitmap
+        Bitmap tmpBitmap = BitmapFactory.decodeByteArray(jpegData, 0,
+                jpegData.length);
+        Matrix matrix = new Matrix();
+        matrix.reset();
+        matrix.preRotate(angle);
+        if (!isBackCamera) {
+            matrix.preScale(-1.0f, 1.0f);
+        }
+        Log.d(TAG,"roi.left="+roi.left+"roi.top="+roi.top+"roi.width()="+roi.width()+"roi.height()="+roi.height()+"tmpBitmap.WIDTH="+tmpBitmap.getWidth());// x + width must be <= bitmap.width()
+        tmpBitmap = Bitmap.createBitmap(tmpBitmap, roi.left, roi.top, roi.width(),//roi.left=0 roi.top=0 roi.width()=640 roi.height()=480
+                roi.height(), matrix, true);
+        tmpBitmap = tmpBitmap.copy(Bitmap.Config.ARGB_8888, true);
+        return tmpBitmap;
+    }
+
+    private void handleData(byte[] pdData, int width, int height) {
+        int ret = 0;
+        int[] id = new int[1];
+        
+        ret = Lite.getInstance().saveFeature(pdData, width, height, mCameraView.Angle, true, savedFeature,image);
+        
+        Log.i(TAG,"ret=" + ret);
+        if (ret == Lite.MG_UNLOCK_OK) {
+            addSavedNV21(pdData, width, height, "camera", "savedYUV");
+            commitSave();
+            Log.i(TAG,"ret1=" + ret);
+            sharedUtil.saveBooleanValue("featureSaved", true);
+            byte[] yuvData = pdData;
+            if (width == -1 && height ==-1) {
+                yuvData = new byte[PdUtils.PREVIEW_DATA_LENGTH];
+                for (int i = 0; i < PdUtils.MIXED_DATA_LENGTH; i++) {
+                    if (i >= PdUtils.PD_RAWDATA_LENGTH) {
+                        yuvData[i - PdUtils.PD_RAWDATA_LENGTH] = pdData[i];
+                    }
+                }
+            }
+            Toast.makeText(FaceActivity.this.getApplicationContext(), R.string.txt_camera_success, Toast.LENGTH_SHORT).show();
+            Log.d(TAG,"mCameraView.Angle="+mCameraView.Angle);
+            
+            
+                 //Bitmap bitmap = abstractCameraUtil.getBitMap(yuvData, new Rect(0, 0, 640,480), angle, isBackCamera);
+            Bitmap bitmap = getBitMap(yuvData, new Rect(0, 0, 480,640), mCameraView.Angle, false);
+            String fileName = "face_" + id[0];
+            String path = ConUtil.saveBitmap(FaceActivity.this, bitmap,
+                    "faces", fileName);
+            //EventBus.getDefault().post(new FeatureUpdateEvent(bitmap, fileName));
+            sharedUtil.saveStringValue("image", path);
+            Log.d(TAG,"fileName="+fileName);
+            saveFaceState(true);
+            isDetect = true;
+
+            final int finalString = R.string.txt_camera_success;
+            runOnUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    mMaskView.setProgress(100);
+                }
+            });
+            finish();
+        } else {
+            if (ret == Lite.MG_UNLOCK_LIVENESS_FAILURE) {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        //abstractCameraUtil.closeCamera();
+                        dialogUtil.showDialog(R.string.unlock_failed_liveness, true);
+                        
+                    }
+                });
+                isDetect = false;
+            
+                return;
+            }
+            int string = 0;
+            switch (ret) {
+                case Lite.MG_UNLOCK_LIVENESS_WARNING:
+                    string = R.string.unlock_failed_warning;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_OFFSET_BOTTOM:
+                    string = R.string.unlock_failed_offset_bottom;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_OFFSET_LEFT:
+                    string = R.string.unlock_failed_offset_left;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_OFFSET_RIGHT:
+                    string = R.string.unlock_failed_offset_right;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_OFFSET_TOP:
+                    string = R.string.unlock_failed_offset_top;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_QUALITY:
+                    string = R.string.unlock_failed_quality;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_SCALE_TOO_LARGE:
+                    string = R.string.unlock_failed_face_large;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_SCALE_TOO_SMALL:
+                    string = R.string.unlock_failed_face_small;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FAILED:
+                    string = R.string.unlock_failed;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_NOT_FOUND:
+                    string = R.string.unlock_failed_face_not_found;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_BAD_LIGHT:
+                    string = R.string.bad_light;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_ROTATED_LEFT:
+                    string = R.string.txt_camera_success_left;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_ROTATED_RIGHT:
+                    string = R.string.txt_camera_success_right;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_DOWN:
+                    string = R.string.txt_camera_success_down;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_RISE:
+                    string = R.string.txt_camera_success_top;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_KEEP:
+                    string = R.string.unlock_camera_steady;
+                    progress = 30+progress;
+                    break;
+                case Lite.MG_ATTR_BLUR:
+                    string = R.string.attr_blur;
+                    progress = 0;
+                    break;
+                case Lite.MG_ATTR_EYE_OCCLUSION:
+                    string = R.string.attr_eye_occlusion;
+                    progress = 0;
+                    break;
+                case Lite.MG_ATTR_EYE_CLOSE:
+                    string = R.string.attr_eye_close;
+                    progress = 0;
+                    break;
+                case Lite.MG_ATTR_MOUTH_OCCLUSION:
+                    string = R.string.attr_mouth_occlusion;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_INVALID_ARGUMENT:
+                    string = R.string.unlock_failed_argument;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_BLUR:
+                    string = R.string.unlock_failed_face_blur;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_MULTI:
+                    string = R.string.unlock_failed_face_multi;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_FACE_NOT_COMPLETE:
+                    string = R.string.unlock_failed_face_not_complete;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_DARKLIGHT:
+                    string = R.string.attr_light_dark;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_HIGHLIGHT:
+                    string = R.string.attr_light_high;
+                    progress = 0;
+                    break;
+                case Lite.MG_UNLOCK_HALF_SHADOW:
+                    string = R.string.attr_light_shadow;
+                    progress = 0;
+                    break;
+                default:
+                    string = R.string.unlock_camera_steady;
+                    break;
+
+            }
+            final int finalString = string;
+            runOnUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    description_info.setText(finalString);
+                    mMaskView.setProgress(progress);
+                }
+            });
+            Log.d(TAG, "saveFeature:" + ret);
+            isDetect = false;
+        }
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/face/scanner/FaceActivity.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/face/scanner/LiteService.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/face/scanner/LiteService.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/face/scanner/LiteService.java	(revision 6857)
@@ -0,0 +1,45 @@
+package com.face.scanner;
+
+import android.os.Handler;
+
+/**
+ * Created by wangshuai on 2018/1/24.
+ */
+
+public interface LiteService {
+
+    int ERROR_NO_ERROR = 0;
+    int ERROR_NOT_INIT = 1;
+    int ERROR_OTHERS = 1000;
+
+    enum Status{
+        idle,
+        initializing,
+        initialized
+    }
+	
+    Handler initAll();
+
+    interface StatusObserver{
+        void onStatusChanged(Status status);
+    }
+
+    void setStatusObserver(StatusObserver statusObserver);
+    interface UnLockCallBack {
+        void onUnlockFinish(boolean success, int errorCode);
+    }
+
+    interface SaveCallBack {
+        void onSaveFinish(boolean success, int errorCode);
+    }
+
+    void pepareSave(SaveCallBack saveCallBack);
+    void save(byte[] imageData, int width, int height, int angle, boolean useLive, byte[] savedFeature, byte[] img, int[] outFeatureId);
+    void resetSave();
+
+    void pepareCompare(UnLockCallBack unlockCallBack);
+    void compare(byte[] imageData, int width, int height, int angle, boolean useLive, boolean strictMode, int[] report);
+    void resetCompare();
+
+    void release();
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/face/scanner/LiteService.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/face/scanner/FaceService.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/face/scanner/FaceService.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/face/scanner/FaceService.java	(revision 6857)
@@ -0,0 +1,391 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.face.scanner;
+
+import android.R.integer;
+import android.app.AlertDialog;
+import android.app.Service;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Debug;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.Looper;
+import android.os.Process;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.RemoteException;
+import android.os.Vibrator;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.WindowManager;
+import android.view.SurfaceHolder;
+import android.view.Window;
+import android.view.WindowManagerGlobal;
+import android.view.IWindowManager;
+import android.view.IApplicationToken;
+import android.graphics.PixelFormat;
+import android.graphics.Color;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+
+import java.io.File;
+import android.content.res.Configuration;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.ComponentName;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.Editor;
+import android.content.ServiceConnection;
+import android.preference.PreferenceManager;
+import android.hardware.Camera;
+import android.media.MediaPlayer;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+import android.widget.Toast;
+import android.provider.Settings;
+import java.util.List;
+import java.util.ArrayList;
+
+import com.face.scanner.view.CameraSurfaceView;
+
+
+import com.face.scanner.view.RoundProgressBar;
+
+import com.android.internal.policy.IFaceService;
+import com.android.internal.policy.IFaceStateCallback;
+import com.android.internal.policy.IKeyguardService;
+import com.sensetime.faceapi.FaceLibrary;
+import com.sensetime.faceapi.model.CvPixelFormat;
+import com.sensetime.faceapi.model.FaceInfo;
+import com.sensetime.faceapi.utils.AccelerometerManager;
+import com.sensetime.faceunlock.bean.FaceFeature;
+import com.sensetime.faceunlock.bean.User;
+import com.sensetime.faceunlock.config.AppConfig;
+import com.sensetime.faceunlock.manager.DetectProxy;
+import com.sensetime.faceunlock.manager.HackerProxy;
+import com.sensetime.faceunlock.manager.VerifyProxy;
+import com.sensetime.faceunlock.util.BrightnessHelper;
+import com.sensetime.faceunlock.util.LogUtil;
+import com.sensetime.faceunlock.widget.CameraView;
+import com.sensetime.faceunlock.util.ConUtil;
+
+import android.widget.RelativeLayout;
+import com.android.keyguard.R;
+import com.android.internal.policy.IFaceOverTimeCallback;
+import com.android.keyguard.KeyguardUpdateMonitor;
+import android.content.SharedPreferences;
+import com.face.scanner.LiteService.UnLockCallBack;
+
+import com.megvii.facepp.sdk.Lite;
+
+public class FaceService extends Service {
+	
+    static final String TAG = "FaceService";
+	
+	//the main thread handler
+	private Handler mHandler;
+	
+	//view to catch camera data
+    private WindowManager mWindowManager;
+    private WindowManager.LayoutParams mLayoutParams;
+    private LayoutInflater mLayoutInflater;
+    private View mFaceView;
+    private CameraView cameraView;
+	
+	//key guard service
+    public static final String KEYGUARD_PACKAGE = "com.android.systemui";
+    public static final String KEYGUARD_CLASS = "com.android.systemui.keyguard.KeyguardService";
+    private volatile IKeyguardService mKeyguardService;
+	
+	//face unlock call back
+    private IFaceStateCallback mCallback;
+    private IFaceOverTimeCallback mFaceOverTimeCallback;
+	
+	//unlock api parameters.
+	private int mResult;
+	private int[] mReport = new int[20];
+	
+	private LiteManager mLiteManager;
+	
+	//Is unlocking or not, this is the important flag that indicate whether it is unlocking or not.
+	private boolean mIsUncloking = false;
+	
+	private UnLockCallBack mUnlockCallBack;
+	private class DefaultUnLockCallBack implements UnLockCallBack{
+	  public void onUnlockFinish(boolean success, int errorCode){
+		if (mUnlockCallBack == this && success){
+			handleUnlockResultSuccess();
+		}
+	  }
+	}
+	
+    @Override
+    public void onCreate() {
+        super.onCreate();
+		// 初始化Lite参数
+		mLiteManager = LiteManager.getInstance(this);
+		mHandler = mLiteManager.initAll();
+		mHandler.post(new Runnable(){
+			public void run(){
+				doCreate();
+			}
+		});
+    }
+	
+	private void doCreate(){
+		mWindowManager = (WindowManager) getApplicationContext()
+                .getSystemService(Context.WINDOW_SERVICE);
+        mLayoutInflater = LayoutInflater.from(this);
+        createView();
+		cameraView = (CameraView) mFaceView.findViewById(R.id.camera_view);
+        cameraView.setVisibility(View.INVISIBLE);// 
+        cameraView.setPreviewCallback(new Camera.PreviewCallback() {
+            @Override
+            public void onPreviewFrame(byte[] data, Camera camera) {
+				if(!mIsUncloking){
+					return;
+				}
+				cameraView.addCallbackBuffer();
+                Log.d(TAG, "onPreviewFrame");
+				handleData(data, cameraView.mPreviewWidth, cameraView.mPreviewHeight);
+            }
+        });
+		//cameraView.addCallbackBuffer();
+		Log.d(TAG, "FaceService:onCreate end...");
+		bindKeyguardService();
+	}
+	
+    @Override
+    public void onStart(Intent intent, int startId) {
+        // TODO Auto-generated method stub
+        Log.d(TAG, "FaceService:onStart()");
+        super.onStart(intent, startId);
+    }
+	
+    private void bindKeyguardService(){
+        Intent bindKeyguardIntent = new Intent();
+        bindKeyguardIntent.setClassName(KEYGUARD_PACKAGE, KEYGUARD_CLASS);
+        if (bindService(bindKeyguardIntent, mKeyguardConn,
+                Context.BIND_AUTO_CREATE)) {
+            Log.d(TAG, "---bindKeyguardService sucess---");
+        } else {
+            Log.d(TAG, "---bindKeyguardService failed---");
+        }
+    }
+	
+    private ServiceConnection mKeyguardConn = new ServiceConnection() {
+        @Override
+        public void onServiceConnected(ComponentName name, IBinder service) {
+            Log.v(TAG, "*** Keyguard connected (yay!)");
+			
+            mKeyguardService = IKeyguardService.Stub.asInterface(service);
+
+        }
+        @Override
+        public void onServiceDisconnected(ComponentName name) {
+            Log.v(TAG, "*** Keyguard disconnected (boo!)");
+            mKeyguardService = null;
+        }
+    };
+
+    private void createView() {
+        mFaceView = mLayoutInflater.inflate(R.layout.face_service_view, null);
+        mLayoutParams = new WindowManager.LayoutParams();
+        mLayoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
+        mLayoutParams.height = WindowManager.LayoutParams.WRAP_CONTENT;
+        mLayoutParams.gravity = Gravity.TOP;
+        mLayoutParams.type = WindowManager.LayoutParams.TYPE_PHONE;
+        mLayoutParams.format = PixelFormat.RGBA_8888;
+        mLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
+    }
+
+	
+    private void handleData(byte[] pdData, int width, int height) {
+		//Lite.getInstance().prepare();
+		mLiteManager.compare(pdData
+                , width
+                , height
+                , cameraView.Angle
+                , true
+                , false, mReport);
+    }
+	
+	private void handleUnlockResultSuccess(){	
+		try {
+			unlock();
+			cameraView.stopPreview();
+			stopIdentify();
+			sendIdentifyResultCallback(true);
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+	}
+	
+	private void handleUnlockResultFail(){
+		Log.i(TAG, "startIdentify end..");		
+		try {
+			cameraView.stopPreview();
+			stopIdentify();
+			sendIdentifyResultCallback(false);
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+	}
+	
+    private void unlock() {
+        try {
+			IKeyguardService keyGuardService = mKeyguardService;
+            if (keyGuardService != null) {
+                keyGuardService.keyguardDone(false,true);
+				Log.d(TAG, "---unlock sucess------");
+            }
+        } catch (Exception e) {
+            Log.d(TAG, "---unlock failed---");
+        }
+    }
+	
+    @Override
+    public IBinder onBind(Intent intent) {
+		Log.d(TAG, "onBind intent " + intent);
+        return mBinder;
+    }
+	
+    @Override
+    public boolean onUnbind(Intent intent) {
+		Log.d(TAG, "onUnbind " + intent);
+       return super.onUnbind(intent);
+    }
+	
+    private Runnable mKillSelfRunnable = new Runnable() {
+        @Override
+        public void run() {
+			Log.d(TAG,"overtime call back");
+			stopIdentify();
+            sendFaceOverTimeCallback();
+        }
+    };
+	
+    public void startIdentify() {
+		if (mIsUncloking) {
+			return;
+		}
+		mIsUncloking = true;
+		// 1.初始化
+		mUnlockCallBack = new DefaultUnLockCallBack();
+		mLiteManager.pepareCompare(mUnlockCallBack);
+		AccelerometerManager.start(this);
+		mHandler.removeCallbacks(mKillSelfRunnable);
+        mHandler.postDelayed(mKillSelfRunnable, 1000*5);
+		cameraView.restartCamera();
+    }
+	
+    public void stopIdentify() {
+		Log.d(TAG, "$$$$ stopIdentify $$$$ mIsUncloking " + mIsUncloking);
+		if (!mIsUncloking) {
+			return;
+		}
+		mIsUncloking = false;
+        mHandler.removeCallbacks(mKillSelfRunnable);
+        AccelerometerManager.stop();
+		cameraView.releaseCamera();
+		mLiteManager.resetCompare();
+		mUnlockCallBack = null;
+    }
+	
+    private final IFaceService.Stub mBinder = new IFaceService.Stub() {
+
+        @Override
+        // Binder interface
+        public void setStateCallback(final IFaceStateCallback callback) {
+			mHandler.post(new Runnable(){
+				public void run(){
+					mCallback = callback;
+				}
+			});
+        }
+		
+		@Override
+        // Binder interface
+        public void faceOverTimeCallback(final IFaceOverTimeCallback callback) {
+			Log.d(TAG,"faceOverTimeCallback is " + callback);
+			mHandler.post(new Runnable(){
+				public void run(){
+					mFaceOverTimeCallback = callback;
+				}
+			});
+        }
+
+        @Override
+        // Binder interface
+        public void startFaceIdentify() {
+			mHandler.post(new Runnable(){
+				public void run(){
+					startIdentify();
+				}
+			});
+        }
+		
+        @Override
+        // Binder interface
+        public void stopFaceIdentify() {
+			mHandler.post(new Runnable(){
+				public void run(){
+					stopIdentify();
+				}
+			});
+        }
+    };
+	
+	public void sendIdentifyResultCallback(boolean success){
+		try {
+			if (mCallback!= null){
+				mCallback.onIdentifyResult(success);
+			}
+		} catch(Exception e){
+			Log.e(TAG, "error when send onIdentifyResult", e);
+		}
+	}
+	
+    public void sendFaceOverTimeCallback(){
+		try {
+			if (mFaceOverTimeCallback!= null){
+				mFaceOverTimeCallback.faceOverTime();
+			}
+		} catch(Exception e){
+			Log.e(TAG, "error when send faceOverTime", e);
+		}
+    }
+	
+	@Override
+    public void onDestroy() {
+        Log.e(TAG, "Fatal error because service is stopped! $$$$ onDestroy $$$$ ");
+		mHandler.post(new Runnable(){
+			public void run(){
+				stopIdentify();
+			}
+		});
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/face/scanner/FaceService.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/face/scanner/BootCompleteReceiver.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/face/scanner/BootCompleteReceiver.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/face/scanner/BootCompleteReceiver.java	(revision 6857)
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.face.scanner;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.util.Log;
+import android.os.RemoteException;
+import android.app.ActivityManagerNative;
+import android.provider.Settings;
+import android.os.UserManager;
+import android.content.pm.UserInfo;
+import com.android.keyguard.R;
+import java.util.List;
+
+/**
+ * A proxy for Recents events which happens strictly for non-owner users.
+ */
+public class BootCompleteReceiver extends BroadcastReceiver {
+    private static final String TAG = "BootCompleteReceiver";
+
+	@Override  
+	public void onReceive(final Context context, final Intent intent) {  
+		Log.d(TAG, "onReceive");  
+		String action = intent.getAction();  
+	   
+		if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {	
+			Log.d(TAG, "boot completed");
+			/*String state = Settings.System.getStringForUser(context.getContentResolver(),Settings.System.PRIVACY_SPACE_ENABLED, 0);zxp*/
+			String state ="0";
+            if (state == null) {
+                state = "0";
+            }
+			if(state.equals("1")) { 	
+				initPrivacySpace(context);
+			}
+		}
+	}  
+
+    private void initPrivacySpace(final Context context) {
+        /*String state = Settings.System.getStringForUser(context.getContentResolver(),Settings.System.PRIVACY_SPACE_STATE, 0);zxp*/
+		String state ="0";
+        try{
+            if(state.equals("0")) {		
+                UserManager um= (UserManager) context.getSystemService(Context.USER_SERVICE);		
+                UserInfo user = um.createUser(context.getString(R.string.privacy_data),UserInfo.FLAG_ADMIN);
+                /*Settings.System.putStringForUser(context.getContentResolver(),Settings.System.PRIVACY_USER_ID,""+user.id, 0);zxp*/
+                ActivityManagerNative.getDefault().startUserInBackground(user.id);
+                //user = um.createUser("clone",UserInfo.FLAG_ADMIN);
+                //Settings.System.putStringForUser(getContentResolver(),Settings.System.CLONE_USER_ID,""+user.id, 0);
+                //ActivityManagerNative.getDefault().startUserInBackground(user.id);
+                /*Settings.System.putStringForUser(context.getContentResolver(),Settings.System.PRIVACY_SPACE_STATE,"1", 0);zxp*/
+            } else {
+                String userID="0";
+    			/*userID = Settings.System.getStringForUser(context.getContentResolver(),Settings.System.PRIVACY_USER_ID, 0);zxp*/
+    			int id = Integer.parseInt(userID);
+    		    ActivityManagerNative.getDefault().startUserInBackground(id);
+    			//userID = Settings.System.getStringForUser(getContentResolver(),Settings.System.CLONE_USER_ID, 0);
+    			//int id = Integer.parseInt(userID);	
+    		    //ActivityManagerNative.getDefault().startUserInBackground(id);
+            } 
+        }catch(Exception re) {
+            Log.e(TAG, "Couldn't switch user " + re);
+        }
+
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/face/scanner/BootCompleteReceiver.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/face/scanner/FaceUnlocker.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/face/scanner/FaceUnlocker.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/face/scanner/FaceUnlocker.java	(revision 6857)
@@ -0,0 +1,216 @@
+package com.megvii.landmarklib.FaceUnlockHelper;
+
+import android.hardware.Camera;
+import android.os.Handler;
+import android.os.Looper;
+
+import com.megvii.facepp.sdk.Lite;
+
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import com.sensetime.faceunlock.util.PdUtils;
+
+/**
+ * 简单的解锁类，维护一个单线程模型，并且支持解锁超时。
+ * 每次解锁的过程：
+ * 1.创建解锁对象
+ * FaceUnlocker faceUnlocker;
+ * 2.启动解锁过程
+ * start
+ * 3.开始解锁尝试
+ * onPreviewFrame
+ * 4.停止解锁
+ * stop
+ * <p>
+ * 5.faceUnlocker = null 销毁解锁对象
+ */
+public class FaceUnlocker {
+
+    private static Executor mExecutor = Executors.newSingleThreadExecutor();
+
+    private Params mParams;
+
+    private int[] mReport = new int[20];
+
+    private UnLockCallBack mUnlockCallBack;
+
+    private static Timer mTimer = new Timer();
+
+    private int mResult;
+
+    private TimeoutTimerTask mTimeoutTimerTask;
+
+    private boolean mStopped = false;
+
+    private Handler mMainHandler = new Handler(Looper.getMainLooper());
+
+    private class TimeoutTimerTask extends TimerTask {
+        @Override
+        public void run() {
+            mExecutor.execute(new Runnable() {
+                @Override
+                public void run() {
+                    boolean success = stopUnlocking();
+                    if (success) {
+                        final UnLockCallBack unLockCallBack = mUnlockCallBack;
+                        mMainHandler.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (unLockCallBack != null) {
+                                    unLockCallBack.onTimeout();
+                                }
+                            }
+                        });
+                    }
+                }
+            });
+        }
+    }
+
+    public static class Params {
+
+        int width = 640;
+
+        int height = 480;
+
+        int angle = 0;
+
+        boolean strictMode = false;
+    }
+
+    public int getResult() {
+        return mResult;
+    }
+
+    public int[] getReport() {
+        return mReport;
+    }
+
+    public FaceUnlocker(Params params) {
+
+        mParams = params;
+    }
+
+    public interface UnLockCallBack {
+
+        void onSuccess();
+
+        void onStop();
+
+        void onTimeout();
+    }
+
+    /**
+     * 开始
+     */
+    public synchronized void start(final UnLockCallBack unClockCallBack
+            , long timeTout) {
+        if (mStopped) {
+            return;
+        }
+        mExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                if (mStopped) {
+                    return;
+                }
+                mUnlockCallBack = unClockCallBack;
+                Lite.getInstance().prepare();
+            }
+        });
+        if (mTimeoutTimerTask == null) {
+            mTimeoutTimerTask = new TimeoutTimerTask();
+        }
+        mTimer.schedule(mTimeoutTimerTask, timeTout);
+    }
+
+    /**
+     * 停止
+     */
+    public synchronized void stop() {
+        if (!mStopped) {
+            mStopped = true;
+            final UnLockCallBack unLockCallBack = mUnlockCallBack;
+            mExecutor.execute(new Runnable() {
+                @Override
+                public void run() {
+                    boolean success = stopUnlocking();
+                    if (success) {
+                        mMainHandler.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (unLockCallBack != null) {
+                                    unLockCallBack.onStop();
+                                }
+                            }
+                        });
+                    }
+                }
+            });
+        }
+    }
+
+
+    private boolean stopUnlocking() {
+        if (mStopped) {
+            return false;
+        }
+        mStopped = true;
+        Lite.getInstance().reset();
+        mTimeoutTimerTask.cancel();
+        mTimeoutTimerTask = null;
+        mReport = null;
+        mResult = 0;
+        return true;
+    }
+
+    /**
+     * 尝试进行解锁
+     *
+     * @param bytes
+     * @param camera
+     */
+    public synchronized void onPreviewFrame(final byte[] bytes
+            , final Camera camera) {
+        if (mStopped) {
+            return;
+        }
+        mExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                if (mStopped) {
+                    return;
+                }
+                byte[] data = PdUtils.getPdData(camera);
+                if (data == null) {
+                    handleData(bytes, mParams.width, mParams.height);
+                } else {
+                    handleData(data, -1, -1);
+                }
+            }
+        });
+    }
+
+    private void handleData(byte[] pdData, int width, int height) {
+        mResult = Lite.getInstance().compare(pdData
+                , width
+                , height
+                , mParams.angle
+                , true
+                , mParams.strictMode, mReport);
+        if (mResult == Lite.MG_UNLOCK_OK) {
+            final UnLockCallBack unLockCallBack = mUnlockCallBack;
+            mMainHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    if (unLockCallBack != null) {
+                        unLockCallBack.onSuccess();
+                    }
+                }
+            });
+            stopUnlocking();
+        }
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/face/scanner/FaceUnlocker.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/face/scanner/FaceViewCloseNotifiy.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/face/scanner/FaceViewCloseNotifiy.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/face/scanner/FaceViewCloseNotifiy.java	(revision 6857)
@@ -0,0 +1,51 @@
+package com.face.scanner;
+
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import com.android.keyguard.R;
+import android.graphics.BitmapFactory;
+
+public class FaceViewCloseNotifiy {
+	private static final int NOTIFICATION_FLAG = 1;  
+	Context mContext = null;;
+	NotificationManager mNotificationManager = null;
+	PendingIntent pendingIntent  = null;
+	Intent mIntent = null;
+	long[] vibs={800,800,800,800};
+	Uri uri = null;
+	public FaceViewCloseNotifiy(Context context) {
+		super();
+		// TODO Auto-generated constructor stub
+		this.mContext=context;
+		mNotificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+		mIntent = new Intent();
+		mIntent.setClassName("com.android.settings", "com.android.settings.face.FaceSettingMainActivity");
+		mIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 
+		pendingIntent = PendingIntent.getActivity(context, 0,  
+				mIntent, 0);
+		uri=Uri.parse("/system/media/audio/notifications/pixiedust.ogg");
+	}
+    public void showNotify() 
+    {
+    	Notification notify = new Notification.Builder(mContext)
+ //       .setTicker("Ticker")
+       // .setSmallIcon(R.drawable.face_notify)
+		/*  .setLargeIcon(BitmapFactory.decodeResource(
+                        mContext.getResources(), R.drawable.face_big_notify))*/
+ //       .setVibrate(vibs)
+          .setContentTitle(mContext.getString(R.string.face_notify_view_title))
+          .setContentText(mContext.getString(R.string.face_notify_view_text))
+          .setContentIntent(pendingIntent)
+          .setAutoCancel(true)
+//        .setDefaults(NotificationCompat.DEFAULT_LIGHTS)
+          .setNumber(1)
+          .setSound(uri)
+          .build();
+    	mNotificationManager.notify(NOTIFICATION_FLAG, notify); 
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/face/scanner/FaceViewCloseNotifiy.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/android/systemui/SystemUIApplication.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/android/systemui/SystemUIApplication.java	(revision 6856)
+++ frameworks/base/packages/SystemUI/src/com/android/systemui/SystemUIApplication.java	(revision 6857)
@@ -109,7 +109,8 @@
                     }
                 }
             }, filter);
-		    checkLicense();
+			
+		   // checkLicense();
             //DetectProxy.init();
             //VerifyProxy.init(this);
             /*new Thread(new Runnable() {
@@ -127,6 +128,7 @@
             // start those components now for the current non-system user.
             startServicesIfNeeded(SERVICES_PER_USER);
         }
+		startFaceService();
     }
 	
     private boolean checkLicense() {
@@ -227,4 +229,11 @@
     public SystemUI[] getServices() {
         return mServices;
     }
+	
+   private void startFaceService() {
+        Intent intent = new Intent();
+        intent.setClassName("com.android.systemui", "com.face.scanner.FaceService");
+        Log.d(TAG, "--start FaceService-");
+        this.startService(intent);
+    }
 }
Index: frameworks/base/packages/SystemUI/src/com/android/systemui/face/FaceCheckActivity.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/android/systemui/face/FaceCheckActivity.java	(revision 6856)
+++ frameworks/base/packages/SystemUI/src/com/android/systemui/face/FaceCheckActivity.java	(revision 6857)
@@ -53,14 +53,7 @@
 
 		setWindowFlag(); 
 		Intent intent = getIntent();
-		mForMmsPrivacyMode = intent.getBooleanExtra("forMmsPrivacyMode", false);
-		/*
-        Intent intentCloseEncrypt = new Intent();
-		intentCloseEncrypt.setClassName("com.android.systemui", "com.Faceking.scanner.PrivacySpaceActivity");
-		intentCloseEncrypt.putExtra("privacyState", 6);
-		intentCloseEncrypt.putExtra("fromNotification", true);
-		*/
-		
+		mForMmsPrivacyMode = intent.getBooleanExtra("forMmsPrivacyMode", false);		
 		/**IUV:add-start for ��������ʶ�� by yunlong.shen on 2017/07/21 */
 		switchToFace();	
 		/**IUV:add-end*/
Index: frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/LockIcon.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/LockIcon.java	(revision 6856)
+++ frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/LockIcon.java	(revision 6857)
@@ -168,11 +168,6 @@
                     R.dimen.keyguard_affordance_customize_icon_height);
 				iconWidth = getResources().getDimensionPixelSize(
                     R.dimen.keyguard_affordance_customize_icon_width);
-			} else if(anyFingerprintIcon){
-				iconHeight = getResources().getDimensionPixelSize(
-                    R.dimen.keyguard_affordance_fingerprint_icon_height);
-				iconWidth = getResources().getDimensionPixelSize(
-                    R.dimen.keyguard_affordance_fingerprint_icon_width);
 			} else {
 				iconHeight = getResources().getDimensionPixelSize(
                     R.dimen.keyguard_affordance_icon_height);
@@ -182,7 +177,7 @@
 			// add end }
 			
 			
-            if (/*!anyFingerprintIcon && */(icon.getIntrinsicHeight() != iconHeight
+            if (!anyFingerprintIcon && (icon.getIntrinsicHeight() != iconHeight
                     || icon.getIntrinsicWidth() != iconWidth)) {
                 icon = new IntrinsicSizeDrawable(icon, iconWidth, iconHeight);
             }
Index: frameworks/base/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java	(revision 6856)
+++ frameworks/base/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java	(revision 6857)
@@ -687,7 +687,6 @@
                 Log.d(TAG, "keyguard gone, mKeyguardDisplayManager is null");
             }
             mVoiceWakeupManager.notifyKeyguardIsGone();
-            mUpdateMonitor.setFaceAuthLockscreenOngoing(false);
             Trace.endSection();
         }
 
@@ -732,7 +731,6 @@
             int currentUser = ActivityManager.getCurrentUser();
             boolean trust = mTrustManager.isTrustUsuallyManaged(currentUser);
             boolean fingerprint = mUpdateMonitor.isUnlockWithFingerprintPossible(currentUser);
-            boolean faceAuthLockscreenOngoing = mUpdateMonitor.isFaceAuthLockscreenOngoing();
             boolean any = trust || fingerprint;
             KeyguardUpdateMonitor.StrongAuthTracker strongAuthTracker =
                     mUpdateMonitor.getStrongAuthTracker();
@@ -748,8 +746,6 @@
                 return KeyguardSecurityView.PROMPT_REASON_USER_REQUEST;
             } else if (any && (strongAuth & STRONG_AUTH_REQUIRED_AFTER_LOCKOUT) != 0) {
                 return KeyguardSecurityView.PROMPT_REASON_AFTER_LOCKOUT;
-            } else if (faceAuthLockscreenOngoing) {
-                return KeyguardSecurityView.PROMPT_REASON_TIMEOUT;
             }
             return KeyguardSecurityView.PROMPT_REASON_NONE;
         }
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceHacker.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceHacker.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceHacker.java	(revision 6857)
@@ -0,0 +1,42 @@
+package com.sensetime.faceapi;
+
+import com.sensetime.faceapi.model.CvPixelFormat;
+import com.sensetime.faceapi.model.FaceInfo;
+import com.sensetime.faceapi.model.FaceOrientation;
+
+/**
+ * 活体检测
+ */
+public class FaceHacker extends FaceHandleBase {
+
+    /**
+     * @param modelPath The FaceHackness model file path 活体检测模型文件路径
+     */
+    public FaceHacker(final String modelPath) {
+        mCvFaceHandle = FaceLibrary.cvFaceCreateHackness(modelPath);
+    }
+
+    /**
+     * 活体检测的方法
+     *
+     * @param image       输入的图片
+     * @param format      图片格式 {@link CvPixelFormat}
+     * @param width       图片宽度
+     * @param height      图片高度
+     * @param stride      图片跨度，即每行有多少个字节数
+     * @param orientation 人脸方向 {@link FaceOrientation}
+     * @param info        人脸信息 {@link FaceInfo}
+     * @return
+     */
+    public float faceHackness(byte[] image, CvPixelFormat format, int width, int height, int stride, FaceOrientation
+            orientation, FaceInfo info) {
+        return FaceLibrary.cvFaceHackness(mCvFaceHandle, image, format.getValue(), width, height, stride, orientation
+                .getValue(), info, mResultCode);
+    }
+
+    @Override
+    protected void releaseHandle() {
+        FaceLibrary.cvFaceDestroyHackness(mCvFaceHandle);
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceHacker.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/ResultCode.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/ResultCode.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/ResultCode.java	(revision 6857)
@@ -0,0 +1,198 @@
+package com.sensetime.faceapi.model;
+
+public enum ResultCode {
+	
+	/**
+     * ok
+     */
+    OK(0),
+    
+    /**
+     * cause by invalid argument
+     */
+    E_INVALIDARG(-1),
+    
+    /**
+     * handle Error,may be cause by sdk out of date or model file incorrect
+     */
+    E_HANDLE(-2),
+    
+    /**
+     * cause by out of memory
+     */
+    E_OUTOFMEMORY(-3),
+    
+    /**
+     * cause by run in fail inside
+     */
+    E_FAIL(-4),
+    
+    /**
+     * cause define not found
+     */
+    E_DELNOTFOUND(-5),
+    
+    /**
+     * cause by invalid pixel format
+     */
+    
+    E_INVALID_PIXEL_FORMAT(-6),
+    
+    /**
+     * cause by file no found
+     */
+    E_FILE_NOT_FOUND(-7),
+    
+    /**
+     * cause by model format error
+     */
+    E_INVALID_FILE_FORMAT(-8),
+    
+    /**
+     * cause by model out of date
+     */
+    E_FILE_EXPIRE (-9),
+    
+    /**
+     * cause by invalid license
+     */
+    E_INVALID_AUTH (-13),
+    
+    /**
+     * cause by invalid appID or package name
+     */
+    E_INVALID_APPID(-14),
+    
+    /**
+     * cause by SDK out of data
+     */
+    E_AUTH_EXPIRE(-15),
+    
+    /**
+     * cause by UUID mismatch
+     */
+    E_UUID_MISMATCH(-16),
+    
+    /**
+     * cause by online auth connect fail
+     */
+    E_ONLINE_AUTH_CONNECT_FAIL (-17),
+    
+    /**
+     * cause by check online timeout
+     */
+    E_ONLINE_AUTH_TIMEOUT (-18),
+    
+    /**
+     * cause by check online fail
+     */
+    E_ONLINE_AUTH_INVALID (-19),
+    
+    /**
+     * cause by license not activiable
+     */
+    E_LICENSE_IS_NOT_ACTIVABLE (-20),
+    
+    /**
+     * cause by license active failed
+     */
+    E_ACTIVE_FAIL (-21),
+    
+    /**
+     * cause by invalid active code
+     */
+    E_ACTIVE_CODE_INVALID (-22),
+    
+    /**
+     * cause by unsupport function called
+     */
+    E_UNSUPPORTED (-1000);
+    
+    
+    private final int resultCode;
+
+    ResultCode(int resultCode) {
+        this.resultCode = resultCode;
+    }
+
+	public int getValue() {
+        return resultCode;
+    }
+    
+    public static String getDescription(int code){
+    	switch (code) {
+		case 0:
+			return DESCRIPTION_OK;
+		case -1:
+			return DESCRIPTION_E_INVALIDARG;
+		case -2:
+			return DESCRIPTION_E_HANDLE;
+		case -3:
+			return DESCRIPTION_E_OUTOFMEMORY;
+		case -4:
+			return DESCRIPTION_E_FAIL;
+		case -5:
+			return DESCRIPTION_E_DELNOTFOUND;
+		case -6:
+			return DESCRIPTION_E_INVALID_PIXEL_FORMAT;
+		case -7:
+			return DESCRIPTION_E_FILE_NOT_FOUND;
+		case -8:
+			return DESCRIPTION_E_INVALID_FILE_FORMAT;
+		case -9:
+			return DESCRIPTION_E_FILE_EXPIRE;
+		case -13:
+			return DESCRIPTION_E_INVALID_AUTH;
+		case -14:
+			return DESCRIPTION_E_INVALID_APPID;
+		case -15:
+			return DESCRIPTION_E_AUTH_EXPIRE;
+		case -16:
+			return DESCRIPTION_E_UUID_MISMATCH;
+		case -17:
+			return DESCRIPTION_E_ONLINE_AUTH_CONNECT_FAIL;
+		case -18:
+			return DESCRIPTION_E_ONLINE_AUTH_TIMEOUT;
+		case -19:
+			return DESCRIPTION_E_ONLINE_AUTH_INVALID;
+		case -20:
+			return DESCRIPTION_E_LICENSE_IS_NOT_ACTIVABLE;
+		case -21:
+			return DESCRIPTION_E_ACTIVE_FAIL;
+		case -22:
+			return DESCRIPTION_E_ACTIVE_CODE_INVALID;
+		case -1000:
+			return DESCRIPTION_E_UNSUPPORTED;
+		default:
+			break;
+		}
+    	return null;
+    }
+    
+    private static final String DESCRIPTION_OK = "OK"; 
+    private static final String DESCRIPTION_E_INVALIDARG = "invalid argument"; 
+    private static final String DESCRIPTION_E_HANDLE = "handle Error,may be cause by sdk out of date or model file incorrect"; 
+    private static final String DESCRIPTION_E_OUTOFMEMORY = "out of memory"; 
+    private static final String DESCRIPTION_E_FAIL = "run in fail inside"; 
+    
+    private static final String DESCRIPTION_E_DELNOTFOUND = "define not found"; 
+    private static final String DESCRIPTION_E_INVALID_PIXEL_FORMAT = "invalid pixel format"; 
+    private static final String DESCRIPTION_E_FILE_NOT_FOUND = "file no found"; 
+    private static final String DESCRIPTION_E_INVALID_FILE_FORMAT = "model format error"; 
+    private static final String DESCRIPTION_E_FILE_EXPIRE = "model out of date"; 
+    
+    private static final String DESCRIPTION_E_INVALID_AUTH = "invalid license"; 
+    private static final String DESCRIPTION_E_INVALID_APPID = "E_INVALID_APPID"; 
+    private static final String DESCRIPTION_E_AUTH_EXPIRE = "E_AUTH_EXPIRE"; 
+    private static final String DESCRIPTION_E_UUID_MISMATCH = "E_UUID_MISMATCH"; 
+    private static final String DESCRIPTION_E_ONLINE_AUTH_CONNECT_FAIL = "online auth connect fail"; 
+    
+    private static final String DESCRIPTION_E_ONLINE_AUTH_TIMEOUT = "check online timeout";
+    private static final String DESCRIPTION_E_ONLINE_AUTH_INVALID = "check online fail"; 
+    
+    private static final String DESCRIPTION_E_LICENSE_IS_NOT_ACTIVABLE = "invalid active code"; 
+    private static final String DESCRIPTION_E_ACTIVE_FAIL = "license active failed"; 
+    private static final String DESCRIPTION_E_ACTIVE_CODE_INVALID = "invalid active code"; 
+    private static final String DESCRIPTION_E_UNSUPPORTED = "unsupport function called"; 
+    
+}
\ No newline at end of file

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/ResultCode.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceInfo.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceInfo.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceInfo.java	(revision 6857)
@@ -0,0 +1,43 @@
+package com.sensetime.faceapi.model;
+
+import android.graphics.PointF;
+import android.graphics.Rect;
+
+/**
+ * 人脸检测返回的结果体
+ */
+public class FaceInfo {
+	
+	public Rect faceRect;
+	public PointF[] facePoints;
+	public int id;
+	public float score;
+	public float yaw;
+	public float pitch;
+	public float roll;
+	public float eyeDist;
+
+	public FaceInfo clone() {
+		FaceInfo faceInfo = new FaceInfo();
+		faceInfo.faceRect = new Rect();
+		faceInfo.facePoints = new PointF[facePoints.length];
+		faceInfo.faceRect.set(faceRect);
+		for (int i = 0; i < faceInfo.facePoints.length; i++) {
+			faceInfo.facePoints[i] = new PointF();
+			faceInfo.facePoints[i].set(facePoints[i]);
+		}
+		faceInfo.id = id;
+		faceInfo.score = score;
+		faceInfo.yaw = yaw;
+		faceInfo.pitch = pitch;
+		faceInfo.roll = roll;
+		faceInfo.eyeDist = eyeDist;
+		return faceInfo;
+	}
+	
+	@Override
+	public String toString() {
+		return "FaceInfo(" + faceRect + ", " + score + ")";
+	}
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceInfo.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceOrientation.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceOrientation.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceOrientation.java	(revision 6857)
@@ -0,0 +1,30 @@
+package com.sensetime.faceapi.model;
+
+public enum FaceOrientation {
+
+    UP(1), // 人脸方向朝上，箭头表示人头位置，直线表示身体，即  ↑
+    LEFT(2), // 人脸方向朝左，箭头表示人头位置，直线表示身体，即  ←
+    DOWN(4), // 人脸方向朝下，箭头表示人头位置，直线表示身体，即  ↓
+    RIGHT(8), // 人脸方向朝右，箭头表示人头位置，直线表示身体，即  →
+    UNKNOWN(15); // 未知
+
+    final int nativeInt;
+
+    FaceOrientation(int ni) {
+        this.nativeInt = ni;
+    }
+
+    private static FaceOrientation sFaceOrientations[] = {
+            null, UP, LEFT, null, DOWN, null, null, null, RIGHT,
+            null, null, null, null, null, null, UNKNOWN
+    };
+
+    public int getValue() {
+        return nativeInt;
+    }
+
+    public static FaceOrientation nativeToOrientation(int ni) {
+        return sFaceOrientations[ni];
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceOrientation.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/IFaceFeatureInfo.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/IFaceFeatureInfo.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/IFaceFeatureInfo.java	(revision 6857)
@@ -0,0 +1,9 @@
+package com.sensetime.faceapi.model;
+
+public interface IFaceFeatureInfo{
+
+	byte[] getFeature();
+	void setGroupId(int groupId);
+	int getGroupId();
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/IFaceFeatureInfo.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/ColorConvertType.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/ColorConvertType.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/ColorConvertType.java	(revision 6857)
@@ -0,0 +1,25 @@
+package com.sensetime.faceapi.model;
+
+public enum ColorConvertType {
+
+    NV212BGRA(1),
+    NV212RGBA(2),
+    RGBA2NV21(3),
+    NV122BGRA(5),
+    BGRA2RGBA(14),
+    RGBA2NV12(20),
+    NV122RGBA(21),
+    RGBA2BGRA(101),
+    NV212BGR(1001);
+
+    final int nativeInt;
+
+    ColorConvertType(int i) {
+        this.nativeInt = i;
+    }
+
+    public int getValue() {
+        return nativeInt;
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/ColorConvertType.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/CvPixelFormat.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/CvPixelFormat.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/CvPixelFormat.java	(revision 6857)
@@ -0,0 +1,31 @@
+package com.sensetime.faceapi.model;
+
+public enum CvPixelFormat {
+
+    GRAY8(0),
+    YUV420P(1),
+    NV12(2),
+    NV21(3),
+    BGRA8888(4),
+    BGR888(5),
+    RGBA8888(6);
+
+    final int nativeInt;
+
+    private static CvPixelFormat sImageFormats[] = {
+            GRAY8, YUV420P, NV12, NV21, BGRA8888, BGR888, RGBA8888
+    };
+
+    CvPixelFormat(int ni) {
+        this.nativeInt = ni;
+    }
+
+    public int getValue() {
+        return nativeInt;
+    }
+
+    public static CvPixelFormat nativeToConfig(int ni) {
+        return sImageFormats[ni];
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/CvPixelFormat.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceConfig.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceConfig.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceConfig.java	(revision 6857)
@@ -0,0 +1,71 @@
+package com.sensetime.faceapi.model;
+
+/**
+ * 创建 FaceTrack 和 FaceDetect 必要的一些配置
+ */
+public class FaceConfig {
+
+    /**
+     * 将输入图片 resize 到某个大小
+     */
+    public enum FaceImageResize {
+
+        DEFAULT_CONFIG(0x00000000),
+        RESIZE_320W(0x00000002),
+        RESIZE_640W(0x00000004),
+        RESIZE_1280W(0x00000008);
+
+        final int value;
+
+        FaceImageResize(int value) {
+            this.value = value;
+        }
+
+        public int getValue() {
+            return value;
+        }
+
+    }
+
+    /**
+     * 返回的人脸关键点数量
+     */
+    public enum FaceKeyPointCount {
+
+        POINT_COUNT_21(0x00000100),
+        POINT_COUNT_106(0x00000200);
+
+        final int value;
+
+        FaceKeyPointCount(int value) {
+            this.value = value;
+        }
+
+        public int getValue() {
+            return value;
+        }
+
+    }
+
+    /**
+     * Track 操作开启的线程数
+     */
+    public enum TrackThreadCount {
+
+        DEFAULT_CONFIG(0x00000000),
+        TWO_THREAD(0x00110000); // 开启双线程人脸跟踪，建议低配置环境开启此选项
+
+        final int value;
+
+        TrackThreadCount(int value) {
+            this.value = value;
+        }
+
+        public int getValue() {
+            return value;
+        }
+
+    }
+
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceConfig.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceAttrInfo.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceAttrInfo.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceAttrInfo.java	(revision 6857)
@@ -0,0 +1,30 @@
+package com.sensetime.faceapi.model;
+
+/**
+ * 属性检测返回的结果体
+ */
+public class FaceAttrInfo {
+
+	public int age;
+	public int sex; // 性别 Male 0, Female 1
+	public float sexScore;
+	public int attractive;
+	public boolean hasEyeGlass;
+	public float eyeGlassScore;
+	public boolean hasSunGlass;
+	public float sunGlassScore;
+	public boolean isSmile;
+	public float smileScore;
+	public boolean hasMask;
+	public float maskScore;
+	public int race;// 种族 Yellow 0, Black 1,White 2
+	public boolean isEyeOpen;
+	public float eyeOpenScore;
+	public boolean isMouthOpen;
+	public float mouthOpenScore;
+	public boolean hasBeard;
+	public float beardScore;
+	public int emotion;
+	public float emotionScore;
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/model/FaceAttrInfo.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/ICamera.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/ICamera.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/ICamera.java	(revision 6857)
@@ -0,0 +1,343 @@
+package com.sensetime.faceapi.utils;
+
+import android.app.Activity;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.ImageFormat;
+import android.graphics.Matrix;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.graphics.SurfaceTexture;
+import android.graphics.YuvImage;
+import android.hardware.Camera;
+import android.hardware.Camera.CameraInfo;
+import android.util.Log;
+import android.view.Surface;
+import android.view.SurfaceHolder;
+import android.widget.RelativeLayout;
+
+import java.io.ByteArrayOutputStream;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * 照相机工具类
+ */
+public class ICamera {
+
+    public Camera mCamera;
+    public int cameraWidth;
+    public int cameraHeight;
+    public int cameraId = 1;// 前置摄像头
+    public int Angle;
+
+    public ICamera() {
+    }
+
+    /**
+     * 打开相机
+     */
+    public Camera openCamera(boolean isBackCamera, Activity activity,
+                             HashMap<String, Integer> resolutionMap) {
+        try {
+            if (isBackCamera)
+                cameraId = 0;
+            else
+                cameraId = 1;
+
+            int width = 480;
+            int height = 640;
+
+            if (resolutionMap != null) {
+                width = resolutionMap.get("width");
+                height = resolutionMap.get("height");
+            }
+
+            mCamera = Camera.open(cameraId);
+            CameraInfo cameraInfo = new CameraInfo();
+            Camera.getCameraInfo(cameraId, cameraInfo);
+            Camera.Parameters params = mCamera.getParameters();
+            // Camera.Size bestPreviewSize = calBestPreviewSize(
+            // mCamera.getParameters(), Screen.mWidth, Screen.mHeight);
+            Camera.Size bestPreviewSize = calBestPreviewSize(
+                    mCamera.getParameters(), width, height);
+            cameraWidth = bestPreviewSize.width;
+            cameraHeight = bestPreviewSize.height;
+            params.setPreviewSize(cameraWidth, cameraHeight);
+            params.setPreviewFormat(ImageFormat.NV21);
+            Angle = getCameraAngle(activity);
+            Log.w("ceshi", "Angle==" + Angle + "|" + cameraWidth + "|" + cameraHeight);
+            // mCamera.setDisplayOrientation(Angle);
+            mCamera.setParameters(params);
+            return mCamera;
+        } catch (Exception e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    // 通过屏幕参数、相机预览尺寸计算布局参数
+   /* public RelativeLayout.LayoutParams getLayoutParam(Activity activity) {
+        float scale = cameraWidth * 1.0f / cameraHeight;
+
+        int layout_width = Screen.mWidth;
+        int layout_height = (int) (layout_width * scale);
+
+
+//		int screenHeight = Screen.mHeight;
+//		
+//		if (Screen.mWidth >= screenHeight || screenHeight < layout_height) {
+//			layout_height = screenHeight;
+//			layout_width = (int) (layout_height / scale);
+//		}
+
+        RelativeLayout.LayoutParams layout_params = new RelativeLayout.LayoutParams(
+                layout_width, layout_height);
+        layout_params.addRule(RelativeLayout.CENTER_HORIZONTAL);// 设置照相机水平居中
+
+        return layout_params;
+    }*/
+
+    /**
+     * 开始检测脸
+     */
+    public void actionDetect(Camera.PreviewCallback mActivity) {
+        if (mCamera != null) {
+            mCamera.setPreviewCallback(mActivity);
+        }
+    }
+
+    public void startPreview(SurfaceTexture surfaceTexture) {
+        if (mCamera != null) {
+            try {
+                mCamera.setPreviewTexture(surfaceTexture);
+                mCamera.startPreview();
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public void startPreview(SurfaceHolder surfaceHolder) {
+        if (mCamera != null) {
+            try {
+                mCamera.setPreviewDisplay(surfaceHolder);
+                mCamera.startPreview();
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public void closeCamera() {
+        if (mCamera != null) {
+            mCamera.stopPreview();
+            mCamera.setPreviewCallback(null);
+            mCamera.release();
+            mCamera = null;
+        }
+    }
+
+    public static ArrayList<HashMap<String, Integer>> getCameraPreviewSize(
+            int cameraId) {
+        ArrayList<HashMap<String, Integer>> size = new ArrayList<HashMap<String, Integer>>();
+        Camera camera = null;
+        try {
+            camera = Camera.open(cameraId);
+            if (camera == null)
+                camera = Camera.open(0);
+
+            List<Camera.Size> allSupportedSize = camera.getParameters()
+                    .getSupportedPreviewSizes();
+            for (Camera.Size tmpSize : allSupportedSize) {
+                if (tmpSize.width > tmpSize.height) {
+                    HashMap<String, Integer> map = new HashMap<String, Integer>();
+                    map.put("width", tmpSize.width);
+                    map.put("height", tmpSize.height);
+                    size.add(map);
+                }
+            }
+
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            if (camera != null) {
+                camera.stopPreview();
+                camera.setPreviewCallback(null);
+                camera.release();
+                camera = null;
+            }
+        }
+
+        return size;
+    }
+
+    /**
+     * 通过传入的宽高算出最接近于宽高值的相机大小
+     */
+    private Camera.Size calBestPreviewSize(Camera.Parameters camPara, final int width, final int
+            height) {
+        List<Camera.Size> allSupportedSize = camPara.getSupportedPreviewSizes();
+        ArrayList<Camera.Size> widthLargerSize = new ArrayList<Camera.Size>();
+        for (Camera.Size tmpSize : allSupportedSize) {
+            Log.w("test", "tmpSize.width===" + tmpSize.width
+                    + ", tmpSize.height===" + tmpSize.height);
+            if (tmpSize.width > tmpSize.height) {
+                widthLargerSize.add(tmpSize);
+            }
+        }
+
+        Collections.sort(widthLargerSize, new Comparator<Camera.Size>() {
+            @Override
+            public int compare(Camera.Size lhs, Camera.Size rhs) {
+                int off_one = Math.abs(lhs.width * lhs.height - width * height);
+                int off_two = Math.abs(rhs.width * rhs.height - width * height);
+                return off_one - off_two;
+            }
+        });
+
+        Log.w("NearSize", widthLargerSize.get(0).width + ":" + widthLargerSize.get(0).height);
+        return widthLargerSize.get(0);
+    }
+
+    /**
+     * 打开前置或后置摄像头
+     */
+    public Camera getCameraSafely(int cameraId) {
+        Camera camera = null;
+        try {
+            camera = Camera.open(cameraId);
+        } catch (Exception e) {
+            camera = null;
+        }
+        return camera;
+    }
+
+    public void copyBGR(Bitmap bitmap, byte[] ret) {
+//		Bitmap bitmap = getBitMap(data, new Rect(0, 0, cameraWidth, cameraHeight), angle,
+// isBackCamera);
+        int width = bitmap.getWidth();
+        int height = bitmap.getHeight();
+
+        int size = width * height;
+        int bytes = bitmap.getByteCount();
+
+        ByteBuffer buffer = ByteBuffer.allocate(bytes);
+        bitmap.copyPixelsToBuffer(buffer);
+        byte temp[] = buffer.array();
+
+        for (int i = 0; i < size; ++i) {
+            ret[i * 3] = temp[i * 4 + 2];
+            ret[i * 3 + 1] = temp[i * 4 + 1];
+            ret[i * 3 + 2] = temp[i * 4];
+        }
+    }
+
+    public Rect transRect(int width, int height, int angle, boolean isBackCamera, Rect rect) {
+        RectF retF = new RectF();
+        Rect ret = new Rect();
+        Matrix matrix = new Matrix();
+        matrix.reset();
+        matrix.preTranslate(-width / 2, -height / 2);
+        matrix.preRotate(angle);
+        if (!isBackCamera) {
+            matrix.preScale(-1.0f, 1.0f);
+        }
+        if (angle == 90 || angle == 270) {
+            matrix.preTranslate(width / 2, height / 2);
+
+        }
+        matrix.mapRect(retF, new RectF(rect));
+
+        retF.round(ret);
+        return ret;
+    }
+
+    public Bitmap getBitMap(byte[] data, Rect roi, int angle, boolean isBackCamera) {
+        YuvImage yuvImage = new YuvImage(data, mCamera.getParameters()
+                .getPreviewFormat(), cameraWidth, cameraHeight, null);
+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+        yuvImage.compressToJpeg(new Rect(0, 0, cameraWidth, cameraHeight), 80,
+                byteArrayOutputStream);
+        byte[] jpegData = byteArrayOutputStream.toByteArray();
+        // 获取照相后的bitmap
+        Bitmap tmpBitmap = BitmapFactory.decodeByteArray(jpegData, 0,
+                jpegData.length);
+        Matrix matrix = new Matrix();
+        matrix.reset();
+        matrix.preRotate(angle);
+        if (!isBackCamera) {
+            matrix.preScale(-1.0f, 1.0f);
+        }
+        tmpBitmap = Bitmap.createBitmap(tmpBitmap, roi.left, roi.top, roi.width(),
+                roi.height(), matrix, true);
+        tmpBitmap = tmpBitmap.copy(Bitmap.Config.ARGB_8888, true);
+
+//		int hight = tmpBitmap.getHeight() > tmpBitmap.getWidth() ? tmpBitmap
+//				.getHeight() : tmpBitmap.getWidth();
+//
+//		float scale = hight / 800.0f;
+//
+//		if (scale > 1) {
+//			tmpBitmap = Bitmap.createScaledBitmap(tmpBitmap,
+//					(int) (tmpBitmap.getWidth() / scale),
+//					(int) (tmpBitmap.getHeight() / scale), false);
+//		}
+        return tmpBitmap;
+    }
+
+    /**
+     * 获取照相机旋转角度
+     */
+    public int getCameraAngle(Activity activity) {
+        int rotateAngle = 90;
+        CameraInfo info = new CameraInfo();
+        Camera.getCameraInfo(cameraId, info);
+        int rotation = activity.getWindowManager().getDefaultDisplay()
+                .getRotation();
+        int degrees = 0;
+        switch (rotation) {
+            case Surface.ROTATION_0:
+                degrees = 0;
+                break;
+            case Surface.ROTATION_90:
+                degrees = 90;
+                break;
+            case Surface.ROTATION_180:
+                degrees = 180;
+                break;
+            case Surface.ROTATION_270:
+                degrees = 270;
+                break;
+        }
+
+        if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {
+            rotateAngle = (info.orientation + degrees) % 360;
+            rotateAngle = (360 - rotateAngle) % 360; // compensate the mirror
+        } else { // back-facing
+            rotateAngle = (info.orientation - degrees + 360) % 360;
+        }
+        return rotateAngle;
+    }
+
+    private int getNavigationBarHeight(Activity activity) {
+        Resources resources = activity.getResources();
+        int resourceId = resources.getIdentifier("navigation_bar_height", "dimen", "android");
+        int height = resources.getDimensionPixelSize(resourceId);
+        Log.w("test", "Navi height:" + height);
+        return height;
+    }
+
+    private int getStatusBarHeight(Activity activity) {
+        Resources resources = activity.getResources();
+        int resourceId = resources.getIdentifier("status_bar_height", "dimen", "android");
+        int height = resources.getDimensionPixelSize(resourceId);
+        Log.w("test", "Status height:" + height);
+        return height;
+    }
+}
\ No newline at end of file

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/ICamera.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/AccelerometerManager.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/AccelerometerManager.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/AccelerometerManager.java	(revision 6857)
@@ -0,0 +1,200 @@
+package com.sensetime.faceapi.utils;
+
+import android.content.Context;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+import android.util.Log;
+
+import com.sensetime.faceapi.model.FaceOrientation;
+
+public class AccelerometerManager {
+
+	public static final String TAG = "AccelerometerManager";
+	private static AccelerometerManager instance;
+	private SensorManager mSensorManager;
+	private AccelerometerSensorListener mAccListener;
+	private boolean mHasStarted = false;
+
+	private AccelerometerManager() {
+	}
+
+	public static AccelerometerManager getInstance() {
+		if (instance == null) {
+			instance = new AccelerometerManager();
+		}
+		return instance;
+	}
+
+	/**
+	 * 启动加速度传感器
+	 */
+	public static void start(Context context) {
+		AccelerometerManager.getInstance().registerListener(context);
+	}
+
+	/**
+	 * 停止加速度传感器
+	 */
+	public static void stop() {
+		AccelerometerManager.getInstance().unregisterListener();
+	}
+
+	/**
+	 * 根据前后摄像头，依靠重力感应器获取方向后得到 FaceOrientation {@link FaceOrientation}
+     */
+	public static FaceOrientation getFaceOrientation(boolean isFrontCamera) {
+		int dir = getDir(isFrontCamera);
+		return getFaceOrientation(dir);
+	}
+
+	/**
+	 * 根据重力感应器得到的方向映射得到相应的 FaceOrientation {@link FaceOrientation}
+     */
+	public static FaceOrientation getFaceOrientation(int dir) {
+		switch (dir) {
+			case 0:
+				return FaceOrientation.UP;
+			case 1:
+				return FaceOrientation.LEFT;
+			case 2:
+				return FaceOrientation.DOWN;
+			case 3:
+				return FaceOrientation.RIGHT;
+			default:
+				return FaceOrientation.UNKNOWN;
+		}
+	}
+
+	/**
+	 * 根据重力感应器方向获取到对应的角度(0,90,180,270)
+	 */
+	public static int getDegree(boolean isFrontCamera){
+		return getDir(isFrontCamera) * 90;
+	}
+
+	/**
+	 * 根据重力感应器方向获取到对应的角度(0,90,180,270)
+	 */
+	public static int getDegree() {
+		return getDir() * 90;
+	}
+
+	/**
+	 * 根据重力感应器方向获取到对应的方向(0,1,2,3)
+	 * @param isFrontCamera 是否为前置摄像头，由于前置摄像头画面是镜像的，所以得到的方向也要做相应的翻转
+	 */
+	public static int getDir(boolean isFrontCamera) {
+		int dir = AccelerometerManager.getInstance().getDirection(isFrontCamera);
+		return dir;
+	}
+
+	/**
+	 * 根据重力感应器方向获取到对应的方向(0,1,2,3)
+	 */
+	public static int getDir() {
+		return getDir(false);
+	}
+
+	// ------------------------------------------------------------------------------
+
+	/**
+	 * Use this method to get the direction of mobile phone
+	 * @param isFrontCamera : Input the current camera which is using is front or not
+	 * @return the mobile phone direction value
+	 */
+	private int getDirection(boolean isFrontCamera) {
+		if (mAccListener != null) {
+			int dir = mAccListener.dir;
+			// 当且仅当为前置摄像头且画面是上下方向(portrait、portrait-inverse)的颠倒
+			if (isFrontCamera && ((dir & 1) == 1)) {
+				dir = (dir ^ 2);
+			}
+			return dir;
+		}
+		return -1; // default value is -1
+	}
+	
+	/**
+	 * Use this method to start listening of the sensor
+	 */
+	private void registerListener(Context context) {
+		if (mHasStarted) {
+			return;
+		}
+		mHasStarted = true;
+		mSensorManager = (SensorManager) context.getApplicationContext().getSystemService(Context.SENSOR_SERVICE);
+		Sensor accelerometerSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); // 获取加速度传感器
+		if (accelerometerSensor != null) { // 加速度传感器存在时才执行
+			mAccListener = new AccelerometerSensorListener();
+			mSensorManager.registerListener(mAccListener, accelerometerSensor, SensorManager.SENSOR_DELAY_NORMAL); // 注册事件监听
+		}
+	}
+
+	/**
+	 * Use this method to stop listening of the sensor
+	 */
+	private void unregisterListener() {
+		if (!mHasStarted || mSensorManager == null) {
+			return;
+		}
+		mHasStarted = false;
+		mSensorManager.unregisterListener(mAccListener);
+	}
+
+	private class AccelerometerSensorListener implements SensorEventListener {
+		
+		/**
+		 * landscape：
+		 *  ___________________
+		 * | +--------------+  |
+		 * | |              |  |
+		 * | |              |  |
+		 * | |              | O|
+		 * | |              |  |
+		 * | |______________|  |
+		 * ---------------------
+		 * portrait：
+		 *  ___________
+		 * |           |
+		 * |+---------+|
+		 * ||         ||
+		 * ||         ||
+		 * ||         ||
+		 * ||         ||
+		 * ||         ||
+		 * |+---------+|
+		 * |_____O_____|
+		 */
+		private int dir = -1;
+
+		public void onAccuracyChanged(Sensor sensor, int accuracy) {
+		}
+
+		public void onSensorChanged(SensorEvent event) {
+			if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
+				// All values are in SI units (m/s^2)
+				float x = event.values[0]; // Acceleration minus Gx on the x-axis
+				float y = event.values[1]; // Acceleration minus Gy on the y-axis
+				Log.d(TAG, "x: " + x + ", y: " + y);
+				if (Math.abs(x) > 0.5f || Math.abs(y) > 0.5f) {
+					if (Math.abs(x) > Math.abs(y)) {
+						if (x > 0) {
+							dir = 0; // landscape
+						} else {
+							dir = 2; // landscape-inverse
+						}
+					} else {
+						if (y > 0) {
+							dir = 1; // portrait
+						} else {
+							dir = 3; // portrait-inverse
+						}
+					}
+				}
+			}
+		}
+	}
+	
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/AccelerometerManager.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/BrightnessUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/BrightnessUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/BrightnessUtil.java	(revision 6857)
@@ -0,0 +1,36 @@
+package com.sensetime.faceapi.utils;
+
+import android.graphics.Rect;
+import android.util.Log;
+
+import com.sensetime.faceapi.FaceLibrary;
+import com.sensetime.faceapi.model.CvPixelFormat;
+import com.sensetime.faceapi.model.FaceInfo;
+
+public class BrightnessUtil {
+	private static final String TAG = "AverageBrightnessUtil";
+	public static float averageBrightness(byte[] imageData,CvPixelFormat format,int width,int height,FaceInfo faceInfo){
+		if(faceInfo == null){
+			Log.w(TAG, "averageBrightness faceInfo is NULL !!!");
+			return 0;
+		}
+		return averageBrightness(imageData,format,width, height, faceInfo.faceRect);
+	}
+
+	public static float averageBrightness(byte[] imageData,CvPixelFormat format,int width,int height,Rect rect){
+		if(rect == null){
+			Log.w(TAG, "averageBrightness rect is NULL !!!");
+			return 0;
+		}
+		return averageBrightness(imageData,format, width, height,rect.left,rect.top,rect.width(),rect.height());
+	}
+
+	public static float averageBrightness(byte[] imageData,CvPixelFormat format,int width,int height,int x,int y,int areaW,int areaH){
+		if(x > width  || y > height || areaW <= 0 || areaH <= 0){
+			Log.w(TAG, "averageBrightness area is not in image frame imageFrame : " + width + "x" + height + " area[x,y,w,h] : "+ x + ","+ y+","+areaW+","+areaH );
+			return 0;
+		}
+		return FaceLibrary.averageBrightness(imageData, format, width, height, x, y, areaW, areaH);
+	}
+	
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/BrightnessUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/FaceDrawUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/FaceDrawUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/FaceDrawUtil.java	(revision 6857)
@@ -0,0 +1,79 @@
+package com.sensetime.faceapi.utils;
+
+import com.sensetime.faceapi.model.FaceInfo;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.PointF;
+import android.graphics.Rect;
+import android.util.Log;
+
+/**
+ * 绘制人脸时常用的一些方法
+ */
+public class FaceDrawUtil {
+
+    public static final boolean DEBUG = true;
+    public static final String TAG = "FaceDrawUtil";
+
+    /**
+     * Use this method to draw faces rect and points
+     *
+     * @param canvas    The canvas where draw
+     * @param faceInfos The face info array contain rect and points
+     * @param paint     The paint used to draw
+     */
+    public static void drawFaces(Canvas canvas, FaceInfo[] faceInfos, Paint paint) {
+        if (canvas == null || faceInfos == null) {
+            Log.w(TAG, "drawFaces canvas or faces is null !");
+            return;
+        }
+        for (FaceInfo faceInfo : faceInfos) {
+            drawFace(canvas, faceInfo, paint);
+        }
+    }
+
+    /**
+     * Use this method to draw one face rect and points
+     *
+     * @param canvas   The canvas where draw
+     * @param faceInfo The one face info contain rect and points
+     * @param paint    The paint used to draw
+     */
+    public static void drawFace(Canvas canvas, FaceInfo faceInfo, Paint paint) {
+        if (canvas == null || faceInfo == null) {
+            Log.w(TAG, "drawFace canvas or faces is null !");
+            return;
+        }
+        drawFaceRect(canvas, faceInfo.faceRect, paint);
+        drawPoints(canvas, faceInfo.facePoints, paint);
+    }
+
+    /**
+     * Use this method to draw face rect
+     *
+     * @param canvas The canvas where draw
+     * @param rect   The face rect
+     * @param paint  The paint used to draw
+     */
+    public static void drawFaceRect(Canvas canvas, Rect rect, Paint paint) {
+        if (canvas == null) return;
+        canvas.drawRect(rect, paint);
+    }
+
+    /**
+     * Use this method to draw face key points
+     *
+     * @param canvas The canvas where draw
+     * @param points The face points
+     * @param paint  The paint used to draw
+     */
+    public static void drawPoints(Canvas canvas, PointF[] points, Paint paint) {
+        if (canvas == null) return;
+        for (PointF point : points) {
+            PointF p = point;
+            canvas.drawPoint(p.x, p.y, paint);
+        }
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/FaceDrawUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/FaceRotationUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/FaceRotationUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/FaceRotationUtil.java	(revision 6857)
@@ -0,0 +1,165 @@
+package com.sensetime.faceapi.utils;
+
+import com.sensetime.faceapi.model.FaceInfo;
+
+import android.graphics.PointF;
+import android.graphics.Rect;
+
+/**
+ * 旋转FaceInfo的工具类, 包括旋转Face本身以及Face矩形框等
+ **/
+public class FaceRotationUtil {
+
+    /**
+     * rotate faces
+     *
+     * @param faceInfos     used to rotate
+     * @param width         The width of image
+     * @param height        The height of image
+     * @param isFrontCamera The isFrontCamera whether the image come from front camera
+     * @param degrees       The degrees of camera display
+     * @see #rotateFaceInfo(FaceInfo, int, int, boolean, int)
+     */
+    public static void rotateFaceInfos(FaceInfo[] faceInfos, int width, int height, boolean isFrontCamera, int
+            degrees) {
+        if (faceInfos == null || faceInfos.length == 0) {
+            return;
+        }
+        for (FaceInfo face : faceInfos) {
+            rotateFaceInfo(face, width, height, isFrontCamera, degrees);
+        }
+    }
+
+    /**
+     * rotate one face
+     *
+     * @param faceInfo      used to rotate
+     * @param width         The width of image
+     * @param height        The height of image
+     * @param isFrontCamera The isFrontCamera whether the image come from front camera
+     * @param degrees       The degrees of camera display
+     */
+    public static void rotateFaceInfo(FaceInfo faceInfo, int width, int height, boolean isFrontCamera, int degrees) {
+        if (faceInfo == null) {
+            return;
+        }
+        rotateFaceRect(faceInfo.faceRect, width, height, isFrontCamera, degrees);
+        PointF[] points = faceInfo.facePoints;
+        for (int i = 0; i < points.length; i++) {
+            rotatePoints(points[i], width, height, isFrontCamera, degrees);
+        }
+    }
+
+    /**
+     * rotate face rect
+     *
+     * @param rect          used to rotate
+     * @param width         The width of image
+     * @param height        The height of image
+     * @param isFrontCamera The isFrontCamera whether the image come from front camera
+     * @param degrees       The degrees of camera display
+     */
+    public static Rect rotateFaceRect(Rect rect, int width, int height, boolean isFrontCamera, int degrees) {
+        int tmp;
+        switch (degrees) {
+            case 0: // landscape
+                // 前置摄像头时左右翻转
+                if (isFrontCamera) {
+                    rect.left = width - rect.left;
+                    rect.right = width - rect.right;
+                }
+                break;
+            case 90: // portrait
+                // 顺时针旋转90°
+                tmp = rect.left;
+                rect.left = height - rect.bottom;
+                rect.bottom = rect.right;
+                rect.right = height - rect.top;
+                rect.top = tmp;
+                // 前置摄像头时上下翻转
+                if (isFrontCamera) {
+                    tmp = rect.top;
+                    rect.top = width - rect.bottom;
+                    rect.bottom = width - tmp;
+                }
+                break;
+            case 180:
+                // 上下翻转
+                rect.top = height - rect.top;
+                rect.bottom = height - rect.bottom;
+                // 后置摄像头时再左右翻转
+                if (!isFrontCamera) {
+                    rect.left = width - rect.left;
+                    rect.right = width - rect.right;
+                }
+                break;
+            case 270:
+                // 顺时针旋转90°
+                tmp = rect.left;
+                rect.left = height - rect.bottom;
+                rect.bottom = rect.right;
+                rect.right = height - rect.top;
+                rect.top = tmp;
+                // 左右翻转
+                tmp = rect.left;
+                rect.left = height - rect.right;
+                rect.right = height - tmp;
+                // 后置摄像头时再上下翻转
+                if (!isFrontCamera) {
+                    tmp = rect.top;
+                    rect.top = width - rect.bottom;
+                    rect.bottom = width - tmp;
+                }
+                break;
+            default:
+                break;
+        }
+        return rect;
+    }
+
+    /**
+     * rotate face key points
+     *
+     * @param point         used to rotate
+     * @param width         The width of image
+     * @param height        The height of image
+     * @param isFrontCamera The isFrontCamera whether the image come from front camera
+     * @param degrees       The degrees of camera display
+     */
+    public static PointF rotatePoints(PointF point, int width, int height, boolean isFrontCamera, int degrees) {
+        float tmp;
+        switch (degrees) {
+            case 0: // landscape
+                if (isFrontCamera) {
+                    point.x = width - point.x;
+                }
+                break;
+            case 90: // portrait
+                tmp = point.x;
+                point.x = height - point.y;
+                point.y = tmp;
+                if (isFrontCamera) {
+                    point.y = width - point.y;
+                }
+                break;
+            case 180:
+                point.y = height - point.y;
+                if (!isFrontCamera) {
+                    point.x = width - point.x;
+                }
+                break;
+            case 270:
+                tmp = point.y;
+                point.y = point.x;
+                point.x = tmp;
+                if (!isFrontCamera) {
+                    point.y = width - point.y;
+                }
+                break;
+            default:
+                break;
+        }
+        return point;
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/FaceRotationUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/ColorConvertUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/ColorConvertUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/ColorConvertUtil.java	(revision 6857)
@@ -0,0 +1,90 @@
+package com.sensetime.faceapi.utils;
+
+import java.nio.ByteBuffer;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.util.Log;
+
+import com.sensetime.faceapi.FaceLibrary;
+
+public class ColorConvertUtil {
+
+    public static final String TAG = "ColorConvertUtil";
+
+    /**
+     * 根据 bitmap 获取 bgr 格式的数据
+     */
+    public static void getBGRFromBitmap(Bitmap bitmap, byte[] bgr) {
+        if (bitmap == null || bitmap.isRecycled() || bgr == null) {
+            Log.e(TAG, "bitmap or bgr is null !!!");
+            return;
+        }
+        if (bitmap.getConfig() != Config.ARGB_8888) {
+            bitmap = bitmap.copy(Config.ARGB_8888, false);
+        }
+        FaceLibrary.getBGRFromBitmap(bitmap, bgr);
+    }
+
+    /**
+     * 从nv21的数据中裁剪出一块指定区域大小的Bitmap图片出来
+     *
+     * @param nv21        数据源
+     * @param imageWidth  原始图片宽度
+     * @param imageHeight 原始图片高度
+     * @param startX      裁剪区域 x 轴的起始位置
+     * @param startY      裁剪区域 y 轴的起始位置
+     * @param cropWidth   裁剪宽度
+     * @param cropHeight  裁剪高度
+     * @return 裁剪后的 bitmap 图片
+     */
+    public static Bitmap cropNv21ToBitmap(byte[] nv21, int imageWidth, int imageHeight, int startX, int startY, int
+            cropWidth, int cropHeight) {
+        if (nv21 == null || startX < 0 || startY < 0 || cropWidth < 0 || cropHeight < 0 || imageWidth < (startX +
+                cropWidth) || imageHeight < (startY + cropHeight)) {
+            Log.e(TAG, "cropNv21ToBitmap failed: illegal para !");
+            return null;
+        }
+        byte[] argb = new byte[cropWidth * cropHeight * 4];
+        ColorConvertUtil.cropNv21DataToARGB(nv21, imageWidth, imageHeight, startX, startY, cropWidth,
+                cropHeight, argb);
+        Bitmap bitmap = byteArrayToBitmap(argb, cropWidth, cropHeight);
+        return bitmap;
+    }
+
+    /**
+     * 从nv21的数据中裁剪出一块指定区域大小的 argb 数据
+     *
+     * @param nv21   数据源
+     * @param width  原始图片宽度
+     * @param height 原始图片高度
+     * @param x      裁剪区域 x 轴的起始位置
+     * @param y      裁剪区域 y 轴的起始位置
+     * @param w      裁剪宽度
+     * @param h      裁剪高度
+     * @param argb   输出的 argb 数据
+     */
+    public static void cropNv21DataToARGB(byte[] nv21, int width, int height, int x, int y, int w, int h, byte[] argb) {
+        if (nv21 == null || argb == null) {
+            Log.e(TAG, "cropNv21DataToARGB failed: nv21 or argb is null ");
+            return;
+        }
+        FaceLibrary.cropNv21Data(nv21, width, height, x, y, w, h, argb);
+    }
+
+    /**
+     * 将 argb 的 byte[] 数据转换成 bitmap
+     *
+     * @param argb   输入的 argb 数据
+     * @param width  图片宽度
+     * @param height 图片高度
+     * @return 得到的 bitmap
+     */
+    public static Bitmap byteArrayToBitmap(byte[] argb, int width, int height) {
+        ByteBuffer buffer = ByteBuffer.wrap(argb);
+        Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
+        bitmap.copyPixelsFromBuffer(buffer);
+        return bitmap;
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/utils/ColorConvertUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/LicenseHelper.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/LicenseHelper.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/LicenseHelper.java	(revision 6857)
@@ -0,0 +1,13 @@
+package com.sensetime.faceapi;
+
+public class LicenseHelper {
+
+	public static int initLicense(byte[] license){
+		return FaceLibrary.initLiscence(license);
+	}
+	
+	public static int initLicense(String license){
+		return FaceLibrary.initLiscenceStr(license);
+	}
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/LicenseHelper.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceLibrary.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceLibrary.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceLibrary.java	(revision 6857)
@@ -0,0 +1,90 @@
+package com.sensetime.faceapi;
+
+import android.graphics.Bitmap;
+
+import com.sensetime.faceapi.model.CvPixelFormat;
+import com.sensetime.faceapi.model.FaceInfo;
+
+public class FaceLibrary {
+
+    static {
+        System.loadLibrary("cvface_api");
+        System.loadLibrary("jni_cvface_api");
+    }
+
+    public static native void setDebug(boolean debug);
+
+    // license
+    public static native int initLiscence(byte[] license);
+
+    public static native int initLiscenceStr(String license);
+
+    // detector
+    public static native long cvFaceCreateDetector(String path, int config);
+
+    public static native void cvFaceDestroyDetector(long handle);
+
+    public static native float getDetectThreshold(long handle, int[] resultCode);
+
+    public static native void setDetectThreshold(long handle, float threshold, int[] resultCode);
+
+    public static native FaceInfo[] cvFaceDetectBytes(long handle, byte[] image, int pixelFormat, int width,
+                                                      int height, int stride, int orientation, int[] resultCode);
+
+    public static native FaceInfo[] cvFaceDetectInts(long handle, int[] image, int pixelFormat, int width, int height,
+                                                     int stride, int orientation, int[] resultCode);
+
+    // tracker
+    public static native void cvFaceShowInsideModel();
+
+    public static native long cvFaceCreateTracker(String detectModelPath, String alignModelPath, int config);
+
+    public static native void cvFaceDestroyTracker(long handle);
+
+    public static native FaceInfo[] cvFaceTrackBytes(long handle, byte[] image, int pixelFormat, int width, int height,
+                                                     int stride, int orientation, int[] resultCode);
+
+    public static native FaceInfo[] cvFaceTrackInts(long handle, int[] image, int pixelFormat, int width, int height,
+                                                    int stride, int orientation, int[] resultCode);
+
+    public static native void cvFaceResetTracker(long handle);
+
+    public static native int cvFaceTrackSetDetectFaceCntLimit(long handle, int count);
+
+    public static native int cvFaceTrackSetDetectInterval(long handle, int count);
+
+    // Verify
+    public static native long cvFaceCreateVerify(final String modelPath);
+
+    public static native int cvFaceGetVerifyVersion(long handle);
+
+    public static native int cvFaceGetVerifyLength(long handle);
+
+    public static native long cvFaceDeserialize(byte[] feature);
+
+    public static native float cvFaceCompareFeature(long handle, byte[] feature1, byte[] feature2, int[] resultCode);
+
+    public static native byte[] cvFaceGetFeatureInts(long handle, int[] image, int format, int width, int height,
+                                                     int stride, FaceInfo cvFace, int[] resultCode);
+
+    public static native byte[] cvFaceGetFeatureBytes(long handle, byte[] image, int format, int width, int height,
+                                                      int stride, FaceInfo cvFace, int[] resultCode);
+
+    public static native void cvFaceDestroyVerify(long handle);
+
+    // hackness
+    public static native long cvFaceCreateHackness(final String modelPath);
+
+    public static native float cvFaceHackness(long handle, byte[] image, int format, int width, int height, int stride,
+                                              int orientation, FaceInfo cvFace, int[] resultCode);
+
+    public static native void cvFaceDestroyHackness(long handle);
+
+    // other
+	public static native void getBGRFromBitmap(Bitmap bitmap, byte[] bgr);
+
+    public static native void cropNv21Data(byte[] in, int width, int height, int x, int y, int w, int h, byte[] out);
+
+    public static native float averageBrightness(byte[] imageData,CvPixelFormat format,int width,int height,int x,int y,int areaW,int areaH);
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceLibrary.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceTrack.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceTrack.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceTrack.java	(revision 6857)
@@ -0,0 +1,205 @@
+package com.sensetime.faceapi;
+
+import com.sensetime.faceapi.model.FaceConfig;
+import com.sensetime.faceapi.model.FaceInfo;
+import com.sensetime.faceapi.model.FaceOrientation;
+import com.sensetime.faceapi.model.CvPixelFormat;
+import com.sensetime.faceapi.utils.ColorConvertUtil;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.util.Log;
+
+public class FaceTrack extends FaceHandleBase {
+
+    private static final boolean DEBUG = true;
+    private static final String TAG = "FaceTrack";
+
+    public FaceTrack() {
+        this(null, null, null, null, null);
+    }
+
+    public FaceTrack(FaceConfig.FaceImageResize resize, FaceConfig.FaceKeyPointCount pointCount,
+                     FaceConfig.TrackThreadCount threadCount) {
+        this(null, null, resize, pointCount, threadCount);
+    }
+
+    /**
+     * @param detectModelPath track模型文件的路径
+     * @param alignModelPath  关键点模型文件的路径
+     * @param resize          resize图片的大小 {@link FaceConfig.FaceImageResize}
+     * @param pointCount      关键点的数量 {@link FaceConfig.FaceKeyPointCount}
+     * @param threadCount     track开启的线程数 {@link FaceConfig.TrackThreadCount}
+     */
+    public FaceTrack(String detectModelPath, String alignModelPath, FaceConfig.FaceImageResize resize,
+                     FaceConfig.FaceKeyPointCount pointCount, FaceConfig.TrackThreadCount threadCount) {
+        if (resize == null) {
+            resize = FaceConfig.FaceImageResize.RESIZE_320W; // 默认使用了压缩为320
+        }
+        if (pointCount == null) {
+            pointCount = FaceConfig.FaceKeyPointCount.POINT_COUNT_21;
+        }
+        if (threadCount == null) {
+            threadCount = FaceConfig.TrackThreadCount.DEFAULT_CONFIG;
+        }
+        int config = resize.getValue() | pointCount.getValue() | threadCount.getValue();
+        init(detectModelPath, alignModelPath, config);
+    }
+
+    /**
+     * Initialize the Native Handler
+     */
+    private void init(String detectModelPath, String alignModelPath, int config) {
+        mCvFaceHandle = FaceLibrary.cvFaceCreateTracker(detectModelPath, alignModelPath, config);
+    }
+
+    /**
+     * Given the Image by Int Array to track face
+     *
+     * @param colorImage    Input image color int[] 输入的图片
+     * @param cvPixelFormat Input image cvImageFormat which you can select the value from CvImageFormat Class 图片格式
+     * @param imageWidth    Input image Width 图片宽度
+     * @param imageHeight   Input image Height 图片高度
+     * @param imageStride   Input bytes of rows 图片跨度，即每行有多少个字节数
+     * @param orientation   Input image orientation 图片方向
+     * @return FaceInfo array, each one in array is tracked by SDK native API
+     */
+    public FaceInfo[] track(int[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight,
+                            int imageStride, FaceOrientation orientation) {
+        FaceInfo[] faces = FaceLibrary.cvFaceTrackInts(mCvFaceHandle, colorImage, cvPixelFormat.getValue(), imageWidth,
+                imageHeight, imageStride, orientation.getValue(), mResultCode);
+        checkResultCode();
+        return faces;
+    }
+
+    /**
+     * Given the Image by Byte Array to track face
+     *
+     * @param colorImage    Input image color byte[] 输入的图片
+     * @param cvPixelFormat Input image cvImageFormat which you can select the value from CvImageFormat Class 图片格式
+     * @param imageWidth    Input image Width 图片宽度
+     * @param imageHeight   Input image Height 图片高度
+     * @param imageStride   Input bytes of rows 图片跨度，即每行有多少个字节数
+     * @param orientation   Input image orientation 图片方向
+     * @return FaceInfo array, each one in array is tracked by SDK native API
+     */
+    public FaceInfo[] track(byte[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight,
+                            int imageStride, FaceOrientation orientation) {
+        FaceInfo[] faces = FaceLibrary.cvFaceTrackBytes(mCvFaceHandle, colorImage, cvPixelFormat.getValue(), imageWidth,
+                imageHeight, imageStride, orientation.getValue(), mResultCode);
+        checkResultCode();
+        return faces;
+    }
+
+    /**
+     * @see #track(Bitmap, FaceOrientation)
+     */
+    public FaceInfo[] track(Bitmap bitmap) {
+        return track(bitmap, FaceOrientation.UP);
+    }
+
+    /**
+     * @see #track(Bitmap, FaceOrientation, byte[])
+     */
+    public FaceInfo[] track(Bitmap bitmap, FaceOrientation orientation) {
+        return track(bitmap, orientation, null);
+    }
+
+    /**
+     * @see #track(byte[], CvPixelFormat, int, int, int, FaceOrientation)
+     */
+    public FaceInfo[] track(Bitmap bitmap, FaceOrientation orientation, byte[] buffer) {
+        if (bitmap == null || bitmap.isRecycled()) {
+            if (DEBUG) {
+                Log.w(TAG, "track image is null or Recycled");
+            }
+            return null;
+        }
+        if (bitmap.getConfig() != Config.ARGB_8888) {
+        	bitmap = bitmap.copy(Config.ARGB_8888, false);
+        }
+        if (buffer == null) {
+            buffer = createBufferIfNeed(bitmap.getWidth(), bitmap.getHeight());
+        } else if (buffer.length != bitmap.getWidth() * bitmap.getHeight() * 3) {
+            throw new RuntimeException("detect buffer is illegal !");
+        }
+        ColorConvertUtil.getBGRFromBitmap(bitmap, buffer);
+        return track(buffer, CvPixelFormat.BGR888, bitmap.getWidth(), bitmap.getHeight(), bitmap.getWidth() * 3,
+                orientation);
+    }
+
+    /**
+     * @see #track(byte[], CvPixelFormat, int, int, FaceOrientation)
+     */
+    public FaceInfo[] track(byte[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight) {
+        return track(colorImage, cvPixelFormat, imageWidth, imageHeight, FaceOrientation.UP);
+    }
+
+    /**
+     * @see #track(byte[], CvPixelFormat, int, int, int, FaceOrientation)
+     */
+    public FaceInfo[] track(byte[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight,
+                            FaceOrientation orientation) {
+        return track(colorImage, cvPixelFormat, imageWidth, imageHeight, imageWidth, orientation);
+    }
+
+    /**
+     * @see #track(int[], CvPixelFormat, int, int, FaceOrientation)
+     */
+    public FaceInfo[] track(int[] colorImage, int imageWidth, int imageHeight, FaceOrientation orientation) {
+        return track(colorImage, CvPixelFormat.BGR888, imageWidth, imageHeight, orientation);
+    }
+
+    /**
+     * @see #track(int[], CvPixelFormat, int, int, int, FaceOrientation)
+     */
+    public FaceInfo[] track(int[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight,
+                            FaceOrientation orientation) {
+        return track(colorImage, cvPixelFormat, imageWidth, imageHeight, imageWidth * 4, orientation);
+    }
+
+    /**
+     * Reset track ,Sometimes,video frame is not discontinuous,when frame
+     * restart you can reset track to avoid tracking face discontinuity
+     */
+    public void reset() {
+        if (!isHandleInitialized()) {
+            if (DEBUG) {
+                Log.e(TAG, "reset Handle not Initialized");
+            }
+            return;
+        }
+        FaceLibrary.cvFaceResetTracker(mCvFaceHandle);
+    }
+
+    public void showInsideModelVersion() {
+        FaceLibrary.cvFaceShowInsideModel();
+    }
+
+    /**
+     * 设置全检测帧数，默认20帧，如果对人脸出框速度有特殊需求，建议：前置无人脸：3  有人脸8  后置无人脸：5 有人脸10
+     */
+    public void setFaceTrackInterval(int count){
+    	FaceLibrary.cvFaceTrackSetDetectInterval(mCvFaceHandle, count);
+    }
+    /**
+     * Set the current face count of track
+     *
+     * @param count of face limit,no limit if count = -1
+     */
+    public void setFaceLimit(int count) {
+        if (!isHandleInitialized()) {
+            if (DEBUG) {
+                Log.e(TAG, "setFaceLimit Handle not Initialized");
+            }
+            return;
+        }
+        int rst = FaceLibrary.cvFaceTrackSetDetectFaceCntLimit(mCvFaceHandle, count <= 0 ? -1 : count);
+        checkResultCode(rst);
+    }
+
+    @Override
+    protected void releaseHandle() {
+        FaceLibrary.cvFaceDestroyTracker(mCvFaceHandle);
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceTrack.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceVerify.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceVerify.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceVerify.java	(revision 6857)
@@ -0,0 +1,116 @@
+package com.sensetime.faceapi;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.sensetime.faceapi.model.CvPixelFormat;
+import com.sensetime.faceapi.model.FaceInfo;
+import com.sensetime.faceapi.utils.ColorConvertUtil;
+
+/**
+ * 人脸认证
+ */
+public class FaceVerify extends FaceHandleBase {
+
+    private static final boolean DEBUG = true;
+    private static final String TAG = "FaceVerify";
+
+    /**
+     * @param modelPath The verify model file path 比对模型文件路径
+     */
+    public FaceVerify(String modelPath) {
+        init(modelPath);
+    }
+
+    private void init(String modelPath) {
+        if (TextUtils.isEmpty(modelPath)) {
+            throw new RuntimeException("verify model path is null!");
+        }
+        mCvFaceHandle = FaceLibrary.cvFaceCreateVerify(modelPath);
+    }
+
+    /**
+     * @see #getFeature(Bitmap, FaceInfo, byte[])
+     */
+    public byte[] getFeature(Bitmap image, FaceInfo faceInfo) {
+        return getFeature(image, faceInfo, null);
+    }
+
+    /**
+     * @see #getFeature(byte[], CvPixelFormat, int, int, int, FaceInfo)
+     */
+    public byte[] getFeature(Bitmap image, FaceInfo faceInfo, byte[] buffer) {
+        if (image == null || image.isRecycled()) {
+            if (DEBUG) {
+                Log.w(TAG, "image is null or Recycled");
+            }
+            return null;
+        }
+        if (image.getConfig() != Config.ARGB_8888) {
+            image = image.copy(Config.ARGB_8888, false);
+        }
+        if (buffer == null) {
+            buffer = createBufferIfNeed(image.getWidth(), image.getHeight());
+        } else if (buffer.length != image.getWidth() * image.getHeight() * 3) {
+            throw new RuntimeException("detect buffer is illegal !");
+        }
+        ColorConvertUtil.getBGRFromBitmap(image, buffer);
+        return getFeature(buffer, CvPixelFormat.BGR888, image.getWidth(), image.getHeight(), image.getWidth() * 3,
+                faceInfo);
+    }
+
+    /**
+     * @param colorImage    Input image color int[] 输入的图片
+     * @param cvPixelFormat Input image cvImageFormat which you can select the value from CvImageFormat Class 图片格式
+     * @param imageWidth    Input image Width 图片宽度
+     * @param imageHeight   Input image Height 图片高度
+     * @param imageStride   Input bytes of rows 图片跨度，即每行有多少个字节数
+     * @param faceInfo      人脸检测后得到的人脸信息 {@link FaceInfo}
+     * @return 人脸特征数组
+     */
+    public byte[] getFeature(int[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight, int
+            imageStride, FaceInfo faceInfo) {
+        byte[] feature = FaceLibrary.cvFaceGetFeatureInts(mCvFaceHandle, colorImage, cvPixelFormat.getValue(),
+                imageWidth, imageHeight, imageStride, faceInfo, mResultCode);
+        checkResultCode(mResultCode[0]);
+        return feature;
+    }
+
+    /**
+     * @param colorImage    Input image color byte[] 输入的图片
+     * @param cvPixelFormat Input image cvImageFormat which you can select the value from CvImageFormat Class 图片格式
+     * @param imageWidth    Input image Width 图片宽度
+     * @param imageHeight   Input image Height 图片高度
+     * @param imageStride   Input bytes of rows 图片跨度，即每行有多少个字节数
+     * @param faceInfo      人脸检测后得到的人脸信息 {@link FaceInfo}
+     * @return 人脸特征数组
+     */
+    public byte[] getFeature(byte[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight, int
+            imageStride, FaceInfo faceInfo) {
+        byte[] feature = FaceLibrary.cvFaceGetFeatureBytes(mCvFaceHandle, colorImage, cvPixelFormat.getValue(),
+                imageWidth, imageHeight, imageStride, faceInfo, mResultCode);
+        checkResultCode(mResultCode[0]);
+        return feature;
+    }
+
+    /**
+     * Given the two byte[] feature to get similar of two face,
+     *
+     * @param feature1 of first face
+     * @param feature2 of other face
+     * @return similar of two face (float[0-1])
+     */
+    public float compareFeature(byte[] feature1, byte[] feature2) {
+        float similar = FaceLibrary.cvFaceCompareFeature(mCvFaceHandle, feature1, feature2, mResultCode);
+        checkResultCode(mResultCode[0]);
+        return similar;
+    }
+
+    @Override
+    protected void releaseHandle() {
+        FaceLibrary.cvFaceDestroyVerify(mCvFaceHandle);
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceVerify.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceHandleBase.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceHandleBase.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceHandleBase.java	(revision 6857)
@@ -0,0 +1,52 @@
+package com.sensetime.faceapi;
+
+import com.sensetime.faceapi.model.ResultCode;
+
+public abstract class FaceHandleBase {
+
+	protected long mCvFaceHandle;
+	protected byte[] mBuffer;
+	protected int[] mResultCode = new int[1];
+	
+	protected boolean isHandleInitialized(){
+		return mCvFaceHandle != 0;
+	}
+
+	protected abstract void releaseHandle();
+	
+	protected void checkResultCode(int resultCode){
+		if (resultCode != ResultCode.OK.getValue()) {
+	        throw new RuntimeException("Calling native method failed! ResultCode : " + resultCode + " Reason : " + ResultCode.getDescription(resultCode));
+	    }
+	}
+	
+	protected void checkResultCode() {
+		checkResultCode(mResultCode[0]);
+	}
+	
+	protected byte[] createBufferIfNeed(int width, int height) {
+		int size = width * height*4;
+		if(mBuffer != null && mBuffer.length == size){
+			return mBuffer;
+		}
+		mBuffer = new byte[size];
+		return mBuffer;
+	}
+	
+	@Override
+	protected void finalize() throws Throwable {
+		release();
+	}
+	
+    /**
+     * release handle in native
+     */
+	public void release(){
+		if(mCvFaceHandle == 0){
+			return;
+		}
+		mBuffer = null;
+		releaseHandle();
+		mCvFaceHandle = 0;
+	}
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceHandleBase.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/filter/IFaceFilter.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/filter/IFaceFilter.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/filter/IFaceFilter.java	(revision 6857)
@@ -0,0 +1,9 @@
+package com.sensetime.faceapi.filter;
+
+import com.sensetime.faceapi.model.FaceInfo;
+
+public interface IFaceFilter {
+
+	boolean onFilter(FaceInfo faceInfo , int width, int height);
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/filter/IFaceFilter.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/filter/FaceFilterGroup.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/filter/FaceFilterGroup.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/filter/FaceFilterGroup.java	(revision 6857)
@@ -0,0 +1,47 @@
+package com.sensetime.faceapi.filter;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.sensetime.faceapi.model.FaceInfo;
+
+import android.util.Log;
+
+public class FaceFilterGroup implements IFaceFilter{
+	private static final boolean DEBUG = true;
+	private static final String TAG = "FaceFilterGroup";
+	private List<IFaceFilter> mFaceFilters = new ArrayList<IFaceFilter>();
+	
+	public void addFilter(IFaceFilter filter){
+		if(filter == null){
+			Log.w(TAG, "addFilter filter is null !");
+			return;
+		}
+		mFaceFilters.add(filter);
+	}
+	
+	public void removeFilter(IFaceFilter filter){
+		if(filter == null){
+			Log.w(TAG, "removeFilter filter is null !");
+			return;
+		}
+		mFaceFilters.add(filter);
+	}
+
+	@Override
+	public boolean onFilter(FaceInfo faceInfo, int width, int height) {
+		if(mFaceFilters == null || mFaceFilters.size() == 0){
+			Log.w(TAG, "onFilter mFaceFilters is empty !");
+			return true;
+		}
+		for(IFaceFilter filter: mFaceFilters){
+			if(!filter.onFilter(faceInfo, width, height)){
+				return false;
+			}
+		}
+		return true;
+	}
+	
+	
+	
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/filter/FaceFilterGroup.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceDetect.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceDetect.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceDetect.java	(revision 6857)
@@ -0,0 +1,144 @@
+package com.sensetime.faceapi;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.util.Log;
+
+import com.sensetime.faceapi.model.FaceConfig;
+import com.sensetime.faceapi.model.FaceInfo;
+import com.sensetime.faceapi.model.FaceOrientation;
+import com.sensetime.faceapi.model.CvPixelFormat;
+import com.sensetime.faceapi.utils.ColorConvertUtil;
+
+/**
+ * 人脸检测
+ */
+public class FaceDetect extends FaceHandleBase {
+
+    private static final boolean DEBUG = true;
+    private static final String TAG = "FaceDetect";
+
+    public FaceDetect() {
+        this(null, null, null);
+    }
+
+    public FaceDetect(FaceConfig.FaceImageResize resize, FaceConfig.FaceKeyPointCount pointCount) {
+        this(null, resize, pointCount);
+    }
+
+    /**
+     * @param modelPath  detect模型文件的路径
+     * @param resize     resize图片的大小 {@link FaceConfig.FaceImageResize}
+     * @param pointCount 关键点的数量 {@link FaceConfig.FaceKeyPointCount}
+     */
+    public FaceDetect(String modelPath, FaceConfig.FaceImageResize resize, FaceConfig.FaceKeyPointCount
+            pointCount) {
+        if (resize == null) {
+            resize = FaceConfig.FaceImageResize.DEFAULT_CONFIG;
+        }
+        if (pointCount == null) {
+            pointCount = FaceConfig.FaceKeyPointCount.POINT_COUNT_21;
+        }
+        int config = resize.getValue() | pointCount.getValue();
+        init(modelPath, config);
+    }
+
+    /**
+     * Initialize the Native Handler
+     */
+    private void init(String modelPath, int config) {
+        mCvFaceHandle = FaceLibrary.cvFaceCreateDetector(modelPath, config);
+    }
+
+    public float getFaceThreshold() {
+        return FaceLibrary.getDetectThreshold(mCvFaceHandle, mResultCode);
+    }
+
+    public void setFaceThreshold(float threshold) {
+        FaceLibrary.setDetectThreshold(mCvFaceHandle, threshold, mResultCode);
+        checkResultCode(mResultCode[0]);
+    }
+
+    /**
+     * @see #detect(Bitmap, FaceOrientation)
+     */
+    public FaceInfo[] detect(Bitmap image) {
+        return detect(image, FaceOrientation.UP);
+    }
+
+    /**
+     * @see #detect(Bitmap, FaceOrientation, byte[])
+     */
+    public FaceInfo[] detect(Bitmap image, FaceOrientation orientation) {
+        return detect(image, orientation, null);
+    }
+
+    /**
+     * @see #detect(byte[], CvPixelFormat, int, int, int, FaceOrientation)
+     */
+    public FaceInfo[] detect(Bitmap image, FaceOrientation orientation, byte[] buffer) {
+        if (image == null || image.isRecycled()) {
+            if (DEBUG) {
+                Log.w(TAG, "detect image is null or recycled");
+            }
+            return null;
+        }
+        if (image.getConfig() != Config.ARGB_8888) {
+            image = image.copy(Config.ARGB_8888, false);
+        }
+        if (buffer == null) {
+            buffer = createBufferIfNeed(image.getWidth(), image.getHeight());
+        }
+        ColorConvertUtil.getBGRFromBitmap(image, buffer);
+        return detect(buffer, CvPixelFormat.BGR888, image.getWidth(), image.getHeight(), image.getWidth() * 3,
+                orientation);
+    }
+
+    /**
+     * Given the Image by Int Array to detect face
+     *
+     * @param colorImage    Input image color int[] 输入的图片
+     * @param cvPixelFormat Input image cvImageFormat which you can select the value from CvImageFormat Class 图片格式
+     * @param imageWidth    Input image Width 图片宽度
+     * @param imageHeight   Input image Height 图片高度
+     * @param imageStride   Input bytes of rows 图片跨度，即每行有多少个字节数
+     * @param orientation   Input image orientation 图片方向
+     * @return FaceInfo array, each one in array is detected by SDK native API
+     */
+    public FaceInfo[] detect(int[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight,
+                             int imageStride, FaceOrientation orientation) {
+        FaceInfo[] faces = FaceLibrary.cvFaceDetectInts(mCvFaceHandle, colorImage, cvPixelFormat.getValue(),
+                imageWidth, imageHeight, imageStride, orientation.getValue(), mResultCode);
+        checkResultCode();
+        return faces;
+    }
+
+    /**
+     * Given the Image by Byte Array to detect face
+     *
+     * @param colorImage    Input image color byte[] 输入的图片
+     * @param cvPixelFormat Input image cvImageFormat which you can select the value from CvImageFormat Class 图片格式
+     * @param imageWidth    Input image Width 图片宽度
+     * @param imageHeight   Input image Height 图片高度
+     * @param imageStride   Input bytes of rows 图片跨度，即每行有多少个字节数
+     * @param orientation   Input image orientation 图片方向
+     * @return FaceInfo array, each one in array is detected by SDK native API
+     */
+    public FaceInfo[] detect(byte[] colorImage, CvPixelFormat cvPixelFormat, int imageWidth, int imageHeight,
+                             int imageStride, FaceOrientation orientation) {
+        FaceInfo[] faces = FaceLibrary.cvFaceDetectBytes(mCvFaceHandle, colorImage, cvPixelFormat.getValue(),
+                imageWidth, imageHeight, imageStride, orientation.getValue(), mResultCode);
+        checkResultCode();
+        return faces;
+    }
+
+    public static void showInsideModel() {
+        FaceLibrary.cvFaceShowInsideModel();
+    }
+
+    @Override
+    protected void releaseHandle() {
+        FaceLibrary.cvFaceDestroyDetector(mCvFaceHandle);
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceapi/FaceDetect.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/handler/WeakHandler.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/handler/WeakHandler.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/handler/WeakHandler.java	(revision 6857)
@@ -0,0 +1,30 @@
+package com.sensetime.faceunlock.handler;
+
+import android.app.Activity;
+import android.os.Handler;
+import android.os.Message;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * 弱引用封装的Handler，避免内存泄漏的发生
+ */
+public abstract class WeakHandler<T extends Activity> extends Handler {
+
+    protected final WeakReference<T> weakReference;
+
+    public WeakHandler(T act) {
+        weakReference = new WeakReference<>(act);
+    }
+
+    public abstract void handleMsg(T act, Message msg);
+
+    @Override
+    public void handleMessage(Message msg) {
+        T act = weakReference.get();
+        if (act != null) {
+            handleMsg(act, msg);
+        }
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/handler/WeakHandler.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/PdUtils.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/PdUtils.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/PdUtils.java	(revision 6857)
@@ -0,0 +1,83 @@
+package com.sensetime.faceunlock.util;
+
+import android.hardware.Camera;
+import android.util.Log;
+import java.io.FileDescriptor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import com.sensetime.faceunlock.util.ShareMemory;
+
+/**
+ * Created by shaoxiaofei on 17/09/2017.
+ * 处理2pd图像
+ */
+
+public class PdUtils {
+    private final static String TAG = "PdUtils";
+
+    private final static int RAW_DATA_WIDTH = 8064;
+    private final static int RAW_DATA_HEIGHT = 756;
+    /**
+     * 混合数据长度
+     */
+    public static final int MIXED_DATA_LENGTH = RAW_DATA_WIDTH * RAW_DATA_HEIGHT + 640 * 480 * 3 / 2;
+
+    /**
+     * PD RAW 数据位置
+     */
+    public static final int PD_RAW_OFFSET = 0;
+
+    /**
+     * PD RAW 数据长度
+     */
+    public static final int PD_RAWDATA_LENGTH = RAW_DATA_WIDTH * RAW_DATA_HEIGHT;
+
+    /**
+     * PREVIEW数据位置
+     */
+    public static final int PREVIEW_OFFSET = PD_RAW_OFFSET + PD_RAWDATA_LENGTH;
+
+    /**
+     * PREVIEW 数据长度
+     */
+    public static final int PREVIEW_DATA_LENGTH = 640 * 480 * 3 / 2;
+
+    public static byte[] getPdData(Camera camera) {
+        if (camera == null) return null;
+        byte[] pdData = null;
+
+        ShareMemory memory = null;
+        Class cls = Camera.class;
+        try {
+            Method methodGetPDData = cls.getMethod("getPDdata");
+            FileDescriptor fd = (FileDescriptor) methodGetPDData.invoke(camera);
+            memory = new ShareMemory(fd, MIXED_DATA_LENGTH);
+        } catch (NoSuchMethodException e) {
+            Log.e(TAG, "error", e);
+        } catch (InvocationTargetException e) {
+            Log.e(TAG, "error", e);
+        } catch (IllegalAccessException e) {
+            Log.e(TAG, "error", e);
+        }
+
+        if (memory != null && memory.getSize() == MIXED_DATA_LENGTH) {
+            pdData = memory.readData(MIXED_DATA_LENGTH);
+            Log.d(TAG, "Length of PDData" + pdData.length);
+        }
+
+        //Test code to verify that whether it is correct.
+        if (pdData != null && pdData.length == MIXED_DATA_LENGTH) {
+
+            Log.d(TAG, "PDData: " + String.format("%02x", pdData[PD_RAW_OFFSET]) + ","
+                    + String.format("%02x", pdData[PD_RAW_OFFSET + PD_RAWDATA_LENGTH - 1]) + " | "
+                    + String.format("%02x", pdData[PREVIEW_OFFSET]) + ","
+                    + String.format("%02x", pdData[PREVIEW_OFFSET + PREVIEW_DATA_LENGTH - 1]));
+        }
+
+        //must be release other will
+        if (memory != null) {
+            memory.releaseShareMemory();
+        }
+        return pdData;
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/PdUtils.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/SharedUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/SharedUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/SharedUtil.java	(revision 6857)
@@ -0,0 +1,207 @@
+package com.sensetime.faceunlock.util;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+
+import java.util.Map;
+
+
+/**
+ * Save Data To SharePreference Or Get Data from SharePreference
+ * 
+ * @author wanglx
+ *通过SharedPreferences来存储数据，自定义类型
+ */
+public class SharedUtil {
+	private static String TAG = "PushSharePreference";
+	private Context ctx;
+	private String FileName = "YueSuoPing";
+ 
+	public SharedUtil(Context ctx) {
+		this.ctx = ctx.getApplicationContext();
+	}
+
+	/**
+	 * Set int value into SharePreference
+	 * 
+	 * @param
+	 * @param key
+	 * @param value
+	 */
+	//通过SharedPreferences来存储键值对
+	public void saveIntValue(String key, int value) {
+		SharedPreferences sharePre = ctx.getSharedPreferences(FileName,
+				Context.MODE_PRIVATE);
+		SharedPreferences.Editor editor = sharePre.edit();
+		editor.putInt(key, value);
+		editor.commit();
+	}
+
+    /**
+     * Set int value into SharePreference
+     *
+     * @param key
+     * @param value
+     */
+    //通过SharedPreferences来存储键值对
+    public void saveLongValue(String key, long value) {
+        SharedPreferences sharePre = ctx.getSharedPreferences(FileName,
+          Context.MODE_PRIVATE);
+        SharedPreferences.Editor editor = sharePre.edit();
+        editor.putLong(key, value);
+        editor.commit();
+    }
+
+	public void writeDownStartApplicationTime() {
+		SharedPreferences sp = ctx.getSharedPreferences(FileName, Context.MODE_PRIVATE);
+		long now = System.currentTimeMillis();
+//		Calendar calendar = Calendar.getInstance();
+		//Date now = calendar.getTime();
+//		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd:hh-mm-ss");
+		SharedPreferences.Editor editor = sp.edit();
+		//editor.putString("启动时间", now.toString());
+		editor.putLong("nowtimekey", now);
+		editor.commit();
+		
+	}
+
+	/**
+	 * Set Boolean value into SharePreference
+	 * 
+	 * @param
+	 * @param key
+	 * @param value
+	 */
+	public void saveBooleanValue(String key, boolean value) {
+		SharedPreferences sharePre = ctx.getSharedPreferences(FileName,
+				Context.MODE_PRIVATE);
+		SharedPreferences.Editor editor = sharePre.edit();
+		editor.putBoolean(key, value);
+		editor.commit();
+	}
+
+	/**
+	 * Remove key from SharePreference
+	 * 
+	 * @param key
+	 */
+	public void removeSharePreferences(String key) {
+		SharedPreferences sharePre = ctx.getSharedPreferences(FileName,
+				Context.MODE_PRIVATE);
+		SharedPreferences.Editor editor = sharePre.edit();
+		editor.remove(key);
+		editor.commit();
+	}
+
+	/**
+	 *  
+	 * 
+	 * @param key
+	 * @return
+	 */
+	public boolean contains(String key) {
+		SharedPreferences sharePre = ctx.getSharedPreferences(FileName,
+				Context.MODE_PRIVATE);
+		return sharePre.contains(key);
+	}
+
+	/**
+	 * Get all value
+	 * 
+	 * @return
+	 */
+	@SuppressWarnings("unchecked")
+	public Map<String, Object> getAllMap() {
+		SharedPreferences sharePre = ctx.getSharedPreferences(FileName,
+				Context.MODE_PRIVATE);
+		return (Map<String, Object>) sharePre.getAll();
+	}
+
+	/**
+	 * Get Integer Value
+	 * 
+	 * @param key
+	 * @return
+	 */
+	public Integer getIntValueByKey(String key) {
+		SharedPreferences sharePre = ctx.getSharedPreferences(FileName,
+				Context.MODE_PRIVATE);
+		return sharePre.getInt(key, -1);
+	}
+
+    /**
+     * Get Integer Value
+     *
+     * @param fileName
+     * @param key
+     * @return
+     */
+    public Long getLongValueByKey(String key) {
+        SharedPreferences sharePre = ctx.getSharedPreferences(FileName,
+          Context.MODE_PRIVATE);
+        return sharePre.getLong(key, -1);
+    }
+
+
+	/**
+	 * Set String value into SharePreference
+	 * 
+	 * @param key
+	 * @param value
+	 */
+	public void saveStringValue(String key, String value) {
+		SharedPreferences sharePre = ctx.getSharedPreferences(FileName,
+				Context.MODE_PRIVATE);
+		SharedPreferences.Editor editor = sharePre.edit();
+		editor.putString(key, value);
+		editor.commit();
+	}
+	
+	/**
+	 * Get String Value
+	 * 通过输入的key来获得userid
+	 * @param key
+	 * @return
+	 */
+	public String getStringValueByKey(String key) {
+		SharedPreferences sharePre = ctx.getSharedPreferences(FileName,
+				Context.MODE_PRIVATE);
+		return sharePre.getString(key, null);
+	}
+
+	public Boolean getBooleanValueByKey(String key) {
+		SharedPreferences sharePre = ctx.getSharedPreferences(FileName,
+				Context.MODE_PRIVATE);
+		return sharePre.getBoolean(key, false);
+	}
+
+	/**
+	 * Get Value, Remove key
+	 * 
+	 * @param key
+	 * @return
+	 */
+	public Integer getIntValueAndRemoveByKey(String key) {
+		Integer value = getIntValueByKey(key);
+		removeSharePreferences(key);
+		return value;
+	}
+
+	/**
+	 * 设置userkey
+	 * 
+	 * @param userkey
+	 */
+	public void setUserkey(String userkey) {
+		this.saveStringValue("params_userkey", userkey);
+	}
+
+	/**
+	 * 获取userkey
+	 * 
+	 */
+	public String getUserkey() {
+		return this.getStringValueByKey("params_userkey");
+	}
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/SharedUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/BrightnessHelper.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/BrightnessHelper.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/BrightnessHelper.java	(revision 6857)
@@ -0,0 +1,48 @@
+package com.sensetime.faceunlock.util;
+
+import android.provider.Settings;
+import android.util.Log;
+import android.content.Context;
+
+/**
+ * Created by Administrator on 2017/7/11 14:31.
+ * email: huan.fu@gometech.com.cn
+ */
+
+public class BrightnessHelper {
+    //得到屏幕亮度调节模式
+    public static int getScreenMode(Context context) {
+        int screenMode = 0;
+        try {
+            screenMode = Settings.System.getInt(context.getContentResolver(),
+                    Settings.System.SCREEN_BRIGHTNESS_MODE);
+        } catch (Settings.SettingNotFoundException e) {
+            e.printStackTrace();
+        }
+        return screenMode;
+    }
+
+    //设置屏幕亮度调节模式
+    public static void setScreenMode(Context context,int mode) {
+        Settings.System.putInt(context.getContentResolver(),
+                Settings.System.SCREEN_BRIGHTNESS_MODE, mode);
+    }
+
+    //获取屏幕亮度
+    public static int getScreenBrightness(Context context) {
+        int screenBrightness = 0;
+        try {
+            screenBrightness = Settings.System.getInt(context.getContentResolver(),
+                    Settings.System.SCREEN_BRIGHTNESS);
+        } catch (Settings.SettingNotFoundException e) {
+            e.printStackTrace();
+        }
+        return screenBrightness;
+    }
+
+    //设置屏幕亮度
+    public static void setScreenBrightness(Context context,int value) {
+        Settings.System.putInt(context.getContentResolver(),
+                Settings.System.SCREEN_BRIGHTNESS, value);
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/BrightnessHelper.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/DirectUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/DirectUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/DirectUtil.java	(revision 6857)
@@ -0,0 +1,46 @@
+package com.sensetime.faceunlock.util;
+
+import com.sensetime.faceapi.model.FaceInfo;
+
+public class DirectUtil {
+
+    /**
+     * 5方向的人脸
+     */
+    public static int getFiveDirect(FaceInfo face) {
+        if (isCenter(face)) {
+            return 0;
+        } else if (isTop(face)) {
+            return 1;
+        } else if (isRight(face)) {
+            return 4;
+        } else if (isBottom(face)) {
+            return 2;
+        } else if (isLeft(face)) {
+            return 3;
+        } else {
+            return -1;
+        }
+    }
+
+    private static boolean isTop(FaceInfo face) {
+        return face.pitch < -10 && Math.abs(face.yaw) < 10;
+    }
+
+    private static boolean isCenter(FaceInfo face) {
+        return Math.abs(face.pitch) < 5 && Math.abs(face.yaw) < 10;
+    }
+
+    private static boolean isBottom(FaceInfo face) {
+        return face.pitch > 10 && Math.abs(face.yaw) < 10;
+    }
+
+    private static boolean isLeft(FaceInfo face) {
+        return face.yaw < -15 && Math.abs(face.pitch) < 10;
+    }
+
+    private static boolean isRight(FaceInfo face) {
+        return face.yaw > 15 && Math.abs(face.pitch) < 10;
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/DirectUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/AbstractCameraUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/AbstractCameraUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/AbstractCameraUtil.java	(revision 6857)
@@ -0,0 +1,116 @@
+package com.sensetime.faceunlock.util;
+
+import android.app.Activity;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.ImageFormat;
+import android.graphics.Matrix;
+import android.graphics.Rect;
+import android.graphics.YuvImage;
+import android.hardware.Camera;
+import android.view.SurfaceHolder;
+
+import java.io.ByteArrayOutputStream;
+import java.util.HashMap;
+
+/**
+ * Created by zhangjiakang on 2017/11/29.
+ */
+
+public abstract class AbstractCameraUtil {
+
+    protected int width = 480;
+    protected int height = 640;
+    protected int angle = 90;
+    /**
+     * 开始检测，接收数据回调
+     * @param callback 回调
+     */
+   // public void actionDetect(IPreviewCallback callback) {};
+
+    /**
+     * 开启preview
+     * @param surfaceHolder
+     */
+    public void startPreview(SurfaceHolder surfaceHolder) {};
+
+    /**
+     * 停止preview
+     */
+    public void stopPreview() {};
+
+
+    /**
+     * 关闭camera
+     */
+    public void closeCamera() {};
+    /**
+     * 打开相机
+     */
+    public void openCamera(boolean isBackCamera, Activity activity,
+                      HashMap<String, Integer> resolutionMap) {};
+
+    /**
+     * 获取宽度
+     * @return
+     */
+    public int getWidth() { return width; }
+
+    /**
+     * 获取角度
+     * @return
+     */
+    public int getAngle() { return angle; }
+
+    /**
+     * 获取高度
+     * @return
+     */
+    public int getHeight() { return height; }
+
+    /**
+     * 设置展示朝向
+     * @param angle
+     */
+    public void setDisplayOrientation(int angle) {};
+
+    /**
+     * 根据yuv图像得到bitmap(用于保存底库图片）
+     * @param data YUV数据
+     * @param roi  图像矩形
+     * @param angle 图像旋转角度
+     * @param isBackCamera 是否是后置摄像头拍摄的图像
+     * @return 图像的Bitmap
+     */
+    public Bitmap getBitMap(byte[] data, Rect roi, int angle, boolean isBackCamera) {
+        YuvImage yuvImage = new YuvImage(data, ImageFormat.NV21, width, height, null);
+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+        yuvImage.compressToJpeg(new Rect(0, 0, width, height), 80,
+                byteArrayOutputStream);
+        byte[] jpegData = byteArrayOutputStream.toByteArray();
+        // 获取照相后的bitmap
+        Bitmap tmpBitmap = BitmapFactory.decodeByteArray(jpegData, 0,
+                jpegData.length);
+        Matrix matrix = new Matrix();
+        matrix.reset();
+        matrix.preRotate(angle);
+        if (!isBackCamera) {
+            matrix.preScale(-1.0f, 1.0f);
+        }
+        tmpBitmap = Bitmap.createBitmap(tmpBitmap, roi.left, roi.top, roi.width(),
+                roi.height(), matrix, true);
+        tmpBitmap = tmpBitmap.copy(Bitmap.Config.ARGB_8888, true);
+
+//		int hight = tmpBitmap.getHeight() > tmpBitmap.getWidth() ? tmpBitmap
+//				.getHeight() : tmpBitmap.getWidth();
+//
+//		float scale = hight / 800.0f;
+//
+//		if (scale > 1) {
+//			tmpBitmap = Bitmap.createScaledBitmap(tmpBitmap,
+//					(int) (tmpBitmap.getWidth() / scale),
+//					(int) (tmpBitmap.getHeight() / scale), false);
+//		}
+        return tmpBitmap;
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/AbstractCameraUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/BitmapUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/BitmapUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/BitmapUtil.java	(revision 6857)
@@ -0,0 +1,55 @@
+package com.sensetime.faceunlock.util;
+
+import android.graphics.Bitmap;
+import android.graphics.Matrix;
+import android.graphics.Rect;
+
+import com.sensetime.faceapi.utils.ColorConvertUtil;
+
+public class BitmapUtil {
+
+    public static Bitmap cropBitmap(byte[] nv21, Rect rect, int previewWidth, int previewHeight) {
+        Rect scaleRect = BitmapUtil.getScaleRect(rect, 2, 2, previewWidth, previewHeight);
+        int cropWidth = scaleRect.width();
+        int cropHeight = scaleRect.height();
+        int startX = scaleRect.left % 2 == 0 ? scaleRect.left : scaleRect.left + 1;
+        int startY = scaleRect.top % 2 == 0 ? scaleRect.top : scaleRect.top + 1;
+        if (cropWidth % 2 != 0) {
+            cropWidth -= 1;
+        }
+        if (cropHeight % 2 != 0) {
+            cropHeight -= 1;
+        }
+        Bitmap cropBitmap = ColorConvertUtil.cropNv21ToBitmap(nv21, previewWidth, previewHeight, startX, startY,
+                cropWidth, cropHeight);
+        return cropBitmap;
+    }
+
+    public static Rect getScaleRect(Rect rect, float scaleX, float scaleY, int maxW, int maxH) {
+        Rect resultRect = new Rect();
+        int left = (int) (rect.left - rect.width() * (scaleX - 1) / 2);
+        int right = (int) (rect.right + rect.width() * (scaleX - 1) / 2);
+        int bottom = (int) (rect.bottom + rect.height() * (scaleY - 1) / 2);
+        int top = (int) (rect.top - rect.height() * (scaleY - 1) / 2);
+        resultRect.left = left > 0 ? left : 0;
+        resultRect.right = right > maxW ? maxW : right;
+        resultRect.bottom = bottom > maxH ? maxH : bottom;
+        resultRect.top = top > 0 ? top : 0;
+        return resultRect;
+    }
+
+    public static Bitmap rotateBitmap(Bitmap sourceBitmap, int degree, boolean frontCamera) {
+        if (degree == 0 && frontCamera == false) {
+            return sourceBitmap;
+        }
+        Matrix matrix = new Matrix();
+        matrix.postRotate(degree);
+        if (frontCamera) {
+            matrix.postScale(-1, 1);
+        }
+        Bitmap rotaBitmap = Bitmap.createBitmap(sourceBitmap, 0, 0, sourceBitmap.getWidth(), sourceBitmap.getHeight()
+                , matrix, false);
+        return rotaBitmap;
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/BitmapUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/ShareMemory.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/ShareMemory.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/ShareMemory.java	(revision 6857)
@@ -0,0 +1,82 @@
+package com.sensetime.faceunlock.util;
+
+import android.os.MemoryFile;
+import android.util.Log;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+
+/** @hide */
+public class ShareMemory {
+    private static final String TAG = ShareMemory.class.getSimpleName();
+    private MemoryFile shareMemory;
+
+    public ShareMemory(String name, int length)throws IOException {
+        shareMemory = new MemoryFile(name, length);
+    }
+    public ShareMemory(FileDescriptor fd, int length){
+        try{
+            Class clz = MemoryFile.class;
+            Constructor cstr = clz.getConstructor(FileDescriptor.class,int.class);
+            shareMemory = (MemoryFile) cstr.newInstance(fd,length);
+        }catch(Exception e){
+            Log.d(TAG,"new share memory error ",e);
+        }
+    }        
+    public boolean writeData(byte[] data){
+        try{
+            if (shareMemory  != null && data != null && data.length > 0) {
+                shareMemory.writeBytes(data, 0, 0, data.length);
+                return true;
+            }
+        }catch(Exception e){
+            Log.i(TAG,"write share memory exception",e);
+        }
+        return false;
+    }
+
+    public byte[] readData(int length){
+        try{
+            if (shareMemory  != null) {
+                byte[] buffer = new byte[length];
+                shareMemory.readBytes(buffer, 0, 0, length);
+                return buffer;
+            }
+        }catch(Exception e){
+            Log.i(TAG,"read share memory exception",e);
+        }
+        return null;
+    }
+
+
+    public int getSize(){
+        try{
+            if(shareMemory != null){
+                return shareMemory.length();
+            }else{
+                return 0;
+            }
+        }catch(Exception e){
+            Log.i(TAG,"read share memory exception",e);
+        }
+        return 0;
+    }
+    public void clearData(){
+        if(shareMemory != null){
+            final int size = getSize();
+            byte[] zero = new byte[size];
+            try{
+                shareMemory.writeBytes(zero,0,0,size);
+            }catch(Exception e){
+                Log.e(TAG,"clear data error",e);
+            }
+        }
+    }
+
+    public void releaseShareMemory(){
+        if(shareMemory != null){
+            shareMemory.close();
+        }
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/ShareMemory.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/FaceUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/FaceUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/FaceUtil.java	(revision 6857)
@@ -0,0 +1,63 @@
+package com.sensetime.faceunlock.util;
+
+import android.graphics.Rect;
+import android.util.Log;
+
+import com.sensetime.faceapi.model.CvPixelFormat;
+import com.sensetime.faceapi.model.FaceInfo;
+import com.sensetime.faceapi.utils.BrightnessUtil;
+
+public class FaceUtil {
+
+    private static final String TAG = "FaceUtil";
+    private static final float MIN_BRIGHT = 0.14f;
+
+    /**
+     * 得到最大人脸
+     */
+    public static FaceInfo getMaxFace(FaceInfo[] faces) {
+        if (faces == null || faces.length <= 0) {
+            return null;
+        }
+        FaceInfo faceInfo = null;
+        for (int i = 0; i < faces.length; i++) {
+            if (faceInfo == null || faces[i].faceRect.width() > faceInfo.faceRect.width()) {
+                faceInfo = faces[i];
+            }
+        }
+        return faceInfo;
+    }
+
+    /**
+     * 亮度过滤
+     */
+    public static FaceInfo brightnessFilter(byte[] nv21, int width, int height, FaceInfo faceInfo) {
+        float bright = BrightnessUtil.averageBrightness(nv21, CvPixelFormat.NV21, width, height, faceInfo);
+        LogUtil.d(TAG, "filterFaces bright : " + bright);
+        if (bright < MIN_BRIGHT) {
+            LogUtil.w(TAG, "this face brightness is illegal !");
+            return null;
+        }
+        return faceInfo;
+    }
+
+    public static boolean isFrontFace(FaceInfo faceInfo) {
+        return Math.abs(faceInfo.pitch) < 15 && Math.abs(faceInfo.yaw) < 25;
+    }
+
+    /**
+     * 判断人脸是否在预览框内
+     *
+     * @param faceInfo 人脸信息
+     * @param width    预览宽度
+     * @param height   预览高度
+     * @return
+     */
+    public static boolean containFace(FaceInfo faceInfo, int width, int height) {
+        FaceInfo clone = faceInfo.clone();
+        int tolerantWidth = clone.faceRect.width() / 8;
+        Rect containerRect = new Rect(-tolerantWidth, -tolerantWidth, width + tolerantWidth, height + tolerantWidth);
+        return containerRect.contains(clone.faceRect);
+    }
+
+}
\ No newline at end of file

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/FaceUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/ConUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/ConUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/ConUtil.java	(revision 6857)
@@ -0,0 +1,555 @@
+package com.sensetime.faceunlock.util;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.Context;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.Rect;
+import android.graphics.YuvImage;
+import android.hardware.Camera;
+import android.media.Image;
+import android.net.wifi.WifiInfo;
+import android.net.wifi.WifiManager;
+import android.os.Environment;
+import android.os.PowerManager;
+import android.telephony.TelephonyManager;
+import android.util.Base64;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.WindowManager;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.Toast;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.UUID;
+
+public class ConUtil {
+
+	public static String getJsonString(HashMap<String, byte[]> featureMap) {
+		try {
+			JSONObject jsonObject = new JSONObject(featureMap);
+			return jsonObject.toString();
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+		return null;
+	}
+
+	public static void initFeatureMap(String jsonStr) {
+		if (jsonStr == null)
+			return;
+		try {
+			JSONObject jsonObject = new JSONObject(jsonStr);
+			Iterator<String> keys = jsonObject.keys();// 定义迭代器
+			while (keys.hasNext()) {
+				String key = keys.next();
+				JSONArray jsonArray = (JSONArray) jsonObject.get(key);
+				byte[] value = new byte[jsonArray.length()];
+				for (int i = 0; i < jsonArray.length(); i++) {
+					value[i] = (byte) jsonArray.getDouble(i);
+				}
+				Log.w("test", "key ::" + key);
+				Log.w("test", "value ::" + value.toString());
+				Util.featureMap.put(key, value);
+			}
+		} catch (JSONException e) {
+			e.printStackTrace();
+		}
+	}
+
+	public static Bitmap getBitMap(byte[] data, Camera camera, int Angle) {
+
+		int width = camera.getParameters().getPreviewSize().width;
+		int height = camera.getParameters().getPreviewSize().height;
+		if (Angle == 90 || Angle == 270) {
+			height = camera.getParameters().getPreviewSize().width;
+			width = camera.getParameters().getPreviewSize().height;
+		}
+		YuvImage yuvImage = new YuvImage(data, camera.getParameters().getPreviewFormat(), width, height, null);
+		ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+		yuvImage.compressToJpeg(new Rect(0, 0, width, height), 100, byteArrayOutputStream);
+		byte[] jpegData = byteArrayOutputStream.toByteArray();
+		// 获取照相后的bitmap
+		Bitmap tmpBitmap = BitmapFactory.decodeByteArray(jpegData, 0, jpegData.length);
+		tmpBitmap = tmpBitmap.copy(Config.ARGB_8888, true);
+		return tmpBitmap;
+	}
+
+	public static boolean isReadKey(Context context) {
+		InputStream inputStream = null;
+		ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+		byte[] buffer = new byte[1024];
+		int count = -1;
+		try {
+			inputStream = context.getAssets().open("key");
+			while ((count = inputStream.read(buffer)) != -1) {
+				byteArrayOutputStream.write(buffer, 0, count);
+			}
+			byteArrayOutputStream.close();
+		} catch (IOException e) {
+			e.printStackTrace();
+		} finally {
+			if (inputStream != null) {
+				try {
+					inputStream.close();
+				} catch (IOException e) {
+					e.printStackTrace();
+				}
+			}
+		}
+		String str = new String(byteArrayOutputStream.toByteArray());
+		String key = null;
+		String screct = null;
+		try {
+			String[] strs = str.split(";");
+			key = strs[0].trim();
+			screct = strs[1].trim();
+		} catch (Exception e) {
+		}
+		Util.API_KEY = key;
+		Util.API_SECRET = screct;
+		if (Util.API_KEY == null || Util.API_SECRET == null)
+			return false;
+
+		return true;
+	}
+
+	/**
+	 * 时间格式化(格式到秒)
+	 */
+	public static String getFormatterDate(long time) {
+		Date d = new Date(time);
+		SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");
+		String data = formatter.format(d);
+		return data;
+	}
+
+	public static String getUUIDString(Context mContext) {
+		String KEY_UUID = "key_uuid";
+		SharedUtil sharedUtil = new SharedUtil(mContext);
+		String uuid = sharedUtil.getStringValueByKey(KEY_UUID);
+		if (uuid != null)
+			return uuid;
+
+		uuid = getPhoneNumber(mContext);
+
+		if (uuid == null || uuid.trim().length() == 0) {
+			uuid = getMacAddress(mContext);
+			if (uuid == null || uuid.trim().length() == 0) {
+				uuid = getDeviceID(mContext);
+				if (uuid == null || uuid.trim().length() == 0) {
+					uuid = UUID.randomUUID().toString();
+					uuid = Base64.encodeToString(uuid.getBytes(), Base64.DEFAULT);
+				}
+			}
+		}
+		sharedUtil.saveStringValue(KEY_UUID, uuid);
+		return uuid;
+	}
+
+	// public static byte[] readModel(Context context) {
+	// InputStream inputStream = null;
+	// ByteArrayOutputStream byteArrayOutputStream = new
+	// ByteArrayOutputStream();
+	// byte[] buffer = new byte[1024];
+	// int count = -1;
+	// try {
+	// inputStream =
+	// context.getResources().openRawResource(R.raw.megviifacepp_0_3_1_model);
+	// while ((count = inputStream.read(buffer)) != -1) {
+	// byteArrayOutputStream.write(buffer, 0, count);
+	// }
+	// byteArrayOutputStream.close();
+	// } catch (IOException e) {
+	// e.printStackTrace();
+	// } finally {
+	// if (inputStream != null) {
+	// try {
+	// inputStream.close();
+	// } catch (IOException e) {
+	// e.printStackTrace();
+	// }
+	// }
+	// }
+	// return byteArrayOutputStream.toByteArray();
+	// }
+
+	public static String getPhoneNumber(Context mContext) {
+		TelephonyManager phoneMgr = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
+		return phoneMgr.getLine1Number();
+	}
+
+	public static String getDeviceID(Context mContext) {
+		TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
+		return tm.getDeviceId();
+	}
+
+	public static String getMacAddress(Context mContext) {
+		WifiManager wifi = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
+		WifiInfo info = wifi.getConnectionInfo();
+		String address = info.getMacAddress();
+		if (address != null && address.length() > 0) {
+			address = address.replace(":", "");
+		}
+		return address;
+	}
+
+	/**
+	 * 隐藏软键盘
+	 */
+	public static void isGoneKeyBoard(Activity activity) {
+		if (activity.getCurrentFocus() != null) {
+			// 隐藏软键盘
+			((InputMethodManager) activity.getSystemService(activity.INPUT_METHOD_SERVICE)).hideSoftInputFromWindow(
+					activity.getCurrentFocus().getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);
+		}
+	}
+
+	public static PowerManager.WakeLock wakeLock = null;
+
+	public static void acquireWakeLock(Context context) {
+		if (wakeLock == null) {
+			PowerManager powerManager = (PowerManager) (context.getSystemService(Context.POWER_SERVICE));
+			wakeLock = powerManager.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK, "My Tag");
+			wakeLock.acquire();
+		}
+	}
+
+	public static void releaseWakeLock() {
+		if (wakeLock != null && wakeLock.isHeld()) {
+			wakeLock.release();
+			wakeLock = null;
+		}
+	}
+
+	public static void setBrightness(Activity context, int brightness) {
+		WindowManager.LayoutParams lp = context.getWindow().getAttributes();
+		lp.screenBrightness = Float.valueOf(brightness) * (1f / 255f);
+		context.getWindow().setAttributes(lp);
+	}
+
+	public static int getBrightness(Activity context) {
+		WindowManager.LayoutParams lp = context.getWindow().getAttributes();
+		return (int)(lp.screenBrightness * 255);
+	}
+
+	/**
+	 * 获取bitmap的灰度图像
+	 */
+	public static byte[] getGrayscale(Bitmap bitmap) {
+		if (bitmap == null)
+			return null;
+
+		byte[] ret = new byte[bitmap.getWidth() * bitmap.getHeight()];
+		for (int j = 0; j < bitmap.getHeight(); ++j)
+			for (int i = 0; i < bitmap.getWidth(); ++i) {
+				int pixel = bitmap.getPixel(i, j);
+				int red = ((pixel & 0x00FF0000) >> 16);
+				int green = ((pixel & 0x0000FF00) >> 8);
+				int blue = pixel & 0x000000FF;
+				ret[j * bitmap.getWidth() + i] = (byte) ((299 * red + 587 * green + 114 * blue) / 1000);
+			}
+		return ret;
+	}
+
+    public static byte[] readFileInfo(String pathName) {
+        InputStream inputStream = null;
+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+
+        byte[] buffer = new byte[1024];
+        int count = -1;
+        try {
+            inputStream = new FileInputStream(pathName);
+            while ((count = inputStream.read(buffer)) != -1) {
+                byteArrayOutputStream.write(buffer, 0, count);
+            }
+            byteArrayOutputStream.close();
+        } catch (IOException e) {
+            return null;
+        } finally {
+            if (inputStream != null) {
+                try {
+                    inputStream.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        return byteArrayOutputStream.toByteArray();
+    }
+
+	public static byte[] getFileContent(Context context, int id) {
+		InputStream inputStream = null;
+		ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+		byte[] buffer = new byte[1024];
+		int count = -1;
+		try {
+			inputStream = context.getResources().openRawResource(id);
+			while ((count = inputStream.read(buffer)) != -1) {
+				byteArrayOutputStream.write(buffer, 0, count);
+			}
+			byteArrayOutputStream.close();
+		} catch (IOException e) {
+			return null;
+		} finally {
+			// closeStreamSilently(inputStream);
+			inputStream = null;
+		}
+		return byteArrayOutputStream.toByteArray();
+	}
+
+	private static Toast toast;
+
+	/**
+	 * 输出toast
+	 */
+	public static void showToast(Context context, String str) {
+		if (toast != null)
+			toast.cancel();
+		if (context != null) {
+			toast = Toast.makeText(context, str, Toast.LENGTH_SHORT);
+			// 可以控制toast显示的位置
+			toast.setGravity(Gravity.TOP, 0, 30);
+			toast.show();
+		}
+	}
+
+	/**
+	 * 输出长时间toast
+	 */
+	public static void showLongToast(Context context, String str) {
+		if (toast != null)
+			toast.cancel();
+		if (context != null) {
+			toast = Toast.makeText(context, str, Toast.LENGTH_LONG);
+			// 可以控制toast显示的位置
+			toast.setGravity(Gravity.TOP, 0, 30);
+			toast.show();
+		}
+	}
+
+	/**
+	 * 获取APP版本名
+	 */
+	public static String getVersionName(Context context) {
+		try {
+			String versionName = context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionName;
+			return versionName;
+		} catch (NameNotFoundException e) {
+			e.printStackTrace();
+			return null;
+		}
+	}
+
+	/**
+	 * 镜像旋转
+	 */
+	public static Bitmap convert(Bitmap bitmap, boolean mIsFrontalCamera) {
+		int w = bitmap.getWidth();
+		int h = bitmap.getHeight();
+		Bitmap newbBitmap = Bitmap.createBitmap(w, h, Config.ARGB_8888);// 创建一个新的和SRC长度宽度一样的位图
+		Canvas cv = new Canvas(newbBitmap);
+		Matrix m = new Matrix();
+		// m.postScale(1, -1); //镜像垂直翻转
+		if (mIsFrontalCamera) {
+			m.postScale(-1, 1); // 镜像水平翻转
+		}
+		// m.postRotate(-90); //旋转-90度
+		Bitmap bitmap2 = Bitmap.createBitmap(bitmap, 0, 0, w, h, m, true);
+		cv.drawBitmap(bitmap2, new Rect(0, 0, bitmap2.getWidth(), bitmap2.getHeight()), new Rect(0, 0, w, h), null);
+		return newbBitmap;
+	}
+
+	public static Bitmap bgr2bitmap(byte[] img, int width, int height) {
+		int[] tmp = new int[width * height];
+		for (int i = 0; i < width * height; ++i) {
+			int b = 0xff & ((int)img[3 * i]);
+			int g = 0xff & ((int)img[3 * i + 1]);
+			int r = 0xff & ((int)img[3 * i + 2]);
+			tmp[i] = (255 << 24) | (r << 16) | (g << 8) | (b);
+		}
+		return Bitmap.createBitmap(tmp, width, height, Config.ARGB_8888);
+	}
+
+	/**
+	 * 保存bitmap至指定Picture文件夹
+	 */
+	public static String saveBitmap(Context mContext, Bitmap bitmaptosave, String path, String name) {
+		if (bitmaptosave == null)
+			return null;
+
+		File mediaStorageDir = mContext.getExternalFilesDir("megvii");
+		File dir = new File(mediaStorageDir, path);
+
+		if (!dir.exists()) {
+			if (!dir.mkdirs()) {
+				return null;
+			}
+		}
+		String bitmapFileName =  name + ".png";
+		// String bitmapFileName = System.currentTimeMillis() + "";
+		File file = new File(dir, bitmapFileName);
+		FileOutputStream fos = null;
+		String ret = null;
+		try {
+			fos = new FileOutputStream(file);
+			boolean successful = bitmaptosave.compress(Bitmap.CompressFormat.PNG, 75, fos);
+
+			if (successful) ret = file.getAbsolutePath();
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		} finally {
+			try {
+				if (fos != null) fos.close();
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		return ret;
+	}
+
+    public static String saveNV21(Context mContext, byte[] data, int w, int h, String path, String name) {
+        if (data == null)
+            return null;
+
+        File mediaStorageDir = mContext.getExternalFilesDir("megvii");
+        File dir = new File(mediaStorageDir, path);
+
+        if (!dir.exists()) {
+            if (!dir.mkdirs()) {
+                return null;
+            }
+        }
+        String bitmapFileName = name + ".nv21." + w + "." + h;
+        // String bitmapFileName = System.currentTimeMillis() + "";
+        File file = new File(dir, bitmapFileName);
+        FileOutputStream fos = null;
+        String ret = null;
+        try {
+            fos = new FileOutputStream(file);
+            fos.write(data);
+            ret = file.getAbsolutePath();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            try {
+                if (fos != null) fos.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        return ret;
+    }
+
+	public static String saveRaw(Context context, int res, String path, String name) {
+		File dir = new File(context.getExternalFilesDir("megvii"), path);
+		if (!dir.exists()) {
+			if (!dir.mkdirs()) {
+				return null;
+			}
+		}
+		File file = new File(dir, name);
+
+		FileOutputStream fos = null;
+		InputStream is = null;
+		String ret = null;
+		try {
+			int count;
+			byte[] buffer = new byte[1024];
+			fos = new FileOutputStream(file);
+			is = context.getResources().openRawResource(res);
+			while ((count = is.read(buffer)) != -1) {
+				fos.write(buffer, 0, count);
+			}
+
+			ret = file.getAbsolutePath();
+		} catch (Exception e) {
+			e.printStackTrace();
+			return null;
+		} finally {
+			try {
+				if (fos != null) fos.close();
+				if (is != null) is.close();
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+		return ret;
+	}
+
+	public static String saveString(Context context, String content, String path, String name) {
+		File dir = new File(context.getExternalFilesDir("megvii"), path);
+		if (!dir.exists()) {
+			if (!dir.mkdirs()) return null;
+		}
+		File file = new File(dir, name);
+		FileOutputStream fos = null;
+		String ret = null;
+		try {
+			fos = new FileOutputStream(file);
+			fos.write(content.getBytes(Charset.forName("UTF-8")));
+
+			ret = file.getAbsolutePath();
+		} catch (Exception e) {
+			e.printStackTrace();
+		} finally {
+			try {
+				if (fos != null) fos.close();
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+		return ret;
+	}
+
+	public static String saveFeature(Context context, byte[] feature, String path, String name) {
+		File dir = new File(Environment.getExternalStorageDirectory().getPath(), path);
+		if (!dir.exists()) {
+			if (!dir.mkdirs()) return null;
+		}
+		File file = new File(dir, name);
+		FileOutputStream fos = null;
+		String ret = null;
+		try {
+			fos = new FileOutputStream(file);
+			fos.write(feature);
+
+			ret = file.getAbsolutePath();
+		} catch (Exception e) {
+			e.printStackTrace();
+		} finally {
+			try {
+				if (fos != null) fos.close();
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+		return ret;
+	}
+
+
+
+
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/ConUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/DialogUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/DialogUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/DialogUtil.java	(revision 6857)
@@ -0,0 +1,344 @@
+package com.sensetime.faceunlock.util;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.AlertDialog.Builder;
+import android.app.Dialog;
+import android.content.DialogInterface;
+import android.graphics.BitmapFactory;
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.view.Gravity;
+import android.view.View;
+import android.view.ViewGroup.LayoutParams;
+import android.view.Window;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+
+
+public class DialogUtil {
+
+	private Activity activity;
+
+	public DialogUtil(Activity activity) {
+		this.activity = activity;
+	}
+
+	private Dialog createDialog(int layout) {
+		Dialog dialog = new Dialog(activity);
+		dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
+		dialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
+		dialog.setContentView(layout);
+
+		return dialog;
+	}
+
+	public void showDialog(int message, final boolean close) {/*
+		final Dialog dialog = createDialog(R.layout.dialog_layout);
+
+		TextView textView = (TextView) dialog.findViewById(R.id.dialog_text);
+		textView.setText(message);
+
+		Button button = (Button) dialog.findViewById(R.id.dialog_button);
+		button.setOnClickListener(new View.OnClickListener() {
+			@Override
+			public void onClick(View view) {
+				dialog.dismiss();
+				if (close) activity.finish();
+			}
+		});
+
+		dialog.show();*/
+	}
+
+	public void showDialog(int message, final View.OnClickListener onOK) {
+		/*final Dialog dialog = createDialog(R.layout.dialog_cancel_layout);
+
+		TextView textView = (TextView) dialog.findViewById(R.id.dialog_cancel_text);
+		textView.setText(message);
+
+		Button ok = (Button) dialog.findViewById(R.id.dialog_ok);
+		ok.setOnClickListener(new View.OnClickListener() {
+			@Override
+			public void onClick(View view) {
+				dialog.dismiss();
+				onOK.onClick(view);
+			}
+		});
+
+		Button cancel = (Button) dialog.findViewById(R.id.dialog_cancel);
+		cancel.setOnClickListener(new View.OnClickListener() {
+			@Override
+			public void onClick(View view) {
+				dialog.dismiss();
+			}
+		});
+
+		dialog.show();*/
+	}
+
+	public void showSuccess() {/*
+		final Dialog dialog = createDialog(R.layout.dialog_success_layout);
+		dialog.setCancelable(false);
+
+		Button ok = (Button) dialog.findViewById(R.id.dialog_back);
+		ok.setOnClickListener(new View.OnClickListener() {
+			@Override
+			public void onClick(View view) {
+				dialog.dismiss();
+				activity.finish();
+			}
+		});
+
+		Button cancel = (Button) dialog.findViewById(R.id.dialog_again);
+		cancel.setOnClickListener(new View.OnClickListener() {
+			@Override
+			public void onClick(View view) {
+				dialog.dismiss();
+				((UnlockActivity)activity).refresh();
+			}
+		});
+
+		dialog.show();*/
+	}
+
+	public void showName() {/*
+		final Dialog dialog = createDialog(R.layout.dialog_name_layout);
+		dialog.setCancelable(false);
+
+		Button ok = (Button) dialog.findViewById(R.id.dialog_name_ok);
+		final EditText edit = (EditText) dialog.findViewById(R.id.dialog_name_edit);
+		ok.setOnClickListener(new View.OnClickListener() {
+			@Override
+			public void onClick(View view) {
+				String name = edit.getText().toString();
+				if (name != null && !name.isEmpty()) {
+					dialog.dismiss();
+					((CameraActivity)activity).finish(name);
+				}
+			}
+		});
+
+		dialog.show();*/
+	}
+
+	public void showImageDialog(String message, String path, final boolean isCompare) {/*
+		Builder builder = new Builder(activity);
+		if (isCompare)
+			builder.setTitle("比对完成"); // 设置对话框标题
+		else
+			builder.setTitle("注册成功"); // 设置对话框标题
+		builder.setIcon(android.R.drawable.btn_star); // 设置对话框标题前的图标
+		LayoutParams linearLp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+		LayoutParams textLp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
+		LayoutParams imageLp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+
+		LinearLayout linear = new LinearLayout(activity);
+		linear.setGravity(Gravity.CENTER);
+		linear.setOrientation(LinearLayout.VERTICAL);
+		TextView text = new TextView(activity);
+		text.setText(message);
+		text.setTextColor(0XFFFFFFFF);
+		if (isCompare)
+			text.setTextSize(15);
+		else
+			text.setTextSize(35);
+		text.setGravity(Gravity.CENTER);
+		linear.addView(text, textLp);
+		ImageView image = new ImageView(activity);
+		image.setImageBitmap(BitmapFactory.decodeFile(path));
+		linear.addView(image, imageLp);
+		linear.setLayoutParams(linearLp);
+
+		builder.setView(linear);
+		builder.setPositiveButton("确认", new DialogInterface.OnClickListener() {
+			@Override
+			public void onClick(DialogInterface dialog, int which) {
+				if (activity instanceof CameraActivity) {
+					activity.finish();
+				}
+			}
+		});
+
+		builder.setCancelable(true); // 设置按钮是否可以按返回键取消,false则不可以取消
+		AlertDialog dialog = builder.create(); // 创建对话框
+		dialog.setCanceledOnTouchOutside(true); // 设置弹出框失去焦点是否隐藏,即点击屏蔽其它地方是否隐藏
+		dialog.show();*/
+	}
+
+	public void showNameEditText() {/*
+		Builder builder = new Builder(activity);
+		builder.setTitle("请输入姓名"); // 设置对话框标题
+		builder.setIcon(android.R.drawable.btn_star); // 设置对话框标题前的图标
+		LayoutParams tvLp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+
+		final EditText edit = new EditText(activity);
+		edit.setLayoutParams(tvLp);
+
+		final InputMethodManager imm = (InputMethodManager) edit.getContext()
+				.getSystemService(Activity.INPUT_METHOD_SERVICE);
+		imm.toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_NOT_ALWAYS);
+
+		builder.setView(edit);
+		builder.setPositiveButton("确认", new DialogInterface.OnClickListener() {
+			@Override
+			public void onClick(DialogInterface dialog, int which) {
+				String name = edit.getText().toString();
+				if (name == null || name.length() == 0) {
+					ConUtil.showToast(activity, "姓名不能为空！");
+				}
+
+				// 取消重命名时候隐藏软键盘
+				imm.hideSoftInputFromWindow(edit.getWindowToken(), 0);
+			}
+		});
+		builder.setNegativeButton("取消", new DialogInterface.OnClickListener() {
+			@Override
+			public void onClick(DialogInterface dialog, int which) {
+				// 取消重命名时候隐藏软键盘
+				imm.hideSoftInputFromWindow(edit.getWindowToken(), 0);
+			}
+		});
+
+		builder.setCancelable(true); // 设置按钮是否可以按返回键取消,false则不可以取消
+		AlertDialog dialog = builder.create(); // 创建对话框
+		dialog.setCanceledOnTouchOutside(true); // 设置弹出框失去焦点是否隐藏,即点击屏蔽其它地方是否隐藏
+		dialog.show();*/
+	}
+
+	public void showEditText(final TextView text, final int index) {/*
+		Builder builder = new Builder(activity);
+		builder.setTitle(getTitle(index)); // 设置对话框标题
+		builder.setIcon(android.R.drawable.btn_star); // 设置对话框标题前的图标
+		LayoutParams tvLp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+
+		final EditText edit = new EditText(activity);
+		edit.setLayoutParams(tvLp);
+		edit.setText(text.getText().toString());
+		edit.setSelection(text.getText().toString().length());
+
+		final InputMethodManager imm = (InputMethodManager) edit.getContext()
+				.getSystemService(Activity.INPUT_METHOD_SERVICE);
+		imm.toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_NOT_ALWAYS);
+
+		builder.setView(edit);
+		builder.setPositiveButton("确认", new DialogInterface.OnClickListener() {
+			@Override
+			public void onClick(DialogInterface dialog, int which) {
+				String str = edit.getText().toString();
+				if (isNum(str)) {
+					ConUtil.showToast(activity, "请输入数字！");
+					return;
+				} else {
+					try {
+						String value = getContent(str, index);
+						setTextSzie(text, value.length());
+						text.setText(value);
+					} catch (Exception e) {
+						ConUtil.showToast(activity, "请输入数字！");
+					}
+				}
+
+				// 取消重命名时候隐藏软键盘
+				imm.hideSoftInputFromWindow(edit.getWindowToken(), 0);
+			}
+		});
+		builder.setNegativeButton("取消", new DialogInterface.OnClickListener() {
+			@Override
+			public void onClick(DialogInterface dialog, int which) {
+				// 取消重命名时候隐藏软键盘
+				imm.hideSoftInputFromWindow(edit.getWindowToken(), 0);
+			}
+		});
+
+		builder.setCancelable(true); // 设置按钮是否可以按返回键取消,false则不可以取消
+		AlertDialog dialog = builder.create(); // 创建对话框
+		dialog.setCanceledOnTouchOutside(true); // 设置弹出框失去焦点是否隐藏,即点击屏蔽其它地方是否隐藏
+		dialog.show();*/
+	}
+
+	public static void setTextSzie(TextView text, int num) {
+		if (num < 3)
+			text.setTextSize(20);
+		else if (num < 5)
+			text.setTextSize(18);
+		else if (num < 7)
+			text.setTextSize(16);
+		else if (num < 9)
+			text.setTextSize(14);
+		else if (num >= 9)
+			text.setTextSize(12);
+	}
+
+	public String getTitle(int index) {
+		String title = "请输入";
+		switch (index) {
+		case 0:
+			title = "最小值是33\n最大值是2147483647";
+			break;
+		case 1:
+			title = "最小值是1\n最大值是2147483647";
+			break;
+		case 2:
+			title = "最小值是0\n最大值是1          ";
+			break;
+		case 3:
+			title = "最小值是0\n最大值是1          ";
+			break;
+		case 4:
+			title = "最小值是0\n最大值是1          ";
+			break;
+		}
+		return title;
+	}
+
+	public String getContent(String str, int index) {
+		String content = str;
+		switch (index) {
+		case 0:
+			long faceSize = (long) Float.parseFloat(content);
+			if (faceSize < 33)
+				faceSize = 33;
+			else if (faceSize > 2147483647)
+				faceSize = 2147483647;
+
+			content = faceSize + "";
+			break;
+		case 1:
+			long interval = (long) Float.parseFloat(content);
+			if (interval < 1)
+				interval = 1;
+			else if (interval > 2147483647)
+				interval = 2147483647;
+
+			content = interval + "";
+			break;
+		case 2:
+		case 3:
+		case 4:
+			float vlaue = Float.parseFloat(content);
+			if (vlaue < 0)
+				vlaue = 0;
+			else if (vlaue > 1)
+				vlaue = 1;
+
+			content = vlaue + "";
+			break;
+		}
+		return content;
+	}
+
+	public boolean isNum(String str) {
+		String reg = "[a-zA-Z]+";
+		return str.matches(reg);
+	}
+
+	public void onDestory() {
+		activity = null;
+	}
+}
\ No newline at end of file

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/DialogUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/FileUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/FileUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/FileUtil.java	(revision 6857)
@@ -0,0 +1,131 @@
+package com.sensetime.faceunlock.util;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.UUID;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.os.Environment;
+
+import com.sensetime.faceapi.utils.ColorConvertUtil;
+
+public class FileUtil {
+
+	public static final String TAG = "FileUtil";
+	public static final String VERIFY_MODEL = "verify.model";
+//	public static final String HACKER_MODEL = "M_Liveness_Antispoofing_General_6.0.2.model";
+
+	public static void copyModelFile(Context context) {
+		copyFileIfNeed(context, VERIFY_MODEL);
+//		copyFileIfNeed(context, HACKER_MODEL);
+	}
+
+	private static void copyFileIfNeed(Context context, String modelName) {
+		try {
+			File modelFile = new File(context.getFilesDir(), modelName);
+			InputStream is = context.getAssets().open(modelName);
+			if (modelFile.length() == is.available()) {
+				return;
+			}
+			OutputStream os = new FileOutputStream(modelFile);
+			byte[] buffer = new byte[1024 << 9]; // 512KB
+			int length = is.read(buffer);
+			while (length > 0) {
+				os.write(buffer, 0, length);
+				length = is.read(buffer);
+			}
+			os.flush();
+			os.close();
+			is.close();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}finally{
+		}
+	}
+
+	public static String getAssertData(Context context, String path) {
+		try {
+			InputStream stream = context.getAssets().open(path);
+			int length = stream.available();
+			byte[] data = new byte[length];
+			stream.read(data);
+			stream.close();
+			return new String(data);
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+		return null;
+	}
+
+	public static String getUUIDName() {
+		String s = UUID.randomUUID().toString();
+		return s.substring(0, 8) + s.substring(9, 13) + s.substring(14, 18) + s.substring(19, 23) + s.substring(24);
+	}
+
+	public static boolean saveBitmap(Bitmap bitmap, String imagePath) {
+		File file = new File(imagePath);
+		File parentFile = file.getParentFile();
+		if (!parentFile.exists()) {
+			parentFile.mkdirs();
+		}
+		try {
+			FileOutputStream fos = new FileOutputStream(file);
+			bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos);
+			fos.flush();
+			fos.close();
+			return true;
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+		return false;
+	}
+
+	public static boolean saveBytes(byte[] bytes, String filePath) {
+		File file = new File(filePath);
+		File parentFile = file.getParentFile();
+		if (!parentFile.exists()) {
+			parentFile.mkdirs();
+		}
+		try {
+			FileOutputStream fos = new FileOutputStream(file);
+			fos.write(bytes);
+			fos.flush();
+			fos.close();
+			return true;
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+		return false;
+	}
+
+	public static final String DIR = Environment.getExternalStorageDirectory().getAbsolutePath() + "/sensetime/faceunlock/hacker/";
+	public static void saveHackerData(byte[] nv21, int width, int height, float score) {
+		String timestamp = getFormatTime(System.currentTimeMillis());
+		String nv21Name = DIR + timestamp + "/" + score + ".yuv";
+		saveBytes(nv21, nv21Name);
+		Bitmap bitmap = ColorConvertUtil.cropNv21ToBitmap(nv21, width, height, 0, 0, width, height);
+		String bitmapPath = DIR + timestamp + "/" + score + ".jpg";
+		saveBitmap(bitmap, bitmapPath);
+	}
+
+	/**
+	 * 将毫秒数转换成yyyy-MM-dd-HH-mm-ss的格式
+	 */
+	public static String getFormatTime(long milliseconds) {
+		SimpleDateFormat format = new SimpleDateFormat("yyyy.MM.dd-HH.mm.ss");
+		String times = format.format(new Date(milliseconds));
+		return times;
+	}
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/FileUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/Util.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/Util.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/Util.java	(revision 6857)
@@ -0,0 +1,34 @@
+package com.sensetime.faceunlock.util;
+
+import android.app.ActivityManager;
+import android.content.Context;
+import android.os.Debug;
+import android.os.Process;
+import android.util.Log;
+
+import java.util.HashMap;
+
+/**
+ * Created by binghezhouke on 15-8-12.
+ */
+public class Util {
+
+    public static String API_KEY;
+    public static String API_SECRET;
+
+    public static HashMap<String, byte[]> featureMap = new HashMap<String, byte[]>();//key:name, value:feature
+
+    public static void printMemoryInfo(String tag, Context context) {
+//		Debug.MemoryInfo memoryInfo = new Debug.MemoryInfo();
+//		Debug.getMemoryInfo(memoryInfo);
+//		Log.e(tag, "printMemoryInfo: " + memoryInfo.nativePss);
+
+        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        Debug.MemoryInfo[] memoryInfos = activityManager.getProcessMemoryInfo(new int[]{Process.myPid()});
+        for (Debug.MemoryInfo memoryInfo : memoryInfos) {
+            Log.e(tag, "testMem: " + (memoryInfo.getTotalPss() - memoryInfo.dalvikPss));
+        }
+
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/Util.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/LogUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/LogUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/LogUtil.java	(revision 6857)
@@ -0,0 +1,128 @@
+package com.sensetime.faceunlock.util;
+
+/*import android.util.Log;
+
+public class LogUtil {
+
+    private static final boolean DEBUG = true;
+
+    public static void v(String tag, String msg) {
+        if (DEBUG) Log.v(tag, msg);
+    }
+
+    public static void d(String tag, String msg) {
+        if (DEBUG) Log.d(tag, msg);
+    }
+
+    public static void i(String tag, String msg) {
+        if (DEBUG) Log.i(tag, msg);
+    }
+
+    public static void w(String tag, String msg) {
+        if (DEBUG) Log.w(tag, msg);
+    }
+
+    public static void e(String tag, String msg) {
+        if (DEBUG) Log.e(tag, msg);
+    }
+
+}*/
+
+
+import android.content.Context;
+import android.util.Log;
+import android.os.Environment;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+public class LogUtil {
+
+    private static final boolean DEBUG = true;
+    private static BufferedWriter bw;
+
+    public static void v(String tag, String msg) {
+        if (DEBUG) Log.v(tag, msg);
+    }
+
+    public static void d(String tag, String msg) {
+        if (DEBUG) Log.d(tag, msg);
+        if (bw != null) {
+            try {
+                bw.write(tag + "___" + msg);
+                bw.newLine();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public static void i(String tag, String msg) {
+        if (DEBUG) Log.i(tag, msg);
+        if (bw != null) {
+            try {
+                bw.write(tag + "___" + msg);
+                bw.newLine();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public static void w(String tag, String msg) {
+        if (DEBUG) Log.w(tag, msg);
+        if (bw != null) {
+            try {
+                bw.write(tag + "___" + msg);
+                bw.newLine();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public static void e(String tag, String msg) {
+        if (DEBUG) Log.e(tag, msg);
+        if (bw != null) {
+            try {
+                bw.write(tag + "___" + msg);
+                bw.newLine();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public static void init() {
+        String path = Environment.getExternalStorageDirectory().getPath();
+        String time = getTime();
+        try {
+            File file = new File(path, time);
+            bw = new BufferedWriter(new FileWriter(file));
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+    }
+
+    public static String getTime() {
+        long time = System.currentTimeMillis();//long now = android.os.SystemClock.uptimeMillis();
+        SimpleDateFormat format = new SimpleDateFormat("yyyy_MM_dd_HH_mm_ss");
+        Date d = new Date(time);
+        return format.format(d);
+    }
+
+    public static void destroy() {
+        if (bw != null) {
+            try {
+                bw.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/LogUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/SPUtil.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/SPUtil.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/SPUtil.java	(revision 6857)
@@ -0,0 +1,54 @@
+package com.sensetime.faceunlock.util;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+
+public class SPUtil {
+
+	private static final String FILE_NAME = "config_data";
+	public static final String THRESHOLD_KEY = "threshold";
+	public static final String TRY_COUNT_KEY = "try_count";
+	public static final String IS_OPEN_LIVENESS = "is_open_liveness";
+
+	/**
+	 * 保存数据的方法，我们需要拿到保存数据的具体类型，然后根据类型调用不同的保存方法
+	 */
+	public static void put(Context context, String key, Object object) {
+		SharedPreferences sp = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
+		SharedPreferences.Editor editor = sp.edit();
+		if (object instanceof String) {
+			editor.putString(key, (String) object);
+		} else if (object instanceof Integer) {
+			editor.putInt(key, (Integer) object);
+		} else if (object instanceof Boolean) {
+			editor.putBoolean(key, (Boolean) object);
+		} else if (object instanceof Float) {
+			editor.putFloat(key, (Float) object);
+		} else if (object instanceof Long) {
+			editor.putLong(key, (Long) object);
+		} else {
+			editor.putString(key, object.toString());
+		}
+		editor.commit();
+	}
+
+	/**
+	 * 得到保存数据的方法，我们根据默认值得到保存的数据的具体类型，然后调用相对于的方法获取值
+	 */
+	public static Object get(Context context, String key, Object defaultObject) {
+		SharedPreferences sp = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
+		if (defaultObject instanceof String) {
+			return sp.getString(key, (String) defaultObject);
+		} else if (defaultObject instanceof Integer) {
+			return sp.getInt(key, (Integer) defaultObject);
+		} else if (defaultObject instanceof Boolean) {
+			return sp.getBoolean(key, (Boolean) defaultObject);
+		} else if (defaultObject instanceof Float) {
+			return sp.getFloat(key, (Float) defaultObject);
+		} else if (defaultObject instanceof Long) {
+			return sp.getLong(key, (Long) defaultObject);
+		}
+		return null;
+	}
+
+}
\ No newline at end of file

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/SPUtil.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/FaceUnlocker.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/FaceUnlocker.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/FaceUnlocker.java	(revision 6857)
@@ -0,0 +1,215 @@
+package com.sensetime.faceunlock.util;
+
+import android.hardware.Camera;
+import android.os.Handler;
+import android.os.Looper;
+
+import com.megvii.facepp.sdk.Lite;
+
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+
+/**
+ * 简单的解锁类，维护一个单线程模型，并且支持解锁超时。
+ * 每次解锁的过程：
+ * 1.创建解锁对象
+ * FaceUnlocker faceUnlocker;
+ * 2.启动解锁过程
+ * start
+ * 3.开始解锁尝试
+ * onPreviewFrame
+ * 4.停止解锁
+ * stop
+ * <p>
+ * 5.faceUnlocker = null 销毁解锁对象
+ */
+public class FaceUnlocker {
+
+    private static Executor mExecutor = Executors.newSingleThreadExecutor();
+
+    private Params mParams;
+
+    private int[] mReport = new int[20];
+
+    private UnLockCallBack mUnlockCallBack;
+
+    private static Timer mTimer = new Timer();
+
+    private int mResult;
+
+    private TimeoutTimerTask mTimeoutTimerTask;
+
+    private boolean mStopped = false;
+
+    private Handler mMainHandler = new Handler(Looper.getMainLooper());
+
+    private class TimeoutTimerTask extends TimerTask {
+        @Override
+        public void run() {
+            mExecutor.execute(new Runnable() {
+                @Override
+                public void run() {
+                    boolean success = stopUnlocking();
+                    if (success) {
+                        final UnLockCallBack unLockCallBack = mUnlockCallBack;
+                        mMainHandler.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (unLockCallBack != null) {
+                                    unLockCallBack.onTimeout();
+                                }
+                            }
+                        });
+                    }
+                }
+            });
+        }
+    }
+
+    public static class Params {
+
+        int width = 640;
+
+        int height = 480;
+
+        int angle = 0;
+
+        boolean strictMode = false;
+    }
+
+    public int getResult() {
+        return mResult;
+    }
+
+    public int[] getReport() {
+        return mReport;
+    }
+
+    public FaceUnlocker(Params params) {
+
+        mParams = params;
+    }
+
+    public interface UnLockCallBack {
+
+        void onSuccess();
+
+        void onStop();
+
+        void onTimeout();
+    }
+
+    /**
+     * 开始
+     */
+    public synchronized void start(final UnLockCallBack unClockCallBack
+            , long timeTout) {
+        if (mStopped) {
+            return;
+        }
+        mExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                if (mStopped) {
+                    return;
+                }
+                mUnlockCallBack = unClockCallBack;
+                Lite.getInstance().prepare();
+            }
+        });
+        if (mTimeoutTimerTask == null) {
+            mTimeoutTimerTask = new TimeoutTimerTask();
+        }
+        mTimer.schedule(mTimeoutTimerTask, timeTout);
+    }
+
+    /**
+     * 停止
+     */
+    public synchronized void stop() {
+        if (!mStopped) {
+            mStopped = true;
+            final UnLockCallBack unLockCallBack = mUnlockCallBack;
+            mExecutor.execute(new Runnable() {
+                @Override
+                public void run() {
+                    boolean success = stopUnlocking();
+                    if (success) {
+                        mMainHandler.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (unLockCallBack != null) {
+                                    unLockCallBack.onStop();
+                                }
+                            }
+                        });
+                    }
+                }
+            });
+        }
+    }
+
+
+    private boolean stopUnlocking() {
+        if (mStopped) {
+            return false;
+        }
+        mStopped = true;
+        Lite.getInstance().reset();
+        mTimeoutTimerTask.cancel();
+        mTimeoutTimerTask = null;
+        mReport = null;
+        mResult = 0;
+        return true;
+    }
+
+    /**
+     * 尝试进行解锁
+     *
+     * @param bytes
+     * @param camera
+     */
+    public synchronized void onPreviewFrame(final byte[] bytes
+            , final Camera camera) {
+        if (mStopped) {
+            return;
+        }
+        mExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                if (mStopped) {
+                    return;
+                }
+                byte[] data = PdUtils.getPdData(camera);
+                if (data == null) {
+                    handleData(bytes, mParams.width, mParams.height);
+                } else {
+                    handleData(data, -1, -1);
+                }
+            }
+        });
+    }
+
+    private void handleData(byte[] pdData, int width, int height) {
+        mResult = Lite.getInstance().compare(pdData
+                , width
+                , height
+                , mParams.angle
+                , true
+                , mParams.strictMode, mReport);
+        if (mResult == Lite.MG_UNLOCK_OK) {
+            final UnLockCallBack unLockCallBack = mUnlockCallBack;
+            mMainHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    if (unLockCallBack != null) {
+                        unLockCallBack.onSuccess();
+                    }
+                }
+            });
+            stopUnlocking();
+        }
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/util/FaceUnlocker.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/FaceRegisterView.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/FaceRegisterView.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/FaceRegisterView.java	(revision 6857)
@@ -0,0 +1,82 @@
+package com.sensetime.faceunlock.widget;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.util.AttributeSet;
+import android.view.View;
+
+public class FaceRegisterView extends View {
+	
+	public static final int FACE_DIR_COUNT = 5; // 5方向人脸
+
+	private Paint mPaint = new Paint(); // 绘制用的画笔
+	private RectF mRect = new RectF(); // 控件在屏幕中的位置，用来确定和绘制扇形
+	private boolean[] direct = new boolean[FACE_DIR_COUNT]; // 存储某个方向是否已经检测
+	private int mSmallCircleRadius; // 中间圆的半径
+	private int mStrokeWidth = 4; // 画笔的宽度
+
+	public FaceRegisterView(Context context) {
+		super(context);
+		init();
+	}
+
+	public FaceRegisterView(Context context, AttributeSet attrs) {
+		super(context, attrs);
+		init();
+	}
+
+	private void init() {
+		mPaint.setAntiAlias(true);
+		mPaint.setStyle(Paint.Style.STROKE);
+		mPaint.setStrokeWidth(mStrokeWidth);
+	}
+
+	@Override
+	protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+		super.onLayout(changed, left, top, right, bottom);
+		mRect.set(mStrokeWidth, mStrokeWidth, getWidth() - mStrokeWidth, getHeight() - mStrokeWidth);
+		mSmallCircleRadius = getWidth() >> 4;
+	}
+
+	public void reset() {
+		for (int i = 0; i < direct.length; i++) {
+			direct[i] = false;
+		}
+		postInvalidate(); // 更新UI
+	}
+	
+	/**
+	 * 设置某个方向去做特征分析，返回成功状态
+	 */
+	public boolean setDirectTrue(int index) {
+		if (index < 0 || index >= direct.length || direct[index]) {
+			return false; // 如果index越界或者direct[index]已经做过了特征分析，则返回false
+		}
+		direct[index] = true; // 设置direct[index]的状态为已经做过特征分析
+		postInvalidate(); // 更新UI
+		return true;
+	}
+	
+	@Override
+	protected void onDraw(Canvas canvas) {
+		super.onDraw(canvas);
+		mPaint.setColor(Color.RED);
+		canvas.drawCircle(mRect.centerX(), mRect.centerY(), mRect.width() / 2, mPaint);
+		canvas.drawCircle(mRect.centerX(), mRect.centerY(), mSmallCircleRadius, mPaint);
+		for (int i = 0; i < direct.length; i++) {
+			if (direct[i]) {
+				mPaint.setColor(Color.CYAN);
+				if (i == 0) {
+					canvas.drawCircle(mRect.centerX(), mRect.centerY(), mSmallCircleRadius, mPaint);
+				} else {
+					canvas.drawArc(mRect, 90 * i - 45, 90, false, mPaint);
+					// canvas.drawArc(mRect, 45 * i - 22.5f, 45, false, mPaint); // 9方向
+				}
+			}
+		}
+	}
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/FaceRegisterView.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/FaceUnlockCyleView.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/FaceUnlockCyleView.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/FaceUnlockCyleView.java	(revision 6857)
@@ -0,0 +1,180 @@
+package com.sensetime.faceunlock.widget;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.graphics.Typeface;
+import android.util.AttributeSet;
+import com.android.keyguard.R;
+import android.util.Log;
+import android.view.View;
+
+public class FaceUnlockCyleView extends View {
+
+	private Paint paint;
+
+	private int roundColor;
+
+	private int roundProgressColor;
+
+	private float roundProgressInerCycle;
+
+	private int textColor;
+
+	private float textSize;
+
+	private float roundWidth;
+
+	private int max;
+
+	private int progress;
+
+	private boolean textIsDisplayable;
+
+	private int style;
+
+	public static final int STROKE = 0;
+	public static final int FILL = 1;
+
+	public FaceUnlockCyleView(Context context) {
+		this(context, null);
+	}
+
+	public FaceUnlockCyleView(Context context, AttributeSet attrs) {
+		this(context, attrs, 0);
+	}
+
+	public FaceUnlockCyleView(Context context, AttributeSet attrs, int defStyle) {
+		super(context, attrs, defStyle);
+
+		paint = new Paint();
+		TypedArray mTypedArray = context.obtainStyledAttributes(attrs, R.styleable.RoundProgressBar);
+		roundColor = mTypedArray.getColor(R.styleable.RoundProgressBar_roundColor, Color.RED);
+		roundProgressColor = mTypedArray.getColor(R.styleable.RoundProgressBar_roundProgressColor, Color.GREEN);
+		roundProgressInerCycle = mTypedArray.getDimension(R.styleable.RoundProgressBar_roundProgressInterCycle, 20);
+		textColor = mTypedArray.getColor(R.styleable.RoundProgressBar_textColor, Color.GREEN);
+		textSize = mTypedArray.getDimension(R.styleable.RoundProgressBar_textSize, 15);
+		roundWidth = mTypedArray.getDimension(R.styleable.RoundProgressBar_roundWidth, 5);
+		max = mTypedArray.getInteger(R.styleable.RoundProgressBar_max, 100);
+		textIsDisplayable = mTypedArray.getBoolean(R.styleable.RoundProgressBar_textIsDisplayable, true);
+		style = mTypedArray.getInt(R.styleable.RoundProgressBar_style, 0);
+		mTypedArray.recycle();
+	}
+
+	@Override
+	protected void onDraw(Canvas canvas) {
+		super.onDraw(canvas);
+
+		int centre = getWidth() / 2;
+		int radius = (int) (centre - roundWidth / 2);
+		paint.setColor(roundColor);
+		paint.setStyle(Paint.Style.STROKE);
+		paint.setStrokeWidth(roundWidth);
+		paint.setAntiAlias(true);
+		canvas.drawCircle(centre, centre, radius, paint);
+
+		paint.setStrokeWidth(0);
+		paint.setColor(textColor);
+		paint.setTextSize(textSize);
+		paint.setTypeface(Typeface.DEFAULT_BOLD);
+		int percent = (int) (((float) progress / (float) max) * 100);
+		float textWidth = paint.measureText(percent + "%");
+
+		if (textIsDisplayable && percent != 0 && style == STROKE) {
+			canvas.drawText(percent + "%", centre - textWidth / 2, centre + textSize+760 / 2, paint);
+		}
+
+		paint.setStrokeWidth(roundWidth);
+		paint.setColor(roundProgressColor);
+		
+		RectF oval = new RectF(centre - radius, centre - radius, centre + radius, centre + radius);
+
+		switch (style) {
+		case STROKE: {
+			paint.setStyle(Paint.Style.STROKE);
+			canvas.drawArc(oval, -90, 360 * progress / max, false, paint);
+			break;
+		}
+		case FILL: {
+			paint.setStyle(Paint.Style.FILL_AND_STROKE);
+			if (progress != 0)
+//				canvas.drawArc(oval, 0, 360 * progress / max, true, paint);
+			break;
+		}
+		}
+
+	}
+
+	public synchronized int getMax() {
+		return max;
+	}
+
+	public synchronized void setMax(int max) {
+		if (max < 0) {
+			throw new IllegalArgumentException("max not less than 0");
+		}
+		this.max = max;
+	}
+
+	public synchronized int getProgress() {
+		return progress;
+	}
+
+	public synchronized void setProgress(int progress) {
+		if (progress < 0) {
+			throw new IllegalArgumentException("progress not less than 0");
+		}
+		if (progress > max) {
+			progress = max;
+		}
+		if (progress <= max) {
+			this.progress = progress;
+			postInvalidate();
+		}
+
+	}
+
+	public int getCricleColor() {
+		return roundColor;
+	}
+
+	public void setCricleColor(int cricleColor) {
+		this.roundColor = cricleColor;
+	}
+
+	public int getCricleProgressColor() {
+		return roundProgressColor;
+	}
+
+	public void setCricleProgressColor(int cricleProgressColor) {
+		this.roundProgressColor = cricleProgressColor;
+	}
+
+	public int getTextColor() {
+		return textColor;
+	}
+
+	public void setTextColor(int textColor) {
+		this.textColor = textColor;
+	}
+
+	public float getTextSize() {
+		return textSize;
+	}
+
+	public void setTextSize(float textSize) {
+		this.textSize = textSize;
+	}
+
+	public float getRoundWidth() {
+		return roundWidth;
+	}
+
+	public void setRoundWidth(float roundWidth) {
+		this.roundWidth = roundWidth;
+	}
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/FaceUnlockCyleView.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/CameraView.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/CameraView.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/CameraView.java	(revision 6857)
@@ -0,0 +1,586 @@
+package com.sensetime.faceunlock.widget;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.ImageFormat;
+import android.graphics.Matrix;
+import android.graphics.Rect;
+import android.hardware.Camera;
+import android.hardware.Camera.Parameters;
+import android.hardware.Camera.PreviewCallback;
+import android.hardware.Camera.Size;
+import android.util.AttributeSet;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.MotionEvent;
+import android.view.Surface;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.View;
+import android.view.WindowManager;
+import android.widget.Toast;
+
+import com.android.keyguard.R;
+
+import java.util.ArrayList;
+import java.util.List;
+import android.content.Intent;
+
+/**
+ * 相机View
+ */
+public class CameraView extends SurfaceView implements Camera.AutoFocusCallback {
+
+    private final static String TAG = "CameraView";
+    private final static boolean DEBUG = true;
+    private final static int SCALE_TYPE_4_3 = 1; // 自定义属性中4:3比例的枚举对应的值为1
+    private final static int SCALE_TYPE_16_9 = 2; // 自定义属性中16:9比例的枚举对应的值为2
+    private final static String CAMERA_STOP_FACE_SERVICE = "camera_stop_face_service"; //add by yukai,2017/7/29 
+
+    private Camera mCamera; // 相机对象
+    private Matrix matrix = new Matrix(); // 记录屏幕拉伸的矩阵，用于绘制人脸框使用
+    private PreviewCallback mPreviewCallback; // 相机预览的数据回调
+    private Size mPreviewSize; // 当前预览分辨率大小
+
+    private float mPreviewScale; // 预览显示的比例(4:3/16:9)
+    private float previewScaleX;
+    private float previewScaleY;
+    private int mResolution; // 分辨率大小，以预览高度为标准(320, 480, 720, 1080...)
+    private int mCameraFacing; // 摄像头方向
+    private boolean mIsOpened;
+
+    public int mPreviewWidth; // 预览宽度
+    public int mPreviewHeight; // 预览高度
+    public int mDegrees; // 预览显示的角度
+    public byte[] mBuffer; // 预览缓冲数据，使用可以让底层减少重复创建byte[]，起到重用的作用
+	public int Angle = 0;
+
+    public CameraView(Context context) {
+        super(context);
+        init(context, null);
+    }
+
+    public CameraView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(context, attrs);
+    }
+
+    private void init(Context context, AttributeSet attrs) {
+        // 设置透明状态栏和透明导航栏，需要 API >= 19
+//        ((Activity) context).getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
+//        ((Activity) context).getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
+        // 设置屏幕常亮
+        setKeepScreenOn(true);
+        // 自定义属性
+        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CameraView);
+        mCameraFacing = a.getInt(R.styleable.CameraView_cameraFacing, Camera.CameraInfo.CAMERA_FACING_FRONT);
+        mResolution = a.getInt(R.styleable.CameraView_resolution, 480);
+        int scaleType = a.getInt(R.styleable.CameraView_scale, 0);
+        mPreviewScale = getPreviewScale(scaleType);
+        a.recycle();
+        // 设置SurfaceHolder的回调
+        getHolder().addCallback(callback);
+    }
+
+    private SurfaceHolder.Callback callback = new SurfaceHolder.Callback() {
+        @Override
+        public void surfaceCreated(SurfaceHolder holder) {
+            if (DEBUG) {
+                Log.v(TAG, "SurfaceHolder Created");
+            }
+            try {
+                openCamera(mCameraFacing); // 1.打开相机
+                initParameters(); // 2.设置相机参数
+                mCamera.setPreviewDisplay(getHolder()); // 3.设置预览显示的SurFace
+            } catch (Exception e) {
+                e.printStackTrace();
+				Toast.makeText(getContext(), "打开人脸识别失败, 请检查相机或者权限是否被占用", Toast.LENGTH_SHORT).show();
+				Intent intent = new Intent();
+				intent.setAction(CAMERA_STOP_FACE_SERVICE);
+				getContext().sendBroadcast(intent);
+            }
+        }
+        @Override
+        public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
+            if (DEBUG) {
+                Log.v(TAG, "SurfaceHolder Changed. width : " + width + ", height : " + height);
+            }
+            updateCamera(); // 4.更新相机属性，每次更换分辨率需要更新的操作，包括设置预览大小和方向，开始预览
+            if (width > height) {
+                previewScaleX = width / (float) mPreviewWidth;
+                previewScaleY = height / (float) mPreviewHeight;
+            } else {
+                previewScaleX = width / (float) mPreviewHeight;
+                previewScaleY = height / (float) mPreviewWidth;
+            }
+            matrix.setScale(previewScaleX, previewScaleY);
+        }
+
+        @Override
+        public void surfaceDestroyed(SurfaceHolder holder) {
+            if (DEBUG) {
+                Log.v(TAG, "SurfaceHolder Destroyed");
+            }
+			holder.removeCallback(this);
+            releaseCamera(); // 5.释放相机资源
+        }
+    };
+
+    private void openCamera(int mCameraFacing) throws RuntimeException {
+        releaseCamera();
+        Camera.CameraInfo info = new Camera.CameraInfo();
+        for (int i = 0; i < Camera.getNumberOfCameras(); i++) {
+            Camera.getCameraInfo(i, info);
+            if (info.facing == mCameraFacing) {
+                mCamera = Camera.open(i); // 打开对应的摄像头，获取到camera实例
+		
+				Angle = (info.orientation + mDegrees) % 360;
+                mIsOpened = true;
+                return;
+            }
+        }
+    }
+
+    private void initParameters() {
+        if (mCamera == null) {
+            return;
+        }
+        try {
+            Parameters parameters = mCamera.getParameters();
+            // 如果摄像头不支持这些参数都会出错的，所以设置的时候一定要判断是否支持
+            List<String> supportedFlashModes = parameters.getSupportedFlashModes();
+            if (supportedFlashModes != null && supportedFlashModes.contains(Parameters.FLASH_MODE_OFF)) {
+                parameters.setFlashMode(Parameters.FLASH_MODE_OFF); // 设置闪光模式
+            }
+            List<String> supportedFocusModes = parameters.getSupportedFocusModes();
+            if (supportedFocusModes != null && supportedFocusModes.contains(Parameters.FOCUS_MODE_AUTO)) {
+                parameters.setFocusMode(Parameters.FOCUS_MODE_AUTO); // 设置聚焦模式
+            }
+            parameters.setPreviewFormat(ImageFormat.NV21); // 设置预览图片格式
+            parameters.setPictureFormat(ImageFormat.JPEG); // 设置拍照图片格式
+            parameters.setExposureCompensation(0);
+            mCamera.setParameters(parameters); // 将设置好的parameters添加到相机里
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * 每次启动摄像头、切换分辨率都需要进行的操作，所以抽离出来作为一个单独的方法
+     */
+    private void updateCamera() {
+        if (mCamera == null) {
+            return;
+        }
+        mCamera.stopPreview(); // 1.先停止预览
+        setCameraDisplayOrientation(getContext(), mCamera); // 2.设置相机的显示方向
+        initPreviewSize(); // 3.初始化相机预览尺寸
+        initPreviewBuffer(); // 4.初始化相机预览的缓存
+        mCamera.startPreview(); // 5.开始预览
+    }
+
+    /**
+     * 初始化预览尺寸大小并设置，根据拉伸比例、分辨率来计算
+     */
+    private void initPreviewSize() {
+        if (mCamera == null) {
+            return;
+        }
+        Parameters parameters = mCamera.getParameters();
+        mPreviewSize = getFitPreviewSize(parameters); // 获取适合的预览大小
+        mPreviewWidth = mPreviewSize.width;
+        mPreviewHeight = mPreviewSize.height;
+        parameters.setPreviewSize(mPreviewWidth, mPreviewHeight); // 设置预览图片大小
+        if (DEBUG) {
+            Log.d(TAG, "initPreviewSize() mPreviewWidth: " + mPreviewWidth + ", mPreviewHeight: " + mPreviewHeight);
+        }
+        mCamera.setParameters(parameters);
+    }
+	
+
+    /**
+     * 具体计算最佳分辨率大小的方法
+     */
+    private Size getFitPreviewSize(Parameters parameters) {
+        List<Size> previewSizes = parameters.getSupportedPreviewSizes(); // 获取支持的预览尺寸大小
+        int minDelta = Integer.MAX_VALUE; // 最小的差值，初始值应该设置大点保证之后的计算中会被重置
+        int index = 0; // 最小的差值对应的索引坐标
+        for (int i = 0; i < previewSizes.size(); i++) {
+            Size previewSize = previewSizes.get(i);
+            if (DEBUG) {
+                Log.d(TAG, "SupportedPreviewSize, width: " + previewSize.width + ", height: " + previewSize.height);
+            }
+            // 找到一个与设置的分辨率差值最小的相机支持的分辨率大小
+            if (previewSize.width * mPreviewScale == previewSize.height) {
+                int delta = Math.abs(mResolution - previewSize.height);
+                if (delta == 0) {
+                    return previewSize;
+                }
+                if (minDelta > delta) {
+                    minDelta = delta;
+                    index = i;
+                }
+            }
+        }
+        return previewSizes.get(index); // 默认返回与设置的分辨率最接近的预览尺寸
+    }
+
+    private void initPreviewBuffer() {
+        if (mCamera == null) {
+            return;
+        }
+        mBuffer = new byte[mPreviewWidth * mPreviewHeight * 3 / 2]; // 初始化预览缓冲数据的大小
+        if (DEBUG) {
+            Log.d(TAG, "initPreviewBuffer() mBuffer.length: " + mBuffer.length);
+        }
+        mCamera.addCallbackBuffer(mBuffer); // 将此预览缓冲数据添加到相机预览缓冲数据队列里
+        mCamera.setPreviewCallbackWithBuffer(mPreviewCallback); // 设置预览的回调
+		
+    }
+
+    /**
+     * 设置相机显示的方向，必须设置，否则显示的图像方向会错误
+     */
+    private void setCameraDisplayOrientation(Context context, Camera camera) {
+        int rotation = ((WindowManager) (context.getApplicationContext().getSystemService(Context.WINDOW_SERVICE)))
+                .getDefaultDisplay().getRotation();
+        switch (rotation) {
+            case Surface.ROTATION_0: // portrait
+                mDegrees = 90;
+                break;
+            case Surface.ROTATION_90: // landscape
+                mDegrees = 0;
+                break;
+            case Surface.ROTATION_180: // portrait-reverse
+                mDegrees = 270;
+                break;
+            case Surface.ROTATION_270: // landscape-reverse
+                mDegrees = 180;
+                break;
+            default:
+                mDegrees = 90; // 大部分使用场景都是portrait，默认使用portrait的显示方向
+                break;
+        }
+        camera.setDisplayOrientation(mDegrees);
+    }
+	 public int getCameraAngle() {
+        return Angle;
+    }
+
+
+    protected void setExposure(int value) {
+        Parameters parameters = mCamera.getParameters();
+        if (value == parameters.getExposureCompensation()) {
+            return;
+        }
+        Log.d(TAG, "exposure value : " + value);
+        parameters.setExposureCompensation(value);
+        mCamera.setParameters(parameters);
+    }
+
+    /**
+     * 释放相机资源
+     */
+    public void releaseCamera() {
+        if (null != mCamera) {
+            if (DEBUG) {
+                Log.v(TAG, "releaseCamera()");
+            }
+            mCamera.setPreviewCallbackWithBuffer(null);
+            mCamera.stopPreview();
+            mCamera.release();
+            mCamera = null;
+            mIsOpened = false;
+			if(mBuffer != null){
+				mBuffer = null;
+			}
+        }
+    }
+
+    /**
+     * 根据自定义属性的模式（4:3模式,16:9模式,auto模式）来获取相机的显示比例
+     */
+    private float getPreviewScale(int type) {
+        if (type == SCALE_TYPE_4_3) { // 4:3模式
+            return 0.75f;
+        }
+        if (type == SCALE_TYPE_16_9) { // 16:9模式
+            return 0.5625f;
+        }
+        return getScreenScale(); // auto模式
+    }
+
+    /**
+     * 获取设备屏幕的拉伸比例，目前安卓的设备屏幕比例只有4：3和16：9两种
+     */
+    private float getScreenScale() {
+        WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
+        DisplayMetrics displayMetrics = new DisplayMetrics();
+        wm.getDefaultDisplay().getMetrics(displayMetrics);
+        float width = displayMetrics.widthPixels;
+        float height = displayMetrics.heightPixels;
+        float scale;
+        if (width > height) {
+            scale = height / width;
+        } else {
+            scale = width / height;
+        }
+        if (DEBUG) {
+            Log.d(TAG, "displayMetrics.widthPixels : " + width);
+            Log.d(TAG, "displayMetrics.heightPixels : " + height);
+            Log.d(TAG, "scale : " + scale);
+        }
+        return Math.abs(scale - 0.75f) > Math.abs(scale - 0.5625f) ? 0.5625f : 0.75f; // 0.75(4:3) 或者 0.5625(16:9)
+    }
+
+    /**
+     * 以点击的坐标点（基于CameraView控件大小的坐标系）为中心进行聚焦
+     */
+    private void focusOnPoint(int x, int y) {
+        if (DEBUG) {
+            Log.d(TAG, "touch point (" + x + ", " + y + ")");
+        }
+        if (mCamera == null) {
+            return;
+        }
+        Parameters parameters = mCamera.getParameters();
+        // 1.先要判断是否支持设置聚焦区域
+        if (parameters.getMaxNumFocusAreas() > 0) {
+            int width = getWidth();
+            int height = getHeight();
+            // 2.以触摸点为中心点，view窄边的1/4为聚焦区域的默认边长
+            int length = Math.min(width, height) >> 3; // 1/8的长度
+            int left = x - length;
+            int top = y - length;
+            int right = x + length;
+            int bottom = y + length;
+            // 3.映射，因为相机聚焦的区域是一个(-1000,-1000)到(1000,1000)的坐标区域
+            left = left * 2000 / width - 1000;
+            top = top * 2000 / height - 1000;
+            right = right * 2000 / width - 1000;
+            bottom = bottom * 2000 / height - 1000;
+            // 4.判断上述矩形区域是否超过边界，若超过则设置为临界值
+            left = left < -1000 ? -1000 : left;
+            top = top < -1000 ? -1000 : top;
+            right = right > 1000 ? 1000 : right;
+            bottom = bottom > 1000 ? 1000 : bottom;
+            if (DEBUG) {
+                Log.d(TAG, "focus area (" + left + ", " + top + ", " + right + ", " + bottom + ")");
+            }
+            ArrayList<Camera.Area> areas = new ArrayList<Camera.Area>();
+            areas.add(new Camera.Area(new Rect(left, top, right, bottom), 600));
+            parameters.setFocusAreas(areas);
+        }
+        try {
+            mCamera.cancelAutoFocus(); // 先要取消掉进程中所有的聚焦功能
+            mCamera.setParameters(parameters);
+            mCamera.autoFocus(this); // 调用聚焦
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void setPreviewCallback(PreviewCallback previewCallback) {
+        mPreviewCallback = previewCallback;
+    }
+
+    /**
+     * 每次预览的回调中，需要调用这个方法才可以起到重用mBuffer
+     */
+    public void addCallbackBuffer() {
+        if (mCamera != null) {
+            mCamera.addCallbackBuffer(mBuffer);
+        }
+    }
+
+    /**
+     * 切换前后摄像头
+     */
+    public void switchCamera() {
+        mCameraFacing ^= 1; // 先改变摄像头朝向
+        mIsOpened = false;
+        restartCamera();
+    }
+
+    public void restartCamera() {
+        if (mIsOpened) {
+            return;
+        }
+        Log.w(TAG, "restartCamera");
+        try {
+            openCamera(mCameraFacing); // 重新打开对应的摄像头
+            initParameters(); // 重新初始化参数
+            mCamera.setPreviewDisplay(getHolder());
+            updateCamera();
+        } catch (Exception e) {
+            e.printStackTrace();
+			Toast.makeText(getContext(), "打开人脸识别失败, 请检查相机或者权限是否被占用", Toast.LENGTH_SHORT).show();
+			Intent intent = new Intent();
+			intent.setAction(CAMERA_STOP_FACE_SERVICE);
+			getContext().sendBroadcast(intent);
+        }
+    }
+    /**
+     * 切换分辨率
+     */
+    public void resetResolution(Size size) {
+        float scale = size.height * 1.0f / size.width;
+        if (mPreviewScale == scale && mResolution == size.height) {
+            return; // 比例分辨率均为改变，直接返回
+        }
+        mResolution = size.height; // 重置分辨率大小
+        if (mPreviewScale == scale) {
+            // 比例未改变，只需要重新更新预览分辨率即可
+            updateCamera();
+            resetMatrix();
+        } else {
+            // 比例改变，因为View的大小将要变化了，需要重新布局
+            mPreviewScale = scale;
+            requestLayout();
+        }
+    }
+    /**
+     * 比例未改变时，surfaceView的大小并没有改变，只是相机的预览分辨率改变了，不会调用到surfaceChanged()方法，所以就需要手动重置matrix
+     */
+    private void resetMatrix() {
+        int width = getWidth();
+        int height = getHeight();
+        if (DEBUG) {
+            Log.d(TAG, "resetMatrix() width: " + width + ", height: " + height);
+        }
+        if (width > height) {
+            previewScaleX = width / (float) mPreviewWidth;
+            previewScaleY = height / (float) mPreviewHeight;
+        } else {
+            previewScaleX = width / (float) mPreviewHeight;
+            previewScaleY = height / (float) mPreviewWidth;
+        }
+        matrix.setScale(previewScaleX, previewScaleY);
+    }
+
+    public Camera getCamera() {
+        return mCamera;
+    }
+
+    public List<Size> getSupportPreviewSize() {
+        if (mCamera == null) {
+            return null;
+        }
+        return mCamera.getParameters().getSupportedPreviewSizes();
+    }
+
+    public Matrix getMatrix() {
+        return matrix;
+    }
+
+    public Size getPreviewSize() {
+        return mPreviewSize;
+    }
+
+    public boolean isFrontCamera() {
+        return mCameraFacing == Camera.CameraInfo.CAMERA_FACING_FRONT;
+    }
+
+    public void startPreview() {
+        if (mCamera != null) {
+            if (DEBUG) {
+                Log.d(TAG, "startPreview()");
+            }
+            mCamera.setPreviewCallbackWithBuffer(mPreviewCallback);
+            mCamera.startPreview();
+        }
+    }
+
+    public void stopPreview() {
+        if (mCamera != null) {
+            if (DEBUG) {
+                Log.d(TAG, "stopPreview()");
+            }
+            mCamera.stopPreview();
+        }
+    }
+
+    public float getPreviewScaleX() {
+        return previewScaleX;
+    }
+
+    public float getPreviewScaleY() {
+        return previewScaleY;
+    }
+
+    /**
+     * 设置长按可切换前后摄像头
+     */
+    public void setLongClickSwitchCamera() {
+        setOnLongClickListener(new OnLongClickListener() {
+            @Override
+            public boolean onLongClick(View v) {
+                switchCamera();
+                return true;
+            }
+        });
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+		//super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        int originalWidth = MeasureSpec.getSize(widthMeasureSpec);
+        int originalHeight = MeasureSpec.getSize(heightMeasureSpec);
+        float scale; // 宽高比，用 较小数/较大数
+        int finalWidth, finalHeight; // 根据预览的比例去重新计算和设置View的宽高
+        if (originalWidth < originalHeight) {
+            scale = originalWidth * 1.0f / originalHeight;
+            if (scale == mPreviewScale) { // 比例一样则不改变
+                finalWidth = originalWidth;
+                finalHeight = originalHeight;
+            } else {
+                if (mPreviewScale == 0.75f) { // 预览比例4:3,压缩高度
+                    finalWidth = originalWidth;
+                    finalHeight = finalWidth * 4 / 3;
+                } else { // 预览比例16:9,压缩宽度
+                    finalWidth = originalWidth;
+                    finalHeight = finalWidth * 16 / 9;
+                }
+            }
+        } else {
+            scale = originalHeight * 1.0f / originalWidth;
+            if (scale == mPreviewScale) { // 比例一样则不改变
+                finalWidth = originalWidth;
+                finalHeight = originalHeight;
+            } else {
+                if (mPreviewScale == 0.75f) { // 预览比例4:3,压缩宽度
+                    finalHeight = originalHeight;
+                    finalWidth = finalHeight * 4 / 3;
+                } else { // 预览比例16:9,压缩高度
+                    finalWidth = originalWidth;
+                    finalHeight = finalWidth * 9 / 16;
+                }
+            }
+        }
+        if (DEBUG) {
+            Log.d(TAG, "originalWidth :" + originalWidth + ", originalHeight :" + originalHeight);
+            Log.d(TAG, "finalWidth: " + finalWidth + ", finalHeight: " + finalHeight);
+        }
+        setMeasuredDimension(finalWidth, finalHeight);
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        switch (event.getAction()) {
+            case MotionEvent.ACTION_DOWN:
+                focusOnPoint((int) event.getX(), (int) event.getY()); // 点击聚焦
+                break;
+            default:
+                break;
+        }
+        return super.onTouchEvent(event);
+    }
+
+    @Override
+    public void onAutoFocus(boolean success, Camera camera) {
+        if (DEBUG) {
+            Log.d(TAG, "onAutoFocus : " + success);
+        }
+    }
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/CameraView.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/MaskView.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/MaskView.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/MaskView.java	(revision 6857)
@@ -0,0 +1,115 @@
+package com.sensetime.faceunlock.widget;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.PorterDuff;
+import android.graphics.PorterDuffXfermode;
+import android.graphics.Rect;
+import android.os.Build;
+import android.util.AttributeSet;
+import android.view.View;
+import android.util.Log;
+
+/**
+ * 相机页面的蒙板View
+ */
+public class MaskView extends View {
+
+    private static final String TAG = "MaskView";
+
+    private int left;
+    private int top;
+    private int right;
+    private int bottom;
+    private int progress; // 进度
+
+    private Paint mClearPaint;
+    private Paint mCirclePaint;
+    private Rect mMaskRect;
+    private boolean isFirstScale = true;
+
+    public MaskView(Context context) {
+        super(context);
+        init();
+    }
+
+    public MaskView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init();
+    }
+
+    private void init() {
+        mClearPaint = new Paint();
+        mClearPaint.setAntiAlias(true);
+        mClearPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));
+        mCirclePaint = new Paint();
+		mCirclePaint.setAntiAlias(true);
+        mClearPaint.setAntiAlias(true);
+        mCirclePaint.setStyle(Paint.Style.STROKE);
+        mCirclePaint.setStrokeWidth(10);
+        mMaskRect = new Rect();
+    }
+
+    public void setProgress(int progress) {
+        this.progress = progress;
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            invalidate();
+        }
+    }
+
+    public Rect getMaskRect(float scaleX, float scaleY) {
+        if (isFirstScale) {
+            int left = (int) ((this.left - 40) / scaleX);
+            int top = (int) ((this.top + 60) / scaleY);
+            int right = (int) ((this.right + 40) / scaleX);
+            int bottom = (int) ((this.bottom + 140) / scaleY);
+            int length = left / 2;
+            mMaskRect.set(left - length, top - length, right + length, bottom + length);
+            isFirstScale = false;
+            com.sensetime.faceunlock.util.LogUtil.d(TAG, "scaleX : " + scaleX);
+            com.sensetime.faceunlock.util.LogUtil.d(TAG, "scaleY : " + scaleY);
+            com.sensetime.faceunlock.util.LogUtil.d(TAG, "left : " + left);
+            com.sensetime.faceunlock.util.LogUtil.d(TAG, "top : " + top);
+            com.sensetime.faceunlock.util.LogUtil.d(TAG, "right : " + right);
+            com.sensetime.faceunlock.util.LogUtil.d(TAG, "bottom : " + bottom);
+        }
+        return mMaskRect;
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        super.onLayout(changed, left, top, right, bottom);
+        if (changed)
+            initMaskArea();
+    }
+
+    private void initMaskArea() {
+        int width = getWidth();
+        int length = width / 6;
+        left = length;
+        top = length; // 上下蒙板区域固定
+        right = length * 5;
+        bottom = length * 5;
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+            float cx = (left + right) >> 1;
+            float cy = (top + bottom + 200) >> 1;
+            float radius = (right - left) >> 1;
+            float radius1 = 280;
+			float temp = radius1 - radius;
+            canvas.drawCircle(cx, cy, radius1, mClearPaint);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            mCirclePaint.setColor(0xffaaaaaa);
+            canvas.drawCircle(cx, cy, radius1, mCirclePaint);
+            mCirclePaint.setColor(0xff2EA8FC);
+            float sweepAngle = progress * 360 / 100.0f;
+            com.sensetime.faceunlock.util.LogUtil.d(TAG, "sweepAngle: " + sweepAngle);
+            canvas.drawArc(left - temp , top - temp +100 , right + temp , bottom + temp +100, -90, sweepAngle, false, mCirclePaint);
+        }
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/widget/MaskView.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/bean/FaceFeature.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/bean/FaceFeature.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/bean/FaceFeature.java	(revision 6857)
@@ -0,0 +1,19 @@
+package com.sensetime.faceunlock.bean;
+
+import com.sensetime.faceapi.model.FaceInfo;
+
+public class FaceFeature {
+
+    public FaceInfo faceInfo; // 人脸
+    public byte[] nv21; // 当前帧的 nv21 数据
+    public int width; // 图片宽度
+    public int height; // 图片高度
+
+    public FaceFeature(FaceInfo faceInfo, byte[] nv21, int width, int height) {
+        this.faceInfo = faceInfo;
+        this.nv21 = nv21;
+        this.width = width;
+        this.height = height;
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/bean/FaceFeature.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/bean/User.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/bean/User.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/bean/User.java	(revision 6857)
@@ -0,0 +1,70 @@
+package com.sensetime.faceunlock.bean;
+
+public class User {
+
+	private String userId; // 不同人的 userId 不同，同一人的 userId 相同
+	private String name;
+	private String feature; // 特征值
+	private String imagePath;
+	private int isDisplay; // 是否显示（用户管理时只显示正方向的人脸）
+
+	public User() {
+	}
+
+	public User(String userId, String name, String feature, String imagePath, int isDisplay) {
+		this.userId = userId;
+		this.name = name;
+		this.feature = feature;
+		this.imagePath = imagePath;
+		this.isDisplay = isDisplay;
+	}
+
+	public String getUserId() {
+		return userId;
+	}
+
+	public void setUserId(String userId) {
+		this.userId = userId;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public void setName(String name) {
+		this.name = name;
+	}
+
+	public String getFeature() {
+		return feature;
+	}
+
+	public void setFeature(String feature) {
+		this.feature = feature;
+	}
+
+	public String getImagePath() {
+		return imagePath;
+	}
+
+	public void setImagePath(String imagePath) {
+		this.imagePath = imagePath;
+	}
+
+	public int getIsDisplay() {
+		return isDisplay;
+	}
+
+	public void setIsDisplay(int isDisplay) {
+		this.isDisplay = isDisplay;
+	}
+
+	@Override
+	public String toString() {
+		return "User{" +
+				"name='" + name + '\'' +
+				", imagePath='" + imagePath + '\'' +
+				'}';
+	}
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/bean/User.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/config/AppConfig.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/config/AppConfig.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/config/AppConfig.java	(revision 6857)
@@ -0,0 +1,24 @@
+package com.sensetime.faceunlock.config;
+
+import android.content.Context;
+import com.sensetime.faceunlock.util.LogUtil;
+import com.sensetime.faceunlock.util.SPUtil;
+
+public class AppConfig {
+
+    private static final String TAG = "AppConfig";
+    public static float threshold = 0.65f; // 人脸比对阈值
+    public static int attemptCount = 2; // 重试次数
+    public static boolean isOpenHacker = false; // 活体检测开关
+
+    /*static {
+        Context context = SystemUIApplication.getInstance();
+        threshold = (Float) SPUtil.get(context, SPUtil.THRESHOLD_KEY, 0.65f);
+        attemptCount = (Integer) SPUtil.get(context, SPUtil.TRY_COUNT_KEY, 2);
+        isOpenHacker = (Boolean) SPUtil.get(context, SPUtil.IS_OPEN_LIVENESS, false);
+        LogUtil.d(TAG, "threshold: " + threshold);
+        LogUtil.d(TAG, "attemptCount: " + attemptCount);
+        LogUtil.d(TAG, "isOpenHacker: " + isOpenHacker);
+    }*/
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/config/AppConfig.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/db/SQLHelper.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/db/SQLHelper.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/db/SQLHelper.java	(revision 6857)
@@ -0,0 +1,146 @@
+package com.sensetime.faceunlock.db;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.database.sqlite.SQLiteOpenHelper;
+import com.sensetime.faceunlock.bean.User;
+import com.sensetime.faceunlock.util.LogUtil;
+
+public class SQLHelper extends SQLiteOpenHelper {
+
+    public static final String TAG = "SQLHelper";
+
+    private static final String DATABASE_NAME = "user.db";
+    private static final String TABLE_NAME = "user";
+    private static final int VERSION = 1;
+
+    private static final String ID = "id";
+    private static final String USER_ID = "user_id"; // 一个人的唯一识别号
+    private static final String NAME = "name"; // 姓名
+    private static final String FEATURE = "feature"; // 特征值
+    private static final String IMAGE_PATH = "image_path"; // 图片路径
+    private static final String IS_DISPLAY = "is_display"; // 显示时一个人只会显示一张图片即可，用0表示不显示，1表示显示
+
+    private static SQLHelper instance;
+
+    public static SQLHelper getInstance(Context context) {
+        if (instance == null) {
+            instance = new SQLHelper(context.getApplicationContext(), DATABASE_NAME, null, VERSION);
+        }
+        return instance;
+    }
+
+    public SQLHelper(Context context, String name, CursorFactory factory, int version) {
+        super(context, name, factory, version);
+    }
+
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+        String sql = "CREATE TABLE " + TABLE_NAME + "(" + ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + USER_ID +
+                " TEXT," + NAME + " TEXT," + IMAGE_PATH + " TEXT," + FEATURE + " TEXT," + IS_DISPLAY + " INTEGER)";
+        db.execSQL(sql);
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+    }
+
+    // 增
+    public void add(User user) {
+        SQLiteDatabase db = instance.getWritableDatabase();
+        ContentValues values = new ContentValues();
+        values.put(USER_ID, user.getUserId());
+        values.put(NAME, user.getName());
+        values.put(IMAGE_PATH, user.getImagePath());
+        values.put(FEATURE, user.getFeature());
+        values.put(IS_DISPLAY, user.getIsDisplay());
+        db.insert(TABLE_NAME, null, values);
+        db.close();
+        LogUtil.v(TAG, "db add " + user.toString());
+    }
+
+    // 增
+    public void add(List<User> users) {
+        SQLiteDatabase db = instance.getWritableDatabase();
+        ContentValues values = new ContentValues();
+        for (User user : users) {
+            values.clear();
+            values.put(USER_ID, user.getUserId());
+            values.put(NAME, user.getName());
+            values.put(IMAGE_PATH, user.getImagePath());
+            values.put(FEATURE, user.getFeature());
+            values.put(IS_DISPLAY, user.getIsDisplay());
+            db.insert(TABLE_NAME, null, values);
+            LogUtil.v(TAG, "db add " + user.toString());
+        }
+        db.close();
+    }
+
+    // 查所有
+    public List<User> queryAll() {
+        ArrayList<User> list = new ArrayList<User>();
+        SQLiteDatabase db = instance.getWritableDatabase();
+        Cursor cursor = db.query(TABLE_NAME, null, null, null, null, null, null);
+        while (cursor.moveToNext()) {
+            User user = new User();
+            user.setUserId(cursor.getString(cursor.getColumnIndex(USER_ID)));
+            user.setName(cursor.getString(cursor.getColumnIndex(NAME)));
+            user.setImagePath(cursor.getString(cursor.getColumnIndex(IMAGE_PATH)));
+            user.setFeature(cursor.getString(cursor.getColumnIndex(FEATURE)));
+            user.setIsDisplay(cursor.getInt(cursor.getColumnIndex(IS_DISPLAY)));
+            list.add(user);
+            LogUtil.v(TAG, "list add " + user.toString());
+        }
+        db.close();
+        LogUtil.v(TAG, "list size: " + list.size());
+        return list;
+    }
+    
+    // 查所有
+    public List<User> queryDisplay() {
+    	ArrayList<User> list = new ArrayList<User>();
+    	SQLiteDatabase db = instance.getWritableDatabase();
+        String sql = "select * from " + TABLE_NAME + " where " + IS_DISPLAY + "=" + 1;
+        Cursor cursor = db.rawQuery(sql, null);
+    	while (cursor.moveToNext()) {
+    		User user = new User();
+    		user.setUserId(cursor.getString(cursor.getColumnIndex(USER_ID)));
+    		user.setName(cursor.getString(cursor.getColumnIndex(NAME)));
+    		user.setImagePath(cursor.getString(cursor.getColumnIndex(IMAGE_PATH)));
+    		user.setFeature(cursor.getString(cursor.getColumnIndex(FEATURE)));
+    		user.setIsDisplay(cursor.getInt(cursor.getColumnIndex(IS_DISPLAY)));
+    		list.add(user);
+            LogUtil.v(TAG, "list add " + user.toString());
+    	}
+    	db.close();
+        LogUtil.v(TAG, "list size: " + list.size());
+    	return list;
+    }
+
+    // 删
+    public void delete(String userId) {
+        SQLiteDatabase db = instance.getWritableDatabase();
+        int deleteCount = db.delete(TABLE_NAME, USER_ID + "='" + userId + "'", null);
+        if (deleteCount == 1) {
+            LogUtil.v(TAG, "db delete: " + userId);
+        }
+        db.close();
+    }
+
+    /**
+     * 删除所有
+     */
+    public void deleteAllData() {
+        SQLiteDatabase db = instance.getWritableDatabase();
+        int deleteCount = db.delete(TABLE_NAME, null, null);
+        LogUtil.v(TAG, "db delete count: " + deleteCount);
+        db.close();
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/db/SQLHelper.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/HackerProxy.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/HackerProxy.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/HackerProxy.java	(revision 6857)
@@ -0,0 +1,54 @@
+package com.sensetime.faceunlock.manager;
+
+import com.sensetime.faceapi.FaceHacker;
+import com.sensetime.faceapi.model.CvPixelFormat;
+import com.sensetime.faceapi.model.FaceInfo;
+import com.sensetime.faceapi.model.FaceOrientation;
+import com.sensetime.faceapi.utils.AccelerometerManager;
+import com.sensetime.faceunlock.bean.FaceFeature;
+import com.sensetime.faceunlock.config.AppConfig;
+import com.sensetime.faceunlock.util.FileUtil;
+import com.sensetime.faceunlock.util.LogUtil;
+
+public class HackerProxy {
+
+    private static final String TAG = "HackerProxy";
+
+    public static void init() {
+        FaceSDKManager.getInstance().initHacker();
+    }
+
+    public static boolean isPass(FaceFeature faceFeature, boolean isFrontCamera) {
+        if (!AppConfig.isOpenHacker) {
+            return true; // 如果没有打开活体开关，默认都是活体
+        }
+        float score = HackerProxy.hacker(faceFeature.nv21, faceFeature.width, faceFeature.height, faceFeature
+                .faceInfo, isFrontCamera);
+        boolean isPass = score < 0.98f;
+        LogUtil.d(TAG, "isPass: " + isPass);
+        long time = System.currentTimeMillis();
+        FileUtil.saveHackerData(faceFeature.nv21, faceFeature.width, faceFeature.height, score);
+        LogUtil.d(TAG, "saveHackerData time: " + (System.currentTimeMillis() - time) + "ms");
+        return isPass;
+    }
+
+    public static float hacker(byte[] nv21, int width, int height, FaceInfo faceInfo, boolean isFrontCamera) {
+        FaceHacker faceHacker = FaceSDKManager.getInstance().getFaceHacker();
+        if (faceHacker == null) {
+            LogUtil.w(TAG, "FaceHacker is null !");
+            return 0f;
+        }
+        FaceOrientation faceOrientation = AccelerometerManager.getFaceOrientation(isFrontCamera);
+        long time = System.currentTimeMillis();
+        float score = faceHacker.faceHackness(nv21, CvPixelFormat.NV21, width, height, width,
+                faceOrientation, faceInfo);
+        LogUtil.d(TAG, "hacker time: " + (System.currentTimeMillis() - time));
+        LogUtil.d(TAG, "score: " + score);
+        return score;
+    }
+
+    public static void release() {
+        FaceSDKManager.getInstance().releaseHacker();
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/HackerProxy.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/TrackProxy.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/TrackProxy.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/TrackProxy.java	(revision 6857)
@@ -0,0 +1,37 @@
+package com.sensetime.faceunlock.manager;
+
+import com.sensetime.faceapi.FaceTrack;
+import com.sensetime.faceapi.model.CvPixelFormat;
+import com.sensetime.faceapi.model.FaceInfo;
+import com.sensetime.faceapi.model.FaceOrientation;
+import com.sensetime.faceapi.utils.AccelerometerManager;
+import com.sensetime.faceunlock.util.LogUtil;
+
+public class TrackProxy {
+
+    private static final String TAG = "TrackProxy";
+
+    public static void init() {
+        FaceSDKManager.getInstance().initTrack();
+    }
+
+    public static FaceInfo[] track(byte[] nv21, int width, int height, boolean isFrontCamera) {
+        FaceOrientation faceOrientation = AccelerometerManager.getFaceOrientation(isFrontCamera);
+        LogUtil.v(TAG, "track dir: " + faceOrientation.getValue());
+        FaceTrack tracker = FaceSDKManager.getInstance().getTrack();
+        if (tracker == null) {
+            LogUtil.w(TAG, "FaceTrack is null !");
+            return null;
+        }
+        long time = System.currentTimeMillis();
+        FaceInfo[] faces = tracker.track(nv21, CvPixelFormat.NV21, width, height, faceOrientation);
+        LogUtil.v(TAG, "track time: " + (System.currentTimeMillis() - time) + ", face count: " + ((faces == null) ? 0
+                : faces.length));
+        return faces;
+    }
+
+    public static void release() {
+        FaceSDKManager.getInstance().releaseTrack();
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/TrackProxy.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/VerifyProxy.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/VerifyProxy.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/VerifyProxy.java	(revision 6857)
@@ -0,0 +1,81 @@
+package com.sensetime.faceunlock.manager;
+
+import android.content.Context;
+
+import com.sensetime.faceapi.FaceVerify;
+import com.sensetime.faceapi.model.CvPixelFormat;
+import com.sensetime.faceapi.model.FaceInfo;
+import com.sensetime.faceunlock.bean.FaceFeature;
+import com.sensetime.faceunlock.bean.User;
+import com.sensetime.faceunlock.config.AppConfig;
+import com.sensetime.faceunlock.util.LogUtil;
+
+import java.util.List;
+
+public class VerifyProxy {
+
+    private static final String TAG = "VerifyProxy";
+
+    public static void init(Context context) {
+        FaceSDKManager.getInstance().initVerify(context);
+    }
+
+    public static User isPass(FaceFeature faceFeature, Context context) {
+        if (faceFeature == null) {
+            return null;
+        }
+        List<User> users = UserManager.getAllUser(context);
+        if (users == null || users.size() <= 0) {
+            return null;
+        }
+        byte[] feature = VerifyProxy.getFeature(faceFeature.nv21, faceFeature.width, faceFeature.height, faceFeature
+                .faceInfo);
+        float maxSimilarValue = 0.0f;
+        int maxSimilarIndex = 0;
+        for (int i = 0; i < users.size(); i++) {
+            float similar = VerifyProxy.compare(feature, users.get(i).getFeature().getBytes());
+            if (similar > maxSimilarValue) {
+                maxSimilarValue = similar;
+                maxSimilarIndex = i;
+            }
+        }
+        LogUtil.d(TAG, "maxSimilarValue : " + maxSimilarValue);
+        boolean isPass = maxSimilarValue > AppConfig.threshold;
+        if (isPass) {
+            return users.get(maxSimilarIndex);
+        }
+        return null;
+    }
+
+    public static byte[] getFeature(byte[] nv21, int width, int height, FaceInfo faceInfo) {
+        FaceVerify verifier = FaceSDKManager.getInstance().getVerify();
+        if (verifier == null) {
+            LogUtil.w(TAG, "FaceVerify is null !");
+            return null;
+        }
+        long time = System.currentTimeMillis();
+        byte[] feature = verifier.getFeature(nv21, CvPixelFormat.NV21, width, height, width, faceInfo); // 获取特征值
+        LogUtil.d(TAG, "getFeature time : " + (System.currentTimeMillis() - time));
+        return feature;
+    }
+
+    public static float compare(byte[] feature1, byte[] feature2) {
+        FaceVerify verifier = FaceSDKManager.getInstance().getVerify();
+        if (verifier == null) {
+            LogUtil.w(TAG, "FaceVerify is null !");
+            return 0f;
+        }
+        if (feature1 == null || feature2 == null) {
+            LogUtil.w(TAG, "feature1 or feature2 is null !");
+            return 0f;
+        }
+        float score = verifier.compareFeature(feature1, feature2);
+        return score;
+    }
+
+    public static void release() {
+        FaceSDKManager.getInstance().releaseVerify();
+    }
+
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/VerifyProxy.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/UserManager.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/UserManager.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/UserManager.java	(revision 6857)
@@ -0,0 +1,54 @@
+package com.sensetime.faceunlock.manager;
+
+import android.content.Context;
+
+import com.sensetime.faceunlock.bean.User;
+import com.sensetime.faceunlock.db.SQLHelper;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class UserManager {
+
+    private static final List<User> users = new ArrayList<>(); // 数据库中所有的人员信息
+    private static final List<User> displayUsers = new ArrayList<>(); // 人员管理时仅需要显示的人员信息
+
+    public static List<User> getAllUser(Context context) {
+        if (users.size() <= 0) {
+            users.addAll(SQLHelper.getInstance(context).queryAll());
+        }
+        return users;
+    }
+
+    public static List<User> getDisplayUsers(Context context) {
+        if (displayUsers.size() <= 0) {
+            displayUsers.addAll(SQLHelper.getInstance(context).queryDisplay());
+        }
+        return displayUsers;
+    }
+
+    public static void refresh(Context context) {
+        users.clear();
+        displayUsers.clear();
+        users.addAll(SQLHelper.getInstance(context).queryAll());
+        displayUsers.addAll(SQLHelper.getInstance(context).queryDisplay());
+    }
+
+    public static void addUsers(List<User> users, Context context) {
+        deleteAllUser(context);
+        SQLHelper.getInstance(context).add(users);
+        refresh(context);
+    }
+
+    public static void deleteUser(User user, Context context) {
+        SQLHelper.getInstance(context).delete(user.getUserId());
+        refresh(context);
+    }
+
+    public static void deleteAllUser(Context context) {
+        SQLHelper.getInstance(context).deleteAllData();
+        users.clear();
+        displayUsers.clear();
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/UserManager.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/DetectProxy.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/DetectProxy.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/DetectProxy.java	(revision 6857)
@@ -0,0 +1,34 @@
+package com.sensetime.faceunlock.manager;
+
+import com.sensetime.faceapi.FaceDetect;
+import com.sensetime.faceapi.model.CvPixelFormat;
+import com.sensetime.faceapi.model.FaceInfo;
+import com.sensetime.faceapi.model.FaceOrientation;
+import com.sensetime.faceunlock.util.LogUtil;
+
+public class DetectProxy {
+
+    private static final String TAG = "DetectProxy";
+
+    public static void init() {
+        FaceSDKManager.getInstance().initDetect();
+    }
+
+    public static FaceInfo[] detect(byte[] nv21, int width, int height) {
+        FaceDetect detector = FaceSDKManager.getInstance().getDetect();
+        if (detector == null) {
+            LogUtil.w(TAG, "FaceDetect is null !");
+            return null;
+        }
+        long time = System.currentTimeMillis();
+        FaceInfo[] faces = detector.detect(nv21, CvPixelFormat.NV21, width, height, width, FaceOrientation.RIGHT);
+        LogUtil.d(TAG, "detect time: " + (System.currentTimeMillis() - time) + ", face count: " + ((faces == null) ? 0
+                : faces.length));
+        return faces;
+    }
+
+    public static void release() {
+        FaceSDKManager.getInstance().releaseDetect();
+    }
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/DetectProxy.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/FaceSDKManager.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/FaceSDKManager.java	(revision 0)
+++ frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/FaceSDKManager.java	(revision 6857)
@@ -0,0 +1,118 @@
+package com.sensetime.faceunlock.manager;
+
+import android.content.Context;
+import com.sensetime.faceapi.FaceDetect;
+import com.sensetime.faceapi.FaceHacker;
+import com.sensetime.faceapi.FaceTrack;
+import com.sensetime.faceapi.FaceVerify;
+import com.sensetime.faceapi.model.FaceConfig;
+import com.sensetime.faceunlock.util.FileUtil;
+import com.sensetime.faceunlock.util.LogUtil;
+
+import java.io.File;
+
+public class FaceSDKManager {
+
+	private static final String TAG = "FaceSDKManager";
+	private static final FaceSDKManager INSTANCE = new FaceSDKManager();
+	private FaceSDKManager() {
+	}
+
+	private FaceTrack faceTrack;
+	private FaceDetect faceDetect;
+	private FaceHacker faceHacker;
+	private FaceVerify faceVerify;
+
+	public static FaceSDKManager getInstance() {
+		return INSTANCE;
+	}
+
+	public FaceTrack getTrack() {
+		return faceTrack;
+	}
+
+	public FaceDetect getDetect() {
+		return faceDetect;
+	}
+
+	public FaceHacker getFaceHacker() {
+		return faceHacker;
+	}
+
+	public FaceVerify getVerify() {
+		return faceVerify;
+	}
+
+	public void initTrack() {
+		if (faceTrack != null) {
+			return;
+		}
+		long time = System.currentTimeMillis();
+		faceTrack = new FaceTrack();
+		LogUtil.d(TAG, "initTrack time: " + (System.currentTimeMillis() - time));
+	}
+
+	public void initDetect() {
+		if (faceDetect != null) {
+			return;
+		}
+		long time = System.currentTimeMillis();
+		faceDetect = new FaceDetect(FaceConfig.FaceImageResize.RESIZE_320W, FaceConfig.FaceKeyPointCount.POINT_COUNT_21);
+		LogUtil.d(TAG, "initDetect time: " + (System.currentTimeMillis() - time));
+	}
+
+	public void initHacker() {
+		if (faceHacker != null) {
+			return;
+		}
+		long time = System.currentTimeMillis();
+//		String path = context.getFilesDir().getAbsolutePath().toString() + "/" + FileUtil.HACKER_MODEL;
+//		LogUtil.d(TAG, "hacker model path: " + path);
+		faceHacker = new FaceHacker(null);
+		LogUtil.d(TAG, "initHacker time: " + (System.currentTimeMillis() - time));
+	}
+
+	public void initVerify(Context context) {
+		if (faceVerify != null) {
+			return;
+		}
+		FileUtil.copyModelFile(context);
+		String modelPath = context.getFilesDir().getAbsolutePath() + File.separator + FileUtil.VERIFY_MODEL;
+		long time = System.currentTimeMillis();
+		faceVerify = new FaceVerify(modelPath);
+		LogUtil.d(TAG, "initVerify time: " + (System.currentTimeMillis() - time) + "ms");
+	}
+
+	public void releaseTrack() {
+		if (faceTrack != null) {
+			faceTrack.release();
+			faceTrack = null;
+			LogUtil.v(TAG, "releaseTrack");
+		}
+	}
+
+	public void releaseDetect() {
+		if (faceDetect != null) {
+			faceDetect.release();
+			faceDetect = null;
+			LogUtil.v(TAG, "releaseDetect");
+		}
+	}
+
+	public void releaseHacker() {
+		if (faceHacker != null) {
+			faceHacker.release();
+			faceHacker = null;
+			LogUtil.v(TAG, "releaseHacker");
+		}
+	}
+
+	public void releaseVerify() {
+		if (faceVerify != null) {
+			faceVerify.release();
+			faceVerify = null;
+			LogUtil.v(TAG, "releaseVerify");
+		}
+	}
+
+}

Property changes on: frameworks/base/packages/SystemUI/src/com/sensetime/faceunlock/manager/FaceSDKManager.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/libs/rxjava-1.1.6.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: frameworks/base/packages/SystemUI/libs/rxjava-1.1.6.jar
===================================================================
--- frameworks/base/packages/SystemUI/libs/rxjava-1.1.6.jar	(revision 0)
+++ frameworks/base/packages/SystemUI/libs/rxjava-1.1.6.jar	(revision 6857)

Property changes on: frameworks/base/packages/SystemUI/libs/rxjava-1.1.6.jar
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/libs/rxandroid-1.2.1.aar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: frameworks/base/packages/SystemUI/libs/rxandroid-1.2.1.aar
===================================================================
--- frameworks/base/packages/SystemUI/libs/rxandroid-1.2.1.aar	(revision 0)
+++ frameworks/base/packages/SystemUI/libs/rxandroid-1.2.1.aar	(revision 6857)

Property changes on: frameworks/base/packages/SystemUI/libs/rxandroid-1.2.1.aar
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/res/values/dimens.xml
===================================================================
--- frameworks/base/packages/SystemUI/res/values/dimens.xml	(revision 6856)
+++ frameworks/base/packages/SystemUI/res/values/dimens.xml	(revision 6857)
@@ -443,8 +443,6 @@
 	<dimen name="keyguard_affordance_customize_icon_height">48dp</dimen>
 	<dimen name="keyguard_affordance_customize_icon_width">48dp</dimen>
 	<!-- add end }-->
-	<dimen name="keyguard_affordance_fingerprint_icon_height">32dp</dimen>
-	<dimen name="keyguard_affordance_fingerprint_icon_width">32dp</dimen>
 
     <!-- The text size for battery level -->
     <dimen name="battery_level_text_size">12sp</dimen>
Index: frameworks/base/packages/SystemUI/res/raw/panorama_mgba
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: frameworks/base/packages/SystemUI/res/raw/panorama_mgba
===================================================================
--- frameworks/base/packages/SystemUI/res/raw/panorama_mgba	(revision 0)
+++ frameworks/base/packages/SystemUI/res/raw/panorama_mgba	(revision 6857)

Property changes on: frameworks/base/packages/SystemUI/res/raw/panorama_mgba
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/res/raw/panorama_mgb_s1
===================================================================

Property changes on: frameworks/base/packages/SystemUI/res/raw/panorama_mgb_s1
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/res/raw/panorama_mgb_s2
===================================================================

Property changes on: frameworks/base/packages/SystemUI/res/raw/panorama_mgb_s2
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/res/raw/megviifacepp_modela
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: frameworks/base/packages/SystemUI/res/raw/megviifacepp_modela
===================================================================
--- frameworks/base/packages/SystemUI/res/raw/megviifacepp_modela	(revision 0)
+++ frameworks/base/packages/SystemUI/res/raw/megviifacepp_modela	(revision 6857)

Property changes on: frameworks/base/packages/SystemUI/res/raw/megviifacepp_modela
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/res/layout/activity_verify.xml
===================================================================
--- frameworks/base/packages/SystemUI/res/layout/activity_verify.xml	(revision 0)
+++ frameworks/base/packages/SystemUI/res/layout/activity_verify.xml	(revision 6857)
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent" >
+
+    <com.sensetime.faceunlock.widget.CameraView
+        android:id="@+id/camera_view"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        app:resolution="0"
+        app:scale="scale_16_9" />
+
+</FrameLayout>
\ No newline at end of file

Property changes on: frameworks/base/packages/SystemUI/res/layout/activity_verify.xml
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/res/layout/activity_register.xml
===================================================================
--- frameworks/base/packages/SystemUI/res/layout/activity_register.xml	(revision 0)
+++ frameworks/base/packages/SystemUI/res/layout/activity_register.xml	(revision 6857)
@@ -0,0 +1,164 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:android_custom="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical" >
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="400dp"
+        android:layout_centerHorizontal="true"
+        android:gravity="center"
+        android:orientation="vertical"
+        android:visibility="gone" >
+
+        <com.sensetime.faceunlock.widget.FaceUnlockCyleView
+            android:layout_width="280dp"
+            android:layout_height="280dp"
+            android:layout_gravity="center"
+            android_custom:roundColor="#D1D1D1"
+            android_custom:roundProgressColor="#3C87FE"
+            android_custom:roundWidth="6dp"
+            android_custom:textColor="#9A32CD"
+            android_custom:textSize="18sp" />
+    </RelativeLayout>
+
+    <com.sensetime.faceunlock.widget.CameraView
+        android:id="@+id/camera_view"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android_custom:resolution="480"
+        android_custom:scale="scale_16_9"/>
+    <com.sensetime.faceunlock.widget.MaskView
+        android:id="@+id/mask_view"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_below="@+id/toolbar"
+        android:background="@color/colorBackground"/>
+
+    <RelativeLayout
+        android:id="@+id/face_unlock_scan_layout"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_centerHorizontal="true"
+        android:gravity="center"
+        android:orientation="vertical"
+        android:visibility="gone">
+
+        <com.sensetime.faceunlock.widget.FaceUnlockCyleView
+            android:id="@+id/face_unlock_cycle_view"
+            android:layout_width="310dp"
+            android:layout_height="540dp"
+            android:layout_gravity="center"
+            android:layout_marginTop="110dp"
+            android_custom:roundColor="#D1D1D1"
+            android_custom:roundProgressColor="#3C87FE"
+            android_custom:roundWidth="6dp"
+            android_custom:textColor="#3C87FE"
+            android_custom:textSize="18sp" />
+    </RelativeLayout>
+
+    <LinearLayout
+        android:id="@+id/register"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentRight="true"
+        android:layout_marginRight="14dp"
+        android:layout_marginTop="20dp"
+        android:background="#3f000000"
+        android:orientation="vertical"
+        android:paddingBottom="15sp"
+        android:paddingLeft="12dp"
+        android:paddingRight="12dp"
+        android:paddingTop="15dp"
+        android:visibility="gone" >
+
+        <CheckBox
+            android:id="@+id/register_front"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:button="@drawable/checkbox_button_selector"
+            android:clickable="false"
+            android:text="@string/register_front"
+            android:textColor="@drawable/checkbox_text_color_selector"
+            android:textSize="16sp" />
+
+        <CheckBox
+            android:id="@+id/register_up"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="18dp"
+            android:button="@drawable/checkbox_button_selector"
+            android:clickable="false"
+            android:text="@string/register_up"
+            android:textColor="@drawable/checkbox_text_color_selector"
+            android:textSize="16sp" />
+
+        <CheckBox
+            android:id="@+id/register_down"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="18dp"
+            android:button="@drawable/checkbox_button_selector"
+            android:clickable="false"
+            android:text="@string/register_down"
+            android:textColor="@drawable/checkbox_text_color_selector"
+            android:textSize="16sp" />
+
+        <CheckBox
+            android:id="@+id/register_left"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="18dp"
+            android:button="@drawable/checkbox_button_selector"
+            android:clickable="false"
+            android:text="@string/register_left"
+            android:textColor="@drawable/checkbox_text_color_selector"
+            android:textSize="16sp" />
+
+        <CheckBox
+            android:id="@+id/register_right"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="18dp"
+            android:button="@drawable/checkbox_button_selector"
+            android:clickable="false"
+            android:text="@string/register_right"
+            android:textColor="@drawable/checkbox_text_color_selector"
+            android:textSize="16sp" />
+    </LinearLayout>
+
+    <TextView
+        android:id="@+id/face_unlock_info_text"
+        android:layout_width="match_parent"
+        android:layout_marginTop="420dp"
+        android:layout_height="wrap_content"
+        android:gravity="center_horizontal"
+        android:textStyle="bold"
+        android:textSize="@dimen/ic_default_error_info_size" 
+        android:textColor="@color/ic_default_error_text_color"
+        android:visibility="gone" />
+		
+	<LinearLayout
+	    android:orientation="vertical"
+        android:layout_width="280dp"
+        android:layout_height="wrap_content"
+		android:layout_gravity="center_horizontal"
+        android:layout_marginTop="480dp" >
+
+		
+		<TextView
+			android:id="@+id/face_unlock_scan_bottom_info"
+			android:layout_width="280dp"
+			android:layout_height="wrap_content"
+			android:gravity="center_horizontal"
+			android:lineSpacingExtra="10dp"
+			android:text="@string/ic_default_sacn_face_description_info"
+			android:textSize="15sp" 
+			android:textColor="@color/white" />
+	
+	</LinearLayout>
+
+</FrameLayout>
\ No newline at end of file

Property changes on: frameworks/base/packages/SystemUI/res/layout/activity_register.xml
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/res/layout/face_service_view.xml
===================================================================
--- frameworks/base/packages/SystemUI/res/layout/face_service_view.xml	(revision 0)
+++ frameworks/base/packages/SystemUI/res/layout/face_service_view.xml	(revision 6857)
@@ -0,0 +1,57 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    xmlns:android_custom="http://schemas.android.com/apk/res-auto"
+    android:id="@+id/allHongmoContentLayout"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:keepScreenOn="true"
+    android:orientation="vertical"
+    android:screenOrientation="portrait" >
+
+    <RelativeLayout
+        android:id="@+id/hongmoContentLayout"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical" >
+
+        <FrameLayout
+            android:id="@+id/frame_big"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content" >
+
+            <com.sensetime.faceunlock.widget.CameraView
+                android:id="@+id/camera_view"
+                android:layout_width="wrap_content"
+                android:layout_height="match_parent"
+                android_custom:resolution="0"
+                android_custom:scale="scale_16_9"
+                android:background="#00000000"/>
+        </FrameLayout>
+
+        <LinearLayout
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_alignParentTop="true"
+            android:layout_centerHorizontal="true"
+            android:orientation="vertical"
+            android:visibility="gone" >
+
+            <TextView
+                android:id="@+id/ie_final_result"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textColor="#FF0000"
+                android:textSize="18sp" />
+        </LinearLayout>
+    </RelativeLayout>
+
+    <RelativeLayout
+        android:id="@+id/ll_config"
+        android:layout_width="match_parent"
+        android:layout_height="0dp"
+        android:layout_below="@id/hongmoContentLayout"
+        android:layout_weight="1"
+        android:gravity="bottom" >
+    </RelativeLayout>
+
+</RelativeLayout>

Property changes on: frameworks/base/packages/SystemUI/res/layout/face_service_view.xml
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/res/layout/activity_privacy_space.xml
===================================================================
--- frameworks/base/packages/SystemUI/res/layout/activity_privacy_space.xml	(revision 0)
+++ frameworks/base/packages/SystemUI/res/layout/activity_privacy_space.xml	(revision 6857)
@@ -0,0 +1,68 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    xmlns:android_custom="http://schemas.android.com/apk/res-auto"
+    android:id="@+id/allHongmoContentLayout"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:keepScreenOn="true"
+    android:orientation="vertical"
+    android:background="#b2000000">  
+    <RelativeLayout
+        android:id="@+id/hongmoContentLayout"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical" > 
+
+        <FrameLayout
+            android:id="@+id/frame_big"
+            android:paddingTop="71px"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content" >
+            
+            <com.face.scanner.view.EyeView
+                android:id="@+id/eye"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:background="#00000000" />
+            
+            <com.face.scanner.view.RoundProgressBar
+                    android:id="@+id/roundProgress"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:adjustViewBounds="true"
+                    android_custom:roundColor="@android:color/white"
+                    android_custom:roundProgressColor="#00FF00"
+                    android_custom:roundWidth="6dip"
+                    android_custom:textIsDisplayable="false"
+                    android:visibility="gone"/>
+        </FrameLayout>
+        
+        <LinearLayout
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_alignParentTop="true"
+            android:layout_centerHorizontal="true"
+            android:orientation="vertical"
+            android:visibility="gone">
+
+            <TextView
+                android:id="@+id/ie_final_result"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textColor="#FF0000"
+                android:textSize="18sp" />
+        </LinearLayout>
+
+    </RelativeLayout>
+
+    <RelativeLayout
+        android:id="@+id/ll_config"
+        android:layout_below="@id/hongmoContentLayout"
+        android:layout_width="match_parent"
+        android:layout_height="0dp"
+        android:layout_weight="1"
+        android:gravity="bottom" >
+        
+    </RelativeLayout>
+    
+</RelativeLayout>

Property changes on: frameworks/base/packages/SystemUI/res/layout/activity_privacy_space.xml
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/res/layout/activity_face_identify.xml
===================================================================
--- frameworks/base/packages/SystemUI/res/layout/activity_face_identify.xml	(revision 0)
+++ frameworks/base/packages/SystemUI/res/layout/activity_face_identify.xml	(revision 6857)
@@ -0,0 +1,267 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    xmlns:android_custom="http://schemas.android.com/apk/res-auto"
+    android:id="@+id/allHongmoContentLayout"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:keepScreenOn="true"
+    android:orientation="vertical" >
+
+    <RelativeLayout
+        android:id="@+id/hongmoContentLayout"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical" >
+
+        <FrameLayout
+            android:id="@+id/frame_big"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content" >
+            
+            <com.face.scanner.view.EyeView
+                android:id="@+id/eye"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:background="#00000000" />
+            
+            <com.face.scanner.view.RoundProgressBar
+                    android:id="@+id/roundProgress"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:adjustViewBounds="true"
+                    android_custom:roundColor="@android:color/white"
+                    android_custom:roundProgressColor="#00FF00"
+                    android_custom:roundWidth="6dip"
+                    android_custom:textIsDisplayable="false" 
+                    android:visibility="gone"/>
+        </FrameLayout>
+        
+        <LinearLayout
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_alignParentTop="true"
+            android:layout_centerHorizontal="true"
+            android:orientation="vertical" 
+            android:visibility="gone">
+        </LinearLayout>
+
+    </RelativeLayout>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical"
+        android:id="@+id/face_scan_content"
+        android:layout_alignParentBottom="true"
+        android:background="@drawable/ic_face_scan_steps_bg">
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="72dp"
+            android:layout_marginBottom="16dp"
+            android:orientation="vertical"
+            android:id="@+id/face_scan_steps">
+
+            <RelativeLayout
+                android:layout_width="match_parent"
+                android:layout_height="0dp"
+                android:layout_weight="1"
+                android:visibility="gone">
+
+                <View
+                    android:layout_width="match_parent"
+                    android:layout_height="1dp"
+                    android:layout_centerVertical="true"
+                    android:background="@color/actionBar_text_clock"/>
+
+
+            </RelativeLayout>
+
+            <LinearLayout
+                android:layout_width="match_parent"
+                android:layout_height="0dp"
+                android:layout_weight="1"
+                android:gravity="center_vertical"
+                android:orientation="horizontal"
+                android:visibility="gone">
+
+                <LinearLayout
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:gravity="center">
+
+                    <TextView
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:text="@string/text_face_scan_1"/>
+
+                </LinearLayout>
+
+                <LinearLayout
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:gravity="center">
+
+                    <TextView
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:text="@string/text_face_scan_2"/>
+                </LinearLayout>
+
+                <LinearLayout
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:gravity="center">
+
+                    <TextView
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:text="@string/text_face_scan_3"/>
+
+                </LinearLayout>
+            </LinearLayout>
+        </LinearLayout>
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="bottom"
+            android:gravity="center_vertical"
+            android:layout_marginBottom="60px"
+            android:orientation="horizontal"
+            android:layout_marginLeft="@dimen/activity_left_margin"
+            android:layout_marginRight="@dimen/activity_right_margin">
+                <LinearLayout
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:gravity="center">
+
+                    <Button
+                        android:id="@+id/face_scan_button_1"
+                        style="?android:attr/borderlessButtonStyle"
+                        android:layout_width="@dimen/face_scan_button_size"
+                        android:layout_height="@dimen/face_scan_button_size"
+                        android:background="@drawable/face_scan_button_bg"
+                        android:text="@string/button_text_face_scan_1"
+                        android:textColor="@color/face_scan_steps_text_color_normal"/>
+
+                </LinearLayout>
+            
+            <LinearLayout
+                android:layout_width="@dimen/face_scan_steps_button_width"
+                android:layout_height="@dimen/face_scan_steps_button_height"
+                android:background="@drawable/face_scan_steps_btn_bg">
+
+            </LinearLayout>
+
+                <LinearLayout
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:gravity="center">
+
+                    <Button
+                        android:id="@+id/face_scan_button_2"
+                        style="?android:attr/borderlessButtonStyle"
+                        android:layout_width="@dimen/face_scan_button_size"
+                        android:layout_height="@dimen/face_scan_button_size"
+                        android:background="@drawable/face_scan_button_bg"
+                        android:text="@string/button_text_face_scan_2"
+                        android:textColor="@color/face_scan_steps_text_color_normal"/>
+
+                </LinearLayout>
+
+            <LinearLayout
+                android:layout_width="@dimen/face_scan_steps_button_width"
+                android:layout_height="@dimen/face_scan_steps_button_height"
+                android:background="@drawable/face_scan_steps_btn_bg">
+                </LinearLayout>
+
+                <LinearLayout
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1"
+                    android:gravity="center">
+
+                    <Button
+                        android:id="@+id/face_scan_button_3"
+                        style="?android:attr/borderlessButtonStyle"
+                        android:layout_width="@dimen/face_scan_button_size"
+                        android:layout_height="@dimen/face_scan_button_size"
+                        android:background="@drawable/face_scan_button_bg"
+                        android:text="@string/button_text_face_scan_3"
+                        android:textColor="@color/face_scan_steps_text_color_normal"/>
+
+                </LinearLayout>
+        </LinearLayout>
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="bottom"
+            android:layout_marginBottom="81px"
+            android:gravity="center_vertical"
+            android:orientation="horizontal"
+            android:layout_marginLeft="@dimen/activity_top_margin"
+            android:layout_marginRight="@dimen/activity_bottom_margin">
+
+            <LinearLayout
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:gravity="center">
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/text_face_scan_1"
+                    android:textSize="@dimen/face_scan_steps_text"
+                    android:textColor="@color/face_scan_steps_text_color_normal"/>
+
+            </LinearLayout>
+
+            <LinearLayout
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:gravity="center">
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/text_face_scan_2"
+                    android:textSize="@dimen/face_scan_steps_text"
+                    android:textColor="@color/face_scan_steps_text_color_normal"/>
+            </LinearLayout>
+
+            <LinearLayout
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:gravity="center">
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/text_face_scan_3"
+                    android:textSize="@dimen/face_scan_steps_text"
+                    android:textColor="@color/face_scan_steps_text_color_normal"/>
+
+            </LinearLayout>
+
+        </LinearLayout>
+    </LinearLayout>
+    
+    <TextView
+        android:id="@+id/ie_final_result"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:textColor="#ffffff"
+        android:gravity="center"
+        android:layout_below="@id/hongmoContentLayout"
+        android:textSize="15sp" />
+</RelativeLayout>

Property changes on: frameworks/base/packages/SystemUI/res/layout/activity_face_identify.xml
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: frameworks/base/packages/SystemUI/AndroidManifest.xml
===================================================================
--- frameworks/base/packages/SystemUI/AndroidManifest.xml	(revision 6856)
+++ frameworks/base/packages/SystemUI/AndroidManifest.xml	(revision 6857)
@@ -22,7 +22,7 @@
         android:sharedUserId="android.uid.systemui"
         coreApp="true">
 
-
+    <uses-sdk android:minSdkVersion="15" android:targetSdkVersion="25"/>
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
Index: frameworks/base/packages/SystemUI/proguard.flags
===================================================================
--- frameworks/base/packages/SystemUI/proguard.flags	(revision 6856)
+++ frameworks/base/packages/SystemUI/proguard.flags	(revision 6857)
@@ -68,6 +68,7 @@
  
  #keep hawk sdk
  -keep public class com.lcodercore.**{*;}
+  -keep public class com.megvii.**{*;}
  
  -dontwarn com.hawk.android.adsdk.ads.mediator.**
  -keep class com.hawk.android.adsdk.ads.**{*;}
@@ -74,6 +75,7 @@
  -keep class com.tcl.mediator.**{*;}
  #-kepp class com.google.android.gms.ads.**{*;}
  -keep class com.sensetime.faceapi.model.* {*;}
+ -keep class com.megvii.* {*;}
  -keep class com.google.android.gms.ads.MobileAds{
      <fields>;
      <methods>;
Index: frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java
===================================================================
--- frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java	(revision 6856)
+++ frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java	(revision 6857)
@@ -265,6 +265,7 @@
     static public final String SYSTEM_DIALOG_REASON_HOME_KEY = "homekey";
     static public final String SYSTEM_DIALOG_REASON_ASSIST = "assist";
     private final static String CAMERA_STOP_FACE_SERVICE = "camera_stop_face_service";
+    private final static String UNBIND_STOP_FACE_SERVICE = "unbind_stop_face_service";
 
     /**
      * These are the system UI flags that, when changing, can cause the layout
@@ -865,9 +866,7 @@
                     executeFaceVerifyTimeout();
                     break;
                 case MSG_EXIT_FACE_VERIFY:
-                    if (mFaceVerifyRun) {
-                        exitFaceVerify();
-                    }
+                    exitFaceVerify();
                     break;
                 case MSG_REMOVE_FACE_TIP:
                     removeFaceVerifyTip();
@@ -1247,9 +1246,9 @@
                     + "already in the process of turning the screen on.");
             return;
         }
-
-        if (count == 2) {
+        if (count == 2 && mFaceService ==null) {
             powerMultiPressAction(eventTime, interactive, mDoublePressOnPowerBehavior);
+			
         } else if (count == 3) {
             powerMultiPressAction(eventTime, interactive, mTriplePressOnPowerBehavior);
         } else if (interactive && !mBeganFromNonInteractive) {
@@ -1791,6 +1790,7 @@
 		//register for three finger shotscreen 
 		filter.addAction("intent.action.SendKey");
 		context.registerReceiver(mKeyReceiver, filter);
+		
         // monitor for system gestures
         mSystemGestures = new SystemGesturesPointerEventListener(context,
                 new SystemGesturesPointerEventListener.Callbacks() {
@@ -3785,6 +3785,7 @@
                         intent.setClassName("com.android.systemui", "com.face.scanner.FaceService");
                         intent.putExtra("privacyState",keyguardOn()?2:4);
                         intent.putExtra("call_package", "PhoneWindowManager_FACE_MODE_SWITCH in " + topPkgName);
+						Log.d(TAG, "bind service from mF1KeyLongPressTimeoutRunnable", new Exception());
                         mContext.bindService(intent, mFaceVerifyConn,  Context.BIND_AUTO_CREATE);
                     }
                 } else {
@@ -3823,7 +3824,6 @@
     }
 
     private IFaceService mFaceService;
-    private boolean mFaceVerifyRun = false;
     private static final int FACE_MODE_INVALID = -1;
     private static final int FACE_MODE_UNLOCK = 0;
     private static final int FACE_MODE_SWITCH = 1;
@@ -3834,14 +3834,19 @@
      private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
         public void onReceive(Context context, Intent intent) {
             String action = intent.getAction();
-
             if (action == CAMERA_STOP_FACE_SERVICE) {
                 Log.d(TAG,"*camera stop face service **");
-		        mContext.unbindService(mFaceVerifyConn);
+				if ( mFaceVerifyConn!= null){
+					 Log.d(TAG,"*camera stop face service ** stopFaceIdentify start");
+					 exitFaceVerify();
+					 Log.d(TAG,"*camera stop face service ** stopFaceIdentify end");
+				} else {
+					 Log.e(TAG,"errror when camera stop face service **");
+				}
             }
         }
     };
-
+	
     private ServiceConnection mFaceVerifyConn = new ServiceConnection() {
         @Override
         public void onServiceConnected(ComponentName name, IBinder service) {
@@ -3849,18 +3854,16 @@
             try {
                 mFaceService.setStateCallback(mFaceVerifyStateCallback);
                 mFaceService.faceOverTimeCallback(mFaceVerityTimeoutCallback);
-
+				mFaceService.stopFaceIdentify();
                 mFaceService.startFaceIdentify();
-                mFaceVerifyRun = true;
             } catch (RemoteException e) {
                 Log.d(TAG, "start verity face failed");
             }
         }
-
+		
         @Override
         public void onServiceDisconnected(ComponentName name) {
-            mFaceService = null;
-            mFaceVerifyRun = false;
+			Log.d(TAG,"onServiceDisconnected facke unlock");
         }
     };
 	
@@ -3890,9 +3893,6 @@
 	
     private void executeFaceVerifySucess() {
         if (mFaceMode == FACE_MODE_SWITCH) {
-            //String userId;
-           // userId = Settings.System.getStringForUser(mContext.getContentResolver(),Settings.System.PRIVACY_USER_ID, 0);
-            //int id = Integer.parseInt(userId);
             try{
                 Intent i = new Intent("PRIVACY_SPACE_SWITCH");
                 //i.putExtra("userid",id);
@@ -3917,9 +3917,7 @@
     }
 
     private void executeFaceVerifyTimeout() {
-        if (mFaceVerifyRun) {
-            exitFaceVerify();
-        }
+        exitFaceVerify();
         addFaceVerifyTip(false);
     }
 	TextView mFaceTip = null;
@@ -4057,14 +4055,18 @@
 	
     private void exitFaceVerify(){
         try {
-            Log.d(TAG,"**unbind face service for fail or timeout**");
+			Log.d(TAG,"exitFaceVerify", new Exception());
+			if (mFaceService!= null){
+				Log.d(TAG,"exitFaceVerify stopFaceIdentify");
+				mFaceService.stopFaceIdentify();
+				mFaceService = null; 
+			}
             mContext.unbindService(mFaceVerifyConn);
-            mFaceVerifyRun = false;
         } catch (Exception ex) {
             Slog.w(TAG, "--exit face verify fail");
         }
     }
-
+	
     /** {@inheritDoc} */
     @Override
     public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) {
@@ -7143,15 +7145,10 @@
 	
 	
 	    private void startFaceVerify() { //startFaceVerifyInternal
-        if (!mFaceVerifyRun && keyguardOn() /*&& !isSimPinKeyguardStart && !inCall() && !isSwitchingUser zxp*/) {
+	
+        if (keyguardOn() /*&& !isSimPinKeyguardStart && !inCall() && !isSwitchingUser zxp*/) {
             String faceEnable = Settings.System.getStringForUser(mContext.getContentResolver(), Settings.System.FACE_STATE_ENABLED, 0);
             int faceUnlockState = Settings.System.getInt(mContext.getContentResolver(), Settings.System.FACE_UNLOCK_STATE_ENABLED, 0);
-           // int facemeMode = Settings.System.getInt(mContext.getContentResolver(), Settings.System.PRIVACY_PROTECTION_ENABLED, 0);
-            /*int activeNotificationCountactiveNotificationCount = Settings.System.getInt(mContext.getContentResolver(), Settings.System.ACTIVE_NOTIFICATION_COUNT, 0);
-            int showNotification = Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.LOCK_SCREEN_SHOW_NOTIFICATIONS, 0);
-            Slog.d(TAG, "--faceEnable: " + faceEnable + " ,faceUnlockState: " + faceUnlockState
-                         + " ,faceMode: " + facemeMode + " ,activeNotificationCount" + activeNotificationCount
-                         + " ,showNotification: " + showNotification);zxp*/
             if (faceEnable == null) {
                 faceEnable = "0";
             }
@@ -7159,10 +7156,7 @@
                 if (faceUnlockState == 1) {
                     //mFaceMode = FACE_MODE_UNLOCK;//zxp
                     bindFaceService();
-                } /*else if (facemeMode == 1 && showNotification == 1 && activeNotificationCount > 0) {
-                    mFaceMode = FACE_MODE_FACEME;
-                    bindFaceService();
-                }zxp*/
+                }
             }
 			Slog.d(TAG, "faceEnable = "+faceEnable);
         } else {
@@ -7172,12 +7166,6 @@
     private void bindFaceService() {
         Intent intent = new Intent();
         intent.setClassName("com.android.systemui", "com.face.scanner.FaceService");
-        if (mFaceMode == FACE_MODE_UNLOCK) {
-            intent.putExtra("privacyState", 2);
-            intent.putExtra("call_package", "PhoneWindowManager_FACE_MODE_UNLOCK");
-        } else {
-            intent.putExtra("call_package", "PhoneWindowManager_FACE_MODE_FACEME");
-        }
         Slog.d(TAG, "--start bind FaceService-");
         mContext.bindService(intent, mFaceVerifyConn, Context.BIND_AUTO_CREATE);
     }
